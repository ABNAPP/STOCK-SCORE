# Stock Score – Kodbas (snapshot)

*Genererad för personlig referens. En fil per sektion nedan.*

---

## `.cursor/plans/make_threshold_industry_editable.md`

```markdown
# Make Threshold Industry Columns Editable

## Overview
Make all columns in the Threshold Industry table editable except "Industry" and "Antal" (count). Users should be able to manually edit IRR, LEVERAGE F2, RO40, Cash/SDebt, and Current Ratio values.

## Changes Required

### 1. Update ThresholdIndustryTable Component
- **File**: `src/components/ThresholdIndustryTable.tsx`
- Add state management using `useState` to store edited values (similar to EntryExitTable)
- Create a Map to store edited values keyed by industry name
- Initialize state from props data when data changes
- Add handler function `handleThresholdChange` to update values
- Replace static table cells with input fields for: irr, leverageF2, ro40, cashSdebt, currentRatio
- Keep "Industry" and "Antal" columns as read-only (no input fields)
- Use same input styling pattern as EntryExitTable (number inputs with proper styling)

### 2. Implementation Details
- Use `industry` as the key for storing edited values (since it's unique)
- Input fields should be type="number" for numeric columns
- Handle empty values (show empty string when 0, allow user to clear)
- Use `onClick={(e) => e.stopPropagation()}` to prevent row click events when editing
- Maintain the same visual styling and layout as current table

## Implementation Notes

- Follow the same pattern used in EntryExitTable for manual editing
- State should persist during the session (values are stored in component state)
- No need to persist to backend or localStorage unless specified
- Input fields should have proper focus styling and dark mode support
- Keep sorting functionality working with edited values


```

## `.firebaserc`

```text
{
  "projects": {
    "default": "anchor-decfa"
  }
}

```

## `.github/PULL_REQUEST_TEMPLATE.md`

```markdown
## Beskrivning
<!-- Vad gör denna PR? -->

## Typ av ändring
- [ ] Bugfix
- [ ] Ny funktion
- [ ] Refaktor (ingen beteendeförändring)
- [ ] Dokumentation / konfiguration

## Berörda områden
<!-- t.ex. Apps Script, Cloud Functions, provider-ordning, caching, tableId-mappning -->

## Tester
<!-- Vilka kommandon körde du? npm run build:check, test, test:e2e, storybook? -->

---

## PR Checklist

### Scope
- [ ] PR gör **en sak** (en feature, en fix eller en refactor – inte blandat)
- [ ] Ändringen är begränsad; stora ändringar är uppdelade i flera PR:ar
- [ ] Ingen orelaterad formatering eller lint-fix i samma PR (gör det i separat PR)

### Tester (kör lokalt innan push)
- [ ] **Typecheck:** `npm run build:check` (tsc + vite build)
- [ ] **Lint:** `npm run lint`
- [ ] **Unit:** `npm run test -- --run` (eller `npm run test:unit`)
- [ ] **Integration:** `npm run test:integration` (om du ändrat providers, dataflöden eller integrationstester)
- [ ] **E2E (vid UI/flow-ändringar):** `npm run test:e2e` (Playwright)
- [ ] **Storybook (vid UI-komponenter):** `npm run storybook` – kontrollera att berörda stories fortfarande fungerar

### Backwards compatibility
- [ ] **Apps Script:** Ändrar du request/response eller parametrar mot Apps Script (e.g. `apps-script/`, `src/services/sheets/`)? Om ja – är det planerat och dokumenterat? Befintliga deploymenter ska inte brytas.
- [ ] **Cloud Functions:** Ändrar du `functions/src/` API eller Firestore-struktur? Om ja – samma krav; inget API-brott mot befintliga klienter om det inte är tydligt planerat.

### Riskpunkter (projektsspecifikt)
- [ ] **Provider-ordning:** Om du ändrar `src/main.tsx` eller test-providers: ordningen ska vara ThemeProvider → ToastProvider → AuthProvider → NotificationProvider → (Rest). Test-wrapper (e.g. `src/test/helpers/renderHelpers.tsx`) ska matcha.
- [ ] **RefreshContext:** Komponenter som använder `useRefresh` kräver RefreshProvider (och korrekt ordning). Ändringar kring refresh/auto-refresh ska verifieras.
- [ ] **Caching / delta-sync:** Ändringar i `src/services/cacheService.ts`, `deltaSyncService.ts`, `firestoreCacheService.ts` eller cache-nycklar kan påverka offline/data-konsistens. Verifiera att befintliga cachar inte blir ogiltiga utan migrering om det behövs.
- [ ] **tableId / viewId-mappning:** Ändringar i `src/config/viewTableMap.ts` eller användning av `getTableId`/viewId påverkar Conditions-modal, OnboardingHelp och metadata. Kontrollera att rätt vy mappar till rätt tabell.

### Release / rollback
- [ ] Jag vet hur jag **reverterar** denna PR vid behov: `git revert <merge-commit-hash>` (revert av merge-commit), sedan push. Ingen force-push på main.
- [ ] Efter revert: verifiera med `npm run build:check && npm run test -- --run` (och vid behov e2e) att allt är grönt.
- [ ] Om ändringen är bakom en **feature flag** eller env-var: dokumentera hur man stänger av den vid rollback.

### Definition of Done
- [ ] **Dokumentation:** README, SETUP_APPS_SCRIPT.md, CLOUD_FUNCTIONS_SETUP.md, APPS_SCRIPT_SETUP.md eller TESTING_GUIDE.md uppdaterade om setup/konfiguration/test påverkas.
- [ ] **Storybook:** Om en UI-komponent ändras – relevant story uppdaterad eller tillagd och kontrollerad.
- [ ] **Inga flaky tests:** Om nya eller ändrade tester flakar – de ska fixas i denna PR (eller tas bort/ändras så att de inte blockar CI).

```

## `.gitignore`

```text
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Temporary admin setup
temp-set-admin/
serviceAccountKey.json
*.json.key

node_modules
dist
dist-ssr
*.local

# Environment variables
.env
.env.local
.env.production
.env.development

# Firebase
.firebase/
firebase-debug.log
firestore-debug.log

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?


*storybook.log
storybook-static

```

## `.storybook/main.ts`

```typescript
import type { StorybookConfig } from '@storybook/react-vite';

const config: StorybookConfig = {
  "stories": [
    "../src/**/*.mdx",
    "../src/**/*.stories.@(js|jsx|mjs|ts|tsx)"
  ],
  "addons": [
    "@chromatic-com/storybook",
    "@storybook/addon-vitest",
    "@storybook/addon-a11y",
    "@storybook/addon-docs",
    "@storybook/addon-onboarding"
  ],
  "framework": "@storybook/react-vite"
};
export default config;
```

## `.storybook/preview.ts`

```typescript
import type { Preview } from '@storybook/react-vite'

const preview: Preview = {
  parameters: {
    controls: {
      matchers: {
       color: /(background|color)$/i,
       date: /Date$/i,
      },
    },
  },
};

export default preview;
```

## `ACCESSIBILITY_TESTING.md`

```markdown
# Accessibility Testing Guide

This document provides guidance for testing the accessibility of the Stock Score application using screen readers and other accessibility tools.

## Overview

The application has been improved with comprehensive ARIA labels, proper semantic HTML, and keyboard navigation support. This guide will help you verify that these improvements work correctly with assistive technologies.

## Screen Readers

### Windows

#### NVDA (Free, Recommended)
1. **Download**: https://www.nvaccess.org/download/
2. **Installation**: Run the installer and follow the prompts
3. **Usage**:
   - Start NVDA (usually `Ctrl+Alt+N`)
   - Navigate the application using arrow keys
   - Use `Insert+F7` to open the elements list
   - Use `NVDA+Space` to toggle speech on/off

**Testing Checklist**:
- [ ] All buttons are announced with their purpose
- [ ] Form inputs are properly labeled
- [ ] Navigation menu items are clearly announced
- [ ] Table headers are announced when navigating cells
- [ ] Expand/collapse buttons indicate their state
- [ ] Error messages are announced
- [ ] Loading states are announced

#### JAWS (Commercial)
1. **Download**: https://www.freedomscientific.com/products/software/jaws/
2. **Usage**:
   - Start JAWS
   - Use `Insert+F3` to open the elements list
   - Use `Insert+Down Arrow` to read current line

### macOS

#### VoiceOver (Built-in)
1. **Enable**: System Preferences → Accessibility → VoiceOver (or `Cmd+F5`)
2. **Usage**:
   - Use `Control+Option+Right Arrow` to navigate forward
   - Use `Control+Option+Left Arrow` to navigate backward
   - Use `Control+Option+Space` to activate buttons
   - Use `Control+Option+H` to navigate by headings

**Testing Checklist**:
- [ ] All interactive elements are announced
- [ ] Form labels are read before input values
- [ ] Table navigation works correctly
- [ ] Modal dialogs are properly announced
- [ ] Dynamic content updates are announced

## Keyboard Navigation Testing

### Basic Navigation
- **Tab**: Move forward through interactive elements
- **Shift+Tab**: Move backward through interactive elements
- **Enter/Space**: Activate buttons and links
- **Arrow Keys**: Navigate within components (menus, tables, etc.)
- **Escape**: Close modals and dropdowns

### Testing Checklist
- [ ] All interactive elements are reachable via keyboard
- [ ] Focus indicators are visible
- [ ] Tab order is logical
- [ ] No keyboard traps
- [ ] Modals can be closed with Escape
- [ ] Dropdown menus can be navigated with arrow keys

## Automated Testing Tools

### axe DevTools (Browser Extension)
1. **Install**: Available for Chrome, Firefox, and Edge
2. **Usage**:
   - Open the application
   - Open browser DevTools
   - Navigate to "axe DevTools" tab
   - Click "Analyze" to scan the page
   - Review violations and warnings

### WAVE (Web Accessibility Evaluation Tool)
1. **Install**: Browser extension or use online tool at https://wave.webaim.org/
2. **Usage**:
   - Navigate to the application
   - Run WAVE analysis
   - Review errors, alerts, and features

### Lighthouse (Built into Chrome DevTools)
1. **Usage**:
   - Open Chrome DevTools
   - Navigate to "Lighthouse" tab
   - Select "Accessibility" category
   - Click "Generate report"
   - Review accessibility score and issues

## Manual Testing Checklist

### ARIA Labels
- [ ] All icon buttons have `aria-label` attributes
- [ ] All form inputs have associated labels
- [ ] All tables have `aria-label` or `aria-labelledby`
- [ ] All expandable sections have `aria-expanded` attributes
- [ ] All menus have `role="menu"` and `aria-label`
- [ ] All menu items have `role="menuitem"`

### Semantic HTML
- [ ] Headings are used in logical order (h1 → h2 → h3)
- [ ] Lists use proper `<ul>` or `<ol>` elements
- [ ] Buttons are used for actions, links for navigation
- [ ] Form elements are properly grouped with `<fieldset>` where appropriate

### Color and Contrast
- [ ] Text meets WCAG AA contrast requirements (4.5:1 for normal text, 3:1 for large text)
- [ ] Information is not conveyed by color alone
- [ ] Focus indicators are visible in both light and dark themes

### Focus Management
- [ ] Focus is visible on all interactive elements
- [ ] Focus order is logical
- [ ] Focus is managed correctly in modals (trapped, returned on close)
- [ ] Skip links are available for main content

## Common Issues to Check

### Missing Labels
- Icon-only buttons without `aria-label`
- Form inputs without labels
- Images without alt text (if decorative, should have `aria-hidden="true"`)

### Incorrect ARIA Usage
- Using `role="button"` on elements that aren't buttons
- Missing `aria-expanded` on collapsible elements
- Incorrect `aria-checked` values

### Keyboard Issues
- Elements that can't be reached with keyboard
- Focus indicators that are too subtle
- Keyboard traps in modals or dropdowns

## Testing Specific Components

### Header Component
- [ ] Refresh button is announced correctly
- [ ] Theme selector menu items are announced
- [ ] Language selector menu items are announced
- [ ] User profile button is announced
- [ ] Logout button is announced

### Sidebar Navigation
- [ ] Navigation items are announced with their purpose
- [ ] Active page is indicated with `aria-current="page"`
- [ ] Collapsible sections indicate expanded/collapsed state
- [ ] Navigation structure is clear

### Tables
- [ ] Table headers are associated with cells
- [ ] Sortable columns indicate sort state
- [ ] Expand/collapse buttons for rows are clearly labeled
- [ ] Pagination controls are accessible

### Filters
- [ ] Filter button indicates active filter count
- [ ] Filter inputs are properly labeled
- [ ] Saved filters can be loaded and deleted via keyboard
- [ ] Clear filters button is accessible

## Reporting Issues

When reporting accessibility issues, please include:
1. **Component**: Which component has the issue
2. **Screen Reader**: Which screen reader you're using
3. **Expected Behavior**: What should happen
4. **Actual Behavior**: What actually happens
5. **Steps to Reproduce**: How to trigger the issue

## Resources

- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
- [ARIA Authoring Practices Guide](https://www.w3.org/WAI/ARIA/apg/)
- [WebAIM Screen Reader Testing](https://webaim.org/articles/screenreader_testing/)
- [MDN Accessibility Guide](https://developer.mozilla.org/en-US/docs/Web/Accessibility)

## Continuous Improvement

Accessibility is an ongoing effort. Regular testing should be performed:
- After major feature additions
- Before releases
- When updating dependencies
- When refactoring components

Consider adding accessibility checks to your CI/CD pipeline using tools like:
- [axe-core](https://github.com/dequelabs/axe-core)
- [pa11y](https://pa11y.org/)
- [Lighthouse CI](https://github.com/GoogleChrome/lighthouse-ci)

```

## `APPS_SCRIPT_SETUP.md`

```markdown
# Apps Script Setup Guide

Denna guide visar hur du skapar en Google Apps Script för att ersätta CORS proxy-lösningen med en direkt JSON API. Denna guide inkluderar även delta-sync funktionalitet för effektivare datauppdateringar.

## Delta Sync Support

Appen stödjer nu delta-sync för effektivare datauppdateringar:
- Första gången: Hämtar full snapshot av all data
- Därefter: Hämtar endast ändringar (delta) var 15-30 minuter
- Uppdaterar UI inkrementellt utan full sid-reload

Delta-sync är aktiverat som standard. För att inaktivera, sätt `VITE_DELTA_SYNC_ENABLED=false` i environment variables.

## Steg 1: Skapa Apps Script

1. Öppna ditt Google Sheet: https://docs.google.com/spreadsheets/d/1KOOSLJVGdDZHBV1MUmb4D9oVIKUJj5TIgYCerjkWYcE
2. Gå till **Extensions** → **Apps Script**
3. **För delta-sync support**: Kopiera koden från `apps-script/Code.gs` i detta projekt
4. **Alternativt (endast grundläggande API)**: Ersätt all kod med följande:

```javascript
function doGet(e) {
  try {
    const sheetName = e.parameter.sheet || 'DashBoard';
    const ss = SpreadsheetApp.openById('1KOOSLJVGdDZHBV1MUmb4D9oVIKUJj5TIgYCerjkWYcE');
    const sheet = ss.getSheetByName(sheetName);
    
    if (!sheet) {
      const errorData = { error: `Sheet "${sheetName}" not found` };
      return ContentService
        .createTextOutput(JSON.stringify(errorData))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    const values = sheet.getDataRange().getValues();
    const output = ContentService
      .createTextOutput(JSON.stringify(values))
      .setMimeType(ContentService.MimeType.JSON);
    
    return output;
  } catch (error) {
    const errorData = { 
      error: 'Server error', 
      message: error.toString() 
    };
    return ContentService
      .createTextOutput(JSON.stringify(errorData))
      .setMimeType(ContentService.MimeType.JSON);
  }
}
```

## Steg 2: Konfigurera API Token (Valfritt, rekommenderat för delta-sync)

För delta-sync API-token autentisering (valfritt men rekommenderat):

1. I Apps Script, gå till **Project Settings** (kugghjulsikonen)
2. Klicka på **Script properties**
3. Lägg till en ny property:
   - **Property**: `API_TOKEN`
   - **Value**: Välj en säker token (t.ex. generera med `openssl rand -hex 32`)
4. Klicka **Save**
5. **Viktigt**: Kopiera denna token - du behöver den för frontend-konfiguration

**Notera**: Om ingen token sätts, tillåts alla requests (för enklare setup, men mindre säkert).

## Steg 3: Installera onEdit Trigger (Endast för delta-sync)

Om du använder delta-sync-koden:

1. I Apps Script, välj funktionen `installTriggers` i dropdown-menyn
2. Klicka på **Run** (kör)
3. **Notera**: `onEdit` är en "simple trigger" som installeras automatiskt av Google Sheets - ingen manuell installation behövs
4. Varje gång data ändras i DashBoard eller SMA-ark, loggas ändringen automatiskt i ChangeLog-arket

**ChangeLog-ark**: Skapas automatiskt av Apps Script-koden. Detta ark trackar alla ändringar i övervakade sheets.

## Steg 4: Deploya som Web App

1. Klicka på **Deploy** → **New deployment**
2. Välj typ: **Web app** (INTE "Library"!)
3. Fyll i:
   - **Description**: "Stock Score Data API"
   - **Execute as**: "Me"
   - **Who has access**: **"Anyone"** (viktigt för CORS!)
4. Klicka på **Deploy**
5. **VIKTIGT**: Godkänn behörighetsgivningen när Google ber om det
6. **Kopiera Web App URL** (måste sluta med `/exec`, t.ex: `https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec`)
   - ⚠️ **INTE** `/library/...` - det är för libraries, inte Web Apps
   - ✅ Måste vara `/s/.../exec` format

## Steg 5: Konfigurera i appen

### För lokal utveckling:

Skapa en `.env.local` fil i projektets root:
```
VITE_APPS_SCRIPT_URL=https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec
VITE_DELTA_SYNC_ENABLED=true
VITE_DELTA_SYNC_POLL_MINUTES=15
VITE_APPS_SCRIPT_TOKEN=your-token-here
```

**Delta-sync inställningar** (valfria):
- `VITE_DELTA_SYNC_ENABLED`: Aktivera/inaktivera delta-sync (default: `true`)
- `VITE_DELTA_SYNC_POLL_MINUTES`: Poll-intervall i minuter (default: `15`)
- `VITE_APPS_SCRIPT_TOKEN`: API-token för autentisering (valfritt)

### För Vercel deployment (VIKTIGT!):

1. Gå till [Vercel Dashboard](https://vercel.com/dashboard)
2. Välj ditt projekt "STOCK SCORE"
3. Gå till **Settings** → **Environment Variables**
4. Klicka på **Add New**
5. Fyll i:
   - **Key**: `VITE_APPS_SCRIPT_URL`
   - **Value**: `https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec` (ersätt YOUR_SCRIPT_ID med ditt Script ID från deployment)
   - **Environment**: Välj alla (Production, Preview, Development)
6. (Valfritt) Lägg till delta-sync inställningar:
   - **Key**: `VITE_DELTA_SYNC_ENABLED`, **Value**: `true`
   - **Key**: `VITE_DELTA_SYNC_POLL_MINUTES`, **Value**: `15`
   - **Key**: `VITE_APPS_SCRIPT_TOKEN`, **Value**: `your-token-here` (samma token som i Apps Script)
6. Klicka **Save**
7. **VIKTIGT**: Du måste **redeploya** projektet efter att ha lagt till environment variables!
   - Gå till **Deployments** → Välj senaste deployment → **Redeploy**
   - Eller pusha en ny commit till GitHub (detta triggar automatisk redeploy)

## Steg 6: Testa

1. Starta appen: `npm run dev`
2. Öppna Developer Tools → Network tab
3. Du bör se requests till din Apps Script URL istället för CORS proxy
4. Om Apps Script URL inte är konfigurerad, faller appen tillbaka till CSV via CORS proxy

## Fördelar

- ✅ Snabbare (direkt JSON, ingen CSV parsing)
- ✅ Mer pålitligt (Google's infrastruktur)
- ✅ Mindre dataöverföring (JSON är kompaktare)
- ✅ Bättre kontroll över dataformatering
- ✅ Automatisk fallback till CSV om Apps Script inte är tillgängligt

## Felsökning

### CORS-fel (Access-Control-Allow-Origin)
Om du ser CORS-fel i konsolen:
1. **Kontrollera deployment**: Gå till **Deploy** → **Manage deployments**
2. **Redigera deployment**: Klicka på pennikonen (edit) bredvid din deployment
3. **Kontrollera "Who has access"**: Måste vara **"Anyone"** (inte "Anyone with Google account")
4. **Spara och deploya igen**: Även om inställningarna är rätt, kan det behöva omdeployas
5. **Testa URL direkt**: Öppna Apps Script URL i webbläsaren, du bör se JSON-data direkt
6. **Kontrollera URL-format**: 
   - ✅ Rätt: `https://script.google.com/macros/s/SCRIPT_ID/exec`
   - ❌ Fel: `https://script.google.com/macros/library/LIBRARY_ID/...`

### Data kommer inte
- Kontrollera att sheet-namnet matchar exakt ("DashBoard" eller "SMA" - case-sensitive!)
- Testa Apps Script URL direkt i webbläsaren med parameter: `?sheet=DashBoard`
- Kontrollera att sheet-ID är korrekt i Apps Script-koden

### URL fungerar inte
- Se till att du har kopierat hela URL:en inklusive `/exec`
- Kontrollera att du har deployat som "Web app", inte "Library"
- Testa URL:en i en ny inkognitofönster för att undvika cache-problem

### Ytterligare tips
- Om du ändrar Apps Script-koden, måste du deploya en **ny version** eller **uppdatera** den befintliga
- Google kan kräva att du godkänner behörigheter första gången du deployar
- Vercel environment variables måste vara satta för Production, Preview, och Development miljöer
- **VIKTIGT**: Efter att ha lagt till environment variables i Vercel, måste du **redeploya** projektet för att ändringarna ska gälla!

### Verifiera konfigurationen

För att kontrollera om Apps Script URL är korrekt konfigurerad:

1. **Lokalt**: Öppna Developer Console i webbläsaren. Du bör se:
   - ✅ `Apps Script URL configured successfully!` om URL är satt
   - ❌ `Apps Script URL NOT configured in Vercel!` om URL saknas

2. **I produktion (Vercel)**: Öppna Developer Console på din Vercel-deployade sida
   - Kontrollera samma meddelanden som ovan

3. **Testa Apps Script direkt**: Öppna denna URL i webbläsaren:
   ```
   https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec?sheet=DashBoard
   ```
   (Ersätt YOUR_SCRIPT_ID med ditt Script ID.)
   Du bör se JSON-data direkt. Om du ser en inloggningssida eller fel, kontrollera deployment-inställningarna.

4. **Testa delta-sync endpoints** (om delta-sync är aktiverat):
   - POST (prod): `Authorization: Bearer <token>` + JSON body `{ action: 'snapshot', sheet: 'DashBoard', token: '<token>' }`
   - Legacy: Token i body (fasas ut i Steg B.2)
   - GET med token i URL stöds ej när API_TOKEN är satt

```

## `apps-script/Code.gs`

```javascript
/**
 * Google Apps Script for Delta Sync API
 *
 * Endpoints:
 * - POST (prod): Token in header (Authorization Bearer or X-API-Token) or in body.
 *   Apps Script reads from body until header API is available. JSON body { action, sheet, since?, token }.
 * - GET: No token in URL. When API_TOKEN is set, POST is required.
 *
 * Fail-closed: When API_TOKEN is set in Script Properties, token is required. Missing/invalid => 401.
 * When API_TOKEN is not set: allow access, log warning, include authMode: 'open' in response.
 *
 * Setup:
 * 1. Copy this code to Apps Script bound to your Google Sheet
 * 2. Set API token in Script Properties: key="API_TOKEN", value="your-secret-token"
 * 3. Run installTriggers() function once to set up onEdit trigger
 * 4. Deploy as Web App with "Anyone" access
 */

// Configuration
const SHEET_ID = '1KOOSLJVGdDZHBV1MUmb4D9oVIKUJj5TIgYCerjkWYcE'; // Your spreadsheet ID
const CHANGE_LOG_SHEET_NAME = 'ChangeLog';
const KEY_COLUMN_NAME = 'Ticker'; // Column used as unique key
const MONITORED_SHEETS = ['DashBoard', 'SMA']; // Sheets to track changes for

/**
 * Get token from request. Header-first when Apps Script exposes headers; body fallback for now.
 * Apps Script Web App does NOT expose request headers - we read from body only.
 * Querystring token is NOT supported (legacy; return null to force 401 when API_TOKEN set).
 */
function getRequestToken(e) {
  // A) Header: Apps Script does not expose e.headers - placeholder for future API
  // When available: token = (e.headers && (e.headers['Authorization'] || e.headers['X-Api-Token']));
  var tokenFromHeader = null;

  // B) Body (JSON): primary source until header API exists
  var tokenFromBody = null;
  if (e && e.postData && e.postData.contents) {
    try {
      var body = JSON.parse(e.postData.contents);
      tokenFromBody = body.token || null;
    } catch (err) { /* invalid JSON */ }
  }

  // C) Querystring: NOT supported - never use params.token for security
  return tokenFromHeader || tokenFromBody;
}

/**
 * Main entry point for GET requests (querystring params; no token in URL)
 */
function doGet(e) {
  try {
    var params = e && e.parameter ? e.parameter : {};
    // Legacy: token in querystring is NOT supported when API_TOKEN is set
    var token = null;
    if (params.token) {
      var hasApiToken = PropertiesService.getScriptProperties().getProperty('API_TOKEN');
      if (hasApiToken) {
        return createErrorResponse('Unauthorized: Token in URL not allowed. Use POST with token in body.', 401);
      }
      token = params.token; // dev-only when no API_TOKEN
    }
    var authResult = checkAuth(token);
    if (authResult.error) {
      return authResult.response;
    }
    
    var action = params.action || 'snapshot';
    var sheetName = params.sheet || 'DashBoard';
    
    if (action === 'snapshot' || !params.action) {
      return addAuthMeta(handleSnapshot(sheetName), authResult.authMode);
    } else if (action === 'changes') {
      var sinceVersion = params.since ? parseInt(params.since, 10) : 0;
      return addAuthMeta(handleChanges(sheetName, sinceVersion), authResult.authMode);
    } else {
      return createErrorResponse('Invalid action. Use "snapshot" or "changes"', 400);
    }
  } catch (error) {
    return createErrorResponse('Server error: ' + error.toString(), 500);
  }
}

/**
 * Main entry point for POST requests (JSON body - header-first token, body fallback)
 */
function doPost(e) {
  try {
    var token = getRequestToken(e);
    var action = 'snapshot';
    var sheetName = 'DashBoard';
    var sinceVersion = 0;

    if (e && e.postData && e.postData.contents) {
      try {
        var body = JSON.parse(e.postData.contents);
        action = body.action || 'snapshot';
        sheetName = body.sheet || 'DashBoard';
        sinceVersion = body.since ? parseInt(body.since, 10) : 0;
      } catch (parseErr) {
        return createErrorResponse('Invalid JSON body', 400);
      }
    }

    var authResult = checkAuth(token);
    if (authResult.error) {
      return authResult.response;
    }
    
    if (action === 'snapshot' || !action) {
      return addAuthMeta(handleSnapshot(sheetName), authResult.authMode);
    } else if (action === 'changes') {
      return addAuthMeta(handleChanges(sheetName, sinceVersion), authResult.authMode);
    } else {
      return createErrorResponse('Invalid action. Use "snapshot" or "changes"', 400);
    }
  } catch (error) {
    return createErrorResponse('Server error: ' + error.toString(), 500);
  }
}

/**
 * Wrap JSON response with auth meta when authMode is open (for dev)
 */
function addAuthMeta(output, authMode) {
  if (!authMode) return output;
  try {
    var text = output.getContent();
    var data = JSON.parse(text);
    data.meta = data.meta || {};
    data.meta.authMode = authMode;
    return ContentService.createTextOutput(JSON.stringify(data)).setMimeType(ContentService.MimeType.JSON);
  } catch (err) {
    return output;
  }
}

/**
 * Handle snapshot request - returns full data
 */
function handleSnapshot(sheetName) {
  try {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    const sheet = ss.getSheetByName(sheetName);
    
    if (!sheet) {
      return createErrorResponse('Sheet "' + sheetName + '" not found', 404);
    }
    
    // Get all data
    const values = sheet.getDataRange().getValues();
    if (values.length === 0) {
      return createErrorResponse('Sheet "' + sheetName + '" is empty', 404);
    }
    
    const headers = values[0].map(function(h) { return String(h).trim(); });
    
    // Find key column index
    const keyColumnIndex = headers.indexOf(KEY_COLUMN_NAME);
    if (keyColumnIndex === -1) {
      return createErrorResponse('Key column "' + KEY_COLUMN_NAME + '" not found in sheet', 400);
    }
    
    // Build rows array with key-value pairs
    const rows = [];
    for (var i = 1; i < values.length; i++) {
      var rowValues = values[i];
      var key = rowValues[keyColumnIndex] ? String(rowValues[keyColumnIndex]).trim() : '';
      if (key) { // Only include rows with a key
        rows.push({
          key: key,
          values: rowValues
        });
      }
    }
    
    // Get current version
    const currentVersion = getCurrentVersion();
    
    const response = {
      ok: true,
      version: currentVersion,
      headers: headers,
      rows: rows,
      generatedAt: new Date().toISOString()
    };
    
    return ContentService
      .createTextOutput(JSON.stringify(response))
      .setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    return createErrorResponse('Failed to generate snapshot: ' + error.toString(), 500);
  }
}

/**
 * Handle changes request - returns only changes since version
 */
function handleChanges(sheetName, sinceVersion) {
  try {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    const changeLogSheet = ensureChangeLogSheet(ss);
    
    if (!changeLogSheet) {
      return createErrorResponse('Failed to access ChangeLog sheet', 500);
    }
    
    // Get all change log entries for this sheet since the version
    const changeLogData = changeLogSheet.getDataRange().getValues();
    if (changeLogData.length <= 1) {
      // No changes logged yet (only header row)
      const currentVersion = getCurrentVersion();
      return createSuccessResponse({
        ok: true,
        fromVersion: sinceVersion,
        toVersion: currentVersion,
        changes: [],
        needsFullResync: false
      });
    }
    
    // Parse change log (skip header row)
    const changes = [];
    var maxVersion = sinceVersion;
    
    // Column indices in ChangeLog sheet
    var changeIdCol = 0;
    var tsISOCol = 1;
    var sheetNameCol = 2;
    var rowIndexCol = 3;
    var keyCol = 4;
    var changedColumnsCol = 5;
    var rowValuesJsonCol = 6;
    
    for (var i = 1; i < changeLogData.length; i++) {
      var row = changeLogData[i];
      var changeId = parseInt(row[changeIdCol], 10);
      var logSheetName = String(row[sheetNameCol] || '').trim();
      
      // Filter by sheet name and version
      if (logSheetName === sheetName && changeId > sinceVersion) {
        try {
          var rowValuesJson = row[rowValuesJsonCol];
          var rowValues = JSON.parse(rowValuesJson);
          
          var changedColumnsJson = row[changedColumnsCol];
          var changedColumns = changedColumnsJson ? JSON.parse(changedColumnsJson) : [];
          
          changes.push({
            id: changeId,
            tsISO: String(row[tsISOCol] || ''),
            key: String(row[keyCol] || '').trim(),
            rowIndex: parseInt(row[rowIndexCol], 10),
            changedColumns: changedColumns,
            values: rowValues
          });
          
          if (changeId > maxVersion) {
            maxVersion = changeId;
          }
        } catch (parseError) {
          // Skip invalid entries, log error
          console.error('Failed to parse change log entry:', parseError);
        }
      }
    }
    
    // If sinceVersion is too old (e.g., ChangeLog was cleared), suggest full resync
    var needsFullResync = false;
    if (sinceVersion > 0 && changes.length === 0 && maxVersion > sinceVersion) {
      // This shouldn't happen, but if it does, suggest resync
      needsFullResync = true;
    }
    
    // Check if ChangeLog might have been cleared (sinceVersion exists but no changes found)
    var minChangeId = getMinChangeIdInLog(changeLogSheet);
    if (sinceVersion > 0 && sinceVersion < minChangeId) {
      needsFullResync = true;
    }
    
    const currentVersion = getCurrentVersion();
    
    return createSuccessResponse({
      ok: true,
      fromVersion: sinceVersion,
      toVersion: currentVersion,
      changes: changes,
      needsFullResync: needsFullResync
    });
  } catch (error) {
    return createErrorResponse('Failed to get changes: ' + error.toString(), 500);
  }
}

/**
 * Get minimum changeId currently in ChangeLog
 */
function getMinChangeIdInLog(changeLogSheet) {
  try {
    var data = changeLogSheet.getDataRange().getValues();
    if (data.length <= 1) {
      return 0; // Only header row
    }
    
    var minId = Infinity;
    for (var i = 1; i < data.length; i++) {
      var changeId = parseInt(data[i][0], 10);
      if (!isNaN(changeId) && changeId < minId) {
        minId = changeId;
      }
    }
    
    return isFinite(minId) ? minId : 0;
  } catch (error) {
    return 0;
  }
}

/**
 * onEdit trigger - logs changes to ChangeLog sheet
 */
function onEdit(e) {
  try {
    var sheet = e.source.getActiveSheet();
    var sheetName = sheet.getName();
    
    // Only track changes for monitored sheets
    if (MONITORED_SHEETS.indexOf(sheetName) === -1) {
      return;
    }
    
    // Ignore changes to ChangeLog sheet itself
    if (sheetName === CHANGE_LOG_SHEET_NAME) {
      return;
    }
    
    var range = e.range;
    var rowIndex = range.getRow();
    var columnIndex = range.getColumn();
    
    // Ignore header row (row 1)
    if (rowIndex <= 1) {
      return;
    }
    
    var ss = e.source;
    var changeLogSheet = ensureChangeLogSheet(ss);
    if (!changeLogSheet) {
      return; // Failed to create/access ChangeLog
    }
    
    // Get the edited row data
    var editedRow = sheet.getRange(rowIndex, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    // Get headers to find key column
    var headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(function(h) {
      return String(h).trim();
    });
    var keyColumnIndex = headers.indexOf(KEY_COLUMN_NAME);
    
    if (keyColumnIndex === -1) {
      return; // Key column not found, skip logging
    }
    
    var key = editedRow[keyColumnIndex] ? String(editedRow[keyColumnIndex]).trim() : '';
    if (!key) {
      return; // No key value, skip logging
    }
    
    // Determine which columns changed
    var numColumns = range.getNumColumns();
    var changedColumns = [];
    var startCol = range.getColumn();
    for (var i = 0; i < numColumns; i++) {
      var colIndex = startCol + i - 1; // Convert to 0-based
      if (colIndex < headers.length) {
        changedColumns.push(headers[colIndex]);
      }
    }
    
    // Get next changeId
    var changeId = getNextChangeId();
    
    // Log the change
    var timestamp = new Date().toISOString();
    var rowValuesJson = JSON.stringify(editedRow);
    var changedColumnsJson = JSON.stringify(changedColumns);
    
    changeLogSheet.appendRow([
      changeId,
      timestamp,
      sheetName,
      rowIndex,
      key,
      changedColumnsJson,
      rowValuesJson
    ]);
    
  } catch (error) {
    // Log error but don't throw (onEdit triggers should not throw)
    console.error('Error in onEdit trigger:', error);
  }
}

/**
 * Ensure ChangeLog sheet exists, create if needed
 */
function ensureChangeLogSheet(ss) {
  try {
    var changeLogSheet = ss.getSheetByName(CHANGE_LOG_SHEET_NAME);
    
    if (!changeLogSheet) {
      // Create ChangeLog sheet
      changeLogSheet = ss.insertSheet(CHANGE_LOG_SHEET_NAME);
      
      // Add headers
      changeLogSheet.getRange(1, 1, 1, 7).setValues([[
        'changeId',
        'tsISO',
        'sheetName',
        'rowIndex',
        'key',
        'changedColumns',
        'rowValuesJson'
      ]]);
      
      // Format header row
      var headerRange = changeLogSheet.getRange(1, 1, 1, 7);
      headerRange.setFontWeight('bold');
      headerRange.setBackground('#e0e0e0');
    }
    
    return changeLogSheet;
  } catch (error) {
    console.error('Failed to ensure ChangeLog sheet:', error);
    return null;
  }
}

/**
 * Get current version (latest changeId)
 */
function getCurrentVersion() {
  try {
    var props = PropertiesService.getScriptProperties();
    var version = props.getProperty('CHANGE_ID');
    return version ? parseInt(version, 10) : 0;
  } catch (error) {
    return 0;
  }
}

/**
 * Get next changeId and increment
 */
function getNextChangeId() {
  try {
    var props = PropertiesService.getScriptProperties();
    var currentId = parseInt(props.getProperty('CHANGE_ID') || '0', 10);
    var nextId = currentId + 1;
    props.setProperty('CHANGE_ID', String(nextId));
    return nextId;
  } catch (error) {
    console.error('Failed to get next changeId:', error);
    // Fallback: use timestamp (not ideal but better than failing)
    return Math.floor(Date.now() / 1000);
  }
}

/**
 * Check authentication token. Fail-closed when API_TOKEN is configured.
 * Returns { error: boolean, response?: TextOutput, authMode?: string }
 * - If API_TOKEN set and token missing/invalid: { error: true, response: 401 }
 * - If API_TOKEN not set: { error: false, authMode: 'open' } - allow but log warning
 * - If auth passes: { error: false }
 */
function checkAuth(token) {
  try {
    var props = PropertiesService.getScriptProperties();
    var validToken = props.getProperty('API_TOKEN');
    
    if (!validToken) {
      console.warn('API_TOKEN not configured in Script Properties - authMode: open (not for prod)');
      return { error: false, authMode: 'open' };
    }
    
    if (!token || token !== validToken) {
      return {
        error: true,
        response: createErrorResponse('Unauthorized: Invalid or missing API token', 401)
      };
    }
    
    return { error: false };
  } catch (err) {
    console.error('checkAuth error:', err);
    return { error: true, response: createErrorResponse('Authentication error', 500) };
  }
}

/**
 * Create error response
 */
function createErrorResponse(message, statusCode) {
  var response = {
    ok: false,
    error: message
  };
  
  return ContentService
    .createTextOutput(JSON.stringify(response))
    .setMimeType(ContentService.MimeType.JSON)
    .setHttpResponseCode(statusCode || 500);
}

/**
 * Create success response
 */
function createSuccessResponse(data) {
  return ContentService
    .createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * Install onEdit trigger (run this once after deploying)
 */
function installTriggers() {
  try {
    var ss = SpreadsheetApp.openById(SHEET_ID);
    var triggers = ScriptApp.getProjectTriggers();
    
    // Remove existing onEdit triggers for this function
    for (var i = 0; i < triggers.length; i++) {
      if (triggers[i].getHandlerFunction() === 'onEdit') {
        ScriptApp.deleteTrigger(triggers[i]);
      }
    }
    
    // Note: onEdit is a simple trigger that doesn't need to be installed
    // It's automatically triggered by Google Sheets on edits
    // This function is kept for documentation purposes
    
    console.log('onEdit trigger is automatically handled by Google Sheets');
    console.log('No manual trigger installation needed');
    
  } catch (error) {
    console.error('Error in installTriggers:', error);
    throw error;
  }
}

```

## `CLOUD_FUNCTIONS_SETUP.md`

```markdown
# Cloud Functions Setup för Rollbaserad Åtkomstkontroll

Denna dokumentation beskriver hur du konfigurerar Firebase Cloud Functions för att hantera rollbaserad åtkomstkontroll i appen.

## Översikt

Cloud Functions används för att sätta custom claims på Firebase Authentication-användare. Detta kan inte göras direkt från klienten av säkerhetsskäl - det måste göras från en server med Admin SDK.

## Funktioner som behövs

### 1. setUserRole

Sätter en custom claim (`role`) på en användare och uppdaterar status i `pendingRequests`.

**HTTP Endpoint:** `POST /setUserRole`

**Request Body:**
```json
{
  "userId": "user-id-here",
  "role": "viewer" | "editor",
  "requestId": "request-id-here"
}
```

**Response:**
```json
{
  "success": true,
  "message": "Role set successfully"
}
```

### 2. denyRequest

Markerar en begäran som nekad i `pendingRequests`.

**HTTP Endpoint:** `POST /denyRequest`

**Request Body:**
```json
{
  "userId": "user-id-here",
  "requestId": "request-id-here"
}
```

**Response:**
```json
{
  "success": true,
  "message": "Request denied"
}
```

## Implementation Guide

### Steg 1: Installera Firebase CLI

```bash
npm install -g firebase-tools
```

### Steg 2: Initiera Functions

```bash
firebase init functions
```

Välj TypeScript när du blir tillfrågad.

### Steg 3: Skapa Functions-kod

Skapa `functions/src/index.ts`:

```typescript
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';

admin.initializeApp();

// Middleware för att verifiera admin-autentisering
async function verifyAdmin(context: functions.https.CallableContext): Promise<void> {
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
  }

  const token = await admin.auth().getUser(context.auth.uid);
  const claims = token.customClaims || {};
  
  if (claims.role !== 'admin') {
    throw new functions.https.HttpsError('permission-denied', 'User must be admin');
  }
}

// Set user role
export const setUserRole = functions.https.onCall(async (data, context) => {
  await verifyAdmin(context);

  const { userId, role, requestId } = data;

  if (!userId || !role || !['viewer', 'editor'].includes(role)) {
    throw new functions.https.HttpsError('invalid-argument', 'Invalid parameters');
  }

  try {
    // Set custom claim
    await admin.auth().setCustomUserClaims(userId, { role });

    // Update pending request status
    const db = admin.firestore();
    await db.collection('pendingRequests').doc(requestId || userId).update({
      status: 'approved',
      approvedRole: role,
      approvedAt: admin.firestore.FieldValue.serverTimestamp(),
      approvedBy: context.auth.uid,
    });

    return { success: true, message: 'Role set successfully' };
  } catch (error: any) {
    console.error('Error setting user role:', error);
    throw new functions.https.HttpsError('internal', error.message);
  }
});

// Deny request
export const denyRequest = functions.https.onCall(async (data, context) => {
  await verifyAdmin(context);

  const { userId, requestId } = data;

  if (!userId) {
    throw new functions.https.HttpsError('invalid-argument', 'Invalid parameters');
  }

  try {
    // Update pending request status
    const db = admin.firestore();
    await db.collection('pendingRequests').doc(requestId || userId).update({
      status: 'denied',
      deniedAt: admin.firestore.FieldValue.serverTimestamp(),
      deniedBy: context.auth.uid,
    });

    return { success: true, message: 'Request denied' };
  } catch (error: any) {
    console.error('Error denying request:', error);
    throw new functions.https.HttpsError('internal', error.message);
  }
});
```

### Steg 4: Installera Dependencies

```bash
cd functions
npm install firebase-functions firebase-admin
npm install --save-dev @types/node typescript
```

### Steg 5: Deploy Functions

```bash
firebase deploy --only functions
```

### Steg 6: Konfigurera Environment Variables

Efter deploy, konfigurera Cloud Functions för adminRefreshCache:

```bash
firebase functions:config:set apps_script.url="https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec"
firebase functions:config:set apps_script.token="YOUR_APPS_SCRIPT_TOKEN"
```

Eller använd environment variables vid deploy (Firebase stödjer `process.env` för vissa nycklar). Se Firebase-dokumentation för `.env` eller Secret Manager.

**adminRefreshCache** kräver:
- `APPS_SCRIPT_URL` eller `apps_script.url` – Apps Script Web App URL
- `APPS_SCRIPT_TOKEN` eller `apps_script.token` – Token för Apps Script (samma som `VITE_APPS_SCRIPT_TOKEN`)

## Alternativ: HTTP Functions (för AdminPanel)

Om du vill använda HTTP endpoints istället för Callable Functions, kan du använda `functions.https.onRequest`:

```typescript
import * as express from 'express';
import * as cors from 'cors';

const app = express();
app.use(cors({ origin: true }));
app.use(express.json());

// Middleware för att verifiera admin-autentisering via Authorization header
async function verifyAdminToken(req: express.Request, res: express.Response, next: express.NextFunction) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const token = authHeader.split('Bearer ')[1];
  try {
    const decodedToken = await admin.auth().verifyIdToken(token);
    const user = await admin.auth().getUser(decodedToken.uid);
    const claims = user.customClaims || {};
    
    if (claims.role !== 'admin') {
      return res.status(403).json({ error: 'Forbidden' });
    }
    
    (req as any).user = user;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
}

app.post('/setUserRole', verifyAdminToken, async (req, res) => {
  const { userId, role } = req.body;
  // ... implementation
});

app.post('/denyRequest', verifyAdminToken, async (req, res) => {
  const { userId } = req.body;
  // ... implementation
});

export const api = functions.https.onRequest(app);
```

## Sätt Admin-roll på första användaren

För att sätta admin-roll på första användaren (dig själv), kör detta i Firebase Console eller via en tillfällig Cloud Function:

```typescript
// Tillfällig function för att sätta admin
export const setInitialAdmin = functions.https.onCall(async (data, context) => {
  const { userId } = data;
  
  // VARNING: Ta bort denna function efter första admin är satt!
  await admin.auth().setCustomUserClaims(userId, { role: 'admin' });
  
  return { success: true };
});
```

ELLER via Firebase Console:
1. Gå till Authentication → Users
2. Hitta din användare
3. Klicka på "..." → "Edit User"
4. I "Custom claims", lägg till: `{"role": "admin"}`

ELLER via Firebase CLI:
```bash
firebase auth:export users.json
# Editera users.json för att lägga till custom claims
firebase auth:import users.json
```

## Säkerhet

- ✅ Alla functions verifierar att användaren är admin
- ✅ Custom claims kan bara sättas från server-side kod
- ✅ Security Rules skyddar Firestore-data
- ✅ Frontend kontrollerar roller för UI, men säkerheten ligger i Security Rules

## Testing

Efter deploy, testa functions via Firebase Console eller via HTTP client som Postman med din ID token i Authorization header.

```

## `CONTRIBUTING.md`

```markdown
# Contributing

## Branch-namngivning

- `feature/<kort-beskrivning>` – ny funktion (t.ex. `feature/portfolio-export`)
- `fix/<kort-beskrivning>` – buggfix (t.ex. `fix/tableId-conditions-modal`)
- `refactor/<kort-beskrivning>` – refaktor utan beteendeförändring
- `chore/<kort-beskrivning>` – dependencies, config, docs (t.ex. `chore/update-deps`)
- `docs/<kort-beskrivning>` – endast dokumentation

## Commit-konventioner (Conventional Commits, rekommenderat)

- `feat: ...` – ny funktion
- `fix: ...` – buggfix
- `refactor: ...` – refaktor
- `test: ...` – testerna
- `docs: ...` – dokumentation
- `chore: ...` – övrigt

Exempel: `fix: use shared getTableId in ConditionsSidebar`

För enkel rollback: håll PR:ar små och **en commit per PR** (squash vid merge) underlättar `git revert` (en revert = en commit).

## Lint / ESLint

- ESLint konfigureras **endast** via `eslint.config.js` (flat config). Använd inte legacy `.eslintrc.*`.

## PR och rollback

- Använd [PR-mallen](.github/PULL_REQUEST_TEMPLATE.md) och kryssa av checklistan innan merge.
- Verifiering: se [docs/RELEASE_CHECKLIST.md](docs/RELEASE_CHECKLIST.md) för `npm run verify` / `verify:full`.
- Rollback: se [docs/ROLLBACK.md](docs/ROLLBACK.md).

```

## `docs/CACHE_OFFLINE.md`

```markdown
# Cache & Offline — Verification (Steg A)

After turning off Service Worker caching for API data and removing the localStorage data cache, **Firestore `appCache` is the only source of truth for shared data**. No cached API/snapshot data is stored in localStorage; offline/stale behaviour is driven by Firestore (and optional Firestore offline persistence), not by localStorage or SW data cache.

The Service Worker precaches the app shell (`/`, `/index.html`) so the app can start offline; API requests remain pass-through and are never cached by the SW.

## Manual verification checklist

- [ ] **Online — ScoreBoard load**  
  Load ScoreBoard; data is fetched. No SW cache is used for API (requests go through SW as pass-through only).

- [ ] **Refresh Now (admin)**  
  As admin, run Refresh Now. Firestore `appCache` is updated; UI shows the new data.

- [ ] **Offline**  
  Turn off network (e.g. DevTools offline). OfflineIndicator is shown; app behaves correctly with no SW-stale API fallback (fetch fails normally).

## Test suite

Run the full test suite and confirm all tests pass:

```bash
pnpm test
# or
npm test
```

```

## `docs/RELEASE_CHECKLIST.md`

```markdown
# Release-checklista

Standardiserad verifiering innan merge till main och vid release.

## Verifiering

### Snabb verifiering (pre-push)

Kör innan varje push:

```bash
npm run verify
```

Kör: lint → build:check → unit-tester → integration-tester.

### Full verifiering (pre-release / pre-merge till main)

Kör innan merge till main eller vid release:

```bash
npm run verify:full
```

Kör: `verify` + E2E-tester.

### Manuella steg

| Kommando | Syfte |
|----------|--------|
| `npm run lint` | ESLint (max-warnings 0) |
| `npm run build:check` | TypeScript (tsc) + Vite-build |
| `npm run test:unit` | Unit-tester (`src/**/__tests__/**/*.test.{ts,tsx}`) |
| `npm run test:integration` | Integrationstester (`src/test/integration/`) |
| `npm run test:e2e` | Playwright E2E-tester |
| `npm run test:coverage` | Coverage-rapport |
| `npm run storybook` | Manuell kontroll av UI-komponenter |

### Secret scan (innan push)

Se [docs/SECRETS.md](SECRETS.md) för ripgrep-kommandon som verifierar att inga riktiga API-nycklar finns i repo.

---

## Revertera PR/commit

Se [docs/ROLLBACK.md](ROLLBACK.md) för detaljerad rollback-process.

**Kortversion:**

1. Hitta merge-commit: `git log --oneline main`
2. Revert: `git revert -m 1 <merge-commit-hash>`
3. Push: `git push origin main`
4. Verifiera: `npm run verify` (eller `verify:full` vid E2E-ändringar)

---

## Taggar och release-markering

Om ni vill markera utgivna versioner:

### Skapa tagg

```bash
git checkout main
git pull origin main
git tag -a v1.2.3 -m "Release v1.2.3"
git push origin v1.2.3
```

### Lista taggar

```bash
git tag -l
```

### Checka ut vid specifik version

```bash
git checkout v1.2.3
```

**OBS:** Taggning är valfritt. Vercel deployar automatiskt från main. Använd taggar om ni behöver versionshistorik, rollback till en känd stabil punkt, eller changelog-triggers.

```

## `docs/ROLLBACK-REFRESH-REGISTRY.md`

```markdown
# Rollback: RefreshContext registry (Steg 4)

Om ändringarna i RefreshContext-registryt orsakar problem, återställ med:

```bash
git revert HEAD~3..HEAD  # eller motsvarande commit-range
```

## Ändringar som kan rullas tillbaka

1. **RefreshContext.tsx**
   - Borttagna: `useBenjaminGrahamData`, `useScoreBoardData`, `usePEIndustryData`
   - Tillagda: `registerRefetch`, `useRefreshOptional`, registry-baserad `refreshAll`
   - `isRefreshing` styrs nu av `useState` under refresh i stället för hook-loading

2. **Data hooks (useScoreBoardData, useBenjaminGrahamData, usePEIndustryData)**
   - Ny self-registration: `useRefreshOptional` + `useEffect` som registrerar refetch

3. **Tester**
   - Ny: `RefreshContext.integration.test.tsx`
   - Mocks för `useRefreshOptional` i useScoreBoardData, useBenjaminGrahamData, usePEIndustryData

## Återställning manuellt

För att gå tillbaka till att RefreshProvider själv mountar hooks:
- Återinför de tre `use*Data()`-anropen i RefreshProvider
- Ta bort `registerRefetch` och registry-logiken
- Ta bort self-registration i de tre data-hooksen (useEffect som anropar `registerRefetch`)
- Ta bort `useRefreshOptional` export

```

## `docs/ROLLBACK.md`

```markdown
# Rollback-arbetsflöde

Minimal process när något går fel efter merge till main.

**Verifiering (lint/test/build/e2e):** Se [docs/RELEASE_CHECKLIST.md](RELEASE_CHECKLIST.md).

## Steg

1. **Identifiera commit**  
   Använd `git log` och välj merge-commit för den PR som introducerade problemet.

2. **Revert**
   ```bash
   git checkout main
   git pull
   git revert -m 1 <merge-commit-hash>
   ```
   (Om det var en vanlig merge; `-m 1` behåller main som parent.)

3. **Push**
   ```bash
   git push origin main
   ```
   Vercel/CI bygger automatiskt.

4. **Verifiera**
   ```bash
   npm run verify
   ```
   (Vid E2E- eller UI-ändringar: `npm run verify:full`.)
   - Manuell smoke-test av berörda flöden
   - Vid ändringar i `src/config/viewTableMap.ts`: kontrollera Conditions-modal, OnboardingHelp och metadata (viewId→tableId).

5. **Dokumentera**  
   Kommentera i original-PR eller i ett kort rollback-dokument vad som reverterades och varför. Öppna ny issue för att åtgärda orsaken och eventuellt återintroducera ändringen på ett säkrare sätt. Vid revert av **secrets-cleanup** (docs/SECRETS.md): rotera alla exponerade nycklar omedelbart.

## Feature flags

För stora eller riskfyllda features kan en env-var (t.ex. `VITE_FEATURE_XYZ`) användas för att släppa på funktionen. Vid rollback: ta bort eller sätt flaggan till `false` i Vercel (och redeploy) istället för kod-revert.

```

## `docs/SECRETS.md`

```markdown
# Hemligheter och nycklar

Inga riktiga API-nycklar eller hemligheter får finnas i repo. Använd endast placeholders i `env.template` och docs.

## Så sätter du nycklar lokalt

1. Kopiera `env.template` till `.env.local`:
   ```bash
   cp env.template .env.local
   ```

2. Öppna `.env.local` och ersätt placeholders med dina faktiska värden:
   - `YOUR_SCRIPT_ID` → ditt Apps Script Script ID från deployment (t.ex. från URL:en `https://script.google.com/macros/s/SCRIPT_ID/exec`)
   - `your-eodhd-api-key` etc. → dina API-nycklar för valfria tjänster

3. Filen `.env.local` ignoreras av Git (säkerhet).

4. För produktion (Vercel): sätt environment variables i Vercel Dashboard → Settings → Environment Variables. Redeploya efter ändringar.

Se även `env.template` för full lista av variabler och `APPS_SCRIPT_SETUP.md` för Apps Script-konfiguration.

## Secret scan (verifiera att inget läcker)

Kör följande innan push för att kontrollera att inga riktiga nycklar finns i repo:

```bash
rg -n "AIza[A-Za-z0-9_-]{35}" --glob '!node_modules' --glob '!dist' --glob '!.git'
rg -n "AKfycby[A-Za-z0-9_-]{40,}" --glob '!node_modules' --glob '!dist' --glob '!.git'
rg -n "6926d27c|2eff0b3a|d4hblhhr01qgvvc6ur0|6X4S8B5KZZVKKFP4" --glob '!node_modules' --glob '!dist' --glob '!.git' --glob '!docs/SECRETS.md'
```

- Första raden: söker Firebase API-nycklar (AIza...)
- Andra raden: söker Apps Script Script ID (AKfycby...)
- Tredje raden: söker kända läckta valutakurs-API-nycklar

**Förväntat resultat:** Inga träffar. Om det finns träffar → ta bort nycklarna och ersätt med placeholders.

## Rollback vid secrets-ändring

Om denna secrets-cleanup måste rullas tillbaka (t.ex. om placeholders orsakar konfigurationsproblem):

1. Identifiera merge-commit: `git log --oneline main`
2. Revert: `git revert -m 1 <merge-commit-hash>`
3. Push: `git push origin main`
4. **OBS:** Efter revert kommer riktiga nycklar tillbaka i historiken. Rotera alla exponerade nycklar omedelbart.

```

## `docs/SECURITY.md`

```markdown
# Security

## Data Refresh (Refresh Now)

**Admin Refresh är server-side via Cloud Function.**

- Knappen "Refresh Now" (admin only) anropar Cloud Function `adminRefreshCache`.
- Cloud Function hämtar data från Apps Script och skriver till Firestore `viewData`.
- Klienten hämtar **aldrig** Sheets-data direkt vid Refresh Now; den läser bara `viewData` efter att functionen har uppdaterat.
- Säkerhetskontroller (admin-roll) sker server-side i Cloud Function.

## Apps Script Token

- Token: header-first (Authorization Bearer), body som fallback/legacy under migration.
- Token skickas i POST-body (ej i URL) när token är konfigurerad.
- Apps Script: fail-closed i prod – om `API_TOKEN` är satt i Script Properties krävs giltig token, annars 401.
- Inga loggar ska visa token.

## RBAC (Rollbaserad åtkomst)

- `viewData`: läs enligt `allowedViews`, skriv endast via server (admin).
- `adminActions`: endast admin kan läsa; skriv endast via Cloud Functions.

```

## `e2e/critical-paths.spec.ts`

```typescript
/**
 * E2E Tests for Critical Paths
 * 
 * Tests critical user flows end-to-end using Playwright.
 */

import { test, expect } from '@playwright/test';

test.describe('Critical User Paths', () => {
  test.beforeEach(async ({ page }) => {
    // Navigate to app (adjust URL for your environment)
    await page.goto('http://localhost:5173');
  });

  test('User authentication flow', async ({ page }) => {
    // Check if login page is shown
    const loginButton = page.getByRole('button', { name: /login|log in/i });
    
    if (await loginButton.isVisible()) {
      // Fill in login form (adjust selectors based on your Login component)
      await page.fill('input[type="email"]', 'test@example.com');
      await page.fill('input[type="password"]', 'testpassword');
      await loginButton.click();

      // Wait for authentication
      await page.waitForURL(/\/(?!login)/, { timeout: 10000 });
    }

    // Should be authenticated and see main content
    await expect(page.getByText(/Score|Dashboard/i)).toBeVisible({ timeout: 10000 });
  });

  test('Data loading and display', async ({ page }) => {
    // Wait for data to load
    await page.waitForSelector('table, [role="table"]', { timeout: 15000 });

    // Should see table with data
    const table = page.locator('table, [role="table"]').first();
    await expect(table).toBeVisible();

    // Should have at least one row
    const rows = table.locator('tbody tr, [role="row"]');
    await expect(rows.first()).toBeVisible({ timeout: 5000 });
  });

  test('Filter and search functionality', async ({ page }) => {
    // Wait for table to load
    await page.waitForSelector('table, [role="table"]', { timeout: 15000 });

    // Find search input
    const searchInput = page.getByPlaceholderText(/sök|search/i).first();
    if (await searchInput.isVisible()) {
      await searchInput.fill('Test');
      
      // Wait for filtered results
      await page.waitForTimeout(500);
      
      // Results should be filtered
      const table = page.locator('table, [role="table"]').first();
      await expect(table).toBeVisible();
    }
  });

  test('Navigation between views', async ({ page }) => {
    // Wait for initial load
    await page.waitForSelector('table, [role="table"], nav', { timeout: 15000 });

    // Find navigation links
    const navLinks = page.locator('nav a, [role="navigation"] a, button[aria-label*="view"]');
    const count = await navLinks.count();

    if (count > 0) {
      // Click first navigation link
      await navLinks.first().click();
      
      // Wait for view to change
      await page.waitForTimeout(1000);
      
      // Should see different content
      await expect(page.locator('main, [role="main"]')).toBeVisible();
    }
  });

  test('Responsive design - mobile viewport', async ({ page }) => {
    // Set mobile viewport
    await page.setViewportSize({ width: 375, height: 667 });

    // Wait for content
    await page.waitForSelector('main, [role="main"]', { timeout: 10000 });

    // Should see mobile-optimized layout
    const mobileMenu = page.getByLabelText(/menu|hamburger/i);
    if (await mobileMenu.isVisible()) {
      await mobileMenu.click();
      
      // Sidebar should be visible
      await expect(page.locator('nav, [role="navigation"]')).toBeVisible();
    }
  });

  test('Responsive design - tablet viewport', async ({ page }) => {
    // Set tablet viewport
    await page.setViewportSize({ width: 768, height: 1024 });

    await page.waitForSelector('main, [role="main"]', { timeout: 10000 });

    // Should see tablet layout
    await expect(page.locator('main, [role="main"]')).toBeVisible();
  });

  test('Responsive design - desktop viewport', async ({ page }) => {
    // Set desktop viewport
    await page.setViewportSize({ width: 1920, height: 1080 });

    await page.waitForSelector('main, [role="main"]', { timeout: 10000 });

    // Should see desktop layout
    await expect(page.locator('main, [role="main"]')).toBeVisible();
  });
});

```

## `env.template`

```text
# =============================================================================
# Environment Variables Template
# =============================================================================
#
# INSTRUKTIONER:
# 1. Kopiera denna fil till .env.local i samma mapp
# 2. Filen .env.local kommer automatiskt ignoreras av Git (säkerhet)
# 3. Fyll i alla REQUIRED variabler med dina faktiska värden
# 4. OPTIONAL variabler kan lämnas tomma för att använda standardvärden
# 5. För Vercel: Sätt environment variables i Vercel Dashboard istället
#
# =============================================================================
# REQUIRED - Obligatoriska variabler
# =============================================================================
# Dessa variabler måste vara satta för att applikationen ska fungera.

# -----------------------------------------------------------------------------
# Apps Script Configuration (REQUIRED)
# -----------------------------------------------------------------------------
# Google Apps Script Web App URL
# PRIMÄR METOD: Google Apps Script API ger 5-10x snabbare prestanda än CSV-proxy
# 
# URL-format: https://script.google.com/macros/s/SCRIPT_ID/exec
# Viktigt: URL måste sluta med /exec (inte /library/...)
# 
# Så här får du URL:en:
# 1. Öppna ditt Google Apps Script projekt
# 2. Gå till Deploy → New deployment
# 3. Välj typ: Web app
# 4. Sätt "Who has access" till "Anyone"
# 5. Klicka Deploy och kopiera URL:en
VITE_APPS_SCRIPT_URL=https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec

# -----------------------------------------------------------------------------
# Firebase Configuration (REQUIRED)
# -----------------------------------------------------------------------------
# Dessa värden hittar du i Firebase Console:
# 1. Gå till https://console.firebase.google.com
# 2. Välj ditt projekt
# 3. Gå till Project Settings (kugghjulsikonen) → General tab
# 4. Scrolla ner till "Your apps" och klicka på web-appen
# 5. Kopiera värdena från config-objektet

# Firebase API Key
# Format: Börjar med "AIza" följt av en lång sträng
# Exempel: AIzaSyAbCdEfGhIjKlMnOpQrStUvWxYz1234567
VITE_FIREBASE_API_KEY=

# Firebase Auth Domain
# Format: PROJECT_ID.firebaseapp.com
# Exempel: stock-score-df698.firebaseapp.com
VITE_FIREBASE_AUTH_DOMAIN=

# Firebase Project ID
# Format: Projektnamnet i Firebase Console
# Exempel: stock-score-df698
VITE_FIREBASE_PROJECT_ID=

# Firebase Storage Bucket
# Format: PROJECT_ID.appspot.com
# Exempel: stock-score-df698.appspot.com
VITE_FIREBASE_STORAGE_BUCKET=

# Firebase Messaging Sender ID
# Format: Numerisk sträng
# Exempel: 123456789012
VITE_FIREBASE_MESSAGING_SENDER_ID=

# Firebase App ID
# Format: 1:SENDER_ID:web:APP_ID
# Exempel: 1:123456789012:web:abcdef1234567890
VITE_FIREBASE_APP_ID=

# =============================================================================
# OPTIONAL - Valfria variabler
# =============================================================================
# Dessa variabler har standardvärden och behöver bara sättas om du vill ändra beteendet.

# -----------------------------------------------------------------------------
# OPTIONAL - Apps Script Configuration
# -----------------------------------------------------------------------------

# Delta Sync Enabled
# Aktiverar/avaktiverar delta sync för effektiva inkrementella uppdateringar
# Delta sync hämtar endast ändringar sedan senaste uppdatering istället för full reload
# Standardvärde: true (aktiverad)
# Möjliga värden: true, false
VITE_DELTA_SYNC_ENABLED=true

# Delta Sync Poll Interval (minuter)
# Hur ofta applikationen ska söka efter nya ändringar när delta sync är aktiverad
# Standardvärde: 15 (minuter)
# Rekommenderat: 10-30 minuter beroende på hur ofta data uppdateras
VITE_DELTA_SYNC_POLL_MINUTES=15

# Delta Sync Timeout (sekunder)
# Maximal tid att vänta på delta sync snapshot-anrop innan timeout
# Standardvärde: 60 (sekunder) – ger utrymme för Apps Script cold start och stora sheets
# Rekommenderat: 45-90 sekunder beroende på nätverksförhållanden och sheet-storlek
# Vid timeout görs automatiskt retry (upp till 3 försök); poll-timeouts loggas som varning, inte fel
VITE_DELTA_SYNC_TIMEOUT_SECONDS=60

# Apps Script API Token
# API-token för autentisering vid delta sync-anrop
# Sätt till samma token som i Apps Script Script Properties (API_TOKEN)
# Token skickas i POST-body (Apps Script kan inte läsa headers); aldrig i URL
# PROD: Sätt API_TOKEN i Apps Script => fail-closed (401 utan token)
# DEV: Lämna tomt => Apps Script tillåter, loggar varning
# Standardvärde: (tomt - ingen autentisering)
VITE_APPS_SCRIPT_TOKEN=

# -----------------------------------------------------------------------------
# OPTIONAL - Cache Configuration
# -----------------------------------------------------------------------------

# Cache Default TTL (Time To Live) i minuter
# Hur länge cacheade data ska anses vara giltiga innan de förfaller
# Standardvärde: 20 (minuter)
# Rekommenderat: 15-30 minuter beroende på hur ofta källdata ändras
VITE_CACHE_DEFAULT_TTL_MINUTES=20

# Cache Fresh Threshold i minuter
# Cacheade data nyare än denna tröskel anses vara "färska" och behöver inte uppdateras
# Standardvärde: 5 (minuter)
# Rekommenderat: 3-10 minuter beroende på användningsfall
VITE_CACHE_FRESH_THRESHOLD_MINUTES=5

# Cache Warming Enabled
# Aktiverar/avaktiverar automatisk cache warming vid applikationsstart
# Cache warming förbereder cache med data i bakgrunden för snabbare initial laddning
# Standardvärde: true (aktiverad)
# Möjliga värden: true, false
VITE_CACHE_WARMING_ENABLED=true

# ViewData Migration Mode (dual-write | dual-read | cutover)
# Standardvärde: dual-read
VITE_VIEWDATA_MIGRATION_MODE=dual-read

# -----------------------------------------------------------------------------
# OPTIONAL - Performance Configuration
# -----------------------------------------------------------------------------

# Fetch Timeout i sekunder
# Maximal tid att vänta på API-svar innan request timeout
# Standardvärde: 30 (sekunder)
# Rekommenderat: 20-60 sekunder beroende på nätverksförhållanden
# Öka detta värde om du upplever timeout-fel på långsamma nätverk
VITE_FETCH_TIMEOUT_SECONDS=30

# -----------------------------------------------------------------------------
# OPTIONAL - Currency API Keys (for live exchange rates in Personal Portfolio)
# -----------------------------------------------------------------------------
# API keys for currency exchange rate services (used in priority order)
# If not set, the app falls back to ExchangeRate-API (no key required)

# EODHD API Key (highest priority)
# VITE_EODHD_API_KEY=your-eodhd-api-key

# MarketStack API Key
# VITE_MARKETSTACK_API_KEY=your-marketstack-api-key

# FINNHUB API Key
# VITE_FINNHUB_API_KEY=your-finnhub-api-key

# Alpha Vantage API Key
# VITE_ALPHA_VANTAGE_API_KEY=your-alpha-vantage-api-key

```

## `eslint.config.js`

```javascript
/** Project's single ESLint config (flat config). Do not add .eslintrc.*. */
import js from '@eslint/js';
import tsPlugin from '@typescript-eslint/eslint-plugin';
import tsParser from '@typescript-eslint/parser';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';
import storybook from 'eslint-plugin-storybook';
import globals from 'globals';

export default [
  // Base recommended config
  js.configs.recommended,
  
  // TypeScript and React files
  {
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      parser: tsParser,
      parserOptions: {
        ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
        },
      },
      globals: {
        ...globals.browser,
        ...globals.es2020,
      },
    },
    plugins: {
      '@typescript-eslint': tsPlugin,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...tsPlugin.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
  
  // Storybook files
  {
    files: ['**/*.stories.@(js|jsx|mjs|ts|tsx)', '**/.storybook/**/*.{js,ts}'],
    plugins: {
      storybook,
    },
    rules: {
      ...storybook.configs.recommended.rules,
    },
  },
  
  // Ignore patterns
  {
    ignores: ['dist', 'eslint.config.js', 'node_modules'],
  },
];

```

## `firebase.json`

```json
{
  "firestore": {
    "database": "(default)",
    "location": "europe-north2",
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  }
}

```

## `firestore.indexes.json`

```json
{
  "indexes": [],
  "fieldOverrides": []
}
```

## `firestore.rules`

```text
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to get user role from custom claims
    function getUserRole() {
      return request.auth.token.role;
    }
    
    // Helper function to check if user is admin
    function isAdmin() {
      return getUserRole() == 'admin';
    }
    
    // Helper function to check if user has any role (admin or viewer)
    function hasRole() {
      return getUserRole() == 'viewer' || isAdmin();
    }
    
    // Helper function to check if user is viewer (not admin)
    function isViewer() {
      return getUserRole() == 'viewer';
    }
    
    // Helper function to get viewer allowed views from custom claims (MAP format)
    function getViewerAllowedViewsMap() {
      return request.auth.token.allowedViews;
    }
    
    // Helper: can user read viewId? Admin: yes. Viewer: only if allowedViews[viewId] == true
    function canView(viewId) {
      return isAdmin() || (isViewer() &&
        request.auth.token.allowedViews != null &&
        request.auth.token.allowedViews[viewId] == true);
    }
    
    // Helper function to validate EntryExit value structure
    function isValidEntryExitValue(value) {
      return value.keys().hasAll(['entry1', 'entry2', 'exit1', 'exit2', 'currency']) &&
             value.entry1 is number && value.entry1 >= 0 && value.entry1 <= 1000000 &&
             value.entry2 is number && value.entry2 >= 0 && value.entry2 <= 1000000 &&
             value.exit1 is number && value.exit1 >= 0 && value.exit1 <= 1000000 &&
             value.exit2 is number && value.exit2 >= 0 && value.exit2 <= 1000000 &&
             value.currency is string && value.currency in ['USD', 'EUR', 'SEK', 'DKK', 'NOK', 'GBP', 'AUD', 'CAD', 'NZD'] &&
             (value.dateOfUpdate == null || (value.dateOfUpdate is string && value.dateOfUpdate.matches('^\\d{4}-\\d{2}-\\d{2}$')));
    }
    
    // Helper function to validate EntryExit document structure
    function isValidEntryExitDocument(data) {
      // Check document size (max 1MB)
      return data.size() <= 1048576 &&
             // Validate that values is a map
             data.values is map &&
             // Validate that all values in the map are valid EntryExit values
             // Note: Firestore rules don't support iterating over map values directly,
             // so we validate on write operations instead
             true;
    }
    
    // sharedData/threshold - read: canView(threshold-industry) or admin; write: admin only
    match /sharedData/threshold {
      allow read: if request.auth != null && canView('threshold-industry');
      allow write: if request.auth != null && isAdmin();
    }
    
    // Shared data - read requires authentication and role (viewer or admin), write only for admin
    match /sharedData/{document} {
      // Threshold subcollection (sharedData/threshold/{thresholdId}) - only admin
      match /threshold/{thresholdId} {
        allow read, write: if isAdmin();
      }
      
      // EntryExit data - canView-styrd: only viewers with score/score-board/entry-exit-benjamin-graham may read
      match /entryExit {
        allow read: if request.auth != null && (
          isAdmin() ||
          canView('score') ||
          canView('score-board') ||
          canView('entry-exit-benjamin-graham')
        );
        allow write: if request.auth != null && 
                        isAdmin() && 
                        request.resource.data.size() <= 1048576 &&
                        request.resource.data.values is map;
      }
      
      // All other shared data (excluding threshold document - see sharedData/threshold rule above)
      match /{sharedDoc=**} {
        // Read: Authenticated users with role; threshold doc handled by explicit rule
        allow read: if request.auth != null && hasRole() && document != 'threshold';
        
        // Write: Only admin
        allow write: if request.auth != null && 
                        isAdmin() && 
                        request.resource.data.size() <= 1048576; // 1MB limit
      }
    }
    
    // User preferences - users can read/write their own preferences (requires authentication)
    match /userPreferences/{userId} {
      // Users can only access their own preferences
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Validate structure on write
      allow write: if request.auth != null && 
                      request.auth.uid == userId &&
                      request.resource.data.userId == userId &&
                      request.resource.data.size() <= 10240; // 10KB limit
    }
    
    // User portfolios - users can read/write their own portfolio (requires authentication)
    match /userPortfolios/{userId} {
      // Users can only access their own portfolio
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Validate structure on write
      allow write: if request.auth != null && 
                      request.auth.uid == userId &&
                      request.resource.data.userId == userId &&
                      request.resource.data.size() <= 5242880 && // 5MB limit
                      request.resource.data.portfolio is list;
    }
    
    // App config - API keys
    // Read: All authenticated users (needed for currency exchange rates)
    // Write: Only admin (only admin can view/edit in UI)
    match /appConfig/apiKeys {
      allow read: if request.auth != null;
      allow write: if request.auth != null && isAdmin();
    }
    
    // Currency rates cache - any authenticated user can read/write (first user to need fresh rates populates for all)
    match /appCache/currency_rates_usd {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null &&
                              request.resource.data.size() <= 10485760 &&
                              request.resource.data.data != null &&
                              request.resource.data.timestamp is number &&
                              request.resource.data.ttl is number;
      allow delete: if request.auth != null && isAdmin();
    }
    
    // App cache - shared cache; Viewer can read only Score-view docs, Admin can read all
    match /appCache/{cacheKey} {
      // Read: Admin all; Viewer only scoreBoard, benjaminGraham, peIndustry, sma, currency_rates_usd
      allow read: if request.auth != null && (
        isAdmin() ||
        cacheKey == 'scoreBoard' ||
        cacheKey == 'benjaminGraham' ||
        cacheKey == 'peIndustry' ||
        cacheKey == 'sma' ||
        cacheKey == 'currency_rates_usd'
      );
      
      // Delete: Only admin (no data validation needed for delete)
      allow delete: if request.auth != null && isAdmin();
      
      // Create/Update: Only admin, with validation
      // Validate document structure: must have data, timestamp, and ttl
      allow create, update: if request.auth != null && 
                              isAdmin() &&
                              request.resource.data.size() <= 10485760 && // 10MB limit
                              request.resource.data.data != null &&
                              request.resource.data.timestamp is number &&
                              request.resource.data.ttl is number;
    }
    
    // viewData - per-view data; read: canView(viewId); write: admin only
    match /viewData/{viewId} {
      allow read: if request.auth != null && canView(viewId);
      allow create, update, delete: if request.auth != null && isAdmin()
        && request.resource.data.size() <= 10485760
        && request.resource.data.data != null
        && request.resource.data.timestamp is number
        && request.resource.data.ttl is number
        && request.resource.data.schemaVersion is number;
    }
    
    // Shareable links - authenticated users can read (to load shared links); create/update/delete only by creator
    match /shareableLinks/{linkId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.resource.data.createdBy == request.auth.uid;
      allow update, delete: if request.auth != null && resource.data.createdBy == request.auth.uid;
    }
    
    // User data - created on signup (Cloud Function); user reads own doc, admin reads/writes all
    match /userData/{userId} {
      allow read: if request.auth != null && (request.auth.uid == userId || isAdmin());
      allow write: if request.auth != null && isAdmin();
    }
    
    // Admin actions audit log - written by Cloud Functions (Admin SDK); only admin can read
    match /adminActions/{actionId} {
      allow read: if request.auth != null && isAdmin();
      allow create, update, delete: if false; // Only server (Admin SDK) can write
    }
    
    // Deny all other access by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

```

## `functions/src/adminRefreshHelpers.ts`

```typescript
/**
 * Admin Refresh Helpers
 *
 * Fetch from Apps Script, transform, and write to viewData.
 * Self-contained transformer logic (no imports from client src).
 */

import * as admin from 'firebase-admin';

// Types matching client
type DataRow = Record<string, string | number | undefined>;

interface SnapshotResponse {
  ok: boolean;
  version: number;
  headers: string[];
  rows: Array<{ key: string; values: unknown[] }>;
  generatedAt: string;
  error?: string;
}

const DEFAULT_TTL_MS = 30 * 60 * 1000;

function getValue(possibleNames: string[], row: DataRow): string {
  for (const name of possibleNames) {
    const value = row[name];
    if (value !== undefined && value !== null && value !== '') {
      return String(value).trim();
    }
    const lowerName = name.toLowerCase();
    for (const key in row) {
      if (key.toLowerCase() === lowerName) {
        const val = row[key];
        if (val !== undefined && val !== null && val !== '') {
          return String(val).trim();
        }
      }
    }
  }
  return '';
}

function getValueAllowZero(possibleNames: string[], row: DataRow): string {
  for (const name of possibleNames) {
    const value = row[name];
    if (value !== undefined && value !== null) {
      if (value === 0 || value === '0') return '0';
      if (value === '') continue;
      return String(value).trim();
    }
    const lowerName = name.toLowerCase();
    for (const key in row) {
      if (key.toLowerCase() === lowerName) {
        const val = row[key];
        if (val !== undefined && val !== null) {
          if (val === 0 || val === '0') return '0';
          if (val === '') continue;
          return String(val).trim();
        }
      }
    }
  }
  return '';
}

function isValidValue(value: string): boolean {
  if (!value) return false;
  const n = value.trim().toUpperCase();
  return n !== '#N/A' && n !== 'N/A' && n !== '#NUM!' && n !== '#VALUE!' && n !== '#DIV/0!' && n !== '#REF!' && n !== 'LOADING...';
}

function parseNum(s: string): number | null {
  if (!s || typeof s !== 'string' || !isValidValue(s)) return null;
  const cleaned = String(s).replace(/,/g, '.').replace(/\s/g, '').replace(/#/g, '').replace(/%/g, '').replace(/\$/g, '');
  const n = parseFloat(cleaned);
  if (typeof n !== 'number' || isNaN(n) || !isFinite(n)) return null;
  return n;
}

function parsePct(s: string): number | null {
  return parseNum(s);
}

function median(values: number[]): number | null {
  if (!values || values.length === 0) return null;
  const valid = values.filter((v) => typeof v === 'number' && !isNaN(v) && isFinite(v));
  if (valid.length === 0) return null;
  const sorted = [...valid].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  return sorted.length % 2 === 0 ? (sorted[mid - 1]! + sorted[mid]!) / 2 : sorted[mid]!;
}

function snapshotToDataRows(snapshot: SnapshotResponse): DataRow[] {
  const dataRows: DataRow[] = [];
  for (const row of snapshot.rows || []) {
    if (!row?.values || !Array.isArray(row.values)) continue;
    const dataRow: DataRow = {};
    (snapshot.headers || []).forEach((h, i) => {
      const v = row.values[i];
      dataRow[h] = v === null || v === undefined || v === '' ? '' : typeof v === 'string' || typeof v === 'number' ? v : String(v);
    });
    dataRows.push(dataRow);
  }
  return dataRows;
}

function transformBenjaminGraham(data: DataRow[]): Array<Record<string, unknown>> {
  return data
    .map((row) => {
      const companyName = getValue(['Company Name', 'Company', 'company'], row);
      const ticker = getValue(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
      if (!isValidValue(companyName) || !isValidValue(ticker)) return null;
      return {
        companyName,
        ticker,
        price: parseNum(getValue(['Price', 'price', 'PRICE'], row)),
        benjaminGraham: parseNum(getValue(['Benjamin Graham', 'benjamin graham', 'Benjamin', 'benjamin'], row)),
        ivFcf: parseNum(getValue(['IV (FCF)', 'IV(FCF)', 'iv fcf', 'ivfcf'], row)),
        irr1: parseNum(getValue(['IRR1', 'irr1', 'IRR 1', 'irr 1'], row)),
      };
    })
    .filter((x): x is NonNullable<typeof x> => x !== null);
}

function transformPEIndustry(data: DataRow[]): Array<Record<string, unknown>> {
  const industryMap = new Map<string, { pe: number[]; pe1: number[]; pe2: number[]; count: number }>();
  for (const row of data) {
    const companyName = getValue(['Company Name', 'Company', 'company'], row);
    const ticker = getValue(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
    const industry = getValue(['INDUSTRY', 'Industry', 'industry'], row);
    if (!isValidValue(companyName) || !isValidValue(ticker) || !isValidValue(industry)) continue;
    let d = industryMap.get(industry);
    if (!d) {
      d = { pe: [], pe1: [], pe2: [], count: 0 };
      industryMap.set(industry, d);
    }
    d.count++;
    const pe = parseNum(getValue(['P/E', 'P/E', 'pe', 'PE'], row));
    const pe1 = parseNum(getValue(['P/E1', 'P/E 1', 'pe1', 'PE1'], row));
    const pe2 = parseNum(getValue(['P/E2', 'P/E 2', 'pe2', 'PE2'], row));
    if (pe !== null) d.pe.push(pe);
    if (pe1 !== null) d.pe1.push(pe1);
    if (pe2 !== null) d.pe2.push(pe2);
  }
  return Array.from(industryMap.entries())
    .filter(([, d]) => d.count > 0)
    .map(([industry, d]) => ({
      industry,
      pe: median(d.pe),
      pe1: median(d.pe1),
      pe2: median(d.pe2),
      companyCount: d.count,
    }));
}

function transformSMA(data: DataRow[]): Array<Record<string, unknown>> {
  return data
    .map((row) => {
      const companyName = getValue(['Company Name', 'Company', 'company'], row);
      const ticker = getValue(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
      if (!isValidValue(companyName) || !isValidValue(ticker)) return null;
      const smaCrossStr = getValue(['SMA Cross', 'SMA Cross', 'sma cross', 'smaCross', 'SMACross', 'SMA CROSS'], row);
      let smaCross: string | null = null;
      if (smaCrossStr?.trim()) {
        const t = smaCrossStr.trim().toUpperCase();
        if (t !== '#N/A' && t !== 'N/A' && t !== '') smaCross = smaCrossStr.trim();
      }
      return {
        companyName,
        ticker,
        sma100: parseNum(getValue(['SMA(100)', 'SMA(100)', 'sma(100)', 'sma100', 'SMA100'], row)),
        sma200: parseNum(getValue(['SMA(200)', 'SMA(200)', 'sma(200)', 'sma200', 'SMA200'], row)),
        smaCross,
      };
    })
    .filter((x): x is NonNullable<typeof x> => x !== null);
}

function transformScoreBoard(
  data: DataRow[],
  industryPe1Map: Map<string, number>,
  industryPe2Map: Map<string, number>,
  smaDataMap: Map<string, { sma100: number | null; sma200: number | null; smaCross: string | null }>
): Array<Record<string, unknown>> {
  return data
    .map((row) => {
      const companyName = getValueAllowZero(['Company Name', 'Company', 'company'], row);
      const ticker = getValueAllowZero(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
      const industryStr = getValueAllowZero(['INDUSTRY', 'Industry', 'industry'], row);
      if (!isValidValue(companyName) || !isValidValue(ticker)) return null;
      const cashSdebtStr = getValueAllowZero(['Cash/SDebt', 'Cash/SDebt', 'cash/sdebt', 'CASH/SDEBT'], row);
      const isDiv0 =
        cashSdebtStr &&
        (cashSdebtStr.trim().toUpperCase() === '#DIV/0!' ||
          cashSdebtStr.trim().toUpperCase() === 'INF' ||
          cashSdebtStr.trim().toUpperCase() === '∞');
      const cashSdebt = parseNum(cashSdebtStr);
      const finalCashSdebt = isDiv0 ? 0 : cashSdebt;
      const pe1 = parseNum(getValueAllowZero(['P/E1', 'P/E 1', 'pe1', 'PE1'], row));
      const pe2 = parseNum(getValueAllowZero(['P/E2', 'P/E 2', 'pe2', 'PE2'], row));
      let pe1Industry: number | null = null;
      let pe2Industry: number | null = null;
      if (isValidValue(industryStr) && pe1 !== null && pe1 > 0) {
        const m = industryPe1Map.get(industryStr.trim().toLowerCase());
        if (m !== undefined && m > 0) pe1Industry = ((pe1 - m) / m) * 100;
      }
      if (isValidValue(industryStr) && pe2 !== null && pe2 > 0) {
        const m = industryPe2Map.get(industryStr.trim().toLowerCase());
        if (m !== undefined && m > 0) pe2Industry = ((pe2 - m) / m) * 100;
      }
      const tickerKey = ticker.toLowerCase().trim();
      const smaMatch = smaDataMap.get(tickerKey);
      return {
        companyName,
        ticker,
        industry: industryStr || '',
        irr: parseNum(getValueAllowZero(['IRR', 'irr', 'Irr'], row)),
        mungerQualityScore: parseNum(getValueAllowZero(['Munger Quality Score', 'Munger Quality Score', 'munger quality score', 'MUNGER QUALITY SCORE'], row)),
        valueCreation: parsePct(getValueAllowZero(['VALUE CREATION', 'Value Creation', 'value creation', 'VALUE_CREATION'], row)),
        tbSPrice: parseNum(getValueAllowZero(['(TB/S)/Price', '(TB/S)/Price', '(tb/s)/price', '(TB/S)/PRICE'], row)),
        ro40Cy: parsePct(getValueAllowZero(['Ro40 CY', 'Ro40 CY', 'ro40 cy', 'RO40 CY'], row)),
        ro40F1: parsePct(getValueAllowZero(['Ro40 F1', 'Ro40 F1', 'ro40 f1', 'RO40 F1'], row)),
        ro40F2: parsePct(getValueAllowZero(['Ro40 F2', 'Ro40 F2', 'ro40 f2', 'RO40 F2'], row)),
        leverageF2: parseNum(getValueAllowZero(['Leverage F2', 'Leverage F2', 'leverage f2', 'LEVERAGE F2'], row)),
        currentRatio: parseNum(getValueAllowZero(['Current Ratio', 'Current Ratio', 'current ratio', 'CURRENT RATIO'], row)),
        cashSdebt: finalCashSdebt,
        isCashSdebtDivZero: !!isDiv0,
        pe1Industry,
        pe2Industry,
        sma100: smaMatch?.sma100 ?? null,
        sma200: smaMatch?.sma200 ?? null,
        smaCross: smaMatch?.smaCross ?? null,
      };
    })
    .filter((x): x is NonNullable<typeof x> => x !== null);
}

export interface RefreshResult {
  viewId: string;
  rows: number;
  source: string;
  wroteViewData: boolean;
  wroteAppCache: boolean;
  durationMs: number;
}

const VIEWIDS_FROM_SHEETS = ['score', 'score-board', 'entry-exit-benjamin-graham', 'fundamental-pe-industry'] as const;
const CACHE_KEYS: Record<string, string> = {
  'score-board': 'scoreBoard',
  'score': 'scoreBoard',
  'entry-exit-benjamin-graham': 'benjaminGraham',
  'fundamental-pe-industry': 'peIndustry',
};

export async function fetchAppsScriptSnapshot(
  baseUrl: string,
  token: string | undefined,
  sheetName: string
): Promise<SnapshotResponse> {
  const usePost = !!token;
  const url = usePost ? baseUrl : `${baseUrl}${baseUrl.includes('?') ? '&' : '?'}action=snapshot&sheet=${encodeURIComponent(sheetName)}`;
  const init: RequestInit = usePost
    ? {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
          ...(token ? { Authorization: `Bearer ${token}` } : {}),
        },
        body: JSON.stringify({ action: 'snapshot', sheet: sheetName, token }),
      }
    : { method: 'GET', headers: { Accept: 'application/json' } };
  const res = await fetch(url, init);
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`Apps Script fetch failed: ${res.status} ${res.statusText} - ${text.slice(0, 200)}`);
  }
  const json = (await res.json()) as SnapshotResponse;
  if (!json?.ok) {
    throw new Error(json?.error || 'Apps Script returned error');
  }
  return json;
}

export async function runAdminRefresh(
  baseUrl: string,
  token: string | undefined,
  viewIds: string[],
  adminUid: string,
  migrationMode: 'dual-write' | 'dual-read' | 'cutover',
  dryRun: boolean
): Promise<{ refreshed: RefreshResult[]; errors: string[] }> {
  const refreshed: RefreshResult[] = [];
  const errors: string[] = [];
  const db = admin.firestore();

  const effectiveViewIds = viewIds.length > 0
    ? viewIds.filter((id) => VIEWIDS_FROM_SHEETS.includes(id as (typeof VIEWIDS_FROM_SHEETS)[number]))
    : [...VIEWIDS_FROM_SHEETS];

  let dashboardSnapshot: SnapshotResponse | null = null;
  let smaSnapshot: SnapshotResponse | null = null;

  for (const viewId of effectiveViewIds) {
    const start = Date.now();
    try {
      if (viewId === 'score' || viewId === 'score-board') {
        if (!dashboardSnapshot) {
          dashboardSnapshot = await fetchAppsScriptSnapshot(baseUrl, token, 'DashBoard');
        }
        if (!smaSnapshot) {
          try {
            smaSnapshot = await fetchAppsScriptSnapshot(baseUrl, token, 'SMA');
          } catch (e) {
            errors.push(`SMA fetch failed: ${e instanceof Error ? e.message : String(e)}`);
            smaSnapshot = { ok: true, version: 0, headers: [], rows: [], generatedAt: new Date().toISOString() };
          }
        }
        const dashData = snapshotToDataRows(dashboardSnapshot);
        const peData = transformPEIndustry(dashData);
        const smaData = transformSMA(snapshotToDataRows(smaSnapshot));
        const industryPe1Map = new Map<string, number>();
        const industryPe2Map = new Map<string, number>();
        for (const p of peData as Array<{ industry: string; pe1?: number | null; pe2?: number | null }>) {
          if (p.pe1 != null) industryPe1Map.set(p.industry.toLowerCase(), p.pe1);
          if (p.pe2 != null) industryPe2Map.set(p.industry.toLowerCase(), p.pe2);
        }
        const smaDataMap = new Map<string, { sma100: number | null; sma200: number | null; smaCross: string | null }>();
        for (const s of smaData as Array<{ ticker: string; sma100?: number | null; sma200?: number | null; smaCross?: string | null }>) {
          smaDataMap.set(s.ticker.toLowerCase().trim(), {
            sma100: s.sma100 ?? null,
            sma200: s.sma200 ?? null,
            smaCross: s.smaCross ?? null,
          });
        }
        const scoreBoard = transformScoreBoard(dashData, industryPe1Map, industryPe2Map, smaDataMap);
        const payload = { scoreBoard };
        if (!dryRun) {
          const now = Date.now();
          const doc = {
            data: payload,
            timestamp: now,
            ttl: DEFAULT_TTL_MS,
            schemaVersion: 1,
            source: 'adminRefreshCache',
            updatedBy: adminUid,
          };
          await db.collection('viewData').doc(viewId).set(doc, { merge: false });
          if (migrationMode !== 'cutover' && viewId === 'score-board') {
            await db.collection('appCache').doc('scoreBoard').set(
              {
                data: scoreBoard,
                timestamp: now,
                ttl: DEFAULT_TTL_MS,
                version: dashboardSnapshot.version,
                lastSnapshotAt: now,
                lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
              },
              { merge: false }
            );
          }
        }
        refreshed.push({
          viewId,
          rows: scoreBoard.length,
          source: 'adminRefreshCache',
          wroteViewData: !dryRun,
          wroteAppCache: !dryRun && migrationMode !== 'cutover' && viewId === 'score-board',
          durationMs: Date.now() - start,
        });
      } else if (viewId === 'entry-exit-benjamin-graham') {
        if (!dashboardSnapshot) {
          dashboardSnapshot = await fetchAppsScriptSnapshot(baseUrl, token, 'DashBoard');
        }
        const dashData = snapshotToDataRows(dashboardSnapshot);
        const benjaminGraham = transformBenjaminGraham(dashData);
        const payload = { benjaminGraham };
        if (!dryRun) {
          const now = Date.now();
          await db.collection('viewData').doc(viewId).set(
            {
              data: payload,
              timestamp: now,
              ttl: DEFAULT_TTL_MS,
              schemaVersion: 1,
              source: 'adminRefreshCache',
              updatedBy: adminUid,
            },
            { merge: false }
          );
          if (migrationMode !== 'cutover') {
            await db.collection('appCache').doc('benjaminGraham').set(
              {
                data: benjaminGraham,
                timestamp: now,
                ttl: DEFAULT_TTL_MS,
                version: dashboardSnapshot.version,
                lastSnapshotAt: now,
                lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
              },
              { merge: false }
            );
          }
        }
        refreshed.push({
          viewId,
          rows: benjaminGraham.length,
          source: 'adminRefreshCache',
          wroteViewData: !dryRun,
          wroteAppCache: !dryRun && migrationMode !== 'cutover',
          durationMs: Date.now() - start,
        });
      } else if (viewId === 'fundamental-pe-industry') {
        if (!dashboardSnapshot) {
          dashboardSnapshot = await fetchAppsScriptSnapshot(baseUrl, token, 'DashBoard');
        }
        const dashData = snapshotToDataRows(dashboardSnapshot);
        const peIndustry = transformPEIndustry(dashData);
        const payload = { peIndustry };
        if (!dryRun) {
          const now = Date.now();
          await db.collection('viewData').doc(viewId).set(
            {
              data: payload,
              timestamp: now,
              ttl: DEFAULT_TTL_MS,
              schemaVersion: 1,
              source: 'adminRefreshCache',
              updatedBy: adminUid,
            },
            { merge: false }
          );
          if (migrationMode !== 'cutover') {
            await db.collection('appCache').doc('peIndustry').set(
              {
                data: peIndustry,
                timestamp: now,
                ttl: DEFAULT_TTL_MS,
                version: dashboardSnapshot.version,
                lastSnapshotAt: now,
                lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
              },
              { merge: false }
            );
          }
        }
        refreshed.push({
          viewId,
          rows: peIndustry.length,
          source: 'adminRefreshCache',
          wroteViewData: !dryRun,
          wroteAppCache: !dryRun && migrationMode !== 'cutover',
          durationMs: Date.now() - start,
        });
      }
    } catch (err) {
      const msg = err instanceof Error ? err.message : String(err);
      errors.push(`${viewId}: ${msg}`);
    }
  }

  return { refreshed, errors };
}

```

## `functions/src/index.ts`

```typescript
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';

admin.initializeApp();

// Whitelist of viewIds for allowedViews claim validation
const ALLOWED_VIEW_IDS = ['score', 'score-board', 'entry-exit-benjamin-graham', 'fundamental-pe-industry', 'threshold-industry'] as const;

/** Convert allowedViews claim (array or map) to array for UI */
function allowedViewsToArray(claims: Record<string, unknown>): string[] {
  const av = claims.allowedViews;
  if (Array.isArray(av)) {
    return av.filter((v): v is string => typeof v === 'string');
  }
  if (av && typeof av === 'object' && !Array.isArray(av)) {
    return Object.keys(av).filter((k) => (av as Record<string, unknown>)[k] === true);
  }
  return [];
}

// Middleware för att verifiera admin-autentisering
async function verifyAdmin(context: functions.https.CallableContext): Promise<void> {
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
  }

  const token = await admin.auth().getUser(context.auth.uid);
  const claims = token.customClaims || {};
  
  if (claims.role !== 'admin') {
    throw new functions.https.HttpsError('permission-denied', 'User must be admin');
  }
}

// Claim viewer role (for newly signed-up users; sets role to viewer and creates userData doc)
export const claimViewerRole = functions.https.onCall(async (_data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
  }

  const uid = context.auth.uid;

  try {
    // Default allowedViews for new viewers: score only
    await admin.auth().setCustomUserClaims(uid, { role: 'viewer', allowedViews: { score: true } });

    const userRecord = await admin.auth().getUser(uid);
    const email = userRecord.email ?? '';

    await admin.firestore().doc(`userData/${uid}`).set(
      {
        uid,
        email,
        role: 'viewer',
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );

    return { success: true, message: 'Viewer role set successfully' };
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('Error claiming viewer role:', error);
    throw new functions.https.HttpsError('internal', errorMessage);
  }
});

// List users (admin only) - returns uid, email, role, allowedViews from custom claims
export const listUsers = functions.https.onCall(async (_data, context) => {
  await verifyAdmin(context);

  try {
    const listUsersResult = await admin.auth().listUsers(1000);
    const users = listUsersResult.users.map((userRecord) => {
      const claims = (userRecord.customClaims || {}) as Record<string, unknown>;
      const role = (claims.role as string) || null;
      const allowedViews = allowedViewsToArray(claims);
      return {
        uid: userRecord.uid,
        email: userRecord.email || '',
        role,
        allowedViews,
      };
    });
    return { users };
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('Error listing users:', error);
    throw new functions.https.HttpsError('internal', errorMessage);
  }
});

// Set user role
export const setUserRole = functions.https.onCall(async (data, context) => {
  await verifyAdmin(context);

  const adminUid = context.auth!.uid;
  const { userId, role, allowedViews } = data;

  // Accept 'viewer' or 'admin' as roles
  if (!userId || !role || !['viewer', 'admin'].includes(role)) {
    throw new functions.https.HttpsError('invalid-argument', 'Invalid parameters. Role must be "viewer" or "admin"');
  }

  try {
    // Build custom claims: role + allowedViews as MAP for Firestore rules
    const customClaims: { role: string; allowedViews?: Record<string, boolean> } = { role };

    if (role === 'viewer' && allowedViews && Array.isArray(allowedViews)) {
      // Validate each viewId against whitelist
      const allowedViewsMap: Record<string, boolean> = {};
      for (const viewId of allowedViews) {
        if (typeof viewId === 'string' && (ALLOWED_VIEW_IDS as readonly string[]).includes(viewId)) {
          allowedViewsMap[viewId] = true;
        }
      }
      customClaims.allowedViews = allowedViewsMap;
    } else if (role === 'admin') {
      // Admin does not need allowedViews
      customClaims.allowedViews = undefined;
    }

    await admin.auth().setCustomUserClaims(userId, customClaims);

    // Audit log
    const allowedViewsArray = role === 'viewer' && customClaims.allowedViews
      ? Object.keys(customClaims.allowedViews).filter((k) => customClaims.allowedViews![k] === true)
      : [];
    await admin.firestore().collection('adminActions').add({
      action: 'setUserRole',
      adminUid,
      targetUid: userId,
      newRole: role,
      allowedViewsArray,
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
    });

    return { success: true, message: 'Role set successfully' };
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('Error setting user role:', error);
    throw new functions.https.HttpsError('internal', errorMessage);
  }
});

// Admin refresh cache - fetches from Apps Script, writes to viewData
export const adminRefreshCache = functions.https.onCall(async (data, context) => {
  await verifyAdmin(context);

  const adminUid = context.auth!.uid;
  const { viewIds, force, dryRun } = data || {};

  const appsScriptUrl =
    (process.env.APPS_SCRIPT_URL as string) ||
    (functions.config().apps_script?.url as string) ||
    '';
  const appsScriptToken =
    (process.env.APPS_SCRIPT_TOKEN as string) ||
    (functions.config().apps_script?.token as string) ||
    '';

  if (!appsScriptUrl) {
    throw new functions.https.HttpsError('failed-precondition', 'APPS_SCRIPT_URL not configured');
  }

  const { runAdminRefresh } = await import('./adminRefreshHelpers');
  const migrationMode = (
    (process.env.VIEWDATA_MIGRATION_MODE as string) ||
    (functions.config().viewdata?.migration_mode as string) ||
    'dual-read'
  ) as 'dual-write' | 'dual-read' | 'cutover';

  const viewIdsArray = Array.isArray(viewIds) ? viewIds : [];
  const isDryRun = dryRun === true;

  try {
    const { refreshed, errors } = await runAdminRefresh(
      appsScriptUrl,
      appsScriptToken || undefined,
      viewIdsArray,
      adminUid,
      migrationMode,
      isDryRun
    );

    const resultsSummary = { refreshed: refreshed.length, errors: errors.length };

    await admin.firestore().collection('adminActions').add({
      action: 'adminRefreshCache',
      adminUid,
      viewIds: viewIdsArray.length > 0 ? viewIdsArray : ['all'],
      resultsSummary,
      refreshed: refreshed.map((r) => ({ viewId: r.viewId, rows: r.rows, durationMs: r.durationMs })),
      errors,
      dryRun: isDryRun,
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
    });

    return {
      ok: true,
      refreshed,
      errors,
    };
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('adminRefreshCache error:', error);
    throw new functions.https.HttpsError('internal', errorMessage);
  }
});

// Delete user account
export const deleteUserAccount = functions.https.onCall(async (data, context) => {
  // Verify user is authenticated
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
  }

  const { userId } = data;

  // User can only delete their own account
  if (!userId || userId !== context.auth.uid) {
    throw new functions.https.HttpsError('permission-denied', 'You can only delete your own account');
  }

  try {
    // Delete Firebase Authentication account
    await admin.auth().deleteUser(userId);

    return { success: true, message: 'User account deleted successfully' };
  } catch (error: any) {
    console.error('Error deleting user account:', error);
    throw new functions.https.HttpsError('internal', error.message);
  }
});

```

## `index.html`

```html
<!doctype html>
<html lang="sv">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stock Score</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


```

## `package.json`

```json
{
  "name": "stock-score",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "repository": {
    "type": "git",
    "url": "https://github.com/ABNAPP/STOCK-SCORE.git"
  },
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:check": "tsc --noEmit && vite build",
    "verify": "npm run lint && npm run build:check && npm run test:unit && npm run test:integration",
    "verify:full": "npm run verify && npm run test:e2e",
    "analyze": "vite build",
    "lint": "eslint . --max-warnings 0 --config eslint.config.js",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "test:unit": "vitest run src/**/__tests__/**/*.test.{ts,tsx}",
    "test:integration": "vitest run src/test/integration/**/*.test.{ts,tsx}",
    "test:e2e": "playwright test",
    "storybook": "storybook dev -p 6006",
    "build-storybook": "storybook build"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@heroicons/react": "^2.1.1",
    "firebase": "^12.8.0",
    "i18next": "^25.7.3",
    "pako": "^2.1.0",
    "papaparse": "^5.4.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-i18next": "^16.5.1",
    "react-router-dom": "^7.12.0",
    "recharts": "^2.10.3"
  },
  "devDependencies": {
    "@chromatic-com/storybook": "^5.0.0",
    "@eslint/migrate-config": "^2.0.1",
    "@playwright/test": "^1.40.0",
    "@storybook/addon-a11y": "^10.1.11",
    "@storybook/addon-docs": "^10.1.11",
    "@storybook/addon-onboarding": "^10.1.11",
    "@storybook/addon-vitest": "^10.1.11",
    "@storybook/react-vite": "^10.1.11",
    "@testing-library/jest-dom": "^6.1.5",
    "@testing-library/react": "^14.1.2",
    "@testing-library/user-event": "^14.5.1",
    "@types/papaparse": "^5.3.14",
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^8.53.0",
    "@typescript-eslint/parser": "^8.53.0",
    "@vitejs/plugin-react": "^4.2.1",
    "@vitest/browser": "^4.0.0",
    "@vitest/coverage-v8": "^4.0.0",
    "autoprefixer": "^10.4.16",
    "eslint": "^9.39.2",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.5",
    "eslint-plugin-storybook": "^10.1.11",
    "globals": "^17.0.0",
    "jsdom": "^23.0.1",
    "playwright": "^1.57.0",
    "postcss": "^8.4.32",
    "rollup-plugin-visualizer": "^5.12.0",
    "storybook": "^10.1.11",
    "tailwindcss": "^3.3.6",
    "typescript": "^5.2.2",
    "vite": "^7.3.1",
    "vitest": "^4.0.0"
  }
}

```

## `playwright.config.ts`

```typescript
import { defineConfig, devices } from '@playwright/test';

/**
 * See https://playwright.dev/docs/test-configuration.
 */
export default defineConfig({
  testDir: './e2e',
  /* Run tests in files in parallel */
  fullyParallel: true,
  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env.CI,
  /* Retry on CI only */
  retries: process.env.CI ? 2 : 0,
  /* Opt out of parallel tests on CI. */
  workers: process.env.CI ? 1 : undefined,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: 'html',
  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Base URL to use in actions like `await page.goto('/')`. */
    baseURL: 'http://localhost:5173',
    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: 'on-first-retry',
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },

    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },

    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },

    /* Test against mobile viewports. */
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },
  ],

  /* Run your local dev server before starting the tests */
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
    timeout: 120 * 1000,
  },
});

```

## `postcss.config.js`

```javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


```

## `public/sw.js`

```javascript
/**
 * Service Worker for Stock Score App
 *
 * Policy:
 * - SW caches only static assets (app shell). Precache/navigation can use CACHE_NAME.
 * - API requests are bypassed (no caching). Pass-through fetch only.
 * - All data consistency comes from Firestore appCache (single source of truth).
 *
 * Handles background sync and offline support. Coordinates with delta sync to avoid double syncing.
 */

const CACHE_VERSION = 'v1';
const CACHE_NAME = `stock-score-${CACHE_VERSION}`;
const SYNC_COORDINATION_KEY = 'sw:sync:coordinating';

/** Cache names that were previously used for API caching. Cleared on CLEAR_API_CACHE and activate. */
const LEGACY_API_CACHE_NAMES = [];

/** App-shell URLs precached on install. Only assets that exist in build (e.g. Vite dist). */
const PRECACHE_URLS = ['/', '/index.html'];

/**
 * Returns true if the request is an API request (Apps Script, proxy endpoints).
 * These are never cached by the SW; data comes from Firestore appCache.
 * @param {URL} url - Parsed request URL
 * @param {Request} request - The request (optional, for future method/path checks)
 * @returns {boolean}
 */
function isApiRequest(url, request) {
  const host = url.hostname || '';
  return (
    host.includes('script.google.com') ||
    host.includes('docs.google.com') ||
    host.includes('api.allorigins.win') ||
    host.includes('corsproxy.io')
  );
}

/**
 * Returns true if the URL is a precached app-shell entry (same-origin navigation/document).
 * Used to serve cache-first for GET requests to '/' or '/index.html' when offline.
 * @param {URL} url - Parsed request URL
 * @returns {boolean}
 */
function isPrecachedAppShellUrl(url) {
  const path = url.pathname || '/';
  return path === '/' || path === '' || path === '/index.html';
}

// Install event - cache static assets
self.addEventListener('install', (event) => {
  console.log('[Service Worker] Installing...', CACHE_VERSION);

  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      console.log('[Service Worker] Caching static assets');
      return cache.addAll(PRECACHE_URLS).catch((error) => {
        console.warn('[Service Worker] Failed to cache some assets:', error);
      });
    })
  );

  self.skipWaiting();
});

// Activate event - cleanup old caches (keep CACHE_NAME for static)
self.addEventListener('activate', (event) => {
  console.log('[Service Worker] Activating...', CACHE_VERSION);

  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log('[Service Worker] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );

  return self.clients.claim();
});

// Fetch event - API pass-through (no cache); app-shell cache-first for precached URLs only
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);

  if (isApiRequest(url, event.request)) {
    // Pass-through: do not cache API responses; let fetch fail normally when offline
    event.respondWith(fetch(event.request));
    return;
  }

  // Same-origin GET for precached app-shell URLs: cache-first so offline reload works
  if (
    url.origin === self.location.origin &&
    event.request.method === 'GET' &&
    isPrecachedAppShellUrl(url)
  ) {
    event.respondWith(
      caches.open(CACHE_NAME).then((cache) => cache.match(event.request)).then((cached) => cached || fetch(event.request))
    );
    return;
  }

  // All other non-API: do not intercept (browser handles)
  return;
});

// Message event - coordinate with main app
self.addEventListener('message', (event) => {
  console.log('[Service Worker] Message received:', event.data);

  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }

  if (event.data && event.data.type === 'SYNC_REQUEST') {
    const { sheetName, apiBaseUrl, token } = event.data;
    handleBackgroundSync(sheetName, apiBaseUrl, event.ports[0], token);
  }

  if (event.data && event.data.type === 'CHECK_SYNC_STATUS') {
    event.ports[0].postMessage({
      type: 'SYNC_STATUS',
      isSyncing: false,
    });
  }

  if (event.data && event.data.type === 'CLEAR_API_CACHE') {
    const port = event.ports && event.ports[0];
    Promise.all(
      LEGACY_API_CACHE_NAMES.map((name) => caches.delete(name).catch(() => {}))
    ).then(() => {
      if (port) port.postMessage({ type: 'CLEAR_API_CACHE_DONE' });
    });
  }
});

// Background sync handler - token in POST body when set (Apps Script cannot read headers)
async function handleBackgroundSync(sheetName, apiBaseUrl, port, token) {
  try {
    console.log('[Service Worker] Background sync requested for:', sheetName);

    const usePost = !!token;
    const url = usePost ? apiBaseUrl : (() => {
      const u = new URL(apiBaseUrl);
      u.searchParams.set('action', 'snapshot');
      u.searchParams.set('sheet', sheetName);
      return u.toString();
    })();

    const init = usePost
      ? {
          method: 'POST',
          headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'snapshot', sheet: sheetName, token }),
        }
      : { method: 'GET', headers: { 'Accept': 'application/json' } };

    const response = await fetch(url, init);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const snapshot = await response.json();

    if (port) {
      port.postMessage({
        type: 'SYNC_COMPLETE',
        sheetName,
        snapshot,
      });
    }

    console.log('[Service Worker] Background sync completed for:', sheetName);
  } catch (error) {
    console.error('[Service Worker] Background sync failed:', error);
    if (port) {
      port.postMessage({
        type: 'SYNC_ERROR',
        sheetName,
        error: error.message,
      });
    }
  }
}

```

## `QUICK_FIX.md`

```markdown
# 🚀 Snabb Fix: Apps Script URL

## Problemet
Konsolen visar: `Apps Script URL not configured, falling back to CSV`

## Lösning (välj rätt beroende på var appen körs)

### ✅ Om appen körs LOKALT (localhost:5173)

**Steg 1**: Skapa en fil som heter `.env.local` i projektets root (samma mapp som `package.json`)

**Steg 2**: Lägg till denna rad i filen:
```
VITE_APPS_SCRIPT_URL=https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec
```

**Steg 3**: Spara filen och starta om utvecklingsservern:
```bash
# Stoppa servern (Ctrl+C) och starta igen:
npm run dev
```

**Verifiera**: Öppna Developer Console (F12). Du bör se:
```
✅ Apps Script URL configured successfully!
```

---

### ✅ Om appen körs på VERCEL (produktion)

**Steg 1**: Gå till [Vercel Dashboard](https://vercel.com/dashboard)

**Steg 2**: Välj projektet "STOCK SCORE" (eller ditt projektsnamn)

**Steg 3**: 
- Klicka på **Settings** (överst i menyn)
- Klicka på **Environment Variables** (i sidomenyn)

**Steg 4**: Klicka på knappen **Add New** (eller **Add**)

**Steg 5**: Fyll i formuläret:
- **Key**: `VITE_APPS_SCRIPT_URL`
- **Value**: `https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec` (ersätt YOUR_SCRIPT_ID med ditt Script ID)
- **Environments**: ✅ Production, ✅ Preview, ✅ Development (kryssa i alla tre)

**Steg 6**: Klicka på **Save**

**Steg 7**: ⚠️ **VIKTIGT - Redeploya projektet!**
- Gå till **Deployments**-fliken
- Hitta senaste deployment (överst i listan)
- Klicka på de tre prickarna (⋮) bredvid deploymenten
- Välj **Redeploy**
- Bekräfta

**Alternativt**: Pusha en tom commit till GitHub för att trigga automatisk redeploy:
```bash
git commit --allow-empty -m "Trigger redeploy for environment variables"
git push
```

**Verifiera**: Efter redeploy, öppna din Vercel-URL och Developer Console (F12). Du bör se:
```
✅ Apps Script URL configured successfully!
```

---

## Verifiera att Apps Script fungerar

Testa Apps Script direkt i webbläsaren:
```
https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec?sheet=DashBoard
```

**Förväntat resultat**: Du bör se JSON-data direkt.

**Om du ser inloggningssida eller fel**:
- Gå till [Apps Script](https://script.google.com)
- Välj ditt projekt
- Gå till **Deploy** → **Manage deployments**
- Kontrollera att "Who has access" är satt till **"Anyone"**
- Om inte, redigera deployment och ändra till "Anyone", spara och deploya igen

---

## Felsökning

### Problemet kvarstår efter redeploy?

1. **Hård refresh i webbläsaren**: 
   - Windows: `Ctrl + Shift + R`
   - Mac: `Cmd + Shift + R`
   - Eller öppna i Incognito/Private mode

2. **Dubbelkolla environment variable**:
   - Gå tillbaka till Vercel → Settings → Environment Variables
   - Verifiera att `VITE_APPS_SCRIPT_URL` finns
   - Verifiera att värdet har format: `https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec`
   - Verifiera att alla tre environments (Production, Preview, Development) är ikryssade

3. **Kontrollera i Network tab**:
   - Öppna Developer Tools → Network tab
   - Filtrera på "script.google.com"
   - Se om requests görs till Apps Script (✅) eller CSV proxy (❌)

---

## Template fil

En fil som heter `env.template` finns i projektets root som du kan kopiera till `.env.local` för lokal utveckling.

## Ytterligare hjälp

- **Detaljerad guide**: Se `APPS_SCRIPT_SETUP.md` för komplett dokumentation om Apps Script setup inklusive delta-sync
- **Alternativ snabbguide**: Se `SETUP_APPS_SCRIPT.md` för en liknande snabbguide

```

## `README.md`

```markdown
# Stock Score

En React-webbapplikation som hämtar stock score-data från Google Sheets och visar en dashboard med kategoriserade aktier baserat på score-trösklar.

**Repository:** [https://github.com/ABNAPP/STOCK-SCORE](https://github.com/ABNAPP/STOCK-SCORE)

## Funktioner

- 📊 Hämtar data från Google Sheets automatiskt via Google Apps Script API
- 🎯 Kategorisering av aktier baserat på score-trösklar
- 📈 Flera vyer för olika typer av analys (Score Board, Entry/Exit, P/E Industry, Threshold Industry)
- 🔄 Delta Sync support för effektivare datauppdateringar (endast ändringar istället för full reload)
- 🔐 Firebase Authentication med rollbaserad åtkomstkontroll (admin, editor, viewer1, viewer2)
- ⚙️ Anpassningsbara inställningar (trösklar, auto-uppdatering)
- 🔔 Browser notifications support
- 🌐 Internationalisering (i18n) - stöd för svenska och engelska
- 🎨 Modern, responsiv design med Tailwind CSS
- 📱 Fullständigt responsivt för mobil, tablet och desktop
- ♿ Tillgänglighetsfunktioner (WCAG-kompatibel)
- 🔍 Avancerad filtrering och sökning i tabeller
- 📊 Metadata-system för att visa datakällor, formler och villkor för varje kolumn

## Installation

```bash
npm install
```

## Utveckling

```bash
npm run dev
```

## Bygga för produktion

```bash
npm run build
```

## Deployment på Vercel

1. Pusha koden till GitHub
2. Importera projektet i Vercel
3. Vercel kommer automatiskt att detektera Vite-projektet
4. Deploy!

## Konfiguration

### Datahämtning (Primär metod: Google Apps Script API)

Appen använder **Google Apps Script API** som primär metod för datahämtning, vilket ger **5-10x snabbare prestanda** än CSV-proxy-metoden. CSV-proxy används endast som fallback om Apps Script API inte är konfigurerat.

#### Aktivera Apps Script API (Rekommenderat)

1. **För lokal utveckling:**
   - Kopiera `env.template` till `.env.local`: `cp env.template .env.local`
   - Öppna `.env.local` och ersätt placeholders med dina värden (se `docs/SECRETS.md` för instruktioner)
   - Lägg till:
     ```
     VITE_APPS_SCRIPT_URL=https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec
     VITE_DELTA_SYNC_ENABLED=true
     VITE_DELTA_SYNC_POLL_MINUTES=15
     ```
   - Starta om utvecklingsservern: `npm run dev`

2. **För produktion (Vercel):**
   - Gå till Vercel Dashboard → Ditt Projekt → Settings → Environment Variables
   - Lägg till: `VITE_APPS_SCRIPT_URL` med din Apps Script Web App URL
   - Välj alla miljöer (Production, Preview, Development)
   - Spara och **REDEPLOY** projektet (viktigt!)

#### Delta Sync (Valfritt men rekommenderat)

Appen stödjer **Delta Sync** för effektivare datauppdateringar:
- Första gången: Hämtar full snapshot av all data
- Därefter: Hämtar endast ändringar (delta) baserat på poll-intervall
- Uppdaterar UI inkrementellt utan full sid-reload

Delta-sync är aktiverat som standard. Se `APPS_SCRIPT_SETUP.md` för detaljerad setup-instruktioner.

#### Fallback till CSV-proxy

Om `VITE_APPS_SCRIPT_URL` inte är konfigurerad, använder appen automatiskt CSV-proxy-metoden som fallback (långsammare men fungerar utan ytterligare konfiguration).

### Firebase Authentication

Appen använder Firebase Authentication för användarautentisering och rollbaserad åtkomstkontroll. Se `SET_ADMIN_ROLE.md` för instruktioner om att sätta admin-roll.

### Dokumentation

- `env.template` - Mall för environment variables (kopiera till `.env.local`)
- `docs/SECRETS.md` - Hur man sätter nycklar lokalt och secret scan
- `APPS_SCRIPT_SETUP.md` - Detaljerad guide för att sätta upp Google Apps Script
- `SETUP_APPS_SCRIPT.md` / `QUICK_FIX.md` - Snabb guide för att konfigurera Apps Script URL
- `SET_ADMIN_ROLE.md` - Guide för att sätta admin-roll på användare
- `CLOUD_FUNCTIONS_SETUP.md` - Guide för Cloud Functions (valfritt)

## Arkitektur

### Data Flow

Appen använder en flerstegs data pipeline för att hämta och hantera data från Google Sheets:

```mermaid
flowchart TD
    A[Google Sheets] -->|Apps Script API| B[Apps Script Web App]
    A -->|CSV Export| C[CORS Proxy]
    B -->|JSON Response| D[Fetch Service]
    C -->|CSV Data| D
    D -->|Transform| E[Data Transformers]
    E -->|Cache| F[Firestore appCache]
    F -->|TTL/Version| G[firestoreCacheService]
    E -->|Delta Sync| H[Delta Sync Service]
    H -->|Version Tracking| F
    E -->|React Hooks| I[UI Components]
    I -->|Display| J[User Interface]
```

### Delta Sync Flow

Delta sync möjliggör effektiva inkrementella uppdateringar:

```mermaid
sequenceDiagram
    participant App as React App
    participant DS as Delta Sync Service
    participant API as Apps Script API
    participant Cache as Firestore appCache
    
    App->>DS: initSync()
    DS->>API: Request Snapshot
    API-->>DS: Full Snapshot + Version
    DS->>Cache: Store Snapshot + Version
    Cache-->>App: Return Cached Data
    
    loop Every 15 minutes
        App->>DS: pollChanges(lastVersion)
        DS->>API: Request Changes Since Version
        API-->>DS: Changes or needsFullResync
        alt Changes Detected
            DS->>API: Request New Snapshot
            API-->>DS: Updated Snapshot + Version
            DS->>Cache: Update Cache + Version
            Cache-->>App: Updated Data
        else No Changes
            DS-->>App: Use Cached Data
        end
    end
```

### Score Calculation Flow

Score-beräkningen använder en viktad algoritm med färgklassificering:

```mermaid
flowchart TD
    A[ScoreBoardData] -->|Input| B[Calculate Score]
    C[ThresholdData] -->|Industry Thresholds| B
    D[BenjaminGrahamData] -->|Price Data| B
    E[EntryExitValues] -->|Entry/Exit Data| B
    
    B -->|For Each Metric| F{Color Classification}
    F -->|GREEN| G[Factor: 1.00]
    F -->|ORANGE/BLUE| H[Factor: 0.70]
    F -->|RED| I[Factor: 0.00]
    F -->|BLANK| I
    
    G -->|Weight × Factor| J[Point Calculation]
    H -->|Weight × Factor| J
    I -->|Weight × Factor| J
    
    J -->|Sum All Points| K[Total Points]
    K -->|Scale to 0-100| L[Final Score]
    
    style F fill:#e1f5ff
    style L fill:#90ee90
```

### Cache Strategy

Data-cache hanteras i **Firestore appCache** (collection `appCache`). Admin uppdaterar cachen via Refresh Now; viewers läser endast whitelistade nycklar (scoreBoard, benjaminGraham, peIndustry, sma, currency_rates_usd). TTL och timestamp styr freshness; ingen localStorage används för data-cache. Offline-visning bygger på Firestore (ev. persistence) och UI (t.ex. OfflineIndicator), inte på localStorage-data-cache.

```mermaid
flowchart TD
    A[Data Need] -->|Check Cache| B{appCache Hit?}
    B -->|Yes| C{Not Expired?}
    B -->|No| D[Fetch from API]
    C -->|Yes| E[Use Cache]
    C -->|No| D
    
    D -->|Admin Refresh| F[Update Firestore appCache]
    F -->|TTL + timestamp| G[Cache Ready]
    E -->|Display| H[User Interface]
    
    style E fill:#90ee90
    style D fill:#ff6b6b
```

**Service Worker:** SW cachar endast static assets (app shell). API-anrop (Apps Script, proxies) går igenom SW utan caching (pass-through); all data-konsistens kommer från Firestore appCache.

### Component Architecture

Appen följer en hierarkisk komponentstruktur med context providers:

```mermaid
graph TD
    A[App.tsx] -->|Providers| B[AuthContext]
    A -->|Providers| C[RefreshContext]
    A -->|Providers| D[AutoRefreshContext]
    A -->|Providers| E[LoadingProgressContext]
    A -->|Providers| F[ToastContext]
    
    A -->|Routes| G[Views]
    G -->|Score View| H[ScoreView]
    G -->|Score Board View| I[ScoreBoardView]
    G -->|Entry Exit View| J[EntryExitView]
    G -->|Fundamental View| K[FundamentalView]
    
    H -->|Data Hook| L[useScoreBoardData]
    I -->|Data Hook| M[useScoreBoardData]
    J -->|Data Hook| N[useBenjaminGrahamData]
    K -->|Data Hook| O[usePEIndustryData]
    
    L -->|Fetch| P[Sheet Services]
    M -->|Fetch| P
    N -->|Delta Sync| Q[Delta Sync Service]
    O -->|Fetch| P
    
    P -->|Cache| R[firestoreCacheService]
    Q -->|Cache| R
    R -->|Storage| S[Firestore appCache]
    
    style A fill:#4a90e2
    style G fill:#7b68ee
    style P fill:#50c878
    style R fill:#ffa500
```

### Data Transformation Pipeline

Data från Google Sheets transformeras genom flera steg:

```mermaid
flowchart LR
    A[Google Sheets] -->|2D Array| B[Fetch Service]
    B -->|Convert| C[DataRow Objects]
    C -->|Transform| D[Data Transformers]
    D -->|Parse Values| E[Type-Safe Data]
    E -->|Validate| F[Business Logic]
    F -->|Output| G[Typed Data Arrays]
    
    D -->|getValue| H[Case-Insensitive Lookup]
    D -->|parseNumericValueNullable| I[Number Parsing]
    D -->|isValidValue| J[N/A Filtering]
    
    style E fill:#90ee90
    style G fill:#4a90e2
```


```

## `scripts/build-codebase-snapshot.cjs`

```text
/**
 * One-off script: builds CODEBASE_SNAPSHOT.md with the entire codebase.
 * Excludes: node_modules, .git, dist, .env.local, package-lock.json, binary assets.
 * Run: node scripts/build-codebase-snapshot.cjs
 */

const fs = require('fs');
const path = require('path');

const ROOT = path.join(__dirname, '..');
const OUT = path.join(ROOT, 'CODEBASE_SNAPSHOT.md');

const SKIP_DIRS = new Set(['node_modules', '.git', 'dist', 'dist-ssr', 'storybook-static', '.firebase']);
const SKIP_FILES = new Set(['.env.local', 'package-lock.json', 'CODEBASE_SNAPSHOT.md']);
const BINARY_EXT = new Set(['.png', '.jpg', '.jpeg', '.gif', '.webp', '.ico', '.avif', '.svg', '.woff', '.woff2', '.ttf', '.eot']);
const SKIP_PATHS = ['temp-set-admin/serviceAccountKey', 'serviceAccountKey.json']; // sensitive

function shouldSkip(filePath) {
  const rel = path.relative(ROOT, filePath);
  if (SKIP_FILES.has(path.basename(filePath))) return true;
  if (rel.split(path.sep).some(seg => SKIP_DIRS.has(seg))) return true;
  if (SKIP_PATHS.some(p => rel.includes(p))) return true;
  return false;
}

function isBinary(filePath) {
  return BINARY_EXT.has(path.extname(filePath).toLowerCase());
}

function* walk(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) {
      if (SKIP_DIRS.has(e.name)) continue;
      yield* walk(full);
    } else {
      if (shouldSkip(full)) continue;
      yield full;
    }
  }
}

function escapeCodeBlock(content) {
  if (typeof content !== 'string') return content;
  return content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
}

function getLang(filename) {
  const ext = path.extname(filename).toLowerCase();
  const map = { '.ts': 'typescript', '.tsx': 'tsx', '.js': 'javascript', '.jsx': 'jsx', '.json': 'json', '.css': 'css', '.html': 'html', '.md': 'markdown', '.mdx': 'mdx', '.gs': 'javascript', '.bat': 'batch', '.rules': 'text' };
  return map[ext] || 'text';
}

const lines = [];
lines.push('# Stock Score – Kodbas (snapshot)');
lines.push('');
lines.push('*Genererad för personlig referens. En fil per sektion nedan.*');
lines.push('');
lines.push('---');
lines.push('');

const files = [...walk(ROOT)].sort((a, b) => a.localeCompare(b));
for (const filePath of files) {
  const rel = path.relative(ROOT, filePath).replace(/\\/g, '/');
  lines.push(`## \`${rel}\``);
  lines.push('');

  if (isBinary(filePath)) {
    lines.push('*(Binärfil – se repo för asset.)*');
    lines.push('');
    continue;
  }

  let content;
  try {
    content = fs.readFileSync(filePath, 'utf8');
  } catch (err) {
    lines.push('*(Kunde inte läsa fil.)*');
    lines.push('');
    continue;
  }

  const lang = getLang(filePath);
  const escaped = escapeCodeBlock(content);
  lines.push('```' + lang);
  lines.push(escaped);
  lines.push('```');
  lines.push('');
}

fs.writeFileSync(OUT, lines.join('\n'), 'utf8');
console.log('Wrote', OUT, 'with', files.length, 'files');

```

## `scripts/build-codebase-snapshot.js`

```javascript
/**
 * One-off script: builds CODEBASE_SNAPSHOT.md with the entire codebase.
 * Excludes: node_modules, .git, dist, .env.local, package-lock.json, binary assets.
 * Run: node scripts/build-codebase-snapshot.js
 */

const fs = require('fs');
const path = require('path');

const ROOT = path.join(__dirname, '..');
const OUT = path.join(ROOT, 'CODEBASE_SNAPSHOT.md');

const SKIP_DIRS = new Set(['node_modules', '.git', 'dist', 'dist-ssr', 'storybook-static', '.firebase']);
const SKIP_FILES = new Set(['.env.local', 'package-lock.json', 'CODEBASE_SNAPSHOT.md']);
const BINARY_EXT = new Set(['.png', '.jpg', '.jpeg', '.gif', '.webp', '.ico', '.avif', '.svg', '.woff', '.woff2', '.ttf', '.eot']);
const SKIP_PATHS = ['temp-set-admin/serviceAccountKey', 'serviceAccountKey.json']; // sensitive

function shouldSkip(filePath) {
  const rel = path.relative(ROOT, filePath);
  if (SKIP_FILES.has(path.basename(filePath))) return true;
  if (rel.split(path.sep).some(seg => SKIP_DIRS.has(seg))) return true;
  if (SKIP_PATHS.some(p => rel.includes(p))) return true;
  return false;
}

function isBinary(filePath) {
  return BINARY_EXT.has(path.extname(filePath).toLowerCase());
}

function* walk(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) {
      if (SKIP_DIRS.has(e.name)) continue;
      yield* walk(full);
    } else {
      if (shouldSkip(full)) continue;
      yield full;
    }
  }
}

function escapeCodeBlock(content) {
  if (typeof content !== 'string') return content;
  return content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
}

function getLang(filename) {
  const ext = path.extname(filename).toLowerCase();
  const map = { '.ts': 'typescript', '.tsx': 'tsx', '.js': 'javascript', '.jsx': 'jsx', '.json': 'json', '.css': 'css', '.html': 'html', '.md': 'markdown', '.mdx': 'mdx', '.gs': 'javascript', '.bat': 'batch', '.rules': 'text' };
  return map[ext] || 'text';
}

const lines = [];
lines.push('# Stock Score – Kodbas (snapshot)');
lines.push('');
lines.push('*Genererad för personlig referens. En fil per sektion nedan.*');
lines.push('');
lines.push('---');
lines.push('');

const files = [...walk(ROOT)].sort((a, b) => a.localeCompare(b));
for (const filePath of files) {
  const rel = path.relative(ROOT, filePath).replace(/\\/g, '/');
  lines.push(`## \`${rel}\``);
  lines.push('');

  if (isBinary(filePath)) {
    lines.push('*(Binärfil – se repo för asset.)*');
    lines.push('');
    continue;
  }

  let content;
  try {
    content = fs.readFileSync(filePath, 'utf8');
  } catch (err) {
    lines.push('*(Kunde inte läsa fil.)*');
    lines.push('');
    continue;
  }

  const lang = getLang(filePath);
  const escaped = escapeCodeBlock(content);
  lines.push('```' + lang);
  lines.push(escaped);
  lines.push('```');
  lines.push('');
}

fs.writeFileSync(OUT, lines.join('\n'), 'utf8');
console.log('Wrote', OUT, 'with', files.length, 'files');

```

## `SET_ADMIN_ROLE.md`

```markdown
# Guide: Sätt Admin-roll på första användaren

Denna guide visar hur du sätter admin-rollen på din användare (babayan.ali@gmail.com) så att du kan börja använda admin-funktionerna.

## Förutsättningar

- ✅ Firebase CLI installerat (`npm install -g firebase-tools`)
- ✅ Du har ditt användar-UID: `ih1PUMO6WhXxm13ZGLKlfC9gZ1h2`

## Steg 1: Logga in i Firebase (valfritt)

Om du inte redan är inloggad i Firebase CLI:

```bash
firebase login
```

Detta öppnar en webbläsare där du loggar in med ditt Google-konto (samma konto som du använder för Firebase Console).

**OBS:** Detta är valfritt för denna guide - du behöver inte vara inloggad i CLI eftersom vi använder Service Account key istället.

## Steg 2: Hämta Service Account Key

1. Gå till Firebase Console: https://console.firebase.google.com
2. Välj ditt projekt (stock-score-df698)
3. Gå till Project Settings (kugghjulsikonen) → Service Accounts-fliken
4. Klicka på "Generate new private key"
5. Klicka på "Generate key" i dialogrutan
6. En JSON-fil laddas ner (t.ex. `stock-score-df698-firebase-adminsdk-xxxxx.json`)
7. **VIKTIGT:** Döp om denna fil till `serviceAccountKey.json`
8. Flytta `serviceAccountKey.json` till mappen `temp-set-admin` i projektets root

## Steg 3: Installera paket

Öppna terminal/kommandotolken i projektets root och kör:

```bash
cd temp-set-admin
npm install
```

Detta installerar Firebase Admin SDK som behövs för att sätta custom claims.

## Steg 4: Kör scriptet

När paketen är installerade, kör:

```bash
node setAdminRole.js
```

ELLER:

```bash
npm start
```

Om allt går bra ska du se:
```
✅ Admin-roll satt framgångsrikt!
User ID: ih1PUMO6WhXxm13ZGLKlfC9gZ1h2
Email: babayan.ali@gmail.com

📝 Nästa steg:
1. Logga ut från appen
2. Logga in igen
3. Du ska nu se admin-panel knappen i headern
```

## Steg 5: Logga ut och in igen i appen

1. Logga ut från appen (klicka på logout-knappen i headern)
2. Logga in igen med din email: babayan.ali@gmail.com
3. Admin-rollen ska nu vara aktiv
4. Du ska se "Admin-panel" knappen i headern (lila knapp)

## Steg 6: Städa upp (viktigt för säkerhet!)

När du är klar och har bekräftat att admin-rollen fungerar, ta bort den tillfälliga mappen:

**På Windows (PowerShell):**
```bash
cd ..
Remove-Item -Recurse -Force temp-set-admin
```

**På Windows (Command Prompt):**
```bash
cd ..
rmdir /s /q temp-set-admin
```

**På Mac/Linux:**
```bash
cd ..
rm -rf temp-set-admin
```

**OBS:** Service Account Key är känslig - se till att den inte commitas till git! (Den är redan i `.gitignore`)

## Felsökning

### Fel: "Cannot find module './serviceAccountKey.json'"
- Kontrollera att `serviceAccountKey.json` finns i `temp-set-admin`-mappen
- Kontrollera att filen heter exakt `serviceAccountKey.json` (case-sensitive)

### Fel: "Permission denied" eller "403 Forbidden"
- Kontrollera att Service Account Key är korrekt
- Kontrollera att du hämtade nyckeln från rätt Firebase-projekt

### Fel: "User not found"
- Kontrollera att User ID (`ih1PUMO6WhXxm13ZGLKlfC9gZ1h2`) är korrekt
- Du hittar User ID i Firebase Console → Authentication → Users → Klicka på din användare → Kopiera User UID

### Rollen visas fortfarande inte efter inloggning:
1. Logga ut och in igen (token behöver refresha)
2. Vänta några sekunder
3. Kontrollera i Firebase Console → Authentication → Users → Din användare → Custom claims ska visa `{"role": "admin"}`

### Efter att rollen är satt:
- Du ska INTE längre se "Waiting for Approval"-meddelandet
- Du ska se "Admin-panel" knappen i headern (lila knapp, endast för admin)
- Du ska kunna öppna Admin-panel och godkänna/neka registreringar

### Fel: "Error loading users" / FirebaseError: internal
När du öppnar Admin-panelen och får ett fel vid laddning av användarlistan visas nu det faktiska felmeddelandet från servern i en toast – använd det för att felsöka.

Vanliga orsaker:
1. **User must be admin** – Du är inloggad men din användare har inte admin-roll. Sätt admin enligt Steg 1–5 ovan och logga ut/in igen.
2. **Cloud Functions inte deployade** – Funktionen `listUsers` måste vara deployad. Kör t.ex. `firebase deploy --only functions` från projektets root.
3. **Fel region** – Om dina functions är deployade i en annan region (t.ex. europe-west1) måste klienten använda samma region (konfigurera i `src/config/firebase.ts` om så är fallet).
4. **Firebase Auth / API** – Kontrollera att Authentication är aktiverat i Firebase Console och att Cloud Functions-loggen (Firebase Console → Functions → Logs) visar det underliggande felet när du anropar listUsers.

```

## `SETUP_APPS_SCRIPT.md`

```markdown
# Quick Setup: Apps Script URL

**Notera**: Detta är en snabbguide. För detaljerad dokumentation inklusive delta-sync setup, se `APPS_SCRIPT_SETUP.md`.

## Snabbinstruktion för att fixa CORS-problemet

### ✅ Steg 1: Skapa .env.local (för lokal utveckling)

Skapa en fil `.env.local` i projektets root med följande innehåll:

```
VITE_APPS_SCRIPT_URL=https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec
```

**OBS**: Filen `.env.local` ignoreras av Git (det är bra för säkerhet).

### ✅ Steg 2: Konfigurera i Vercel (för produktion)

1. Gå till [Vercel Dashboard](https://vercel.com/dashboard)
2. Välj projektet "STOCK SCORE" (eller ditt projektsnamn)
3. Klicka på **Settings** i toppmenyn
4. Klicka på **Environment Variables** i sidomenyn
5. Klicka på knappen **Add New** (eller **Add**)
6. Fyll i formuläret:
   - **Key**: `VITE_APPS_SCRIPT_URL`
   - **Value**: `https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec` (ersätt YOUR_SCRIPT_ID med ditt Script ID från Apps Script deployment)
   - **Environments**: Välj alla tre (Production, Preview, Development)
7. Klicka på **Save**

### ⚠️ Steg 3: VIKTIGT - Redeploya projektet!

Efter att ha lagt till environment variables i Vercel **måste** du redeploya:

**Alternativ A: Via Vercel Dashboard**
1. Gå till **Deployments**-fliken
2. Hitta senaste deployment (överst i listan)
3. Klicka på de tre prickarna (⋮) bredvid deploymenten
4. Välj **Redeploy**
5. Bekräfta

**Alternativ B: Via Git push**
1. Gör en liten ändring i koden (eller skapa en tom commit)
2. Pusha till GitHub
3. Vercel deployar automatiskt

### ✅ Steg 4: Verifiera

1. **Lokalt**: 
   - Starta appen: `npm run dev`
   - Öppna Developer Console (F12)
   - Du bör se: `✅ Apps Script URL configured successfully!`

2. **I produktion**:
   - Besök din Vercel-URL
   - Öppna Developer Console (F12)
   - Du bör se: `✅ Apps Script URL configured successfully!`
   - Om du ser fel, kontrollera att du har redeployat efter att ha lagt till environment variable

3. **Testa Apps Script direkt**:
   Öppna denna URL i webbläsaren:
   ```
   https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec?sheet=DashBoard
   ```
   (Ersätt YOUR_SCRIPT_ID med ditt Script ID.)
   Du bör se JSON-data. Om du ser en inloggningssida eller felmeddelande, kontrollera att Apps Script är deployat med "Who has access" = "Anyone".

### Token och fail-closed (prod)

- **Token** skickas i POST-body (ej i URL). Sätt `VITE_APPS_SCRIPT_TOKEN` i env.
- Token i header (Authorization Bearer) stöds av klienten; Apps Script läser från body tills header-API finns.
- **Fail-closed**: Om `API_TOKEN` är satt i Apps Script Script Properties krävs giltig token – annars 401.
- **Dev**: Lämna `API_TOKEN` tomt i Script Properties för enklare utveckling; Apps Script loggar varning.

## Felsökning

### Problemet kvarstår efter redeploy?

1. **Rensa cache**: 
   - Hård refresh i webbläsaren: `Ctrl+Shift+R` (Windows) eller `Cmd+Shift+R` (Mac)
   - Eller öppna i Incognito/Private mode

2. **Kontrollera environment variable**:
   - Gå tillbaka till Vercel → Settings → Environment Variables
   - Verifiera att `VITE_APPS_SCRIPT_URL` finns
   - Verifiera att värdet är rätt format: `https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec`
   - Verifiera att alla tre environments (Production, Preview, Development) är ikryssade

3. **Kontrollera Apps Script deployment**:
   - Gå till [Apps Script](https://script.google.com)
   - Välj ditt projekt
   - Gå till **Deploy** → **Manage deployments**
   - Kontrollera att "Who has access" är satt till **"Anyone"**
   - Om inte, klicka på redigeringsikonen och ändra till "Anyone", spara och deploya igen

4. **Kontrollera i browser console**:
   - Öppna Network tab i Developer Tools
   - Filtrera på "script.google.com"
   - Se om requests görs till Apps Script eller om det fortfarande använder CSV proxy

## Ytterligare hjälp

- **Detaljerad guide**: Se `APPS_SCRIPT_SETUP.md` för komplett dokumentation om Apps Script setup inklusive delta-sync
- **Alternativ snabbguide**: Se `QUICK_FIX.md` för en kortare version av denna guide
- **Problem?**: Kontrollera att Apps Script är deployat som "Web app" (inte "Library") med "Who has access" = "Anyone"

```

## `src/App.tsx`

```tsx
import { useState, Suspense, useEffect, useCallback } from 'react';
import { lazyWithRetry } from './utils/lazyWithRetry';
import { Routes, Route, useNavigate, useLocation } from 'react-router-dom';
import Header from './components/Header';
import Sidebar from './components/Sidebar';
import Breadcrumbs from './components/Breadcrumbs';
import { ViewId } from './types/navigation';
import { getTableMetadata } from './config/tableMetadata';
import { getTableId } from './config/viewTableMap';
import type { TableMetadata } from './types/columnMetadata';
import { useTranslation } from 'react-i18next';
import { useAuth } from './contexts/AuthContext';
import { useUserRole } from './hooks/useUserRole';
import { RefreshProvider, useRefresh } from './contexts/RefreshContext';
import { AutoRefreshProvider } from './contexts/AutoRefreshContext';
import { LoadingProgressProvider } from './contexts/LoadingProgressContext';
import { useToast } from './contexts/ToastContext';
import ToastContainer from './components/ToastContainer';
import LoadingFallback from './components/LoadingFallback';
import Login from './components/Login';
import SkipLinks from './components/SkipLinks';
import OfflineIndicator from './components/OfflineIndicator';
import { usePullToRefresh } from './hooks/usePullToRefresh';
import ShareableView from './components/views/ShareableView';
import { ShareableLink } from './services/shareableLinkService';
import { FilterValues } from './types/filters';
import { runPostAuthMigrations } from './services/migrations';

// Lazy load view components for better performance (with retry for dev "Failed to fetch" resilience)
const ScoreBoardView = lazyWithRetry<typeof import('./components/views/ScoreBoardView').default>(() => import('./components/views/ScoreBoardView'), 'ScoreBoardView');
const ScoreView = lazyWithRetry<typeof import('./components/views/ScoreView').default>(() => import('./components/views/ScoreView'), 'ScoreView');
const EntryExitView = lazyWithRetry<typeof import('./components/views/EntryExitView').default>(() => import('./components/views/EntryExitView'), 'EntryExitView');
const FundamentalView = lazyWithRetry<typeof import('./components/views/FundamentalView').default>(() => import('./components/views/FundamentalView'), 'FundamentalView');
const ThresholdIndustryView = lazyWithRetry<typeof import('./components/views/ThresholdIndustryView').default>(() => import('./components/views/ThresholdIndustryView'), 'ThresholdIndustryView');
const PersonalPortfolioView = lazyWithRetry<typeof import('./components/views/PersonalPortfolioView').default>(() => import('./components/views/PersonalPortfolioView'), 'PersonalPortfolioView');
const AdminView = lazyWithRetry<typeof import('./components/views/AdminView').default>(() => import('./components/views/AdminView'), 'AdminView');

// Lazy load modal components
const ConditionsModal = lazyWithRetry<typeof import('./components/ConditionsModal').default>(() => import('./components/ConditionsModal'), 'ConditionsModal');
const UserProfileModal = lazyWithRetry<typeof import('./components/UserProfileModal').default>(() => import('./components/UserProfileModal'), 'UserProfileModal');

function App() {
  const { loading: authLoading, currentUser } = useAuth();
  const { canView, isAdmin } = useUserRole();
  const { t } = useTranslation();
  const { showToast } = useToast();
  const navigate = useNavigate();
  const location = useLocation();
  const [activeView, setActiveView] = useState<ViewId>('score');
  const [conditionsModalOpen, setConditionsModalOpen] = useState(false);
  const [selectedViewForModal, setSelectedViewForModal] = useState<ViewId | null>(null);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(true);
  const [userProfileOpen, setUserProfileOpen] = useState(false);
  const [loadedShareableLink, setLoadedShareableLink] = useState<ShareableLink | null>(null);

  // Run post-auth migrations and setup when user is authenticated
  useEffect(() => {
    if (!authLoading && currentUser) {
      runPostAuthMigrations();
    }
  }, [authLoading, currentUser]);

  // Sync activeView from URL (e.g. /admin) and redirect non-admin away from /admin
  useEffect(() => {
    if (!currentUser) return;
    const path = location.pathname.replace(/^\//, '') || 'score';
    if (path === 'admin') {
      if (isAdmin) {
        setActiveView('admin');
      } else {
        navigate('/', { replace: true });
        setActiveView('score');
      }
    }
  }, [currentUser, location.pathname, isAdmin, navigate]);

  // Redirect viewers if they try to access unauthorized views
  // This useEffect must be called before any early returns to maintain hook order
  useEffect(() => {
    if (!canView(activeView)) {
      setActiveView('score');
      showToast(t('common.unauthorizedView') || 'Du har inte tillgång till denna vy', 'warning');
    }
  }, [activeView, canView, showToast, t]);

  // Background sync and cache warming disabled - using Firestore cache instead

  // IMPORTANT: All hooks (including useCallback, useMemo) must be called BEFORE any early returns
  // This ensures hooks are always called in the same order on every render
  const handleLoadShareableLink = useCallback((link: ShareableLink) => {
    setLoadedShareableLink(link);
    setActiveView(link.viewId as ViewId);
    // Apply filter state and sort config from link
    // This will be handled by the view components
  }, []);

  const handleViewChange = useCallback((viewId: ViewId) => {
    // Check if viewer is trying to access unauthorized view
    if (!canView(viewId)) {
      showToast(t('common.unauthorizedView') || 'Du har inte tillgång till denna vy', 'warning');
      return;
    }
    setActiveView(viewId);
    // Update URL without navigation
    navigate(`/${viewId}`, { replace: true });
  }, [canView, showToast, t, navigate]);

  // Show loading state while auth is initializing
  if (authLoading) {
    return <LoadingFallback />;
  }

  // Require login: show Login when not authenticated
  if (!currentUser) {
    const returnUrl = location.pathname + location.search;
    return <Login returnUrl={returnUrl !== '/' ? returnUrl : undefined} />;
  }

  const handleOpenConditionsModal = (viewId: ViewId) => {
    setSelectedViewForModal(viewId);
    setConditionsModalOpen(true);
  };

  const handleCloseConditionsModal = () => {
    setConditionsModalOpen(false);
    setSelectedViewForModal(null);
  };

  const getPageName = (viewId: ViewId): string => {
    const names: Partial<Record<ViewId, string>> = {
      'score-board': t('navigation.scoreBoard'),
      'score': t('navigation.score'),
      'entry-exit-benjamin-graham': t('navigation.benjaminGraham'),
      'fundamental-pe-industry': t('navigation.peIndustry'),
      'threshold-industry': t('navigation.thresholdIndustry'),
      'personal-portfolio': t('navigation.personalPortfolio'),
      'admin': t('navigation.userManagement'),
    };
    return names[viewId] || viewId;
  };

  const renderView = () => {
    if (activeView === 'score') {
      return (
        <Suspense fallback={<LoadingFallback />}>
          <ScoreView />
        </Suspense>
      );
    }

    if (activeView === 'score-board') {
      return (
        <Suspense fallback={<LoadingFallback />}>
          <ScoreBoardView />
        </Suspense>
      );
    }

    if (activeView.startsWith('entry-exit-')) {
      return (
        <Suspense fallback={<LoadingFallback />}>
          <EntryExitView viewId={activeView} />
        </Suspense>
      );
    }

    if (activeView.startsWith('fundamental-')) {
      return (
        <Suspense fallback={<LoadingFallback />}>
          <FundamentalView viewId={activeView} />
        </Suspense>
      );
    }

    if (activeView === 'threshold-industry') {
      return (
        <Suspense fallback={<LoadingFallback />}>
          <ThresholdIndustryView />
        </Suspense>
      );
    }

    if (activeView === 'personal-portfolio') {
      return (
        <Suspense fallback={<LoadingFallback />}>
          <PersonalPortfolioView />
        </Suspense>
      );
    }

    if (activeView === 'admin') {
      return (
        <Suspense fallback={<LoadingFallback />}>
          <AdminView />
        </Suspense>
      );
    }

    return (
      <Suspense fallback={<LoadingFallback />}>
        <ScoreView />
      </Suspense>
    );
  };

  const tableId = selectedViewForModal ? getTableId(selectedViewForModal) : null;
  const metadata: TableMetadata | null = tableId ? getTableMetadata(tableId) ?? null : null;
  const pageName = selectedViewForModal ? getPageName(selectedViewForModal) : '';

  // CRITICAL: Provider order is essential for context availability
  // Order MUST be: LoadingProgressProvider (outermost) → RefreshProvider → AutoRefreshProvider (innermost)
  // AutoRefreshProvider requires RefreshProvider to be its direct parent
  // DO NOT change this order without understanding the context dependencies!
  return (
    <Routes>
      <Route
        path="/share/:linkId"
        element={
          <LoadingProgressProvider>
            <RefreshProvider>
              <AutoRefreshProvider>
                <Suspense fallback={<LoadingFallback />}>
                  <ShareableView onLoadLink={handleLoadShareableLink} />
                </Suspense>
              </AutoRefreshProvider>
            </RefreshProvider>
          </LoadingProgressProvider>
        }
      />
      <Route
        path="/*"
        element={
          <LoadingProgressProvider>
            <RefreshProvider>
              <AutoRefreshProvider>
                <AppContent
                  activeView={activeView}
                  setActiveView={handleViewChange}
                  sidebarCollapsed={sidebarCollapsed}
                  setSidebarCollapsed={setSidebarCollapsed}
                  conditionsModalOpen={conditionsModalOpen}
                  handleOpenConditionsModal={handleOpenConditionsModal}
                  handleCloseConditionsModal={handleCloseConditionsModal}
                  selectedViewForModal={selectedViewForModal}
                  renderView={renderView}
                  metadata={metadata}
                  pageName={pageName}
                  userProfileOpen={userProfileOpen}
                  setUserProfileOpen={setUserProfileOpen}
                  loadedShareableLink={loadedShareableLink}
                />
              </AutoRefreshProvider>
            </RefreshProvider>
          </LoadingProgressProvider>
        }
      />
    </Routes>
  );
}

function AppContent({
  activeView,
  setActiveView,
  sidebarCollapsed,
  setSidebarCollapsed,
  conditionsModalOpen,
  handleOpenConditionsModal,
  handleCloseConditionsModal,
  selectedViewForModal: _selectedViewForModal,
  renderView,
  metadata,
  pageName,
  userProfileOpen,
  setUserProfileOpen,
  loadedShareableLink,
}: {
  activeView: ViewId;
  setActiveView: (view: ViewId) => void;
  sidebarCollapsed: boolean;
  setSidebarCollapsed: (collapsed: boolean) => void;
  conditionsModalOpen: boolean;
  handleOpenConditionsModal: (viewId: ViewId) => void;
  handleCloseConditionsModal: () => void;
  selectedViewForModal: ViewId | null;
  renderView: () => JSX.Element;
  metadata: TableMetadata | null;
  pageName: string;
  userProfileOpen: boolean;
  setUserProfileOpen: (open: boolean) => void;
  loadedShareableLink: ShareableLink | null;
}) {
  const { toasts, removeToast } = useToast();
  const { t } = useTranslation();
  const { refreshAll, isRefreshing } = useRefresh();

  // Pull-to-refresh for mobile
  const { containerRef, pullDistance, pullProgress, isRefreshing: isPullRefreshing } = usePullToRefresh({
    onRefresh: refreshAll,
    disabled: isRefreshing,
    enabled: true,
  });

  const isRefreshingAny = isRefreshing || isPullRefreshing;

  return (
    <div className="flex h-screen bg-gray-100 dark:bg-gray-900">
      <SkipLinks />
      <Header 
        onNavigate={setActiveView}
        activeView={activeView}
        sidebarCollapsed={sidebarCollapsed}
      />
      <Sidebar 
        activeView={activeView} 
        onViewChange={setActiveView}
        onOpenConditionsModal={handleOpenConditionsModal}
        isOpen={true}
        onClose={() => {}}
        isCollapsed={sidebarCollapsed}
        onToggleCollapse={() => setSidebarCollapsed(!sidebarCollapsed)}
        onOpenUserProfile={() => setUserProfileOpen(true)}
      />
      <main 
        ref={containerRef as React.RefObject<HTMLElement>}
        id="main-content" 
        className={`flex-1 mt-16 overflow-y-auto overflow-x-hidden flex flex-col w-full relative ${sidebarCollapsed ? 'ml-16' : 'ml-64'}`}
        role="main" 
        aria-label={t('aria.mainContent', 'Huvudinnehåll')}
        style={{
          transform: pullDistance > 0 ? `translateY(${Math.min(pullDistance, 80)}px)` : undefined,
          transition: pullDistance === 0 ? 'transform 0.2s ease-out' : undefined,
        }}
      >
        {/* Pull-to-refresh indicator */}
        {pullDistance > 0 && (
          <div 
            className="absolute top-0 left-0 right-0 flex items-center justify-center py-4 z-50"
            style={{ 
              opacity: Math.min(pullProgress, 1),
              transform: `translateY(${-pullDistance}px)`,
            }}
          >
            <div className="flex flex-col items-center gap-2">
              {isRefreshingAny ? (
                <>
                  <svg
                    className="w-6 h-6 text-blue-600 dark:text-blue-400 animate-spin"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                    />
                  </svg>
                  <span className="text-sm font-medium text-blue-600 dark:text-blue-400">
                    {t('pullToRefresh.refreshing', 'Uppdaterar...')}
                  </span>
                </>
              ) : (
                <>
                  <svg
                    className={`w-6 h-6 text-blue-600 dark:text-blue-400 transition-transform duration-200 ${pullProgress >= 1 ? 'rotate-180' : ''}`}
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M19 14l-7 7m0 0l-7-7m7 7V3"
                    />
                  </svg>
                  <span className="text-sm font-medium text-blue-600 dark:text-blue-400">
                    {pullProgress >= 1 
                      ? t('pullToRefresh.release', 'Släpp för att uppdatera')
                      : t('pullToRefresh.pull', 'Dra för att uppdatera')
                    }
                  </span>
                </>
              )}
            </div>
          </div>
        )}
        <Breadcrumbs activeView={activeView} onViewChange={setActiveView} />
        <div className="h-full transition-all duration-300 ease-in-out animate-fade-in" aria-live="polite" aria-atomic="true" role="region">
          {renderView()}
        </div>
      </main>
      {conditionsModalOpen && (
        <Suspense fallback={null}>
          <ConditionsModal
            isOpen={conditionsModalOpen}
            onClose={handleCloseConditionsModal}
            metadata={metadata}
            pageName={pageName}
          />
        </Suspense>
      )}
      {userProfileOpen && (
        <Suspense fallback={null}>
          <UserProfileModal
            isOpen={userProfileOpen}
            onClose={() => setUserProfileOpen(false)}
          />
        </Suspense>
      )}
      <ToastContainer toasts={toasts} onClose={removeToast} />
      <OfflineIndicator />
    </div>
  );
}

export default App;

```

## `src/components/__tests__/BaseTable.integration.test.tsx`

```tsx
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen, within, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import BaseTable, { ColumnDefinition } from '../BaseTable';
import { FilterConfig } from '../AdvancedFilters';
import { ThemeProvider } from '../../contexts/ThemeContext';
import { EntryExitProvider } from '../../contexts/EntryExitContext';
import '../../i18n/config';

// Test data type
interface TestData {
  id: number;
  name: string;
  value: number;
  category: string;
  status: string;
}

// Test wrapper component
function TestWrapper({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider>
      <EntryExitProvider>
        {children}
      </EntryExitProvider>
    </ThemeProvider>
  );
}

describe('BaseTable Integration Tests', () => {
  const mockColumns: ColumnDefinition<TestData>[] = [
    { key: 'id', label: 'ID', required: true, sticky: true, sortable: true },
    { key: 'name', label: 'Name', required: true, sticky: true, sortable: true },
    { key: 'value', label: 'Value', defaultVisible: true, sortable: true, align: 'center' },
    { key: 'category', label: 'Category', defaultVisible: true, sortable: true },
    { key: 'status', label: 'Status', defaultVisible: false, sortable: false },
  ];

  const mockFilters: FilterConfig[] = [
    { key: 'name', label: 'Name', type: 'text' },
    { key: 'category', label: 'Category', type: 'select', options: [
      { value: 'A', label: 'Category A' },
      { value: 'B', label: 'Category B' },
      { value: 'C', label: 'Category C' },
    ]},
    { key: 'value', label: 'Value', type: 'numberRange', min: 0, max: 100, step: 1 },
    { key: 'status', label: 'Status', type: 'text' },
  ];

  const createTestData = (count: number): TestData[] => {
    return Array.from({ length: count }, (_, i) => ({
      id: i + 1,
      name: `Item ${i + 1}`,
      value: Math.floor(Math.random() * 100),
      category: ['A', 'B', 'C'][i % 3],
      status: i % 2 === 0 ? 'Active' : 'Inactive',
    }));
  };

  const renderCell = (item: TestData, column: ColumnDefinition<TestData>) => {
    switch (column.key) {
      case 'id':
        return item.id;
      case 'name':
        return <span>{item.name}</span>;
      case 'value':
        return item.value;
      case 'category':
        return item.category;
      case 'status':
        return item.status;
      default:
        return null;
    }
  };

  describe('Rendering with different data sizes', () => {
    it('should render with empty data', () => {
      render(
        <BaseTable
          data={[]}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
          emptyMessage="No data available"
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('No data available')).toBeInTheDocument();
    });

    it('should render with single row', () => {
      const data = createTestData(1);
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('Item 1')).toBeInTheDocument();
    });

    it('should render with small dataset (< 10 rows)', () => {
      const data = createTestData(5);
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('Item 1')).toBeInTheDocument();
      expect(screen.getByText('Item 5')).toBeInTheDocument();
    });

    it('should render with large dataset (> 100 rows)', () => {
      const data = createTestData(150);
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
          enablePagination={true}
          itemsPerPage={50}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('Item 1')).toBeInTheDocument();
      // Should show pagination
      expect(screen.getByText(/Visar/i)).toBeInTheDocument();
    });
  });

  describe('Search functionality', () => {
    it('should filter data by search term', async () => {
      const user = userEvent.setup();
      const data = createTestData(10);
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
        />,
        { wrapper: TestWrapper }
      );

      const searchInput = screen.getByPlaceholderText(/Sök/i);
      await user.type(searchInput, 'Item 1');

      await waitFor(() => {
        expect(screen.getByText('Item 1')).toBeInTheDocument();
        expect(screen.queryByText('Item 2')).not.toBeInTheDocument();
      });
    });

    it('should search across multiple fields', async () => {
      const user = userEvent.setup();
      const data = [
        { id: 1, name: 'Apple', value: 10, category: 'Fruit', status: 'Active' },
        { id: 2, name: 'Banana', value: 20, category: 'Fruit', status: 'Active' },
        { id: 3, name: 'Carrot', value: 30, category: 'Vegetable', status: 'Inactive' },
      ];
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
        />,
        { wrapper: TestWrapper }
      );

      const searchInput = screen.getByPlaceholderText(/Sök/i);
      await user.type(searchInput, 'Fruit');

      await waitFor(() => {
        expect(screen.getByText('Apple')).toBeInTheDocument();
        expect(screen.getByText('Banana')).toBeInTheDocument();
        expect(screen.queryByText('Carrot')).not.toBeInTheDocument();
      });
    });
  });

  describe('Advanced filters', () => {
    it('should filter by text filter', async () => {
      const user = userEvent.setup();
      const data = createTestData(10);
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
        />,
        { wrapper: TestWrapper }
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Find and fill name filter
      const nameInput = screen.getByPlaceholderText(/Sök name/i);
      await user.type(nameInput, 'Item 1');

      await waitFor(() => {
        expect(screen.getByText('Item 1')).toBeInTheDocument();
      });
    });

    it('should filter by select filter', async () => {
      const user = userEvent.setup();
      const data = [
        { id: 1, name: 'Item 1', value: 10, category: 'A', status: 'Active' },
        { id: 2, name: 'Item 2', value: 20, category: 'B', status: 'Active' },
        { id: 3, name: 'Item 3', value: 30, category: 'C', status: 'Inactive' },
      ];
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
        />,
        { wrapper: TestWrapper }
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Select category filter
      const categorySelect = screen.getByLabelText(/Category/i) || 
        within(screen.getByText('Category').closest('div')!).getByRole('combobox');
      
      // Try to find select element
      const selects = screen.getAllByRole('combobox');
      const categorySelectElement = selects.find(select => 
        select.closest('div')?.textContent?.includes('Category')
      ) || selects[0];

      if (categorySelectElement) {
        await user.selectOptions(categorySelectElement, 'A');
      }

      await waitFor(() => {
        expect(screen.getByText('Item 1')).toBeInTheDocument();
      });
    });

    it('should filter by number range', async () => {
      const user = userEvent.setup();
      const data = [
        { id: 1, name: 'Item 1', value: 10, category: 'A', status: 'Active' },
        { id: 2, name: 'Item 2', value: 50, category: 'B', status: 'Active' },
        { id: 3, name: 'Item 3', value: 90, category: 'C', status: 'Inactive' },
      ];
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
        />,
        { wrapper: TestWrapper }
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Find value range inputs
      const inputs = screen.getAllByPlaceholderText(/Min|Max/i);
      const minInput = inputs.find(input => input.getAttribute('placeholder') === 'Min') || inputs[0];
      const maxInput = inputs.find(input => input.getAttribute('placeholder') === 'Max') || inputs[1];

      if (minInput) await user.type(minInput, '20');
      if (maxInput) await user.type(maxInput, '60');

      await waitFor(() => {
        expect(screen.getByText('Item 2')).toBeInTheDocument();
        expect(screen.queryByText('Item 1')).not.toBeInTheDocument();
        expect(screen.queryByText('Item 3')).not.toBeInTheDocument();
      });
    });
  });

  describe('Filter combinations', () => {
    it('should apply multiple filters simultaneously', async () => {
      const user = userEvent.setup();
      const data = [
        { id: 1, name: 'Apple', value: 10, category: 'A', status: 'Active' },
        { id: 2, name: 'Banana', value: 20, category: 'A', status: 'Active' },
        { id: 3, name: 'Carrot', value: 30, category: 'B', status: 'Inactive' },
      ];
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
        />,
        { wrapper: TestWrapper }
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Apply name filter
      const nameInput = screen.getByPlaceholderText(/Sök name/i);
      await user.type(nameInput, 'Apple');

      // Apply value range
      const inputs = screen.getAllByPlaceholderText(/Min|Max/i);
      const minInput = inputs.find(input => input.getAttribute('placeholder') === 'Min') || inputs[0];
      if (minInput) await user.type(minInput, '5');

      await waitFor(() => {
        expect(screen.getByText('Apple')).toBeInTheDocument();
        expect(screen.queryByText('Banana')).not.toBeInTheDocument();
      });
    });

    it('should combine search and filters', async () => {
      const user = userEvent.setup();
      const data = createTestData(10);
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
        />,
        { wrapper: TestWrapper }
      );

      // Apply search
      const searchInput = screen.getByPlaceholderText(/Sök/i);
      await user.type(searchInput, 'Item');

      // Open and apply filter
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);
      const nameInput = screen.getByPlaceholderText(/Sök name/i);
      await user.type(nameInput, '1');

      await waitFor(() => {
        expect(screen.getByText('Item 1')).toBeInTheDocument();
      });
    });
  });

  describe('Sorting', () => {
    it('should sort ascending when clicking column header', async () => {
      const user = userEvent.setup();
      const data = [
        { id: 3, name: 'Zebra', value: 30, category: 'C', status: 'Active' },
        { id: 1, name: 'Apple', value: 10, category: 'A', status: 'Active' },
        { id: 2, name: 'Banana', value: 20, category: 'B', status: 'Active' },
      ];
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
          defaultSortKey="name"
        />,
        { wrapper: TestWrapper }
      );

      // Click name column to sort
      const nameHeader = screen.getByText('Name');
      await user.click(nameHeader);

      await waitFor(() => {
        const rows = screen.getAllByRole('row');
        // First data row should be Apple
        expect(rows[1]).toHaveTextContent('Apple');
      });
    });

    it('should toggle sort direction on second click', async () => {
      const user = userEvent.setup();
      const data = [
        { id: 1, name: 'Apple', value: 10, category: 'A', status: 'Active' },
        { id: 2, name: 'Banana', value: 20, category: 'B', status: 'Active' },
        { id: 3, name: 'Zebra', value: 30, category: 'C', status: 'Active' },
      ];
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
          defaultSortKey="name"
        />,
        { wrapper: TestWrapper }
      );

      const nameHeader = screen.getByText('Name');
      // Click twice to toggle
      await user.click(nameHeader);
      await user.click(nameHeader);

      await waitFor(() => {
        const rows = screen.getAllByRole('row');
        // Should be sorted descending (Zebra first)
        expect(rows[1]).toHaveTextContent('Zebra');
      });
    });
  });

  describe('Pagination', () => {
    it('should paginate large datasets', async () => {
      const user = userEvent.setup();
      const data = createTestData(150);
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
          enablePagination={true}
          itemsPerPage={50}
        />,
        { wrapper: TestWrapper }
      );

      // Should show first page
      expect(screen.getByText('Item 1')).toBeInTheDocument();
      
      // Navigate to next page
      const nextButton = screen.getByText(/Nästa|Next/i);
      if (nextButton) {
        await user.click(nextButton);
        
        await waitFor(() => {
          expect(screen.getByText('Item 51')).toBeInTheDocument();
        });
      }
    });

    it('should maintain filters when paginating', async () => {
      const user = userEvent.setup();
      const data = createTestData(150);
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
          enablePagination={true}
          itemsPerPage={50}
        />,
        { wrapper: TestWrapper }
      );

      // Apply search
      const searchInput = screen.getByPlaceholderText(/Sök/i);
      await user.type(searchInput, 'Item 1');

      // Navigate pages
      const nextButton = screen.getByText(/Nästa|Next/i);
      if (nextButton) {
        await user.click(nextButton);
        
        await waitFor(() => {
          // Should still show filtered results
          expect(screen.queryByText('Item 2')).not.toBeInTheDocument();
        });
      }
    });
  });

  describe('Column visibility', () => {
    it('should toggle column visibility', async () => {
      const user = userEvent.setup();
      const data = createTestData(5);
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
        />,
        { wrapper: TestWrapper }
      );

      // Open column visibility toggle
      const columnToggle = screen.getByLabelText(/Kolumnsynlighet|Column visibility/i) ||
        screen.getByTitle(/Kolumnsynlighet|Column visibility/i) ||
        screen.getAllByRole('button').find(btn => btn.textContent?.includes('Kolumn') || btn.textContent?.includes('Column'));
      
      if (columnToggle) {
        await user.click(columnToggle);
        
        // Try to find and toggle a column
        await waitFor(() => {
          // Column visibility should be accessible
          expect(columnToggle).toBeInTheDocument();
        });
      }
    });
  });

  describe('Loading and error states', () => {
    it('should show loading state', () => {
      render(
        <BaseTable
          data={[]}
          loading={true}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
        />,
        { wrapper: TestWrapper }
      );

      // Should show skeleton/loading state
      const table = screen.getByRole('table');
      expect(table).toBeInTheDocument();
    });

    it('should show error state', () => {
      render(
        <BaseTable
          data={[]}
          loading={false}
          error="Failed to load data"
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText(/error|Error/i)).toBeInTheDocument();
      expect(screen.getByText('Failed to load data')).toBeInTheDocument();
    });
  });

  describe('Sticky columns', () => {
    it('should render sticky columns', () => {
      const data = createTestData(5);
      
      render(
        <BaseTable
          data={data}
          loading={false}
          error={null}
          columns={mockColumns}
          filters={mockFilters}
          tableId="test-table"
          renderCell={renderCell}
          searchFields={['name', 'category']}
          stickyColumns={['id', 'name']}
        />,
        { wrapper: TestWrapper }
      );

      // Sticky columns should be rendered
      expect(screen.getByText('ID')).toBeInTheDocument();
      expect(screen.getByText('Name')).toBeInTheDocument();
    });
  });
});


```

## `src/components/__tests__/BenjaminGrahamTable.integration.test.tsx`

```tsx
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import EntryExitTable from '../EntryExitTable';
import { ThemeProvider } from '../../contexts/ThemeContext';
import { EntryExitProvider } from '../../contexts/EntryExitContext';
import {
  createMockBenjaminGrahamData,
  generateLargeBenjaminGrahamDataSet,
} from '../../test/helpers';
import { BenjaminGrahamData } from '../../types/stock';
import '../../i18n/config';

// Mock the EntryExitContext hook
vi.mock('../../contexts/EntryExitContext', async () => {
  const actual = await vi.importActual('../../contexts/EntryExitContext');
  return {
    ...actual,
    useEntryExitValues: () => ({
      getEntryExitValue: vi.fn(() => ({
        entry1: 100,
        entry2: 90,
        exit1: 150,
        exit2: 140,
        dateOfUpdate: '2024-01-01',
      })),
      setEntryExitValue: vi.fn(),
      initializeFromData: vi.fn(),
      entryExitValues: new Map(),
    }),
  };
});

// Test wrapper
function TestWrapper({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider>
      <EntryExitProvider>
        {children}
      </EntryExitProvider>
    </ThemeProvider>
  );
}

describe('EntryExitTable Integration Tests', () => {
  describe('Rendering', () => {
    it('should render with empty data', () => {
      render(
        <EntryExitTable
          data={[]}
          loading={false}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText(/Inga resultat|No data/i)).toBeInTheDocument();
    });

    it('should render with data', () => {
      const data: BenjaminGrahamData[] = [
        createMockBenjaminGrahamData({
          companyName: 'Test Company',
          ticker: 'TEST',
          price: 100,
          benjaminGraham: 90,
        }),
      ];

      render(
        <EntryExitTable
          data={data}
          loading={false}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('Test Company')).toBeInTheDocument();
      expect(screen.getByText('TEST')).toBeInTheDocument();
    });

    it('should render with large dataset', () => {
      const data = generateLargeBenjaminGrahamDataSet(150);

      render(
        <EntryExitTable
          data={data}
          loading={false}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('Company 1')).toBeInTheDocument();
    });
  });

  describe('Filter combinations', () => {
    it('should filter by price range', async () => {
      const user = userEvent.setup();
      const data: BenjaminGrahamData[] = [
        createMockBenjaminGrahamData({ ticker: 'TEST1', price: 50 }),
        createMockBenjaminGrahamData({ ticker: 'TEST2', price: 100 }),
        createMockBenjaminGrahamData({ ticker: 'TEST3', price: 200 }),
      ];

      render(
        <EntryExitTable
          data={data}
          loading={false}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Find price range inputs
      const inputs = screen.getAllByPlaceholderText(/Min|Max/i);
      const minInput = inputs.find(input => {
        const label = input.closest('div')?.querySelector('label')?.textContent;
        return label?.includes('Pris') || label?.includes('Price');
      }) || inputs[0];
      const maxInput = inputs[inputs.length - 1];

      if (minInput && maxInput) {
        await user.type(minInput, '75');
        await user.type(maxInput, '125');
      }

      await waitFor(() => {
        expect(screen.getByText('TEST2')).toBeInTheDocument();
        expect(screen.queryByText('TEST1')).not.toBeInTheDocument();
        expect(screen.queryByText('TEST3')).not.toBeInTheDocument();
      });
    });

    it('should filter by benjaminGraham range', async () => {
      const user = userEvent.setup();
      const data: BenjaminGrahamData[] = [
        createMockBenjaminGrahamData({ ticker: 'TEST1', benjaminGraham: 50 }),
        createMockBenjaminGrahamData({ ticker: 'TEST2', benjaminGraham: 100 }),
        createMockBenjaminGrahamData({ ticker: 'TEST3', benjaminGraham: 150 }),
      ];

      render(
        <EntryExitTable
          data={data}
          loading={false}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Find benjaminGraham range inputs
      const inputs = screen.getAllByPlaceholderText(/Min|Max/i);
      const bgInputs = inputs.filter(input => {
        const label = input.closest('div')?.querySelector('label')?.textContent;
        return label?.includes('Benjamin Graham');
      });

      if (bgInputs[0] && bgInputs[1]) {
        await user.type(bgInputs[0], '75');
        await user.type(bgInputs[1], '125');
      }

      await waitFor(() => {
        expect(screen.getByText('TEST2')).toBeInTheDocument();
      });
    });
  });

  describe('Sorting', () => {
    it('should sort by price', async () => {
      const user = userEvent.setup();
      const data: BenjaminGrahamData[] = [
        createMockBenjaminGrahamData({ ticker: 'TEST1', price: 200 }),
        createMockBenjaminGrahamData({ ticker: 'TEST2', price: 100 }),
        createMockBenjaminGrahamData({ ticker: 'TEST3', price: 50 }),
      ];

      render(
        <EntryExitTable
          data={data}
          loading={false}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      // Click price header
      const priceHeader = screen.getByText('Price');
      await user.click(priceHeader);

      await waitFor(() => {
        const rows = screen.getAllByRole('row');
        // Should be sorted ascending (50 first)
        expect(rows[1]).toHaveTextContent('TEST3');
      });
    });
  });

  describe('RR1/RR2 calculations', () => {
    it('should calculate and display RR1', () => {
      const data: BenjaminGrahamData[] = [
        createMockBenjaminGrahamData({
          ticker: 'TEST1',
          companyName: 'Test Company',
          price: 100,
        }),
      ];

      render(
        <EntryExitTable
          data={data}
          loading={false}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      // RR1 should be calculated and displayed
      expect(screen.getByText('TEST1')).toBeInTheDocument();
    });
  });

  describe('Loading and error states', () => {
    it('should show loading state', () => {
      render(
        <EntryExitTable
          data={[]}
          loading={true}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      const table = screen.getByRole('table');
      expect(table).toBeInTheDocument();
    });

    it('should show error state', () => {
      render(
        <EntryExitTable
          data={[]}
          loading={false}
          error="Failed to load data"
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText(/error|Error/i)).toBeInTheDocument();
      expect(screen.getByText('Failed to load data')).toBeInTheDocument();
    });
  });
});


```

## `src/components/__tests__/ErrorBoundary.test.tsx`

```tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { ErrorBoundary } from '../ErrorBoundary';
import i18n from '../../i18n/config';

// Mock i18n
vi.mock('../../i18n/config', () => ({
  default: {
    t: (key: string) => {
      const translations: Record<string, string> = {
        'errorBoundary.configurationError': 'Configuration Error',
        'errorBoundary.unknownError': 'An unknown error occurred',
        'errorBoundary.reloadPage': 'Reload Page',
      };
      return translations[key] || key;
    },
  },
}));

// Component that throws an error
function ThrowError({ shouldThrow }: { shouldThrow: boolean }) {
  if (shouldThrow) {
    throw new Error('Test error');
  }
  return <div>No error</div>;
}

describe('ErrorBoundary', () => {
  // Suppress console.error for error boundary tests
  const originalError = console.error;
  beforeAll(() => {
    console.error = vi.fn();
  });

  afterAll(() => {
    console.error = originalError;
  });

  it('should render children when there is no error', () => {
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    );

    expect(screen.getByText('No error')).toBeInTheDocument();
  });

  it('should render error UI when there is an error', () => {
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );

    expect(screen.getByText(/Configuration Error/i)).toBeInTheDocument();
  });

  it('should display error message', () => {
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );

    expect(screen.getByText(/Test error/i)).toBeInTheDocument();
  });

  it('should display reload button', () => {
    const reloadSpy = vi.spyOn(window.location, 'reload').mockImplementation(() => {});

    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );

    const reloadButton = screen.getByText(/Reload Page/i);
    expect(reloadButton).toBeInTheDocument();

    reloadSpy.mockRestore();
  });

  it('should handle Firebase configuration errors', () => {
    function ThrowFirebaseError() {
      throw new Error('Firebase configuration error');
    }

    render(
      <ErrorBoundary>
        <ThrowFirebaseError />
      </ErrorBoundary>
    );

    expect(screen.getByText(/Configuration Error/i)).toBeInTheDocument();
  });

  it('should handle provider context errors', () => {
    function ThrowProviderError() {
      throw new Error('useRefresh must be used within a RefreshProvider');
    }

    render(
      <ErrorBoundary>
        <ThrowProviderError />
      </ErrorBoundary>
    );

    expect(screen.getByText(/Configuration Error/i)).toBeInTheDocument();
  });

  it('should handle unknown errors', () => {
    function ThrowUnknownError() {
      throw new Error('Some other error');
    }

    render(
      <ErrorBoundary>
        <ThrowUnknownError />
      </ErrorBoundary>
    );

    expect(screen.getByText(/Configuration Error/i)).toBeInTheDocument();
  });

  it('should log errors to console', () => {
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );

    expect(consoleSpy).toHaveBeenCalled();

    consoleSpy.mockRestore();
  });
});

```

## `src/components/__tests__/PEIndustryTable.integration.test.tsx`

```tsx
import { describe, it, expect } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import PEIndustryTable from '../PEIndustryTable';
import { ThemeProvider } from '../../contexts/ThemeContext';
import { EntryExitProvider } from '../../contexts/EntryExitContext';
import {
  createMockPEIndustryData,
  generateLargePEIndustryDataSet,
} from '../../test/helpers';
import { PEIndustryData } from '../../types/stock';
import '../../i18n/config';

// Test wrapper
function TestWrapper({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider>
      <EntryExitProvider>
        {children}
      </EntryExitProvider>
    </ThemeProvider>
  );
}

describe('PEIndustryTable Integration Tests', () => {
  describe('Rendering', () => {
    it('should render with empty data', () => {
      render(
        <PEIndustryTable
          data={[]}
          loading={false}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText(/Inga resultat|No data/i)).toBeInTheDocument();
    });

    it('should render with data', () => {
      const data: PEIndustryData[] = [
        createMockPEIndustryData({
          industry: 'Technology',
          pe: 15,
          pe1: 20,
          pe2: 18,
          companyCount: 10,
        }),
      ];

      render(
        <PEIndustryTable
          data={data}
          loading={false}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('Technology')).toBeInTheDocument();
    });

    it('should render with large dataset', () => {
      const data = generateLargePEIndustryDataSet(50);

      render(
        <PEIndustryTable
          data={data}
          loading={false}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('Technology 1')).toBeInTheDocument();
    });
  });

  describe('Filtering', () => {
    it('should filter by industry', async () => {
      const user = userEvent.setup();
      const data: PEIndustryData[] = [
        createMockPEIndustryData({ industry: 'Technology', pe: 15 }),
        createMockPEIndustryData({ industry: 'Finance', pe: 20 }),
      ];

      render(
        <PEIndustryTable
          data={data}
          loading={false}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Find industry select
      const selects = screen.getAllByRole('combobox');
      const industrySelect = selects.find(select =>
        select.closest('div')?.textContent?.includes('Industri') || 
        select.closest('div')?.textContent?.includes('Industry')
      ) || selects[0];

      if (industrySelect) {
        await user.selectOptions(industrySelect, 'Technology');
      }

      await waitFor(() => {
        expect(screen.getByText('Technology')).toBeInTheDocument();
        expect(screen.queryByText('Finance')).not.toBeInTheDocument();
      });
    });
  });

  describe('Sorting', () => {
    it('should sort by P/E values', async () => {
      const user = userEvent.setup();
      const data: PEIndustryData[] = [
        createMockPEIndustryData({ industry: 'Industry 1', pe: 30 }),
        createMockPEIndustryData({ industry: 'Industry 2', pe: 10 }),
        createMockPEIndustryData({ industry: 'Industry 3', pe: 20 }),
      ];

      render(
        <PEIndustryTable
          data={data}
          loading={false}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      // Click P/E header
      const peHeader = screen.getByText('P/E INDUSTRY');
      await user.click(peHeader);

      await waitFor(() => {
        const rows = screen.getAllByRole('row');
        // Should be sorted ascending (10 first)
        expect(rows[1]).toHaveTextContent('Industry 2');
      });
    });
  });

  describe('Loading and error states', () => {
    it('should show loading state', () => {
      render(
        <PEIndustryTable
          data={[]}
          loading={true}
          error={null}
        />,
        { wrapper: TestWrapper }
      );

      const table = screen.getByRole('table');
      expect(table).toBeInTheDocument();
    });

    it('should show error state', () => {
      render(
        <PEIndustryTable
          data={[]}
          loading={false}
          error="Failed to load data"
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText(/error|Error/i)).toBeInTheDocument();
      expect(screen.getByText('Failed to load data')).toBeInTheDocument();
    });
  });
});


```

## `src/components/__tests__/ScoreBoardTable.colorLogic.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import {
  getCurrentRatioColor,
  getCashSdebtColor,
  getRo40Color,
  getIRRColor,
  getLeverageF2Color,
  getTBSPPriceColor,
  getSMAColor,
  colorTypeToCssClass,
  COLORS,
} from '../../utils/colorThresholds';
import type { ColorType } from '../../utils/colorThresholds';
import { ThresholdIndustryData } from '../../types/stock';
import { createMockThresholdData } from '../../test/helpers';

describe('Color Logic Functions (ScoreBoardTable integration)', () => {
  const mockThresholdData: ThresholdIndustryData[] = [
    createMockThresholdData({
      industry: 'Test Industry',
      irr: 25,
      leverageF2Min: 2.0,
      leverageF2Max: 3.0,
      ro40Min: 0.15,
      ro40Max: 0.25,
      cashSdebtMin: 0.7,
      cashSdebtMax: 1.2,
      currentRatioMin: 1.1,
      currentRatioMax: 2.0,
    }),
  ];

  const toCss = (color: ColorType, opts?: { orangeVariant?: 'blue' | 'yellow' }) =>
    colorTypeToCssClass(color, opts);

  describe('getCurrentRatioColor', () => {
    it('should return green for value >= min && < max', () => {
      expect(toCss(getCurrentRatioColor(1.5, 'Test Industry', mockThresholdData))).toBe(COLORS.green);
      expect(toCss(getCurrentRatioColor(1.1, 'Test Industry', mockThresholdData))).toBe(COLORS.green);
      expect(toCss(getCurrentRatioColor(1.99, 'Test Industry', mockThresholdData))).toBe(COLORS.green);
    });

    it('should return red for value < min', () => {
      expect(toCss(getCurrentRatioColor(0.8, 'Test Industry', mockThresholdData))).toBe(COLORS.red);
      expect(toCss(getCurrentRatioColor(0.5, 'Test Industry', mockThresholdData))).toBe(COLORS.red);
    });

    it('should return blue (ORANGE) for value >= max', () => {
      expect(toCss(getCurrentRatioColor(2.0, 'Test Industry', mockThresholdData))).toBe(COLORS.blue);
      expect(toCss(getCurrentRatioColor(2.5, 'Test Industry', mockThresholdData))).toBe(COLORS.blue);
    });

    it('should return null for null value', () => {
      expect(toCss(getCurrentRatioColor(null, 'Test Industry', mockThresholdData))).toBeNull();
    });
  });

  describe('getCashSdebtColor', () => {
    it('should return green for isDivZero = true', () => {
      expect(toCss(getCashSdebtColor(null, true, 'Test Industry', mockThresholdData))).toBe(COLORS.green);
    });

    it('should return green for value >= max', () => {
      expect(toCss(getCashSdebtColor(1.2, false, 'Test Industry', mockThresholdData))).toBe(COLORS.green);
      expect(toCss(getCashSdebtColor(1.5, false, 'Test Industry', mockThresholdData))).toBe(COLORS.green);
    });

    it('should return red for value <= min', () => {
      expect(toCss(getCashSdebtColor(0.7, false, 'Test Industry', mockThresholdData))).toBe(COLORS.red);
      expect(toCss(getCashSdebtColor(0.5, false, 'Test Industry', mockThresholdData))).toBe(COLORS.red);
    });

    it('should return blue for value between min and max', () => {
      expect(toCss(getCashSdebtColor(0.9, false, 'Test Industry', mockThresholdData))).toBe(COLORS.blue);
      expect(toCss(getCashSdebtColor(1.0, false, 'Test Industry', mockThresholdData))).toBe(COLORS.blue);
    });

    it('should return null for null value when isDivZero is false', () => {
      expect(toCss(getCashSdebtColor(null, false, 'Test Industry', mockThresholdData))).toBeNull();
    });
  });

  describe('getRo40Color', () => {
    it('should transform percentage to decimal and return green for >= max', () => {
      expect(toCss(getRo40Color(30, 'Test Industry', mockThresholdData))).toBe(COLORS.green);
    });

    it('should transform percentage to decimal and return red for <= min', () => {
      expect(toCss(getRo40Color(10, 'Test Industry', mockThresholdData))).toBe(COLORS.red);
    });

    it('should transform percentage to decimal and return blue for between min and max', () => {
      expect(toCss(getRo40Color(20, 'Test Industry', mockThresholdData))).toBe(COLORS.blue);
    });

    it('should return null for null value', () => {
      expect(toCss(getRo40Color(null, 'Test Industry', mockThresholdData))).toBeNull();
    });
  });

  describe('getIRRColor', () => {
    it('should return green for value >= threshold', () => {
      expect(toCss(getIRRColor(30, 'Test Industry', mockThresholdData))).toBe(COLORS.green);
      expect(toCss(getIRRColor(25, 'Test Industry', mockThresholdData))).toBe(COLORS.green);
    });

    it('should return red for value < threshold', () => {
      expect(toCss(getIRRColor(20, 'Test Industry', mockThresholdData))).toBe(COLORS.red);
    });

    it('should return null for null value', () => {
      expect(toCss(getIRRColor(null, 'Test Industry', mockThresholdData))).toBeNull();
    });
  });

  describe('getLeverageF2Color', () => {
    it('should return green for value <= min (inverted)', () => {
      expect(toCss(getLeverageF2Color(2.0, 'Test Industry', mockThresholdData))).toBe(COLORS.green);
      expect(toCss(getLeverageF2Color(1.5, 'Test Industry', mockThresholdData))).toBe(COLORS.green);
    });

    it('should return blue for value <= max (inverted)', () => {
      expect(toCss(getLeverageF2Color(3.0, 'Test Industry', mockThresholdData))).toBe(COLORS.blue);
      expect(toCss(getLeverageF2Color(2.5, 'Test Industry', mockThresholdData))).toBe(COLORS.blue);
    });

    it('should return red for value > max (inverted)', () => {
      expect(toCss(getLeverageF2Color(3.5, 'Test Industry', mockThresholdData))).toBe(COLORS.red);
    });

    it('should return null for null value', () => {
      expect(toCss(getLeverageF2Color(null, 'Test Industry', mockThresholdData))).toBeNull();
    });
  });

  describe('getTBSPPriceColor', () => {
    it('should return green for value >= 1.00', () => {
      expect(toCss(getTBSPPriceColor(1.0))).toBe(COLORS.green);
      expect(toCss(getTBSPPriceColor(1.5))).toBe(COLORS.green);
    });

    it('should return red for value < 1.00', () => {
      expect(toCss(getTBSPPriceColor(0.9))).toBe(COLORS.red);
      expect(toCss(getTBSPPriceColor(0.5))).toBe(COLORS.red);
    });

    it('should return null for null value', () => {
      expect(toCss(getTBSPPriceColor(null))).toBeNull();
    });
  });

  describe('getSMAColor', () => {
    it('should return green when price > smaValue', () => {
      expect(toCss(getSMAColor(100, 90))).toBe(COLORS.green);
    });

    it('should return red when price < smaValue', () => {
      expect(toCss(getSMAColor(80, 90))).toBe(COLORS.red);
    });

    it('should return yellow when price === smaValue (orangeVariant yellow)', () => {
      expect(colorTypeToCssClass(getSMAColor(100, 100), { orangeVariant: 'yellow' })).toBe(COLORS.yellow);
    });

    it('should return null when price is null', () => {
      expect(toCss(getSMAColor(null, 90))).toBeNull();
    });

    it('should return null when smaValue is null', () => {
      expect(toCss(getSMAColor(100, null))).toBeNull();
    });

    it('should return null when both are null', () => {
      expect(toCss(getSMAColor(null, null))).toBeNull();
    });

    it('should return null when price is undefined', () => {
      expect(toCss(getSMAColor(undefined, 90))).toBeNull();
    });
  });
});

```

## `src/components/__tests__/ScoreBoardTable.integration.test.tsx`

```tsx
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen, within, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ScoreBoardTable from '../ScoreBoardTable';
import { ThemeProvider } from '../../contexts/ThemeContext';
import { EntryExitProvider } from '../../contexts/EntryExitContext';
import {
  createMockScoreBoardData,
  createMockThresholdData,
  createMockBenjaminGrahamData,
  createMockEntryExitValues,
  generateLargeScoreBoardDataSet,
  generateEdgeCaseScoreBoardData,
} from '../../test/helpers';
import { ScoreBoardData, ThresholdIndustryData, BenjaminGrahamData } from '../../types/stock';
import '../../i18n/config';

// Mock the hooks
vi.mock('../../hooks/useBenjaminGrahamData', () => ({
  useBenjaminGrahamData: vi.fn(),
}));

import { useBenjaminGrahamData } from '../../hooks/useBenjaminGrahamData';

// Test wrapper
function TestWrapper({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider>
      <EntryExitProvider>
        {children}
      </EntryExitProvider>
    </ThemeProvider>
  );
}

describe('ScoreBoardTable Integration Tests', () => {
  const mockBenjaminGrahamData: BenjaminGrahamData[] = [
    createMockBenjaminGrahamData({ ticker: 'TEST1', companyName: 'Test Company 1', price: 100 }),
    createMockBenjaminGrahamData({ ticker: 'TEST2', companyName: 'Test Company 2', price: 150 }),
  ];

  const mockThresholdData: ThresholdIndustryData[] = [
    createMockThresholdData({ industry: 'Technology', irr: 25 }),
    createMockThresholdData({ industry: 'Finance', irr: 20 }),
  ];

  beforeEach(() => {
    vi.mocked(useBenjaminGrahamData).mockReturnValue({
      data: mockBenjaminGrahamData,
      loading: false,
      error: null,
      lastUpdated: new Date(),
      refetch: vi.fn(),
    });
  });

  describe('Rendering with different data', () => {
    it('should render with empty data', () => {
      render(
        <ScoreBoardTable
          data={[]}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText(/Inga resultat|No data/i)).toBeInTheDocument();
    });

    it('should render with single row', () => {
      const data = [
        createMockScoreBoardData({
          companyName: 'Test Company',
          ticker: 'TEST',
          industry: 'Technology',
        }),
      ];

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('Test Company')).toBeInTheDocument();
      expect(screen.getByText('TEST')).toBeInTheDocument();
    });

    it('should render with large dataset', () => {
      const data = generateLargeScoreBoardDataSet(150);

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('Company 1')).toBeInTheDocument();
      // Should show pagination
      expect(screen.getByText(/Visar/i)).toBeInTheDocument();
    });
  });

  describe('Filter combinations', () => {
    it('should filter by company name', async () => {
      const user = userEvent.setup();
      const data = [
        createMockScoreBoardData({ companyName: 'Apple Inc', ticker: 'AAPL', industry: 'Technology' }),
        createMockScoreBoardData({ companyName: 'Microsoft Corp', ticker: 'MSFT', industry: 'Technology' }),
      ];

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Find and fill company name filter
      const nameInput = screen.getByPlaceholderText(/Sök företagsnamn/i);
      await user.type(nameInput, 'Apple');

      await waitFor(() => {
        expect(screen.getByText('Apple Inc')).toBeInTheDocument();
        expect(screen.queryByText('Microsoft Corp')).not.toBeInTheDocument();
      });
    });

    it('should filter by industry select', async () => {
      const user = userEvent.setup();
      const data = [
        createMockScoreBoardData({ companyName: 'Tech Company', ticker: 'TECH', industry: 'Technology' }),
        createMockScoreBoardData({ companyName: 'Finance Company', ticker: 'FIN', industry: 'Finance' }),
      ];

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Find industry select
      const selects = screen.getAllByRole('combobox');
      const industrySelect = selects.find(select =>
        select.closest('div')?.textContent?.includes('Industri')
      ) || selects[0];

      if (industrySelect) {
        await user.selectOptions(industrySelect, 'Technology');
      }

      await waitFor(() => {
        expect(screen.getByText('Tech Company')).toBeInTheDocument();
        expect(screen.queryByText('Finance Company')).not.toBeInTheDocument();
      });
    });

    it('should filter by IRR range', async () => {
      const user = userEvent.setup();
      const data = [
        createMockScoreBoardData({ ticker: 'TEST1', irr: 15, industry: 'Technology' }),
        createMockScoreBoardData({ ticker: 'TEST2', irr: 30, industry: 'Technology' }),
        createMockScoreBoardData({ ticker: 'TEST3', irr: 45, industry: 'Technology' }),
      ];

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Find IRR range inputs
      const inputs = screen.getAllByPlaceholderText(/Min|Max/i);
      const minInput = inputs.find(input => {
        const label = input.closest('div')?.querySelector('label')?.textContent;
        return label?.includes('IRR');
      }) || inputs[0];
      const maxInput = inputs[inputs.length - 1];

      if (minInput && maxInput) {
        await user.type(minInput, '20');
        await user.type(maxInput, '40');
      }

      await waitFor(() => {
        expect(screen.getByText('TEST2')).toBeInTheDocument();
        expect(screen.queryByText('TEST1')).not.toBeInTheDocument();
        expect(screen.queryByText('TEST3')).not.toBeInTheDocument();
      });
    });

    it('should combine multiple filters', async () => {
      const user = userEvent.setup();
      const data = [
        createMockScoreBoardData({
          companyName: 'Tech Corp',
          ticker: 'TECH',
          industry: 'Technology',
          irr: 25,
          mungerQualityScore: 60,
        }),
        createMockScoreBoardData({
          companyName: 'Tech Inc',
          ticker: 'TINC',
          industry: 'Technology',
          irr: 15,
          mungerQualityScore: 40,
        }),
        createMockScoreBoardData({
          companyName: 'Finance Corp',
          ticker: 'FIN',
          industry: 'Finance',
          irr: 25,
          mungerQualityScore: 60,
        }),
      ];

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Apply industry filter
      const selects = screen.getAllByRole('combobox');
      const industrySelect = selects.find(select =>
        select.closest('div')?.textContent?.includes('Industri')
      );
      if (industrySelect) {
        await user.selectOptions(industrySelect, 'Technology');
      }

      // Apply IRR range
      const inputs = screen.getAllByPlaceholderText(/Min|Max/i);
      const irrInputs = inputs.filter(input => {
        const label = input.closest('div')?.querySelector('label')?.textContent;
        return label?.includes('IRR');
      });
      if (irrInputs[0]) await user.type(irrInputs[0], '20');
      if (irrInputs[1]) await user.type(irrInputs[1], '30');

      await waitFor(() => {
        expect(screen.getByText('Tech Corp')).toBeInTheDocument();
        expect(screen.queryByText('Tech Inc')).not.toBeInTheDocument();
        expect(screen.queryByText('Finance Corp')).not.toBeInTheDocument();
      });
    });

    it('should combine search and filters', async () => {
      const user = userEvent.setup();
      const data = [
        createMockScoreBoardData({ companyName: 'Apple Inc', ticker: 'AAPL', industry: 'Technology' }),
        createMockScoreBoardData({ companyName: 'Apple Finance', ticker: 'APLF', industry: 'Finance' }),
      ];

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      // Apply search
      const searchInput = screen.getByPlaceholderText(/Sök/i);
      await user.type(searchInput, 'Apple');

      // Open and apply industry filter
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      const selects = screen.getAllByRole('combobox');
      const industrySelect = selects.find(select =>
        select.closest('div')?.textContent?.includes('Industri')
      );
      if (industrySelect) {
        await user.selectOptions(industrySelect, 'Technology');
      }

      await waitFor(() => {
        expect(screen.getByText('Apple Inc')).toBeInTheDocument();
        expect(screen.queryByText('Apple Finance')).not.toBeInTheDocument();
      });
    });
  });

  describe('Sorting', () => {
    it('should sort by company name', async () => {
      const user = userEvent.setup();
      const data = [
        createMockScoreBoardData({ companyName: 'Zebra Corp', ticker: 'ZEB' }),
        createMockScoreBoardData({ companyName: 'Apple Inc', ticker: 'AAPL' }),
        createMockScoreBoardData({ companyName: 'Microsoft Corp', ticker: 'MSFT' }),
      ];

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      // Click company name header
      const nameHeader = screen.getByText('Company Name');
      await user.click(nameHeader);

      await waitFor(() => {
        const rows = screen.getAllByRole('row');
        expect(rows[1]).toHaveTextContent('Apple Inc');
      });
    });

    it('should sort by IRR', async () => {
      const user = userEvent.setup();
      const data = [
        createMockScoreBoardData({ ticker: 'TEST1', irr: 30, industry: 'Technology' }),
        createMockScoreBoardData({ ticker: 'TEST2', irr: 10, industry: 'Technology' }),
        createMockScoreBoardData({ ticker: 'TEST3', irr: 50, industry: 'Technology' }),
      ];

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      // Click IRR header
      const irrHeader = screen.getByText('IRR');
      await user.click(irrHeader);

      await waitFor(() => {
        const rows = screen.getAllByRole('row');
        // Should be sorted ascending (10% first)
        expect(rows[1]).toHaveTextContent('TEST2');
      });
    });
  });

  describe('Color coding based on threshold data', () => {
    it('should apply color coding for IRR based on threshold', () => {
      const data = [
        createMockScoreBoardData({
          ticker: 'TEST1',
          irr: 30, // Above threshold (25)
          industry: 'Technology',
        }),
        createMockScoreBoardData({
          ticker: 'TEST2',
          irr: 15, // Below threshold (25)
          industry: 'Technology',
        }),
      ];

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      // Colors are applied via CSS classes, check that cells are rendered
      expect(screen.getByText('30%')).toBeInTheDocument();
      expect(screen.getByText('15%')).toBeInTheDocument();
    });

    it('should handle missing threshold data gracefully', () => {
      const data = [
        createMockScoreBoardData({
          ticker: 'TEST1',
          irr: 30,
          industry: 'Unknown Industry',
        }),
      ];

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      // Should still render without errors
      expect(screen.getByText('TEST1')).toBeInTheDocument();
    });
  });

  describe('TheoEntry logic', () => {
    it('should show B when conditions are met', () => {
      const data = [
        createMockScoreBoardData({
          ticker: 'TEST1',
          companyName: 'Test Company 1',
          industry: 'Technology',
        }),
      ];

      // Mock EntryExit values that meet conditions
      const entryExitMap = new Map();
      entryExitMap.set('TEST1-Test Company 1', {
        entry1: 100,
        exit1: 160, // RR1 = 60%
        entry2: 0,
        exit2: 0,
        dateOfUpdate: '2024-01-01',
      });

      vi.mocked(useBenjaminGrahamData).mockReturnValue({
        data: [createMockBenjaminGrahamData({ ticker: 'TEST1', companyName: 'Test Company 1', price: 100 })],
        loading: false,
        error: null,
        lastUpdated: new Date(),
        refetch: vi.fn(),
      });

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      // TheoEntry should show B when conditions are met
      // This depends on the actual implementation logic
      expect(screen.getByText('TEST1')).toBeInTheDocument();
    });
  });

  describe('Edge cases', () => {
    it('should handle edge case data', () => {
      const data = generateEdgeCaseScoreBoardData();

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      // Should render without errors
      expect(screen.getByText('Null Company')).toBeInTheDocument();
    });

    it('should handle empty threshold data', () => {
      const data = [
        createMockScoreBoardData({
          ticker: 'TEST1',
          irr: 30,
          industry: 'Technology',
        }),
      ];

      render(
        <ScoreBoardTable
          data={data}
          loading={false}
          error={null}
          thresholdData={[]}
        />,
        { wrapper: TestWrapper }
      );

      // Should render without errors
      expect(screen.getByText('TEST1')).toBeInTheDocument();
    });

    it('should handle loading state', () => {
      render(
        <ScoreBoardTable
          data={[]}
          loading={true}
          error={null}
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      // Should show loading state
      const table = screen.getByRole('table');
      expect(table).toBeInTheDocument();
    });

    it('should handle error state', () => {
      render(
        <ScoreBoardTable
          data={[]}
          loading={false}
          error="Failed to load data"
          thresholdData={mockThresholdData}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText(/error|Error/i)).toBeInTheDocument();
      expect(screen.getByText('Failed to load data')).toBeInTheDocument();
    });
  });
});


```

## `src/components/__tests__/ScoreTable.integration.test.tsx`

```tsx
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ScoreTable from '../ScoreTable';
import { ThemeProvider } from '../../contexts/ThemeContext';
import { EntryExitProvider } from '../../contexts/EntryExitContext';
import {
  createMockScoreData,
  createMockScoreBoardData,
  createMockThresholdData,
  createMockBenjaminGrahamData,
  generateLargeScoreDataSet,
} from '../../test/helpers';
import { ScoreData } from '../views/ScoreView';
import { ThresholdIndustryData, BenjaminGrahamData } from '../../types/stock';
import { EntryExitValues } from '../../contexts/EntryExitContext';
import '../../i18n/config';

// Test wrapper
function TestWrapper({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider>
      <EntryExitProvider>
        {children}
      </EntryExitProvider>
    </ThemeProvider>
  );
}

describe('ScoreTable Integration Tests', () => {
  const mockThresholdData: ThresholdIndustryData[] = [
    createMockThresholdData({ industry: 'Technology' }),
  ];

  const mockBenjaminGrahamData: BenjaminGrahamData[] = [
    createMockBenjaminGrahamData({ ticker: 'TEST1', companyName: 'Test Company 1' }),
  ];

  const mockEntryExitValues = new Map<string, EntryExitValues>();

  describe('Rendering', () => {
    it('should render with empty data', () => {
      render(
        <ScoreTable
          data={[]}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
          benjaminGrahamData={mockBenjaminGrahamData}
          entryExitValues={mockEntryExitValues}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText(/Inga resultat|No data/i)).toBeInTheDocument();
    });

    it('should render with score data', () => {
      const data: ScoreData[] = [
        createMockScoreData({
          companyName: 'Test Company',
          ticker: 'TEST',
          score: 75,
        }),
      ];

      render(
        <ScoreTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
          benjaminGrahamData={mockBenjaminGrahamData}
          entryExitValues={mockEntryExitValues}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('Test Company')).toBeInTheDocument();
      expect(screen.getByText('TEST')).toBeInTheDocument();
      expect(screen.getByText('75.0')).toBeInTheDocument();
    });

    it('should render with large dataset', () => {
      const data = generateLargeScoreDataSet(150);

      render(
        <ScoreTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
          benjaminGrahamData={mockBenjaminGrahamData}
          entryExitValues={mockEntryExitValues}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('Company 1')).toBeInTheDocument();
    });
  });

  describe('Score filtering', () => {
    it('should filter by score range', async () => {
      const user = userEvent.setup();
      const data: ScoreData[] = [
        createMockScoreData({ ticker: 'TEST1', score: 30 }),
        createMockScoreData({ ticker: 'TEST2', score: 60 }),
        createMockScoreData({ ticker: 'TEST3', score: 90 }),
      ];

      render(
        <ScoreTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
          benjaminGrahamData={mockBenjaminGrahamData}
          entryExitValues={mockEntryExitValues}
        />,
        { wrapper: TestWrapper }
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Find score range inputs
      const inputs = screen.getAllByPlaceholderText(/Min|Max/i);
      const minInput = inputs.find(input => {
        const label = input.closest('div')?.querySelector('label')?.textContent;
        return label?.includes('Score');
      }) || inputs[0];
      const maxInput = inputs[inputs.length - 1];

      if (minInput && maxInput) {
        await user.type(minInput, '50');
        await user.type(maxInput, '70');
      }

      await waitFor(() => {
        expect(screen.getByText('TEST2')).toBeInTheDocument();
        expect(screen.queryByText('TEST1')).not.toBeInTheDocument();
        expect(screen.queryByText('TEST3')).not.toBeInTheDocument();
      });
    });
  });

  describe('Score color coding', () => {
    it('should apply green color for high scores (>= 75)', () => {
      const data: ScoreData[] = [
        createMockScoreData({ ticker: 'TEST1', score: 80 }),
        createMockScoreData({ ticker: 'TEST2', score: 75 }),
      ];

      render(
        <ScoreTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
          benjaminGrahamData={mockBenjaminGrahamData}
          entryExitValues={mockEntryExitValues}
        />,
        { wrapper: TestWrapper }
      );

      // Check that scores are rendered (color is applied via CSS classes)
      expect(screen.getByText('80.0')).toBeInTheDocument();
      expect(screen.getByText('75.0')).toBeInTheDocument();
    });

    it('should apply blue color for medium scores (45-74)', () => {
      const data: ScoreData[] = [
        createMockScoreData({ ticker: 'TEST1', score: 60 }),
        createMockScoreData({ ticker: 'TEST2', score: 45 }),
      ];

      render(
        <ScoreTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
          benjaminGrahamData={mockBenjaminGrahamData}
          entryExitValues={mockEntryExitValues}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('60.0')).toBeInTheDocument();
      expect(screen.getByText('45.0')).toBeInTheDocument();
    });

    it('should apply gray color for low scores (< 45)', () => {
      const data: ScoreData[] = [
        createMockScoreData({ ticker: 'TEST1', score: 30 }),
        createMockScoreData({ ticker: 'TEST2', score: 0 }),
      ];

      render(
        <ScoreTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
          benjaminGrahamData={mockBenjaminGrahamData}
          entryExitValues={mockEntryExitValues}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText('30.0')).toBeInTheDocument();
      expect(screen.getByText('0.0')).toBeInTheDocument();
    });
  });

  describe('Sorting', () => {
    it('should sort by score', async () => {
      const user = userEvent.setup();
      const data: ScoreData[] = [
        createMockScoreData({ ticker: 'TEST1', score: 30 }),
        createMockScoreData({ ticker: 'TEST2', score: 60 }),
        createMockScoreData({ ticker: 'TEST3', score: 90 }),
      ];

      render(
        <ScoreTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
          benjaminGrahamData={mockBenjaminGrahamData}
          entryExitValues={mockEntryExitValues}
        />,
        { wrapper: TestWrapper }
      );

      // Click score header
      const scoreHeader = screen.getByText('Score');
      await user.click(scoreHeader);

      await waitFor(() => {
        const rows = screen.getAllByRole('row');
        // Should be sorted ascending (30 first)
        expect(rows[1]).toHaveTextContent('TEST1');
      });
    });
  });

  describe('ScoreBreakdownTooltip integration', () => {
    it('should render score with tooltip', () => {
      const data: ScoreData[] = [
        createMockScoreData({
          ticker: 'TEST1',
          score: 75,
          scoreBoardData: createMockScoreBoardData({ ticker: 'TEST1' }),
        }),
      ];

      render(
        <ScoreTable
          data={data}
          loading={false}
          error={null}
          thresholdData={mockThresholdData}
          benjaminGrahamData={mockBenjaminGrahamData}
          entryExitValues={mockEntryExitValues}
        />,
        { wrapper: TestWrapper }
      );

      // Score should be rendered (tooltip is interactive)
      expect(screen.getByText('75.0')).toBeInTheDocument();
    });
  });

  describe('Loading and error states', () => {
    it('should show loading state', () => {
      render(
        <ScoreTable
          data={[]}
          loading={true}
          error={null}
          thresholdData={mockThresholdData}
          benjaminGrahamData={mockBenjaminGrahamData}
          entryExitValues={mockEntryExitValues}
        />,
        { wrapper: TestWrapper }
      );

      const table = screen.getByRole('table');
      expect(table).toBeInTheDocument();
    });

    it('should show error state', () => {
      render(
        <ScoreTable
          data={[]}
          loading={false}
          error="Failed to load data"
          thresholdData={mockThresholdData}
          benjaminGrahamData={mockBenjaminGrahamData}
          entryExitValues={mockEntryExitValues}
        />,
        { wrapper: TestWrapper }
      );

      expect(screen.getByText(/error|Error/i)).toBeInTheDocument();
      expect(screen.getByText('Failed to load data')).toBeInTheDocument();
    });
  });
});


```

## `src/components/__tests__/snapshots/AdvancedFilters.snapshot.test.tsx`

```tsx
import { describe, it, expect } from 'vitest';
import { renderWithProviders } from '../../../test/helpers/renderHelpers';
import AdvancedFilters, { FilterConfig } from '../AdvancedFilters';

describe('AdvancedFilters Snapshot', () => {
  const mockFilters: FilterConfig[] = [
    { key: 'companyName', label: 'Company Name', type: 'text' },
    { key: 'score', label: 'Score', type: 'numberRange', min: 0, max: 100 },
    { key: 'industry', label: 'Industry', type: 'select', options: [
      { value: 'Technology', label: 'Technology' },
      { value: 'Finance', label: 'Finance' },
    ]},
  ];

  const mockValues = {
    companyName: 'Test',
    score: { min: 50, max: 100 },
    industry: 'Technology',
  };

  it('should match snapshot when closed', () => {
    const { container } = renderWithProviders(
      <AdvancedFilters
        filters={mockFilters}
        values={mockValues}
        onChange={() => {}}
        onClear={() => {}}
        tableId="test-table"
      />
    );

    expect(container.firstChild).toMatchSnapshot();
  });
});

```

## `src/components/__tests__/snapshots/Header.snapshot.test.tsx`

```tsx
import { describe, it, expect } from 'vitest';
import { renderWithProviders } from '../../../test/helpers/renderHelpers';
import Header from '../Header';

describe('Header Snapshot', () => {
  it('should match snapshot', () => {
    const { container } = renderWithProviders(
      <Header
        onMenuToggle={() => {}}
        isMenuOpen={false}
        onNavigate={() => {}}
        onOpenUserProfile={() => {}}
      />
    );

    expect(container.firstChild).toMatchSnapshot();
  });

  it('should match snapshot with menu open', () => {
    const { container } = renderWithProviders(
      <Header
        onMenuToggle={() => {}}
        isMenuOpen={true}
        onNavigate={() => {}}
        onOpenUserProfile={() => {}}
      />
    );

    expect(container.firstChild).toMatchSnapshot();
  });
});

```

## `src/components/__tests__/snapshots/ScoreBoardTable.snapshot.test.tsx`

```tsx
import { describe, it, expect } from 'vitest';
import { render } from '@testing-library/react';
import ScoreBoardTable from '../ScoreBoardTable';
import { createMockScoreBoardData } from '../../../test/helpers';
import { renderWithProviders } from '../../../test/helpers/renderHelpers';

describe('ScoreBoardTable Snapshot', () => {
  const mockData = [
    createMockScoreBoardData({ companyName: 'Company A', ticker: 'A', score: 75 }),
    createMockScoreBoardData({ companyName: 'Company B', ticker: 'B', score: 80 }),
  ];

  it('should match snapshot', () => {
    const { container } = renderWithProviders(
      <ScoreBoardTable data={mockData} loading={false} error={null} />
    );

    expect(container.firstChild).toMatchSnapshot();
  });

  it('should match snapshot when loading', () => {
    const { container } = renderWithProviders(
      <ScoreBoardTable data={[]} loading={true} error={null} />
    );

    expect(container.firstChild).toMatchSnapshot();
  });

  it('should match snapshot with error', () => {
    const { container } = renderWithProviders(
      <ScoreBoardTable data={[]} loading={false} error="Error message" />
    );

    expect(container.firstChild).toMatchSnapshot();
  });
});

```

## `src/components/__tests__/snapshots/Sidebar.snapshot.test.tsx`

```tsx
import { describe, it, expect } from 'vitest';
import { renderWithProviders } from '../../../test/helpers/renderHelpers';
import Sidebar from '../Sidebar';

describe('Sidebar Snapshot', () => {
  it('should match snapshot', () => {
    const { container } = renderWithProviders(
      <Sidebar
        activeView="score"
        onViewChange={() => {}}
        onOpenConditionsModal={() => {}}
        isOpen={true}
        onClose={() => {}}
      />
    );

    expect(container.firstChild).toMatchSnapshot();
  });

  it('should match snapshot when closed', () => {
    const { container } = renderWithProviders(
      <Sidebar
        activeView="score"
        onViewChange={() => {}}
        onOpenConditionsModal={() => {}}
        isOpen={false}
        onClose={() => {}}
      />
    );

    expect(container.firstChild).toMatchSnapshot();
  });
});

```

## `src/components/__tests__/ThresholdIndustryTable.integration.test.tsx`

```tsx
import { describe, it, expect } from 'vitest';
import { screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ThresholdIndustryTable from '../ThresholdIndustryTable';
import { renderWithAuth } from '../../test/helpers/renderHelpers';
import {
  createMockThresholdData,
  generateLargeThresholdDataSet,
} from '../../test/helpers';
import { ThresholdIndustryData } from '../../types/stock';
import '../../i18n/config';

// renderWithAuth provides all providers and defaults to admin role for editable threshold table

describe('ThresholdIndustryTable Integration Tests', () => {
  describe('Rendering', () => {
    it('should render with empty data', () => {
renderWithAuth(
          <ThresholdIndustryTable
            data={[]}
            loading={false}
            error={null}
          />
        );

      expect(screen.getByText(/Inga resultat|No data/i)).toBeInTheDocument();
    });

    it('should render with data', () => {
      const data: ThresholdIndustryData[] = [
        createMockThresholdData({
          industry: 'Technology',
          irr: 25,
          leverageF2Min: 2.0,
          leverageF2Max: 3.0,
          ro40Min: 0.15,
          ro40Max: 0.25,
          cashSdebtMin: 0.7,
          cashSdebtMax: 1.2,
          currentRatioMin: 1.1,
          currentRatioMax: 2.0,
        }),
      ];

      renderWithAuth(
        <ThresholdIndustryTable
          data={data}
          loading={false}
          error={null}
        />,
      );

      expect(screen.getByText('Technology')).toBeInTheDocument();
    });

    it('should render with large dataset', () => {
      const data = generateLargeThresholdDataSet(50);

      renderWithAuth(
        <ThresholdIndustryTable
          data={data}
          loading={false}
          error={null}
        />,
      );

      expect(screen.getByText('Technology 1')).toBeInTheDocument();
    });
  });

  describe('Filtering', () => {
    it('should filter by industry', async () => {
      const user = userEvent.setup();
      const data: ThresholdIndustryData[] = [
        createMockThresholdData({ industry: 'Technology', irr: 25 }),
        createMockThresholdData({ industry: 'Finance', irr: 20 }),
      ];

      renderWithAuth(
        <ThresholdIndustryTable
          data={data}
          loading={false}
          error={null}
        />,
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Find industry select
      const selects = screen.getAllByRole('combobox');
      const industrySelect = selects.find(select =>
        select.closest('div')?.textContent?.includes('INDUSTRY') ||
        select.closest('div')?.textContent?.includes('Industry')
      ) || selects[0];

      if (industrySelect) {
        await user.selectOptions(industrySelect, 'Technology');
      }

      await waitFor(() => {
        expect(screen.getByText('Technology')).toBeInTheDocument();
        expect(screen.queryByText('Finance')).not.toBeInTheDocument();
      });
    });

    it('should filter by IRR range', async () => {
      const user = userEvent.setup();
      const data: ThresholdIndustryData[] = [
        createMockThresholdData({ industry: 'Industry 1', irr: 15 }),
        createMockThresholdData({ industry: 'Industry 2', irr: 25 }),
        createMockThresholdData({ industry: 'Industry 3', irr: 35 }),
      ];

      renderWithAuth(
        <ThresholdIndustryTable
          data={data}
          loading={false}
          error={null}
        />,
      );

      // Open filters
      const filterButton = screen.getByText('Filter');
      await user.click(filterButton);

      // Find IRR range inputs
      const inputs = screen.getAllByPlaceholderText(/Min|Max/i);
      const irrInputs = inputs.filter(input => {
        const label = input.closest('div')?.querySelector('label')?.textContent;
        return label?.includes('IRR');
      });

      if (irrInputs[0] && irrInputs[1]) {
        await user.type(irrInputs[0], '20');
        await user.type(irrInputs[1], '30');
      }

      await waitFor(() => {
        expect(screen.getByText('Industry 2')).toBeInTheDocument();
        expect(screen.queryByText('Industry 1')).not.toBeInTheDocument();
        expect(screen.queryByText('Industry 3')).not.toBeInTheDocument();
      });
    });
  });

  describe('Sorting', () => {
    it('should sort by IRR', async () => {
      const user = userEvent.setup();
      const data: ThresholdIndustryData[] = [
        createMockThresholdData({ industry: 'Industry 1', irr: 35 }),
        createMockThresholdData({ industry: 'Industry 2', irr: 15 }),
        createMockThresholdData({ industry: 'Industry 3', irr: 25 }),
      ];

      renderWithAuth(
        <ThresholdIndustryTable
          data={data}
          loading={false}
          error={null}
        />,
      );

      // Click IRR header
      const irrHeader = screen.getByText('IRR');
      await user.click(irrHeader);

      await waitFor(() => {
        const rows = screen.getAllByRole('row');
        // Should be sorted ascending (15 first)
        expect(rows[1]).toHaveTextContent('Industry 2');
      });
    });

    it('should sort by leverageF2Min', async () => {
      const user = userEvent.setup();
      const data: ThresholdIndustryData[] = [
        createMockThresholdData({ industry: 'Industry 1', leverageF2Min: 3.0 }),
        createMockThresholdData({ industry: 'Industry 2', leverageF2Min: 1.0 }),
        createMockThresholdData({ industry: 'Industry 3', leverageF2Min: 2.0 }),
      ];

      renderWithAuth(
        <ThresholdIndustryTable
          data={data}
          loading={false}
          error={null}
        />,
      );

      // Click leverageF2Min header
      const leverageHeader = screen.getByText('LEVERAGE F2 MIN');
      await user.click(leverageHeader);

      await waitFor(() => {
        const rows = screen.getAllByRole('row');
        // Should be sorted ascending (1.0 first)
        expect(rows[1]).toHaveTextContent('Industry 2');
      });
    });
  });

  describe('Loading and error states', () => {
    it('should show loading state', () => {
      renderWithAuth(
        <ThresholdIndustryTable
          data={[]}
          loading={true}
          error={null}
        />,
      );

      const table = screen.getByRole('table');
      expect(table).toBeInTheDocument();
    });

    it('should show error state', () => {
      renderWithAuth(
        <ThresholdIndustryTable
          data={[]}
          loading={false}
          error="Failed to load data"
        />,
      );

      expect(screen.getByText(/error|Error/i)).toBeInTheDocument();
      expect(screen.getByText('Failed to load data')).toBeInTheDocument();
    });
  });
});


```

## `src/components/AdvancedFilters.tsx`

```tsx
import { useState, useRef, useEffect, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { saveFilter, loadFilter, getSavedFilters, deleteFilter, SavedFilter } from '../services/filterStorageService';
import { getAllTemplates, loadTemplate, saveTemplate, deleteTemplate, FilterTemplate } from '../services/filterTemplateService';
import { validateTextInput, validateNumberInput, validateNumberRange, validateSelectInput, validateFilterName } from '../utils/inputValidator';
import { useNotifications } from '../contexts/NotificationContext';
import { FilterConfig, FilterValues, FilterType } from '../types/filters';

// Re-export for backward compatibility
export type { FilterType, FilterConfig, FilterValues };

interface AdvancedFiltersProps {
  filters: FilterConfig[];
  values: FilterValues;
  onChange: (values: FilterValues) => void;
  onClear: () => void;
  tableId?: string;
}

export default function AdvancedFilters({ filters, values, onChange, onClear, tableId }: AdvancedFiltersProps) {
  const { t } = useTranslation();
  const { createNotification } = useNotifications();
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const [savedFilters, setSavedFilters] = useState<SavedFilter[]>([]);
  const [saveFilterName, setSaveFilterName] = useState('');
  const [saveError, setSaveError] = useState<string | null>(null);
  const [saveSuccess, setSaveSuccess] = useState(false);
  const [validationErrors, setValidationErrors] = useState<Record<string, string>>({});
  const [templates, setTemplates] = useState<FilterTemplate[]>([]);
  const [showTemplates, setShowTemplates] = useState(false);

  // Load saved filters and templates when tableId changes or dropdown opens
  useEffect(() => {
    if (tableId && isOpen) {
      const filters = getSavedFilters(tableId);
      setSavedFilters(filters);
      const allTemplates = getAllTemplates(tableId);
      setTemplates(allTemplates);
    }
  }, [tableId, isOpen]);

  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
        setSaveFilterName('');
        setSaveError(null);
        setSaveSuccess(false);
      }
    }

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen]);

  const handleSaveFilter = useCallback(() => {
    if (!tableId) {
      setSaveError('Tabell-ID saknas');
      return;
    }

    const trimmedName = saveFilterName.trim();
    const nameValidation = validateFilterName(trimmedName);
    if (!nameValidation.isValid) {
      setSaveError(nameValidation.error || 'Ogiltigt filternamn');
      return;
    }

    try {
      saveFilter(tableId, trimmedName, values);
      setSaveFilterName('');
      setSaveError(null);
      setSaveSuccess(true);
      
      // Refresh saved filters list
      const updatedFilters = getSavedFilters(tableId);
      setSavedFilters(updatedFilters);
      
      // Show notification
      createNotification(
        'success',
        'Filter Saved',
        `Filter "${trimmedName}" has been saved successfully`,
        {
          showDesktop: false,
          persistent: false,
        }
      );
      
      // Clear success message after 2 seconds
      setTimeout(() => setSaveSuccess(false), 2000);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Kunde inte spara filter';
      setSaveError(errorMessage);
      setSaveSuccess(false);
      
      createNotification(
        'error',
        'Filter Save Failed',
        errorMessage,
        {
          showDesktop: true,
          persistent: false,
        }
      );
    }
  }, [tableId, saveFilterName, values, createNotification]);

  const handleLoadFilter = useCallback((filterName: string) => {
    if (!tableId) return;
    
    const loadedValues = loadFilter(tableId, filterName);
    if (loadedValues) {
      onChange(loadedValues);
      setSaveError(null);
    }
  }, [tableId, onChange]);

  const handleLoadTemplate = useCallback((templateId: string) => {
    if (!tableId) return;
    
    const loadedValues = loadTemplate(tableId, templateId);
    if (loadedValues) {
      onChange(loadedValues);
      setSaveError(null);
      setIsOpen(false);
    }
  }, [tableId, onChange]);

  const handleSaveAsTemplate = useCallback(() => {
    if (!tableId) {
      setSaveError('Tabell-ID saknas');
      return;
    }

    const trimmedName = saveFilterName.trim();
    const nameValidation = validateFilterName(trimmedName);
    if (!nameValidation.isValid) {
      setSaveError(nameValidation.error || 'Ogiltigt templatenamn');
      return;
    }

    try {
      saveTemplate(tableId, trimmedName, values);
      setSaveFilterName('');
      setSaveError(null);
      setSaveSuccess(true);
      
      // Refresh templates list
      const allTemplates = getAllTemplates(tableId);
      setTemplates(allTemplates);
      
      createNotification(
        'success',
        'Template Saved',
        `Template "${trimmedName}" has been saved successfully`,
        {
          showDesktop: false,
          persistent: false,
        }
      );
      
      setTimeout(() => setSaveSuccess(false), 2000);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Kunde inte spara template';
      setSaveError(errorMessage);
      setSaveSuccess(false);
      
      createNotification(
        'error',
        'Template Save Failed',
        errorMessage,
        {
          showDesktop: true,
          persistent: false,
        }
      );
    }
  }, [tableId, saveFilterName, values, createNotification]);

  const handleDeleteFilter = useCallback((filterName: string) => {
    if (!tableId) return;
    
    if (window.confirm(`Är du säker på att du vill ta bort filtret "${filterName}"?`)) {
      deleteFilter(tableId, filterName);
      const updatedFilters = getSavedFilters(tableId);
      setSavedFilters(updatedFilters);
    }
  }, [tableId]);

  const handleFilterChange = (key: string, value: string | number | { min?: number; max?: number } | boolean | null) => {
    const filter = filters.find((f) => f.key === key);
    if (!filter) {
      onChange({
        ...values,
        [key]: value === '' || value === null || (typeof value === 'object' && !value.min && !value.max) ? null : value,
      });
      return;
    }

    // Validate based on filter type
    let validationError: string | undefined;
    const errors = { ...validationErrors };

    if (filter.type === 'text') {
      const result = validateTextInput(value as string, { maxLength: 200 });
      if (!result.isValid) {
        validationError = result.error;
      } else {
        delete errors[key];
      }
    } else if (filter.type === 'number') {
      const result = validateNumberInput(value as number, {
        min: filter.min,
        max: filter.max,
        allowDecimal: filter.step !== undefined && filter.step < 1,
        maxDecimals: filter.step !== undefined && filter.step < 1 ? 2 : 0,
      });
      if (!result.isValid) {
        validationError = result.error;
      } else {
        delete errors[key];
      }
    } else if (filter.type === 'numberRange') {
      const rangeValue = typeof value === 'object' && value !== null ? value : { min: undefined, max: undefined };
      const result = validateNumberRange(rangeValue, {
        min: filter.min,
        max: filter.max,
      });
      if (!result.isValid) {
        validationError = result.error;
      } else {
        delete errors[key];
      }
    } else if (filter.type === 'select' && filter.options) {
      const result = validateSelectInput(value as string | number, filter.options.map((opt) => opt.value));
      if (!result.isValid) {
        validationError = result.error;
      } else {
        delete errors[key];
      }
    }

    if (validationError) {
      errors[key] = validationError;
    } else {
      delete errors[key];
    }

    setValidationErrors(errors);

    // Only update values if validation passes or value is empty/null
    const isEmpty = value === '' || value === null || (typeof value === 'object' && !value.min && !value.max);
    if (isEmpty || !validationError) {
      onChange({
        ...values,
        [key]: isEmpty ? null : value,
      });
    }
  };

  const hasActiveFilters = Object.values(values).some(
    (v) => v !== null && v !== '' && v !== undefined && (typeof v !== 'object' || v.min !== undefined || v.max !== undefined)
  );

  const activeFilterCount = Object.values(values).filter(
    (v) => v !== null && v !== '' && v !== undefined && (typeof v !== 'object' || v.min !== undefined || v.max !== undefined)
  ).length;

  return (
    <div className="relative" ref={dropdownRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={`px-3 sm:px-3 py-3 sm:py-2 text-sm font-medium rounded-md border transition-all duration-200 hover:shadow-md hover:scale-105 active:scale-95 flex items-center space-x-2 min-h-[44px] touch-manipulation ${
          hasActiveFilters
            ? 'bg-blue-50 dark:bg-blue-900/20 border-blue-300 dark:border-blue-600 text-blue-700 dark:text-blue-400'
            : 'bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-500 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600'
        }`}
        title="Avancerade filter"
        aria-label={t('aria.filterButton')}
        aria-expanded={isOpen}
        aria-haspopup="true"
      >
        <svg
          className="w-4 h-4"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          aria-hidden="true"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"
          />
        </svg>
        <span>Filter</span>
        {activeFilterCount > 0 && (
          <span className="bg-blue-600 dark:bg-blue-500 text-white text-xs font-semibold px-1.5 py-0.5 rounded-full min-w-[20px] text-center">
            {activeFilterCount}
          </span>
        )}
        <svg
          className={`w-4 h-4 transition-transform duration-300 ease-in-out ${isOpen ? 'transform rotate-180' : ''}`}
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          aria-hidden="true"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M19 9l-7 7-7-7"
          />
        </svg>
      </button>

      {isOpen && (
        <div className="absolute right-0 mt-2 w-80 bg-white dark:bg-gray-800 rounded-md shadow-lg border border-gray-300 dark:border-gray-400 z-50 max-h-96 overflow-y-auto animate-fade-in-up transition-all duration-200">
          <div className="p-4 border-b border-gray-300 dark:border-gray-400">
            <div className="flex items-center justify-between mb-3">
              <h3 className="text-sm font-semibold text-black dark:text-white">
                Avancerade filter
              </h3>
              {hasActiveFilters && (
                <button
                  onClick={() => {
                    onClear();
                    setIsOpen(false);
                  }}
                  className="text-xs px-2 py-1 text-blue-600 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded transition-all duration-200 hover:scale-105 active:scale-95"
                  aria-label={t('aria.clearFilters')}
                >
                  Rensa alla
                </button>
              )}
            </div>
          </div>
          <div className="p-4 space-y-4">
            {filters.map((filter) => {
              const currentValue = values[filter.key];

              return (
                <div key={filter.key}>
                  <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1.5">
                    {filter.label}
                  </label>
                  
                  {filter.type === 'text' && (
                    <div>
                      <input
                        type="text"
                        value={(currentValue as string) || ''}
                        onChange={(e) => handleFilterChange(filter.key, e.target.value)}
                        placeholder={`Sök ${filter.label.toLowerCase()}...`}
                        className={`w-full px-3 py-2 text-sm border rounded-md bg-white dark:bg-gray-700 text-black dark:text-white placeholder-gray-600 dark:placeholder-gray-300 focus:outline-none focus:ring-2 focus:border-blue-500 ${
                          validationErrors[filter.key]
                            ? 'border-red-500 dark:border-red-500 focus:ring-red-500'
                            : 'border-gray-300 dark:border-gray-400 focus:ring-blue-500'
                        }`}
                        aria-label={filter.label}
                        aria-invalid={!!validationErrors[filter.key]}
                        tabIndex={0}
                        onKeyDown={(e) => {
                          if (e.key === 'Tab' && !e.shiftKey) {
                            // Allow normal tab navigation
                            return;
                          }
                          if (e.key === 'Enter') {
                            e.preventDefault();
                            // Find next filter input and focus it
                            const filterInputs = Array.from(dropdownRef.current?.querySelectorAll('input, select') || []) as HTMLElement[];
                            const currentIndex = filterInputs.indexOf(e.currentTarget);
                            if (currentIndex < filterInputs.length - 1) {
                              filterInputs[currentIndex + 1]?.focus();
                            }
                          }
                        }}
                      />
                      {validationErrors[filter.key] && (
                        <p className="mt-1 text-xs text-red-600 dark:text-red-400" role="alert">
                          {validationErrors[filter.key]}
                        </p>
                      )}
                    </div>
                  )}

                  {filter.type === 'number' && (
                    <div>
                      <input
                        type="number"
                        value={(currentValue as number) || ''}
                        onChange={(e) => handleFilterChange(filter.key, e.target.value ? parseFloat(e.target.value) : null)}
                        placeholder="Värde..."
                        step={filter.step || 1}
                        min={filter.min}
                        max={filter.max}
                        className={`w-full px-3 py-2 text-sm border rounded-md bg-white dark:bg-gray-700 text-black dark:text-white placeholder-gray-600 dark:placeholder-gray-300 focus:outline-none focus:ring-2 focus:border-blue-500 ${
                          validationErrors[filter.key]
                            ? 'border-red-500 dark:border-red-500 focus:ring-red-500'
                            : 'border-gray-300 dark:border-gray-400 focus:ring-blue-500'
                        }`}
                        aria-label={filter.label}
                        aria-invalid={!!validationErrors[filter.key]}
                        tabIndex={0}
                        onKeyDown={(e) => {
                          if (e.key === 'Enter') {
                            e.preventDefault();
                            // Find next filter input and focus it
                            const filterInputs = Array.from(dropdownRef.current?.querySelectorAll('input, select') || []) as HTMLElement[];
                            const currentIndex = filterInputs.indexOf(e.currentTarget);
                            if (currentIndex < filterInputs.length - 1) {
                              filterInputs[currentIndex + 1]?.focus();
                            }
                          }
                        }}
                      />
                      {validationErrors[filter.key] && (
                        <p className="mt-1 text-xs text-red-600 dark:text-red-400" role="alert">
                          {validationErrors[filter.key]}
                        </p>
                      )}
                    </div>
                  )}

                  {filter.type === 'numberRange' && (
                    <div className="space-y-2">
                      <div className="flex items-center space-x-2">
                        <input
                          type="number"
                          value={typeof currentValue === 'object' && currentValue !== null ? (currentValue as { min?: number }).min || '' : ''}
                          onChange={(e) => handleFilterChange(filter.key, {
                            ...(typeof currentValue === 'object' && currentValue !== null ? currentValue : {}),
                            min: e.target.value ? parseFloat(e.target.value) : undefined,
                          })}
                          placeholder="Min"
                          step={filter.step || 1}
                          min={filter.min}
                          max={filter.max}
                          className={`flex-1 px-3 py-2 text-sm border rounded-md bg-white dark:bg-gray-700 text-black dark:text-white placeholder-gray-500 dark:placeholder-gray-300 focus:outline-none focus:ring-2 focus:border-blue-500 ${
                            validationErrors[filter.key]
                              ? 'border-red-500 dark:border-red-500 focus:ring-red-500'
                              : 'border-gray-300 dark:border-gray-500 focus:ring-blue-500'
                          }`}
                          aria-label={`${filter.label} minimum`}
                          aria-invalid={!!validationErrors[filter.key]}
                          tabIndex={0}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                              e.preventDefault();
                              // Focus next input in the same range or next filter
                              const filterInputs = Array.from(dropdownRef.current?.querySelectorAll('input, select') || []) as HTMLElement[];
                              const currentIndex = filterInputs.indexOf(e.currentTarget);
                              if (currentIndex < filterInputs.length - 1) {
                                filterInputs[currentIndex + 1]?.focus();
                              }
                            }
                          }}
                        />
                        <span className="text-gray-600 dark:text-gray-300" aria-hidden="true">-</span>
                        <input
                          type="number"
                          value={typeof currentValue === 'object' && currentValue !== null ? (currentValue as { max?: number }).max || '' : ''}
                          onChange={(e) => handleFilterChange(filter.key, {
                            ...(typeof currentValue === 'object' && currentValue !== null ? currentValue : {}),
                            max: e.target.value ? parseFloat(e.target.value) : undefined,
                          })}
                          placeholder="Max"
                          step={filter.step || 1}
                          min={filter.min}
                          max={filter.max}
                          className={`flex-1 px-3 py-2 text-sm border rounded-md bg-white dark:bg-gray-700 text-black dark:text-white placeholder-gray-500 dark:placeholder-gray-300 focus:outline-none focus:ring-2 focus:border-blue-500 ${
                            validationErrors[filter.key]
                              ? 'border-red-500 dark:border-red-500 focus:ring-red-500'
                              : 'border-gray-300 dark:border-gray-500 focus:ring-blue-500'
                          }`}
                          aria-label={`${filter.label} maximum`}
                          aria-invalid={!!validationErrors[filter.key]}
                          tabIndex={0}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                              e.preventDefault();
                              // Find next filter input and focus it
                              const filterInputs = Array.from(dropdownRef.current?.querySelectorAll('input, select') || []) as HTMLElement[];
                              const currentIndex = filterInputs.indexOf(e.currentTarget);
                              if (currentIndex < filterInputs.length - 1) {
                                filterInputs[currentIndex + 1]?.focus();
                              }
                            }
                          }}
                        />
                      </div>
                      {validationErrors[filter.key] && (
                        <p className="text-xs text-red-600 dark:text-red-400" role="alert">
                          {validationErrors[filter.key]}
                        </p>
                      )}
                    </div>
                  )}

                  {filter.type === 'select' && filter.options && (
                    <select
                      value={String(currentValue || '')}
                      onChange={(e) => handleFilterChange(filter.key, e.target.value === '' ? null : e.target.value)}
                      className="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                      aria-label={filter.label}
                      tabIndex={0}
                    >
                      <option value="">Alla</option>
                      {filter.options.map((option) => (
                        <option key={String(option.value)} value={String(option.value)}>
                          {option.label}
                        </option>
                      ))}
                    </select>
                  )}

                  {filter.type === 'boolean' && (
                    <select
                      value={String(currentValue === null ? '' : currentValue)}
                      onChange={(e) => handleFilterChange(filter.key, e.target.value === '' ? null : e.target.value === 'true')}
                      className="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                      aria-label={filter.label}
                      tabIndex={0}
                    >
                      <option value="">Alla</option>
                      <option value="true">Ja</option>
                      <option value="false">Nej</option>
                    </select>
                  )}
                </div>
              );
            })}
          </div>

          {/* Filter Templates Section */}
          {tableId && templates.length > 0 && (
            <div className="border-t border-gray-200 dark:border-gray-500 pt-4 mt-4">
              <div className="flex items-center justify-between mb-3">
                <h4 className="text-xs font-semibold text-gray-700 dark:text-gray-300 uppercase tracking-wider">
                  {t('filters.templates', 'Filter Templates')}
                </h4>
                <button
                  onClick={() => setShowTemplates(!showTemplates)}
                  className="text-xs text-blue-600 dark:text-blue-400 hover:underline"
                >
                  {showTemplates ? t('common.hide', 'Hide') : t('common.show', 'Show')}
                </button>
              </div>
              {showTemplates && (
                <div className="space-y-2 max-h-48 overflow-y-auto">
                  {templates.map((template) => (
                    <div
                      key={template.id}
                      className="flex items-center justify-between p-2 bg-gray-50 dark:bg-gray-700 rounded-md hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors"
                    >
                      <div className="flex-1 min-w-0">
                        <p className="text-sm font-medium text-black dark:text-white truncate">
                          {template.name}
                        </p>
                        {template.description && (
                          <p className="text-xs text-gray-500 dark:text-gray-400 truncate">
                            {template.description}
                          </p>
                        )}
                      </div>
                      <button
                        onClick={() => handleLoadTemplate(template.id)}
                        className="p-1.5 text-blue-600 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded transition-all duration-200 hover:scale-110 active:scale-95 ml-2"
                        title={t('filters.loadTemplate', 'Load template')}
                        aria-label={`${t('filters.loadTemplate', 'Load template')} ${template.name}`}
                      >
                        <svg
                          className="w-4 h-4"
                          fill="none"
                          stroke="currentColor"
                          viewBox="0 0 24 24"
                          aria-hidden="true"
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth={2}
                            d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
                          />
                        </svg>
                      </button>
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}

          {/* Save and Load Filters Section */}
          {tableId && (
            <>
              <div className="border-t border-gray-200 dark:border-gray-500 pt-4 mt-4">
                <h4 className="text-xs font-semibold text-gray-700 dark:text-gray-300 mb-3 uppercase tracking-wider">
                  {t('filters.saveFilter', 'Spara filter')}
                </h4>
                <div className="space-y-2">
                  <div className="flex items-center space-x-2">
                    <input
                      type="text"
                      value={saveFilterName}
                      onChange={(e) => {
                        setSaveFilterName(e.target.value);
                        setSaveError(null);
                        setSaveSuccess(false);
                      }}
                      onKeyDown={(e) => {
                        if (e.key === 'Enter') {
                          handleSaveFilter();
                        }
                      }}
                      placeholder="Namn på filter..."
                      className="flex-1 px-3 py-2 text-sm border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white placeholder-gray-500 dark:placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                      aria-label="Filter name"
                    />
                    <button
                      onClick={handleSaveFilter}
                      disabled={!saveFilterName.trim()}
                      className="px-3 py-2 text-sm font-medium text-white bg-blue-600 dark:bg-blue-500 rounded-md hover:bg-blue-700 dark:hover:bg-blue-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:cursor-not-allowed transition-all duration-200 hover:scale-105 active:scale-95"
                      aria-label={t('aria.saveFilter')}
                    >
                      {t('filters.save', 'Spara')}
                    </button>
                  </div>
                  <div className="flex items-center gap-2 mt-2">
                    <button
                      onClick={handleSaveAsTemplate}
                      disabled={!saveFilterName.trim()}
                      className="px-3 py-2 text-xs font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:cursor-not-allowed transition-all duration-200"
                      aria-label={t('filters.saveAsTemplate', 'Save as Template')}
                    >
                      {t('filters.saveAsTemplate', 'Save as Template')}
                    </button>
                  </div>
                  {saveError && (
                    <p className="text-xs text-red-600 dark:text-red-400">{saveError}</p>
                  )}
                  {saveSuccess && (
                    <p className="text-xs text-green-600 dark:text-green-400">
                      {t('filters.filterSaved', 'Filter sparades!')}
                    </p>
                  )}
                </div>
              </div>

              {/* Saved Filters List */}
              {savedFilters.length > 0 && (
                <div className="border-t border-gray-200 dark:border-gray-500 pt-4 mt-4">
                  <h4 className="text-xs font-semibold text-gray-700 dark:text-gray-300 mb-3 uppercase tracking-wider">
                    Sparade filter
                  </h4>
                  <div className="space-y-2 max-h-48 overflow-y-auto">
                    {savedFilters.map((savedFilter) => (
                      <div
                        key={savedFilter.name}
                        className="flex items-center justify-between p-2 bg-gray-50 dark:bg-gray-700 rounded-md hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                      >
                        <div className="flex-1 min-w-0">
                          <p className="text-sm font-medium text-black dark:text-white truncate">
                            {savedFilter.name}
                          </p>
                          <p className="text-xs text-gray-500 dark:text-gray-400">
                            {new Date(savedFilter.createdAt).toLocaleDateString('sv-SE')}
                          </p>
                        </div>
                        <div className="flex items-center space-x-1 ml-2">
                          <button
                            onClick={() => handleLoadFilter(savedFilter.name)}
                            className="p-1.5 text-blue-600 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded transition-all duration-200 hover:scale-110 active:scale-95"
                            title="Ladda filter"
                            aria-label={`${t('aria.loadFilter')} ${savedFilter.name}`}
                          >
                            <svg
                              className="w-4 h-4"
                              fill="none"
                              stroke="currentColor"
                              viewBox="0 0 24 24"
                              aria-hidden="true"
                            >
                              <path
                                strokeLinecap="round"
                                strokeLinejoin="round"
                                strokeWidth={2}
                                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
                              />
                            </svg>
                          </button>
                          <button
                            onClick={() => handleDeleteFilter(savedFilter.name)}
                            className="p-1.5 text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 rounded transition-all duration-200 hover:scale-110 active:scale-95"
                            title="Ta bort filter"
                            aria-label={`${t('aria.deleteFilter')} ${savedFilter.name}`}
                          >
                            <svg
                              className="w-4 h-4"
                              fill="none"
                              stroke="currentColor"
                              viewBox="0 0 24 24"
                              aria-hidden="true"
                            >
                              <path
                                strokeLinecap="round"
                                strokeLinejoin="round"
                                strokeWidth={2}
                                d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                              />
                            </svg>
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </>
          )}
        </div>
      )}
    </div>
  );
}


```

## `src/components/ApiKeysModal.tsx`

```tsx
import React, { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { getApiKeysForDisplay } from '../config/apiKeys';
import type { ApiKeys } from '../config/apiKeys';

interface ApiKeysModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (keys: ApiKeys) => Promise<void>;
}

export default function ApiKeysModal({ isOpen, onClose, onSave }: ApiKeysModalProps) {
  const { t } = useTranslation();
  const [keys, setKeys] = useState<ApiKeys>({});
  const [saving, setSaving] = useState(false);

  useEffect(() => {
    if (isOpen) {
      const apiKeys = getApiKeysForDisplay();
      setKeys(apiKeys);
    }
  }, [isOpen]);

  const handleSave = async () => {
    setSaving(true);
    try {
      await onSave(keys);
      onClose();
    } finally {
      setSaving(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
      role="dialog"
      aria-modal="true"
      aria-labelledby="api-keys-title"
    >
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-2xl w-full mx-4 shadow-xl">
        <h2 id="api-keys-title" className="text-xl font-semibold mb-4 text-black dark:text-white">
          {t('apiKeys.title', 'API-nycklar')}
        </h2>
        <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
          {t(
            'apiKeys.description',
            'Endast admin kan se och ändra. Ändringar sparas och används för valutakurser.'
          )}
        </p>

        <div className="space-y-3">
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">EODHD</label>
            <input
              type="text"
              value={keys.eodhd || ''}
              onChange={(e) => setKeys((prev) => ({ ...prev, eodhd: e.target.value }))}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">MarketStack</label>
            <input
              type="text"
              value={keys.marketstack || ''}
              onChange={(e) => setKeys((prev) => ({ ...prev, marketstack: e.target.value }))}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">FINNHUB</label>
            <input
              type="text"
              value={keys.finnhub || ''}
              onChange={(e) => setKeys((prev) => ({ ...prev, finnhub: e.target.value }))}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Alpha Vantage</label>
            <input
              type="text"
              value={keys.alphaVantage || ''}
              onChange={(e) => setKeys((prev) => ({ ...prev, alphaVantage: e.target.value }))}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
        </div>

        <div className="flex justify-end gap-2 mt-6">
          <button
            onClick={handleSave}
            disabled={saving}
            className="px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed text-white rounded-md transition-colors min-h-[44px] touch-manipulation"
          >
            {saving ? t('apiKeys.saving', 'Sparar…') : t('apiKeys.save', 'Spara')}
          </button>
          <button
            onClick={onClose}
            disabled={saving}
            className="px-4 py-2 bg-gray-300 dark:bg-gray-600 hover:bg-gray-400 dark:hover:bg-gray-500 text-black dark:text-white rounded-md transition-colors min-h-[44px] touch-manipulation disabled:opacity-50"
          >
            {t('common.close', 'Stäng')}
          </button>
        </div>
      </div>
    </div>
  );
}

```

## `src/components/BaseTable.tsx`

```tsx
import React, { useState, useCallback, useRef, ReactNode, lazy, Suspense } from 'react';
import { useTableSort, SortConfig } from '../hooks/useTableSort';
import { useTableSearch } from '../hooks/useTableSearch';
import { useTablePagination } from '../hooks/useTablePagination';
import { useColumnVisibility, ColumnConfig } from '../hooks/useColumnVisibility';
import VirtualTableBody from './VirtualTableBody';
import { TableSkeleton } from './SkeletonLoader';
import TableSearchBar from './TableSearchBar';
import Pagination from './Pagination';
import ColumnVisibilityToggle from './ColumnVisibilityToggle';
import { FilterConfig, FilterValues } from '../types/filters';
import ShareableLinkModal from './ShareableLinkModal';
import { useTranslation } from 'react-i18next';
import { exportTableData, ExportColumn } from '../services/exportService';
import { useNotifications } from '../contexts/NotificationContext';
import { useAuth } from '../contexts/AuthContext';
import Button from './ui/Button';
import { useColumnResize } from '../hooks/useColumnResize';
import { useColumnReorder } from '../hooks/useColumnReorder';
import { SortableTableHeader } from './SortableTableHeader';
import { printTable } from '../utils/printUtils';
import { useColumnFilters, ColumnFilters, ColumnFilter } from '../hooks/useColumnFilters';
import { UniqueValue } from '../hooks/useColumnUniqueValues';
import ColumnFilterMenu from './ColumnFilterMenu';
import BaseTableToolbar from './BaseTableToolbar';


export interface ColumnDefinition<T = unknown> extends ColumnConfig {
  sortable?: boolean;
  sticky?: boolean;
  align?: 'left' | 'center' | 'right';
  width?: string;
  renderHeader?: (props: HeaderRenderProps<T>) => ReactNode;
  renderCell?: (item: T, column: ColumnDefinition<T>, index: number, globalIndex: number, expandedRows?: { [key: string]: boolean }, toggleRow?: (rowKey: string) => void) => ReactNode;
}

export interface HeaderRenderProps<T = unknown> {
  column: ColumnDefinition<T>;
  sortConfig: SortConfig<T>;
  handleSort: (key: string) => void;
  getSortIcon: (columnKey: string) => string | null;
  getStickyPosition: (columnKey: string) => string;
  isColumnVisible: (columnKey: string) => boolean;
  // Column filter props
  openFilterMenuColumn: string | null;
  setOpenFilterMenuColumn: (columnKey: string | null) => void;
  hasActiveColumnFilter: (columnKey: string) => boolean;
  getColumnUniqueValues: (columnKey: string) => UniqueValue[];
  columnFilters: ColumnFilters;
  setColumnFilter: (columnKey: string, filter: ColumnFilter | null) => void;
  handleColumnSort: (columnKey: string, direction: 'asc' | 'desc') => void;
  headerRefs: React.MutableRefObject<{ [key: string]: HTMLElement | null }>;
}

export interface BaseTableProps<T> {
  // Data & state
  data: T[];
  loading: boolean;
  error: string | null;
  
  // Column configuration
  columns: ColumnDefinition<T>[];
  filters: FilterConfig[];
  tableId: string;
  
  // Rendering functions
  renderCell: (item: T, column: ColumnDefinition<T>, index: number, globalIndex: number, expandedRows?: { [key: string]: boolean }, toggleRow?: (rowKey: string) => void) => ReactNode;
  renderHeader?: (props: HeaderRenderProps<T>) => ReactNode;
  renderMobileCard?: (item: T, index: number, globalIndex: number, isExpanded: boolean, toggleExpand: () => void) => ReactNode;
  renderExpandedRow?: (item: T, index: number, globalIndex: number) => ReactNode;
  
  // Options
  enablePagination?: boolean;
  enableVirtualScroll?: boolean;
  enableHelp?: boolean;
  enableMobileExpand?: boolean;
  itemsPerPage?: number;
  virtualScrollRowHeight?: number;
  virtualScrollOverscan?: number;
  
  // Search configuration
  searchFields: (keyof T)[];
  searchPlaceholder?: string;
  
  // Sort configuration
  defaultSortKey?: keyof T;
  defaultSortDirection?: 'asc' | 'desc';
  
  // Sticky columns
  stickyColumns?: string[];
  
  // Additional props
  ariaLabel?: string;
  emptyMessage?: string;
  minTableWidth?: string;
  
  // Custom header content (for additional buttons, etc.). May be a render-prop to access toggleColumn/isColumnVisible.
  headerActions?: ReactNode | ((api: { toggleColumn: (key: string) => void; isColumnVisible: (key: string) => boolean }) => ReactNode);
  
  // Custom row key generator
  getRowKey?: (item: T, index: number) => string;
  
  // Export configuration
  enableExport?: boolean;
  exportFilename?: string;
  
  // Column resizing
  enableColumnResize?: boolean;
  defaultColumnWidth?: number;
  minColumnWidth?: number;
  maxColumnWidth?: number;
  
  // Column reordering
  enableColumnReorder?: boolean;
  
  // Print configuration
  enablePrint?: boolean;
  printTableName?: string;
  
  // Shareable link configuration
  enableShareableLink?: boolean;
  viewId?: string;
}

export default function BaseTable<T extends Record<string, unknown>>({
  data,
  loading,
  error,
  columns,
  filters,
  tableId,
  renderCell,
  renderHeader,
  renderMobileCard,
  renderExpandedRow,
  enablePagination = false,
  enableVirtualScroll = false,
  enableHelp = false,
  enableMobileExpand = false,
  itemsPerPage = 50,
  virtualScrollRowHeight = 60,
  virtualScrollOverscan = 10,
  searchFields,
  searchPlaceholder = 'Sök...',
  defaultSortKey,
  defaultSortDirection = 'asc',
  stickyColumns = [],
  ariaLabel,
  emptyMessage,
  minTableWidth = '600px',
  headerActions,
  getRowKey,
  enableExport = false,
  exportFilename,
  enableColumnResize = false,
  defaultColumnWidth = 150,
  minColumnWidth = 80,
  maxColumnWidth = 500,
  enableColumnReorder = false,
  enablePrint = false,
  printTableName,
  enableShareableLink = false,
  viewId,
}: BaseTableProps<T>) {
  const { t } = useTranslation();
  const { createNotification } = useNotifications();
  const { currentUser } = useAuth();
  const [filterValues, setFilterValues] = useState<FilterValues>({});
  const [shareableLinkModalOpen, setShareableLinkModalOpen] = useState(false);
  const [expandedRows, setExpandedRows] = useState<{ [key: string]: boolean }>({});
  const [focusedRowIndex, setFocusedRowIndex] = useState<number | null>(null);
  const [openFilterMenuColumn, setOpenFilterMenuColumn] = useState<string | null>(null);
  const tableRef = useRef<HTMLTableElement>(null);
  const headerRefs = useRef<{ [key: string]: HTMLElement | null }>({});

  // Column filters hook
  const {
    filters: columnFilters,
    setColumnFilter,
    clearColumnFilter,
    hasActiveFilter: hasActiveColumnFilter,
    getColumnUniqueValues,
    filteredData: columnFilteredData,
  } = useColumnFilters<T>({
    data,
    tableId,
  });
  
  // Column visibility
  const {
    columnVisibility,
    toggleColumn,
    showAllColumns,
    hideAllColumns,
    resetToDefaults,
    isColumnVisible,
  } = useColumnVisibility({
    tableId,
    columns,
  });

  // Column resizing
  const {
    resizingColumn,
    getColumnWidth,
    handleResizeStart,
  } = useColumnResize({
    tableId,
    columns,
    defaultWidth: defaultColumnWidth,
    minWidth: minColumnWidth,
    maxWidth: maxColumnWidth,
  });

  // Column reordering
  const {
    getOrderedColumns,
    sensors,
    handleDragEnd,
    DndContext,
    SortableContext,
    horizontalListSortingStrategy,
    closestCenter,
  } = useColumnReorder({
    tableId,
    columns,
  });

  // Get columns in correct order
  const orderedColumns = enableColumnReorder ? getOrderedColumns(columns) : columns;

  // Determine which data to use: column filters replace advanced filters
  const hasColumnFilters = Object.keys(columnFilters).length > 0;
  const dataToFilter = hasColumnFilters ? columnFilteredData : data;

  // Search/filter data (only if no column filters are active)
  const { searchValue, setSearchValue, filteredData } = useTableSearch<T>({
    data: dataToFilter,
    searchFields,
    advancedFilters: hasColumnFilters ? {} : filterValues, // Don't apply advanced filters if column filters are active
  });

  // Determine final data: if column filters active, use column filtered data; otherwise use search filtered data
  const finalFilteredData = hasColumnFilters ? columnFilteredData : filteredData;

  // Sort filtered data
  const { sortedData, sortConfig, handleSort: baseHandleSort } = useTableSort(
    finalFilteredData,
    defaultSortKey || (searchFields[0] as keyof T),
    defaultSortDirection
  );

  // Handler specifically for column filter menu sort buttons
  const handleColumnSort = useCallback((columnKey: string, direction: 'asc' | 'desc') => {
    const key = columnKey as keyof T;
    // If already sorted in the desired direction, do nothing
    if (sortConfig.key === key && sortConfig.direction === direction) {
      return;
    }
    
    // If same column but different direction, toggle
    if (sortConfig.key === key) {
      baseHandleSort(key);
    } else {
      // Different column - need to set it
      // Since baseHandleSort always starts with 'asc', we call it once
      // and if we need 'desc', we'll need to call it again after state updates
      baseHandleSort(key);
      if (direction === 'desc') {
        // Use requestAnimationFrame to ensure state has updated
        requestAnimationFrame(() => {
          baseHandleSort(key);
        });
      }
    }
  }, [baseHandleSort, sortConfig]);

  // Default handleSort for column header clicks
  const handleSort = useCallback((key: keyof T) => {
    baseHandleSort(key);
  }, [baseHandleSort]);

  // Paginate sorted data (if enabled)
  const paginationResult = useTablePagination({
    data: sortedData,
    itemsPerPage: enablePagination ? itemsPerPage : sortedData.length,
  });

  const {
    currentPage,
    totalPages,
    itemsPerPage: actualItemsPerPage,
    paginatedData,
    totalItems,
    goToPage,
    nextPage,
    previousPage,
    goToFirstPage,
    goToLastPage,
    startIndex,
    endIndex,
  } = paginationResult;

  // Data to display (paginated if enabled, otherwise all sorted data)
  const displayData = enablePagination ? paginatedData : sortedData;

  const getSortIcon = useCallback((columnKey: string) => {
    if (sortConfig.key !== columnKey) {
      return null;
    }
    return sortConfig.direction === 'asc' ? '↑' : '↓';
  }, [sortConfig]);

  // Calculate sticky column positions based on visible columns
  const getStickyPosition = useCallback((columnKey: string): string => {
    if (!stickyColumns.length) return '';
    
    const visibleStickyColumns = stickyColumns.filter(key => isColumnVisible(key));
    const index = visibleStickyColumns.indexOf(columnKey);
    
    if (index === -1) return '';
    
    // Calculate left position based on index
    // These positions match the original implementations
    if (index === 0) return 'sm:left-0';
    if (index === 1) return 'sm:left-[60px]';
    if (index === 2) return 'sm:left-[260px]';
    if (index === 3) return 'sm:left-[360px]';
    return '';
  }, [stickyColumns, isColumnVisible]);

  // Optimistic filter update
  const handleFilterChange = useCallback((newFilters: FilterValues) => {
    setFilterValues(newFilters);
  }, []);

  // Generate row key - must be defined before it's used in handlers
  const getItemRowKey = useCallback((item: T, index: number) => {
    if (getRowKey) {
      return getRowKey(item, index);
    }
    // Default: try to use ticker and companyName
    const ticker = 'ticker' in item && typeof item.ticker === 'string' ? item.ticker : '';
    const companyName = 'companyName' in item && typeof item.companyName === 'string' ? item.companyName : '';
    return `${ticker}-${companyName}-${index}`;
  }, [getRowKey]);

  // Toggle row expansion for mobile view
  const toggleRow = useCallback((rowKey: string) => {
    setExpandedRows((prev) => ({
      ...prev,
      [rowKey]: !prev[rowKey],
    }));
  }, []);

  // Keyboard navigation handlers
  const handleTableKeyDown = useCallback((e: React.KeyboardEvent<HTMLTableElement>) => {
    if (!displayData.length) return;

    const maxIndex = displayData.length - 1;
    let newIndex = focusedRowIndex ?? -1;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        newIndex = newIndex < maxIndex ? newIndex + 1 : newIndex;
        setFocusedRowIndex(newIndex);
        // Scroll into view
        setTimeout(() => {
          const row = tableRef.current?.querySelector(`tr[data-row-index="${newIndex}"]`);
          row?.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }, 0);
        break;
      case 'ArrowUp':
        e.preventDefault();
        newIndex = newIndex > 0 ? newIndex - 1 : 0;
        setFocusedRowIndex(newIndex);
        // Scroll into view
        setTimeout(() => {
          const row = tableRef.current?.querySelector(`tr[data-row-index="${newIndex}"]`);
          row?.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }, 0);
        break;
      case 'Enter':
        if (focusedRowIndex !== null && focusedRowIndex >= 0 && focusedRowIndex < displayData.length) {
          e.preventDefault();
          const item = displayData[focusedRowIndex];
          const globalIndex = enablePagination ? startIndex - 1 + focusedRowIndex : focusedRowIndex;
          const rowKey = getItemRowKey(item, globalIndex);
          toggleRow(rowKey);
        }
        break;
      case 'Home':
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          setFocusedRowIndex(0);
        }
        break;
      case 'End':
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          setFocusedRowIndex(maxIndex);
        }
        break;
    }
  }, [displayData, focusedRowIndex, enablePagination, startIndex, getItemRowKey, toggleRow]);

  // Handle row click to set focus
  const handleRowClick = useCallback((index: number) => {
    setFocusedRowIndex(index);
  }, []);

  // Export handler
  const handleExport = useCallback((format: 'csv' | 'excel' = 'csv') => {
    if (!enableExport || sortedData.length === 0) return;

    // Convert columns to export format
    const exportColumns: ExportColumn<T>[] = columns
      .filter((col) => isColumnVisible(col.key))
      .map((col) => ({
        key: col.key,
        label: col.label,
        accessor: (item: T) => {
          // Try to get value from renderCell if available, otherwise use direct access
          const value = item[col.key];
          if (value === null || value === undefined) {
            return '';
          }
          if (typeof value === 'object') {
            return JSON.stringify(value);
          }
          return String(value);
        },
      }));

    const filename = exportFilename || `${tableId}_export_${new Date().toISOString().split('T')[0]}`;
    const exportDate = new Date();
    
    // Build filter info string
    const activeFilters = Object.entries(filterValues)
      .filter(([_, value]) => value !== null && value !== '' && value !== undefined)
      .map(([key, value]) => {
        const filter = filters.find((f) => f.key === key);
        const label = filter?.label || key;
        if (typeof value === 'object' && value !== null && ('min' in value || 'max' in value)) {
          const range = value as { min?: number; max?: number };
          const parts: string[] = [];
          if (range.min !== undefined) parts.push(`≥${range.min}`);
          if (range.max !== undefined) parts.push(`≤${range.max}`);
          return `${label}: ${parts.join(' - ')}`;
        }
        return `${label}: ${value}`;
      })
      .join(', ');

    try {
      exportTableData(data, sortedData, exportColumns, format, {
        filename,
        includeHeaders: true,
        includeMetadata: true,
        metadata: {
          tableName: tableId,
          exportDate,
          filterInfo: activeFilters || 'No filters',
          rowCount: sortedData.length,
        },
      });
      
      createNotification(
        'success',
        'Export Complete',
        `Exported ${sortedData.length} rows to ${format.toUpperCase()}`,
        {
          showDesktop: false,
          persistent: false,
        }
      );
    } catch (error) {
      createNotification(
        'error',
        'Export Failed',
        `Failed to export data: ${error instanceof Error ? error.message : 'Unknown error'}`,
        {
          showDesktop: true,
          persistent: false,
        }
      );
    }
  }, [enableExport, sortedData, columns, isColumnVisible, data, tableId, exportFilename, createNotification]);

  // Print handler
  const handlePrint = useCallback(() => {
    if (!enablePrint) return;
    const tableElement = tableRef.current;
    const tableName = printTableName || tableId;
    
    // Build filter info string
    const activeFilters = Object.entries(filterValues)
      .filter(([_, value]) => value !== null && value !== '' && value !== undefined)
      .map(([key, value]) => {
        const filter = filters.find((f) => f.key === key);
        const label = filter?.label || key;
        if (typeof value === 'object' && value !== null && ('min' in value || 'max' in value)) {
          const range = value as { min?: number; max?: number };
          const parts: string[] = [];
          if (range.min !== undefined) parts.push(`≥${range.min}`);
          if (range.max !== undefined) parts.push(`≤${range.max}`);
          return `${label}: ${parts.join(' - ')}`;
        }
        return `${label}: ${value}`;
      })
      .join(', ');
    
    printTable(tableElement, tableName, {
      includeHeader: true,
      includeFooter: true,
      filterInfo: activeFilters || 'No filters',
      rowCount: sortedData.length,
    });
  }, [enablePrint, printTableName, tableId, filterValues, filters, sortedData.length]);

  // Default header renderer
  const defaultRenderHeader = useCallback((props: HeaderRenderProps<T>) => {
    const { column, sortConfig, handleSort, getSortIcon, getStickyPosition } = props;
    const isSticky = stickyColumns.includes(column.key);
    const isSorted = sortConfig.key === column.key;
    const sortIcon = getSortIcon(column.key);
    const stickyClass = isSticky ? `sm:sticky sm:top-0 ${getStickyPosition(column.key)} z-50` : '';
    
    const columnWidth = enableColumnResize ? getColumnWidth(column.key) : undefined;
    const isResizing = enableColumnResize && resizingColumn === column.key;
    const isFilterMenuOpen = openFilterMenuColumn === column.key;
    const hasActiveFilter = hasActiveColumnFilter(column.key);
    const headerRef = headerRefs.current[column.key] || null;
    
    const handleFilterIconClick = (e: React.MouseEvent) => {
      e.stopPropagation();
      // Close any other open menu, then toggle this one
      if (isFilterMenuOpen) {
        setOpenFilterMenuColumn(null);
      } else {
        setOpenFilterMenuColumn(column.key);
      }
    };

    const handleSortClick = (e: React.MouseEvent) => {
      // Only sort if clicking on the label area, not on filter icon
      if (!isFilterMenuOpen) {
        e.stopPropagation();
        handleSort(column.key);
      }
    };

    const filterIcon = (
      <button
        onClick={handleFilterIconClick}
        className={`ml-2 p-1 rounded hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors ${
          hasActiveFilter ? 'text-blue-600 dark:text-blue-400' : 'text-gray-500 dark:text-gray-400'
        }`}
        aria-label={`Filter ${column.label}`}
        aria-expanded={isFilterMenuOpen}
        title="Filter och sortering"
        type="button"
      >
        <svg
          className="w-4 h-4"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M4 6h16M4 12h16M4 18h16"
          />
        </svg>
      </button>
    );

    const headerContent = (
      <div className="flex items-center justify-between relative w-full">
        <div className="flex items-center flex-1" onClick={column.sortable ? handleSortClick : undefined}>
          {column.sortable && (
            <div className={`flex items-center ${column.sortable ? 'cursor-pointer' : ''}`}>
              <span>{column.label}</span>
              {sortIcon && <span className="ml-1 text-gray-600 dark:text-gray-300">{sortIcon}</span>}
            </div>
          )}
          {!column.sortable && <span>{column.label}</span>}
        </div>
        <div className="flex items-center relative" style={{ minWidth: '40px' }}>
          <div className="relative">
            {filterIcon}
            {isFilterMenuOpen && headerRef && (
              <ColumnFilterMenu
                columnKey={column.key}
                columnLabel={column.label}
                isOpen={isFilterMenuOpen}
                onClose={() => setOpenFilterMenuColumn(null)}
                filter={columnFilters[column.key]}
                onFilterChange={(filter) => setColumnFilter(column.key, filter)}
                sortConfig={sortConfig}
                onSort={handleColumnSort}
                uniqueValues={getColumnUniqueValues(column.key)}
                triggerRef={{ current: headerRef }}
              />
            )}
          </div>
          {enableColumnResize && (
            <div
              className="absolute right-0 top-0 bottom-0 w-1 cursor-col-resize hover:bg-blue-500 dark:hover:bg-blue-400 transition-colors duration-base"
              onMouseDown={(e) => {
                if (column.sortable) {
                  e.stopPropagation();
                }
                handleResizeStart(column.key, e);
              }}
              role="separator"
              aria-orientation="vertical"
              aria-label={t('aria.resizeColumn', 'Ändra kolumnbredd')}
            />
          )}
        </div>
      </div>
    );
    
    if (!column.sortable) {
      return (
        <th
          ref={(el) => {
            headerRefs.current[column.key] = el;
          }}
          className={`px-6 py-3 text-left text-xs font-bold text-gray-700 dark:text-gray-200 uppercase tracking-wider ${stickyClass} bg-gray-50 dark:bg-gray-900 ${isResizing ? 'bg-blue-100 dark:bg-blue-900/50' : ''}`}
          style={columnWidth ? { width: `${columnWidth}px`, minWidth: `${columnWidth}px`, maxWidth: `${columnWidth}px` } : undefined}
          scope="col"
          role="columnheader"
        >
          {headerContent}
        </th>
      );
    }
    
    return (
      <th
        ref={(el) => {
          headerRefs.current[column.key] = el;
        }}
        className={`px-6 py-3 text-left text-xs font-bold text-gray-700 dark:text-gray-200 uppercase tracking-wider cursor-pointer hover:bg-blue-100 dark:hover:bg-blue-900/30 hover:text-blue-700 dark:hover:text-blue-200 transition-all duration-base ${stickyClass} bg-gray-50 dark:bg-gray-900 ${isResizing ? 'bg-blue-100 dark:bg-blue-900/50' : ''}`}
        style={columnWidth ? { width: `${columnWidth}px`, minWidth: `${columnWidth}px`, maxWidth: `${columnWidth}px` } : undefined}
        scope="col"
        role="columnheader"
        aria-label={`${t('aria.sortColumn')}: ${column.label}`}
        aria-sort={isSorted ? (sortConfig.direction === 'asc' ? 'ascending' : 'descending') : 'none'}
      >
        {headerContent}
      </th>
    );
  }, [stickyColumns, enableColumnResize, getColumnWidth, resizingColumn, handleResizeStart, t, openFilterMenuColumn, hasActiveColumnFilter, columnFilters, getColumnUniqueValues, handleSort, sortConfig]);

  // Default mobile card renderer
  const defaultRenderMobileCard = useCallback((item: T, index: number, globalIndex: number, isExpanded: boolean, toggleExpand: () => void) => {
    const rowBgClass = globalIndex % 2 === 0 
      ? 'bg-white dark:bg-gray-800' 
      : 'bg-gray-50 dark:bg-gray-800';
    const rowKey = getItemRowKey(item, globalIndex);

    return (
      <div
        className={`${rowBgClass} rounded-lg border border-gray-300 dark:border-gray-600 shadow-sm transition-all duration-300 ease-in-out`}
      >
        <div className="p-4 flex items-start justify-between gap-4">
          <div className="flex-1 space-y-3">
            {columns
              .filter(col => isColumnVisible(col.key))
              .slice(0, enableMobileExpand ? 3 : undefined)
              .map((column) => (
                <div key={column.key} className="flex items-center justify-between">
                  <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">
                    {column.label}
                  </span>
                  <span className="text-sm text-black dark:text-white text-right">
                    {column.renderCell
                      ? column.renderCell(item, column, index, globalIndex, expandedRows, toggleRow)
                      : renderCell(item, column, index, globalIndex, expandedRows, toggleRow)}
                  </span>
                </div>
              ))}
          </div>
          {enableMobileExpand && (
            <button
              onClick={toggleExpand}
              className="p-2 text-gray-600 dark:text-gray-300 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-all duration-200 flex-shrink-0"
              aria-label={isExpanded ? t('aria.collapseRow') : t('aria.expandRow')}
              aria-expanded={isExpanded}
            >
              <svg
                className={`w-5 h-5 transition-transform duration-200 ${isExpanded ? 'rotate-180' : ''}`}
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M19 9l-7 7-7-7"
                />
              </svg>
            </button>
          )}
        </div>
        {enableMobileExpand && isExpanded && (
          <div className="border-t border-gray-300 dark:border-gray-600 p-4 space-y-3 animate-fade-in">
            {columns
              .filter(col => isColumnVisible(col.key))
              .slice(3)
              .map((column) => (
                <div key={column.key} className="flex items-center justify-between">
                  <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">
                    {column.label}
                  </span>
                  <span className="text-sm text-black dark:text-white text-right">
                    {column.renderCell
                      ? column.renderCell(item, column, index, globalIndex, expandedRows, toggleRow)
                      : renderCell(item, column, index, globalIndex, expandedRows, toggleRow)}
                  </span>
                </div>
              ))}
          </div>
        )}
      </div>
    );
  }, [columns, isColumnVisible, enableMobileExpand, renderCell, expandedRows, toggleRow, getItemRowKey]);

  if (loading) {
    return (
      <div role="status" aria-live="polite" aria-label={t('aria.loading')}>
        <TableSkeleton rows={15} columns={columns.length} hasStickyColumns={stickyColumns.length > 0} />
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-8" role="alert" aria-live="assertive">
        <h3 className="text-xl font-bold text-red-600 dark:text-red-400 mb-2">{t('aria.error')}</h3>
        <p className="text-base font-medium text-gray-700 dark:text-gray-300">{error}</p>
      </div>
    );
  }

  const headerRenderProps: HeaderRenderProps<T> = {
    column: columns[0], // Will be overridden per column
    sortConfig,
    handleSort: (key: string) => handleSort(key as keyof T),
    getSortIcon,
    getStickyPosition,
    isColumnVisible,
    openFilterMenuColumn,
    setOpenFilterMenuColumn,
    hasActiveColumnFilter,
    getColumnUniqueValues,
    columnFilters,
    setColumnFilter,
    handleColumnSort,
    headerRefs,
  };

  return (
    <>
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-hidden h-full flex flex-col transition-all duration-normal ease-in-out">
        <BaseTableToolbar
          searchValue={searchValue}
          onSearchChange={setSearchValue}
          totalRows={data.length}
          filteredRows={filteredData.length}
          searchPlaceholder={searchPlaceholder}
          columns={columns}
          columnVisibility={columnVisibility}
          onToggleColumn={toggleColumn}
          onShowAll={showAllColumns}
          onHideAll={hideAllColumns}
          onResetToDefaults={resetToDefaults}
          isColumnVisible={isColumnVisible}
          enableExport={enableExport}
          sortedRowCount={sortedData.length}
          onExportCsv={() => handleExport('csv')}
          onExportExcel={() => handleExport('excel')}
          enablePrint={enablePrint}
          onPrint={handlePrint}
          enableShareableLink={enableShareableLink}
          hasCurrentUser={!!currentUser}
          viewId={viewId}
          onOpenShareableLink={() => setShareableLinkModalOpen(true)}
          headerActions={headerActions}
        />

        {/* Table View */}
        <div className="flex-1 overflow-auto min-h-0 sm:overflow-y-auto">
          <table 
            ref={tableRef}
            className="min-w-full sm:min-w-full divide-y divide-gray-300 dark:divide-gray-600"
            style={{ minWidth: minTableWidth }}
            role="grid"
            aria-label={ariaLabel || tableId}
            onKeyDown={handleTableKeyDown}
            tabIndex={0}
          >
            <thead className="sticky top-0 z-40 bg-gray-50 dark:bg-gray-900">
              {enableColumnReorder ? (
                <DndContext
                  sensors={sensors}
                  collisionDetection={closestCenter}
                  onDragEnd={handleDragEnd}
                >
                  <SortableContext
                    items={orderedColumns.filter((col) => isColumnVisible(col.key)).map((col) => col.key)}
                    strategy={horizontalListSortingStrategy}
                  >
                    <tr role="row" aria-rowindex={1}>
                      {orderedColumns
                        .filter((col) => isColumnVisible(col.key))
                        .map((column) => {
                          headerRenderProps.column = column;
                          const isResizing = enableColumnResize && resizingColumn === column.key;
                          const columnWidth = enableColumnResize ? getColumnWidth(column.key) : undefined;
                          
                          const headerContent = column.renderHeader 
                            ? column.renderHeader(headerRenderProps)
                            : (renderHeader ? renderHeader(headerRenderProps) : defaultRenderHeader(headerRenderProps));
                          
                          // Extract content from header if it's a React element
                          let headerChildren: React.ReactNode = headerContent;
                          let headerClassName = '';
                          if (React.isValidElement(headerContent)) {
                            const props = headerContent.props as { children?: React.ReactNode; className?: string };
                            headerChildren = props.children || headerContent;
                            headerClassName = props.className || '';
                          }
                          
                          return (
                            <SortableTableHeader
                              key={column.key}
                              id={column.key}
                              className={headerClassName}
                              style={columnWidth ? { width: `${columnWidth}px`, minWidth: `${columnWidth}px`, maxWidth: `${columnWidth}px` } : undefined}
                              isResizing={isResizing}
                              enableResize={enableColumnResize}
                              onResizeStart={enableColumnResize ? (e) => handleResizeStart(column.key, e) : undefined}
                            >
                              {headerChildren}
                            </SortableTableHeader>
                          );
                        })}
                    </tr>
                  </SortableContext>
                </DndContext>
              ) : (
                <tr role="row" aria-rowindex={1}>
                  {orderedColumns
                    .filter((col) => isColumnVisible(col.key))
                    .map((column, colIndex) => {
                      headerRenderProps.column = column;
                      const headerContent = column.renderHeader 
                        ? column.renderHeader(headerRenderProps)
                        : (renderHeader ? renderHeader(headerRenderProps) : defaultRenderHeader(headerRenderProps));
                      // Add aria-colindex to header cells
                      const headerWithIndex = React.isValidElement(headerContent) 
                        ? React.cloneElement(headerContent as React.ReactElement<{ 'aria-colindex'?: number }>, { 'aria-colindex': colIndex + 1 })
                        : headerContent;
                      return <React.Fragment key={column.key}>{headerWithIndex}</React.Fragment>;
                    })}
                </tr>
              )}
            </thead>
            {enableVirtualScroll ? (
              <VirtualTableBody
                data={displayData}
                renderRow={(item, index, globalIndex) => {
                  const rowKey = getItemRowKey(item, globalIndex);
                  const rowBgClass = globalIndex % 2 === 0 
                    ? 'bg-white dark:bg-gray-800' 
                    : 'bg-gray-50 dark:bg-gray-800';
                  
                  const isFocused = focusedRowIndex === index;
                  const isExpanded = expandedRows[rowKey] || false;
                  const visibleColumnsCount = orderedColumns.filter(col => isColumnVisible(col.key)).length;
                  
                  return (
                    <React.Fragment key={rowKey}>
                      <tr 
                        data-row-index={index}
                        className={`group transition-all duration-normal ease-in-out hover:bg-blue-50 dark:hover:bg-blue-900/20 hover:shadow-md cursor-pointer transition-colors duration-base ${rowBgClass} ${isFocused ? 'ring-2 ring-blue-500 dark:ring-blue-400 bg-blue-50 dark:bg-blue-900/30' : ''}`}
                        onClick={() => handleRowClick(index)}
                        onKeyDown={(e) => {
                          if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            toggleRow(rowKey);
                          }
                        }}
                        tabIndex={0}
                        role="row"
                        aria-rowindex={globalIndex + 2}
                        aria-label={`Row ${globalIndex + 1}: ${'companyName' in item && typeof item.companyName === 'string' ? item.companyName : 'Item ' + (globalIndex + 1)}`}
                        aria-expanded={isExpanded}
                      >
                        {orderedColumns
                          .filter(col => isColumnVisible(col.key))
                          .map((column, colIndex) => {
                            const cellContent = column.renderCell
                              ? column.renderCell(item, column, index, globalIndex, expandedRows, toggleRow)
                              : renderCell(item, column, index, globalIndex, expandedRows, toggleRow);
                            
                            const isSticky = stickyColumns.includes(column.key);
                            const stickyClass = isSticky ? `sm:sticky ${getStickyPosition(column.key)} z-20` : '';
                            const alignClass = column.align === 'center' ? 'text-center' : column.align === 'right' ? 'text-right' : '';
                            const bgClass = globalIndex % 2 === 0 
                              ? 'bg-white dark:bg-gray-800 group-hover:bg-blue-50 dark:group-hover:bg-blue-900/20' 
                              : 'bg-gray-50 dark:bg-gray-800 group-hover:bg-blue-50 dark:group-hover:bg-blue-900/20';
                            const columnWidth = enableColumnResize ? getColumnWidth(column.key) : undefined;
                            
                            return (
                              <td
                                key={column.key}
                                className={`px-6 py-4 whitespace-nowrap text-sm text-black dark:text-white transition-colors duration-base ${stickyClass} ${alignClass} ${isSticky ? bgClass : ''}`}
                                style={columnWidth ? { width: `${columnWidth}px`, minWidth: `${columnWidth}px`, maxWidth: `${columnWidth}px` } : undefined}
                                role="gridcell"
                                aria-colindex={colIndex + 1}
                              >
                                {cellContent}
                              </td>
                            );
                          })}
                      </tr>
                      {isExpanded && renderExpandedRow && (
                        <tr 
                          className="bg-gray-50 dark:bg-gray-900/50 transition-all duration-300 ease-in-out"
                          role="row"
                          aria-rowindex={globalIndex + 3}
                        >
                          <td 
                            colSpan={visibleColumnsCount} 
                            className="px-0 py-0"
                            role="gridcell"
                          >
                            {renderExpandedRow(item, index, globalIndex)}
                          </td>
                        </tr>
                      )}
                    </React.Fragment>
                  );
                }}
                rowHeight={virtualScrollRowHeight}
                overscan={virtualScrollOverscan}
                className="divide-y divide-gray-300 dark:divide-gray-600"
              />
            ) : (
              <tbody className="divide-y divide-gray-300 dark:divide-gray-600">
                {displayData.length === 0 ? (
                  <tr role="row">
                    <td 
                      colSpan={orderedColumns.filter(col => isColumnVisible(col.key)).length} 
                      className="px-6 py-8 text-center text-gray-600 dark:text-gray-300"
                      role="gridcell"
                    >
                      <div className="text-sm">{searchValue || hasColumnFilters ? 'Inga resultat hittades.' : (emptyMessage || t('aria.noData'))}</div>
                      {(searchValue || hasColumnFilters) && (
                        <div className="text-xs mt-2 text-gray-500 dark:text-gray-400">
                          Försök ändra dina sökkriterier eller filter.
                        </div>
                      )}
                    </td>
                  </tr>
                ) : (
                  displayData.map((item, index) => {
                    const globalIndex = enablePagination ? startIndex - 1 + index : index;
                    const rowKey = getItemRowKey(item, globalIndex);
                    const rowBgClass = globalIndex % 2 === 0 
                      ? 'bg-white dark:bg-gray-800' 
                      : 'bg-gray-50 dark:bg-gray-800';
                    
                    const isFocused = focusedRowIndex === index;
                    const isExpanded = expandedRows[rowKey] || false;
                    const visibleColumnsCount = orderedColumns.filter(col => isColumnVisible(col.key)).length;
                    
                    return (
                      <React.Fragment key={rowKey}>
                        <tr 
                          data-row-index={index}
                          className={`group transition-all duration-normal ease-in-out hover:bg-blue-50 dark:hover:bg-blue-900/20 hover:shadow-md cursor-pointer transition-colors duration-base animate-fade-in ${rowBgClass} ${isFocused ? 'ring-2 ring-blue-500 dark:ring-blue-400 bg-blue-50 dark:bg-blue-900/30' : ''}`}
                          style={{ animationDelay: `${index * 10}ms` }}
                          onClick={() => handleRowClick(index)}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                              e.preventDefault();
                              const globalIndex = enablePagination ? startIndex - 1 + index : index;
                              const rowKey = getItemRowKey(item, globalIndex);
                              toggleRow(rowKey);
                            }
                          }}
                          tabIndex={0}
                          role="row"
                          aria-rowindex={globalIndex + 2}
                          aria-label={`Row ${globalIndex + 1}: ${'companyName' in item && typeof item.companyName === 'string' ? item.companyName : 'Item ' + (globalIndex + 1)}`}
                          aria-expanded={isExpanded}
                        >
                          {orderedColumns
                            .filter(col => isColumnVisible(col.key))
                            .map((column, colIndex) => {
                              const cellContent = column.renderCell
                                ? column.renderCell(item, column, index, globalIndex, expandedRows, toggleRow)
                                : renderCell(item, column, index, globalIndex, expandedRows, toggleRow);
                              
                              const isSticky = stickyColumns.includes(column.key);
                              const stickyClass = isSticky ? `sm:sticky ${getStickyPosition(column.key)} z-20` : '';
                              const alignClass = column.align === 'center' ? 'text-center' : column.align === 'right' ? 'text-right' : '';
                              const bgClass = globalIndex % 2 === 0 
                                ? 'bg-white dark:bg-gray-800 group-hover:bg-blue-50 dark:group-hover:bg-blue-900/20' 
                                : 'bg-gray-50 dark:bg-gray-800 group-hover:bg-blue-50 dark:group-hover:bg-blue-900/20';
                              const columnWidth = enableColumnResize ? getColumnWidth(column.key) : undefined;
                              
                              return (
                                <td
                                  key={column.key}
                                  className={`px-6 py-4 whitespace-nowrap text-sm text-black dark:text-white transition-colors duration-base ${stickyClass} ${alignClass} ${isSticky ? bgClass : ''}`}
                                  style={columnWidth ? { width: `${columnWidth}px`, minWidth: `${columnWidth}px`, maxWidth: `${columnWidth}px` } : undefined}
                                  role="gridcell"
                                  aria-colindex={colIndex + 1}
                                >
                                  {cellContent}
                                </td>
                              );
                            })}
                        </tr>
                        {isExpanded && renderExpandedRow && (
                          <tr 
                            className="bg-gray-50 dark:bg-gray-900/50 transition-all duration-300 ease-in-out"
                            role="row"
                            aria-rowindex={globalIndex + 3}
                          >
                            <td 
                              colSpan={visibleColumnsCount} 
                              className="px-0 py-0"
                              role="gridcell"
                            >
                              {renderExpandedRow(item, index, globalIndex)}
                            </td>
                          </tr>
                        )}
                      </React.Fragment>
                    );
                  })
                )}
              </tbody>
            )}
          </table>
        </div>
        
        {/* Pagination */}
        {enablePagination && totalPages > 1 && (
          <div className="rounded-b-lg overflow-visible">
            <Pagination
              currentPage={currentPage}
              totalPages={totalPages}
              totalItems={totalItems}
              itemsPerPage={actualItemsPerPage}
              startIndex={startIndex}
              endIndex={endIndex}
              onPageChange={goToPage}
              onNextPage={nextPage}
              onPreviousPage={previousPage}
              onFirstPage={goToFirstPage}
              onLastPage={goToLastPage}
            />
          </div>
        )}
        
        {/* Row count footer (for non-paginated tables) */}
        {!enablePagination && displayData.length > 0 && (
          <div className="px-4 py-3 text-sm text-gray-700 dark:text-gray-300 border-t border-gray-300 dark:border-gray-500">
            Visar {displayData.length} {displayData.length === 1 ? 'rad' : 'rader'} av {displayData.length} totalt
          </div>
        )}
      </div>
      {enableShareableLink && currentUser && viewId && (
        <ShareableLinkModal
          isOpen={shareableLinkModalOpen}
          onClose={() => setShareableLinkModalOpen(false)}
          filterState={filterValues}
          viewId={viewId}
          tableId={tableId}
          sortConfig={sortConfig.key ? { key: String(sortConfig.key), direction: sortConfig.direction } : undefined}
        />
      )}
    </>
  );
}


```

## `src/components/BaseTableToolbar.tsx`

```tsx
/**
 * Toolbar for BaseTable: search, column visibility, export, print, share, custom actions.
 * Refactored out of BaseTable for maintainability (refactor-only, no behavior change).
 */

import React, { ReactNode } from 'react';
import { useTranslation } from 'react-i18next';
import TableSearchBar from './TableSearchBar';
import ColumnVisibilityToggle from './ColumnVisibilityToggle';
import Button from './ui/Button';

export interface BaseTableToolbarProps<T = unknown> {
  searchValue: string;
  onSearchChange: (value: string) => void;
  totalRows: number;
  filteredRows: number;
  searchPlaceholder?: string;
  columns: Array<{ key: string; label: string }>;
  columnVisibility: Record<string, boolean>;
  onToggleColumn: (key: string) => void;
  onShowAll: () => void;
  onHideAll: () => void;
  onResetToDefaults: () => void;
  isColumnVisible: (key: string) => boolean;
  enableExport?: boolean;
  sortedRowCount: number;
  onExportCsv: () => void;
  onExportExcel: () => void;
  enablePrint?: boolean;
  onPrint: () => void;
  enableShareableLink?: boolean;
  hasCurrentUser: boolean;
  viewId?: string;
  onOpenShareableLink: () => void;
  headerActions?: ReactNode | ((api: { toggleColumn: (key: string) => void; isColumnVisible: (key: string) => boolean }) => ReactNode);
}

export default function BaseTableToolbar<T = unknown>({
  searchValue,
  onSearchChange,
  totalRows,
  filteredRows,
  searchPlaceholder = 'Sök...',
  columns,
  columnVisibility,
  onToggleColumn,
  onShowAll,
  onHideAll,
  onResetToDefaults,
  isColumnVisible,
  enableExport = false,
  sortedRowCount,
  onExportCsv,
  onExportExcel,
  enablePrint = false,
  onPrint,
  enableShareableLink = false,
  hasCurrentUser,
  viewId,
  onOpenShareableLink,
  headerActions,
}: BaseTableToolbarProps<T>) {
  const { t } = useTranslation();

  return (
    <div className="bg-white dark:bg-gray-800 border-b border-gray-300 dark:border-gray-500 px-4 py-3 flex items-center justify-between gap-4 flex-shrink-0">
      <div className="flex-1">
        <TableSearchBar
          searchValue={searchValue}
          onSearchChange={onSearchChange}
          totalRows={totalRows}
          filteredRows={filteredRows}
          placeholder={searchPlaceholder}
        />
      </div>
      <div className="flex items-center gap-2">
        <ColumnVisibilityToggle
          columns={columns}
          columnVisibility={columnVisibility}
          onToggleColumn={onToggleColumn}
          onShowAll={onShowAll}
          onHideAll={onHideAll}
          onReset={onResetToDefaults}
          isColumnVisible={isColumnVisible}
        />
        {enableExport && sortedRowCount > 0 && (
          <div className="flex items-center gap-1">
            <Button
              variant="outline"
              size="sm"
              onClick={onExportCsv}
              leftIcon={
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
              }
              aria-label={t('export.csv', 'Exportera till CSV')}
              title={t('export.csv', 'Exportera till CSV')}
            >
              CSV
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={onExportExcel}
              leftIcon={
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
              }
              aria-label={t('export.excel', 'Exportera till Excel')}
              title={t('export.excel', 'Exportera till Excel')}
            >
              Excel
            </Button>
          </div>
        )}
        {enablePrint && (
          <Button
            variant="outline"
            size="sm"
            onClick={onPrint}
            leftIcon={
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m2 4h6a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2zm8-12V5a2 2 0 00-2-2H9a2 2 0 00-2 2v4h10z" />
              </svg>
            }
            aria-label={t('print.print', 'Skriv ut')}
            title={t('print.print', 'Skriv ut')}
          >
            {t('print.print', 'Skriv ut')}
          </Button>
        )}
        {enableShareableLink && hasCurrentUser && viewId && (
          <Button
            variant="outline"
            size="sm"
            onClick={onOpenShareableLink}
            leftIcon={
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
              </svg>
            }
            aria-label={t('shareableLinks.share', 'Share Link')}
            title={t('shareableLinks.share', 'Share Link')}
          >
            {t('shareableLinks.share', 'Share')}
          </Button>
        )}
        {typeof headerActions === 'function' ? headerActions({ toggleColumn: onToggleColumn, isColumnVisible }) : headerActions}
      </div>
    </div>
  );
}

```

## `src/components/Breadcrumbs.tsx`

```tsx
import { useTranslation } from 'react-i18next';
import { ViewId } from '../types/navigation';

interface BreadcrumbItem {
  id: ViewId | 'home' | 'category';
  label: string;
  isCategory?: boolean; // True if it's a category, not a clickable view
}

interface BreadcrumbsProps {
  activeView: ViewId;
  onViewChange: (viewId: ViewId) => void;
}

/** Maps each ViewId to its breadcrumb label (single level: no parent). */
function getViewLabel(viewId: ViewId, t: (key: string) => string): string {
  const labels: Partial<Record<ViewId, string>> = {
    'score': t('navigation.score'),
    'score-board': t('navigation.scoreBoard'),
    'entry-exit-benjamin-graham': t('navigation.benjaminGraham'),
    'entry-exit-entry2': t('navigation.entry2'),
    'entry-exit-exit1': t('navigation.exit1'),
    'entry-exit-exit2': t('navigation.exit2'),
    'entry-exit-irr1': t('navigation.irr1'),
    'entry-exit-iv-fcf': t('navigation.ivFcf'),
    'fundamental-pe-industry': t('navigation.peIndustry'),
    'fundamental-current-ratio': t('navigation.currentRatio'),
    'fundamental-cash-sdebt': t('navigation.cashSdebt'),
    'fundamental-ro40-cy': t('navigation.ro40Cy'),
    'fundamental-ro40-f1': t('navigation.ro40F1'),
    'fundamental-ro40-f2': t('navigation.ro40F2'),
    'threshold-industry': t('navigation.thresholdIndustry'),
    'personal-portfolio': t('navigation.personalPortfolio'),
    'admin': t('navigation.userManagement'),
    'teknikal-tachart': t('navigation.tachart'),
  };
  return labels[viewId] ?? viewId;
}

export default function Breadcrumbs({ activeView, onViewChange }: BreadcrumbsProps) {
  const { t } = useTranslation();

  const getBreadcrumbs = (): BreadcrumbItem[] => {
    const label = getViewLabel(activeView, t);
    return [{ id: activeView, label }];
  };

  const breadcrumbs = getBreadcrumbs();

  if (breadcrumbs.length === 0) {
    return null;
  }

  return (
    <nav className="px-3 sm:px-4 lg:px-6 py-3 sm:py-4 bg-white dark:bg-gray-800 border-b border-gray-300 dark:border-gray-500" aria-label="Breadcrumb">
      <ol className="flex items-center space-x-2 text-sm">
        {breadcrumbs.map((crumb, index) => {
          const isLast = index === breadcrumbs.length - 1;

          return (
            <li key={crumb.id} className="flex items-center">
              {index > 0 && (
                <svg
                  className="w-4 h-4 text-gray-600 dark:text-gray-300 mx-2"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M9 5l7 7-7 7"
                  />
                </svg>
              )}
              {isLast ? (
                <span className="text-black dark:text-white font-semibold inline-flex items-center gap-1.5" aria-current="page">
                  {crumb.label}
                </span>
              ) : crumb.isCategory ? (
                <span className="text-gray-600 dark:text-gray-300">
                  {crumb.label}
                </span>
              ) : (
                <button
                  onClick={() => onViewChange(crumb.id as ViewId)}
                  className="text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100 transition-all duration-200 hover:underline hover:scale-105 active:scale-95 cursor-pointer font-medium py-2 px-1 -mx-1 min-h-[44px] touch-manipulation inline-flex items-center gap-1.5"
                >
                  {crumb.label}
                </button>
              )}
            </li>
          );
        })}
      </ol>
    </nav>
  );
}

```

## `src/components/ColumnFilterMenu.tsx`

```tsx
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { useDebounce } from '../hooks/useDebounce';
import { ColumnFilter, FilterOperator } from '../hooks/useColumnFilters';
import { UniqueValue } from '../hooks/useColumnUniqueValues';
import { SortConfig } from '../hooks/useTableSort';

interface ColumnFilterMenuProps<T> {
  columnKey: string;
  columnLabel: string;
  isOpen: boolean;
  onClose: () => void;
  filter: ColumnFilter | undefined;
  onFilterChange: (filter: ColumnFilter | null) => void;
  sortConfig: SortConfig<T>;
  onSort: (key: string, direction: 'asc' | 'desc') => void;
  uniqueValues: UniqueValue[];
  triggerRef?: React.RefObject<HTMLElement>;
}

const FILTER_OPERATORS: { value: FilterOperator; label: string }[] = [
  { value: 'equals', label: 'Lika med' },
  { value: 'notEquals', label: 'Inte lika med' },
  { value: 'greaterThan', label: 'Större än' },
  { value: 'lessThan', label: 'Mindre än' },
  { value: 'greaterThanOrEqual', label: 'Större än eller lika med' },
  { value: 'lessThanOrEqual', label: 'Mindre än eller lika med' },
  { value: 'contains', label: 'Innehåller' },
];

export default function ColumnFilterMenu<T extends Record<string, unknown>>({
  columnKey,
  columnLabel,
  isOpen,
  onClose,
  filter,
  onFilterChange,
  sortConfig,
  onSort,
  uniqueValues,
  triggerRef,
}: ColumnFilterMenuProps<T>) {
  const { t } = useTranslation();
  const menuRef = useRef<HTMLDivElement>(null);
  const [searchValue, setSearchValue] = useState('');
  const [showValueFilter, setShowValueFilter] = useState(false);
  const [showConditionFilter, setShowConditionFilter] = useState(false);
  const [menuPosition, setMenuPosition] = useState<{ top: number; left: number; flipped: boolean }>({ top: 0, left: 0, flipped: false });
  const debouncedSearchValue = useDebounce(searchValue, 300);

  // Calculate menu position based on trigger element
  useEffect(() => {
    if (isOpen && triggerRef?.current) {
      const calculatePosition = () => {
        if (!triggerRef.current) return;
        
        const triggerRect = triggerRef.current.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;
        
        // Get menu dimensions (use estimated height if not yet rendered)
        const menuWidth = 256; // w-64 = 256px
        const estimatedMenuHeight = 500; // max-h-[500px]
        const actualMenuHeight = menuRef.current?.getBoundingClientRect().height || estimatedMenuHeight;
        
        // Default: position below trigger
        let top = triggerRect.bottom + 4; // 4px gap (mt-1 equivalent)
        let left = triggerRect.left;
        let flipped = false;
        
        // Check if menu would extend below viewport
        const spaceBelow = viewportHeight - triggerRect.bottom;
        const spaceAbove = triggerRect.top;
        
        // If not enough space below but more space above, flip upward
        if (spaceBelow < actualMenuHeight && spaceAbove > spaceBelow) {
          top = triggerRect.top - actualMenuHeight - 4;
          flipped = true;
        }
        
        // Ensure menu doesn't go off-screen horizontally
        if (left + menuWidth > viewportWidth) {
          left = viewportWidth - menuWidth - 8; // 8px margin from edge
        }
        if (left < 8) {
          left = 8; // 8px margin from edge
        }
        
        setMenuPosition({ top, left, flipped });
      };
      
      // Calculate position after a brief delay to ensure menu is rendered
      const timeoutId = setTimeout(() => {
        calculatePosition();
      }, 0);
      
      // Also calculate on next frame to get accurate dimensions
      requestAnimationFrame(() => {
        calculatePosition();
      });
      
      // Recalculate on scroll (for sticky headers)
      const handleScroll = () => {
        calculatePosition();
      };
      
      // Recalculate on window resize
      const handleResize = () => {
        calculatePosition();
      };
      
      window.addEventListener('scroll', handleScroll, true); // Use capture to catch all scrolls
      window.addEventListener('resize', handleResize);
      
      return () => {
        clearTimeout(timeoutId);
        window.removeEventListener('scroll', handleScroll, true);
        window.removeEventListener('resize', handleResize);
      };
    }
  }, [isOpen, triggerRef, showValueFilter, showConditionFilter]); // Recalculate when filter sections expand/collapse

  // Reset state when menu closes
  useEffect(() => {
    if (!isOpen) {
      setSearchValue('');
      setShowValueFilter(false);
      setShowConditionFilter(false);
    }
  }, [isOpen]);

  // Click outside handler
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (
        menuRef.current &&
        !menuRef.current.contains(event.target as Node) &&
        triggerRef?.current &&
        !triggerRef.current.contains(event.target as Node)
      ) {
        onClose();
      }
    }

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
      return () => {
        document.removeEventListener('mousedown', handleClickOutside);
      };
    }
  }, [isOpen, onClose, triggerRef]);

  // Escape key handler
  useEffect(() => {
    function handleEscape(event: KeyboardEvent) {
      if (event.key === 'Escape' && isOpen) {
        onClose();
      }
    }

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      return () => {
        document.removeEventListener('keydown', handleEscape);
      };
    }
  }, [isOpen, onClose]);

  // Filter unique values based on search
  const filteredValues = React.useMemo(() => {
    if (!debouncedSearchValue.trim()) {
      return uniqueValues;
    }
    const searchLower = debouncedSearchValue.toLowerCase();
    return uniqueValues.filter((uv) =>
      uv.displayValue.toLowerCase().includes(searchLower)
    );
  }, [uniqueValues, debouncedSearchValue]);

  // Get selected values for value filter
  const selectedValues = filter?.type === 'values' ? filter.selectedValues || [] : [];

  // Handle value selection toggle
  const handleValueToggle = useCallback((value: string | number | boolean | null) => {
    const currentValues = selectedValues;
    const isSelected = currentValues.some((v) => {
      if (v === null && value === null) return true;
      if (v === null || value === null) return false;
      return String(v).toLowerCase() === String(value).toLowerCase();
    });

    let newValues: (string | number | boolean | null)[];
    if (isSelected) {
      newValues = currentValues.filter((v) => {
        if (v === null && value === null) return false;
        if (v === null || value === null) return true;
        return String(v).toLowerCase() !== String(value).toLowerCase();
      });
    } else {
      newValues = [...currentValues, value];
    }

    if (newValues.length === 0) {
      onFilterChange(null);
    } else {
      onFilterChange({
        columnKey,
        type: 'values',
        selectedValues: newValues,
      });
    }
  }, [selectedValues, columnKey, onFilterChange]);

  // Handle select all / clear all
  const handleSelectAll = useCallback(() => {
    if (selectedValues.length === filteredValues.length) {
      // Clear all
      onFilterChange(null);
    } else {
      // Select all
      onFilterChange({
        columnKey,
        type: 'values',
        selectedValues: filteredValues.map((uv) => uv.value),
      });
    }
  }, [selectedValues.length, filteredValues, columnKey, onFilterChange]);

  // Handle condition filter change
  const handleConditionChange = useCallback((operator: FilterOperator, value: string | number) => {
    if (!value || value === '') {
      onFilterChange(null);
    } else {
      onFilterChange({
        columnKey,
        type: 'condition',
        conditionOperator: operator,
        conditionValue: value,
      });
    }
  }, [columnKey, onFilterChange]);

  // Handle sort
  const handleSort = useCallback((direction: 'asc' | 'desc') => {
    onSort(columnKey, direction);
    onClose();
  }, [columnKey, onSort, onClose]);

  // Clear filter
  const handleClearFilter = useCallback(() => {
    onFilterChange(null);
  }, [onFilterChange]);

  const isColumnSorted = sortConfig.key === columnKey;
  const hasActiveFilter = filter && filter.type !== 'none';

  if (!isOpen) return null;

  return (
    <div
      ref={menuRef}
      className="fixed w-64 bg-white dark:bg-gray-800 rounded-md shadow-lg border border-gray-200 dark:border-gray-500 z-[100] max-h-[500px] overflow-hidden flex flex-col animate-fade-in-up transition-all duration-200"
      style={{ 
        top: `${menuPosition.top}px`,
        left: `${menuPosition.left}px`
      }}
      role="menu"
      aria-label={`Filter och sortering för ${columnLabel}`}
    >
      {/* Sort Section */}
      <div className="border-b border-gray-200 dark:border-gray-500">
        <div className="px-3 py-2 text-xs font-semibold text-gray-700 dark:text-gray-300 uppercase tracking-wider">
          Sortera
        </div>
        <button
          onClick={() => handleSort('asc')}
          className={`w-full px-3 py-2 text-left text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors flex items-center justify-between ${
            isColumnSorted && sortConfig.direction === 'asc' ? 'bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-400' : ''
          }`}
          role="menuitem"
        >
          <span>Sortera A till Ö</span>
          {isColumnSorted && sortConfig.direction === 'asc' && (
            <span className="text-blue-600 dark:text-blue-400">✓</span>
          )}
        </button>
        <button
          onClick={() => handleSort('desc')}
          className={`w-full px-3 py-2 text-left text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors flex items-center justify-between ${
            isColumnSorted && sortConfig.direction === 'desc' ? 'bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-400' : ''
          }`}
          role="menuitem"
        >
          <span>Sortera Ö till A</span>
          {isColumnSorted && sortConfig.direction === 'desc' && (
            <span className="text-blue-600 dark:text-blue-400">✓</span>
          )}
        </button>
        <button
          onClick={() => {}}
          className="w-full px-3 py-2 text-left text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors opacity-50 cursor-not-allowed"
          role="menuitem"
          disabled
        >
          Sortera efter färg
        </button>
      </div>

      {/* Filter Section */}
      <div className="flex-1 overflow-y-auto">
        <div className="px-3 py-2 text-xs font-semibold text-gray-700 dark:text-gray-300 uppercase tracking-wider border-b border-gray-200 dark:border-gray-500">
          Filtrera
        </div>

        {/* Filter by values */}
        <div>
          <button
            onClick={() => setShowValueFilter(!showValueFilter)}
            className={`w-full px-3 py-2 text-left text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors flex items-center justify-between ${
              filter?.type === 'values' ? 'bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-400' : ''
            }`}
            role="menuitem"
          >
            <span>Filtrera efter värden</span>
            <svg
              className={`w-4 h-4 transition-transform duration-200 ${showValueFilter ? 'rotate-90' : ''}`}
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
          </button>

          {showValueFilter && (
            <div className="border-t border-gray-200 dark:border-gray-500 bg-gray-50 dark:bg-gray-900/50">
              {/* Search input */}
              <div className="p-2">
                <input
                  type="text"
                  value={searchValue}
                  onChange={(e) => setSearchValue(e.target.value)}
                  placeholder="Sök värden..."
                  className="w-full px-2 py-1.5 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-black dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  onClick={(e) => e.stopPropagation()}
                />
              </div>

              {/* Select all / Clear */}
              <div className="px-2 pb-2">
                <button
                  onClick={handleSelectAll}
                  className="text-xs text-blue-600 dark:text-blue-400 hover:underline"
                >
                  {selectedValues.length === filteredValues.length
                    ? 'Rensa alla'
                    : `Markera alla ${filteredValues.length}`}
                </button>
              </div>

              {/* Value list with checkboxes */}
              <div className="max-h-64 overflow-y-auto border-t border-gray-200 dark:border-gray-500">
                {filteredValues.length === 0 ? (
                  <div className="px-3 py-2 text-sm text-gray-500 dark:text-gray-400 text-center">
                    Inga värden hittades
                  </div>
                ) : (
                  filteredValues.map((uniqueValue) => {
                    const isSelected = selectedValues.some((v) => {
                      if (v === null && uniqueValue.value === null) return true;
                      if (v === null || uniqueValue.value === null) return false;
                      return String(v).toLowerCase() === String(uniqueValue.value).toLowerCase();
                    });

                    return (
                      <label
                        key={`${uniqueValue.value}-${uniqueValue.count}`}
                        className="flex items-center px-3 py-1.5 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer"
                      >
                        <input
                          type="checkbox"
                          checked={isSelected}
                          onChange={() => handleValueToggle(uniqueValue.value)}
                          className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 dark:bg-gray-800 dark:border-gray-600"
                          onClick={(e) => e.stopPropagation()}
                        />
                        <span className="ml-2 text-sm text-gray-700 dark:text-gray-300 flex-1">
                          {uniqueValue.displayValue}
                        </span>
                        <span className="text-xs text-gray-500 dark:text-gray-400">
                          ({uniqueValue.count})
                        </span>
                      </label>
                    );
                  })
                )}
              </div>
            </div>
          )}
        </div>

        {/* Filter by condition */}
        <div>
          <button
            onClick={() => setShowConditionFilter(!showConditionFilter)}
            className={`w-full px-3 py-2 text-left text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors flex items-center justify-between ${
              filter?.type === 'condition' ? 'bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-400' : ''
            }`}
            role="menuitem"
          >
            <span>Filtrera efter villkor</span>
            <svg
              className={`w-4 h-4 transition-transform duration-200 ${showConditionFilter ? 'rotate-90' : ''}`}
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
          </button>

          {showConditionFilter && (
            <div className="border-t border-gray-200 dark:border-gray-500 bg-gray-50 dark:bg-gray-900/50 p-2 space-y-2">
              <select
                value={filter?.type === 'condition' ? filter.conditionOperator || 'equals' : 'equals'}
                onChange={(e) => {
                  const operator = e.target.value as FilterOperator;
                  const currentValue = filter?.type === 'condition' ? filter.conditionValue : '';
                  if (currentValue) {
                    handleConditionChange(operator, currentValue);
                  }
                }}
                className="w-full px-2 py-1.5 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                onClick={(e) => e.stopPropagation()}
              >
                {FILTER_OPERATORS.map((op) => (
                  <option key={op.value} value={op.value}>
                    {op.label}
                  </option>
                ))}
              </select>
              <input
                type="text"
                value={filter?.type === 'condition' ? String(filter.conditionValue || '') : ''}
                onChange={(e) => {
                  const operator = filter?.type === 'condition' ? filter.conditionOperator || 'equals' : 'equals';
                  handleConditionChange(operator, e.target.value);
                }}
                placeholder="Värde..."
                className="w-full px-2 py-1.5 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-black dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                onClick={(e) => e.stopPropagation()}
              />
            </div>
          )}
        </div>

        {/* Filter by color (disabled for now) */}
        <button
          onClick={() => {}}
          className="w-full px-3 py-2 text-left text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors opacity-50 cursor-not-allowed"
          role="menuitem"
          disabled
        >
          Filtrera efter färg
        </button>
      </div>

      {/* Footer with clear button */}
      {hasActiveFilter && (
        <div className="border-t border-gray-200 dark:border-gray-500 p-2">
          <button
            onClick={handleClearFilter}
            className="w-full px-3 py-1.5 text-sm text-blue-600 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded transition-colors"
          >
            Rensa filter
          </button>
        </div>
      )}
    </div>
  );
}

```

## `src/components/ColumnTooltip.tsx`

```tsx
import { useState, useRef, useEffect, useId } from 'react';
import { ColumnMetadata } from '../types/columnMetadata';

interface ColumnTooltipProps {
  metadata: ColumnMetadata;
  children: React.ReactNode;
}

export default function ColumnTooltip({ metadata, children }: ColumnTooltipProps) {
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const tooltipRef = useRef<HTMLDivElement>(null);
  const triggerRef = useRef<HTMLDivElement>(null);
  const tooltipId = useId();

  useEffect(() => {
    if (isVisible && triggerRef.current) {
      const triggerRect = triggerRef.current.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Initial positioning (will be adjusted after tooltip renders)
      let top = triggerRect.bottom + 8;
      let left = triggerRect.left + triggerRect.width / 2;

      // Adjust if tooltip would go off screen horizontally
      const estimatedWidth = 320;
      if (left - estimatedWidth / 2 < 8) {
        left = 8 + estimatedWidth / 2;
      } else if (left + estimatedWidth / 2 > viewportWidth - 8) {
        left = viewportWidth - 8 - estimatedWidth / 2;
      }

      // If tooltip would go below viewport, show above instead
      const estimatedHeight = 200;
      if (top + estimatedHeight > viewportHeight - 8) {
        top = triggerRect.top - estimatedHeight - 8;
        if (top < 8) {
          top = 8;
        }
      }

      setPosition({ top, left });
    }
  }, [isVisible]);

  const handleMouseEnter = () => {
    setIsVisible(true);
  };

  const handleMouseLeave = () => {
    setIsVisible(false);
  };

  return (
    <>
      <div
        ref={triggerRef}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        className="relative"
        aria-describedby={isVisible ? tooltipId : undefined}
      >
        {children}
      </div>
      {isVisible && (
        <div
          ref={tooltipRef}
          id={tooltipId}
          role="tooltip"
          className="fixed z-50 bg-gray-900 dark:bg-gray-800 text-white dark:text-gray-100 rounded-lg shadow-xl p-4 max-w-sm border border-gray-700"
          style={{
            top: `${position.top}px`,
            left: `${position.left}px`,
            transform: 'translateX(-50%)',
            pointerEvents: 'none',
          }}
        >
          <div className="space-y-2 text-sm">
            <div>
              <span className="font-semibold text-blue-400">Datakälla:</span>
              <p className="mt-1 text-gray-300">{metadata.dataSource}</p>
            </div>
            {metadata.formula && (
              <div>
                <span className="font-semibold text-green-400">Formel:</span>
                <p className="mt-1 text-gray-300">{metadata.formula}</p>
              </div>
            )}
            {metadata.conditions && metadata.conditions.length > 0 && (
              <div>
                <span className="font-semibold text-yellow-400">Villkor:</span>
                <ul className="mt-1 list-disc list-inside space-y-1 text-gray-300">
                  {metadata.conditions.map((condition, index) => (
                    <li key={index} className="text-xs">{condition}</li>
                  ))}
                </ul>
              </div>
            )}
          </div>
        </div>
      )}
    </>
  );
}


```

## `src/components/ColumnVisibilityToggle.tsx`

```tsx
import React, { useState, useRef, useEffect } from 'react';
import { ColumnConfig } from '../hooks/useColumnVisibility';

interface ColumnVisibilityToggleProps {
  columns: ColumnConfig[];
  columnVisibility: Record<string, boolean>;
  onToggleColumn: (columnKey: string) => void;
  onShowAll: () => void;
  onHideAll: () => void;
  onReset: () => void;
  isColumnVisible: (columnKey: string) => boolean;
}

export default function ColumnVisibilityToggle({
  columns,
  columnVisibility,
  onToggleColumn,
  onShowAll,
  onHideAll,
  onReset,
  isColumnVisible,
}: ColumnVisibilityToggleProps) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  // Close dropdown when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    }

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen]);

  const visibleCount = columns.filter(col => isColumnVisible(col.key)).length;
  const totalCount = columns.length;

  return (
    <div className="relative" ref={dropdownRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="px-3 sm:px-3 py-3 sm:py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-500 rounded-md hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200 hover:shadow-md hover:scale-105 active:scale-95 flex items-center space-x-2 min-h-[44px] touch-manipulation"
        title="Välj kolumner att visa"
      >
        <svg
          className="w-4 h-4"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M4 6h16M4 12h16M4 18h16"
          />
        </svg>
        <span>Kolumner</span>
        <span className="text-xs text-gray-500 dark:text-gray-300">
          ({visibleCount}/{totalCount})
        </span>
        <svg
          className={`w-4 h-4 transition-transform duration-300 ease-in-out ${isOpen ? 'transform rotate-180' : ''}`}
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M19 9l-7 7-7-7"
          />
        </svg>
      </button>

      {isOpen && (
        <div className="absolute right-0 mt-2 w-64 bg-white dark:bg-gray-800 rounded-md shadow-lg border border-gray-200 dark:border-gray-500 z-50 max-h-96 overflow-y-auto animate-fade-in-up transition-all duration-200">
          <div className="p-3 border-b border-gray-200 dark:border-gray-500">
            <div className="flex items-center justify-between mb-2">
              <h3 className="text-sm font-semibold text-black dark:text-white">
                Kolumnvisning
              </h3>
              <button
                onClick={() => setIsOpen(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-all duration-200 hover:scale-110 active:scale-95 p-2 min-h-[44px] min-w-[44px] touch-manipulation flex items-center justify-center"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            <div className="flex space-x-2">
              <button
                onClick={onShowAll}
                className="text-xs sm:text-xs px-3 py-2 sm:px-2 sm:py-1 text-blue-700 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded transition-all duration-200 hover:scale-105 active:scale-95 min-h-[44px] sm:min-h-0 touch-manipulation inline-flex items-center gap-1.5 sm:gap-1"
              >
                <svg className="w-3.5 h-3.5 sm:w-3 sm:h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
                <span>Visa alla</span>
              </button>
              <button
                onClick={onHideAll}
                className="text-xs sm:text-xs px-3 py-2 sm:px-2 sm:py-1 text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 rounded transition-all duration-200 hover:scale-105 active:scale-95 min-h-[44px] sm:min-h-0 touch-manipulation inline-flex items-center gap-1.5 sm:gap-1"
              >
                <svg className="w-3.5 h-3.5 sm:w-3 sm:h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                </svg>
                <span>Dölj alla</span>
              </button>
              <button
                onClick={onReset}
                className="text-xs sm:text-xs px-3 py-2 sm:px-2 sm:py-1 text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 rounded transition-all duration-200 hover:scale-105 active:scale-95 min-h-[44px] sm:min-h-0 touch-manipulation inline-flex items-center gap-1.5 sm:gap-1"
              >
                <svg className="w-3.5 h-3.5 sm:w-3 sm:h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                <span>Återställ</span>
              </button>
            </div>
          </div>
          <div className="p-2">
            {columns.map((column) => {
              const isVisible = isColumnVisible(column.key);
              const isRequired = column.required === true;

              return (
                <label
                  key={column.key}
                  className={`flex items-center px-2 py-2 rounded-md hover:bg-gray-50 dark:hover:bg-gray-700 cursor-pointer transition-all duration-200 hover:scale-[1.02] active:scale-95 ${
                    isRequired ? 'opacity-60' : ''
                  }`}
                >
                  <input
                    type="checkbox"
                    checked={isVisible}
                    onChange={() => onToggleColumn(column.key)}
                    disabled={isRequired}
                    className="w-4 h-4 text-blue-700 border-gray-300 rounded focus:ring-blue-500 focus:ring-2 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 hover:scale-110 cursor-pointer"
                  />
                  <span className="ml-2 text-sm text-gray-700 dark:text-gray-300 flex-1">
                    {column.label}
                  </span>
                  {isRequired && (
                    <span className="text-xs text-gray-500 dark:text-gray-300">(krävs)</span>
                  )}
                </label>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
}


```

## `src/components/CONDITIONS_SYSTEM.md`

```markdown
# Conditions System - Dokumentation

## Översikt

Conditions-systemet är en dokumentations- och informationskomponent som ger användare detaljerad information om hur data i Stock Score-applikationen är strukturerad, beräknad och formaterad. Systemet består av metadata som beskriver datakällor, formler och villkor för varje kolumn i varje tabell.

## Systemarkitektur

### 1. Datastruktur

Systemet bygger på en hierarkisk datastruktur definierad i TypeScript:

```typescript
// types/columnMetadata.ts
export interface ColumnMetadata {
  columnKey: string;           // Unik identifierare för kolumnen
  dataSource: string;          // Varifrån data kommer
  formula?: string;           // Beräkningsformel (valfritt)
  conditions?: string[];      // Lista över villkor och regler
  description?: string;       // Ytterligare beskrivning (valfritt)
}

export interface TableMetadata {
  tableId: string;            // Unik identifierare för tabellen
  columns: ColumnMetadata[];   // Lista över kolumnmetadata
}
```

### 2. Metadata-konfiguration

All metadata definieras centralt i `src/config/tableMetadata.ts`. Denna fil innehåller metadata för alla tabeller i systemet:

- **score** - Huvudpoängtabellen
- **score-board** - Detaljerad poängtabell med alla metrics
- **benjamin-graham** - Benjamin Graham-värderingar
- **pe-industry** - P/E-industri-medianer
- **threshold-industry** - Tröskelvärden per industri
- **entry-exit-entry1** - Manuella entry/exit-värden
- **sma-100** - SMA-tekniska indikatorer

Varje tabell har en `tableId` som används för att hämta rätt metadata.

### 3. Komponenter

#### ConditionsModal (`src/components/ConditionsModal.tsx`)

En modal-dialog som visar fullständig information om alla kolumner i en tabell.

**Funktioner:**
- Visar modal med scrollbar för långa listor
- Visar för varje kolumn:
  - Datakälla (dataSource)
  - Formel (formula) - om den finns
  - Villkor (conditions) - lista över alla villkor
- Stängs med Escape-tangent eller stäng-knapp
- Responsiv design med dark mode-stöd
- Animeringar och hover-effekter

**Props:**
```typescript
interface ConditionsModalProps {
  isOpen: boolean;              // Om modalen är öppen
  onClose: () => void;         // Callback för att stänga
  metadata: TableMetadata | null; // Metadata för tabellen
  pageName: string;            // Namn på sidan/tabellen
}
```

#### ConditionsSidebar (`src/components/ConditionsSidebar.tsx`)

En kollapsbar sidebar-komponent i huvudnavigeringen som ger snabb åtkomst till conditions för olika vyer.

**Funktioner:**
- Expandable/collapsible meny
- Listar alla tillgängliga vyer med metadata
- Visar endast vyer som har metadata definierade
- Inaktiverar länkar för vyer utan metadata
- Mappar ViewId till tableId för att hitta rätt metadata

**Props:**
```typescript
interface ConditionsSidebarProps {
  onOpenModal: (viewId: ViewId) => void; // Callback när användare klickar
}
```

**ViewId till TableId-mappning:**
```typescript
'score' → 'score'
'score-board' → 'score-board'
'entry-exit-benjamin-graham' → 'benjamin-graham'
'fundamental-pe-industry' → 'pe-industry'
'entry-exit-entry1' → 'entry-exit-entry1'
'threshold-industry' → 'threshold-industry'
```

#### ColumnTooltip (`src/components/ColumnTooltip.tsx`)

En tooltip-komponent som visas när användaren hovrar över kolumnnamn i tabellerna.

**Funktioner:**
- Visar snabb information om en specifik kolumn
- Visar datakälla, formel och villkor
- Automatisk positionering (undviker viewport-kanter)
- Visas ovanför eller under beroende på plats
- Stängs automatiskt när musen lämnar

**Props:**
```typescript
interface ColumnTooltipProps {
  metadata: ColumnMetadata;    // Metadata för kolumnen
  children: React.ReactNode;   // Element som triggar tooltip
}
```

### 4. Integration i Applikationen

#### App.tsx Integration

Huvudapplikationen hanterar state för conditions-modal:

```typescript
const [conditionsModalOpen, setConditionsModalOpen] = useState(false);
const [selectedViewForModal, setSelectedViewForModal] = useState<ViewId | null>(null);

const handleOpenConditionsModal = (viewId: ViewId) => {
  setSelectedViewForModal(viewId);
  setConditionsModalOpen(true);
};

const handleCloseConditionsModal = () => {
  setConditionsModalOpen(false);
  setSelectedViewForModal(null);
};
```

Metadata hämtas baserat på vald vy:
```typescript
const metadata = selectedViewForModal 
  ? getTableMetadata(getTableId(selectedViewForModal))
  : null;
```

#### Sidebar Integration

Sidebar-komponenten inkluderar ConditionsSidebar:
```tsx
<ConditionsSidebar onOpenModal={handleOpenConditionsModal} />
```

## Dataflöde

1. **Användare klickar på "Villkor" i sidebar**
   - ConditionsSidebar visar expanderad meny
   - Användare väljer en vy (t.ex. "SCORE BOARD")

2. **ConditionsSidebar anropar callback**
   - `onOpenModal(viewId)` anropas med vald ViewId

3. **App.tsx hanterar öppning**
   - `handleOpenConditionsModal(viewId)` sätter state
   - ViewId mappas till tableId
   - Metadata hämtas från `tableMetadata.ts`

4. **ConditionsModal renderas**
   - Tar emot metadata som prop
   - Visar alla kolumner med deras information
   - Användare kan scrolla och läsa information

5. **Användare stänger modal**
   - Klickar på stäng-knapp eller Escape
   - `handleCloseConditionsModal()` rensar state

## Användningsfall

### 1. För användare
- **Förstå datakällor**: Se varifrån data kommer (Google Sheets, beräkningar, etc.)
- **Förstå formler**: Se hur värden beräknas
- **Förstå villkor**: Se filtreringsregler, färgkodning, formatering

### 2. För utvecklare
- **Dokumentation**: Metadata fungerar som levande dokumentation
- **Underhåll**: Centraliserad plats för att uppdatera beskrivningar
- **Kvalitetssäkring**: Tydlig dokumentation av affärslogik

## Exempel på Conditions

### Enkel kolumn (companyName)
```typescript
{
  columnKey: 'companyName',
  dataSource: 'Dashboard sheet, kolumn "Company Name"',
  conditions: [
    'Filtrera bort rader där Company Name är N/A eller tomt',
    'Filtrera bort rader där Ticker är N/A (Dashboard regel)'
  ]
}
```

### Kolumn med formel (pe)
```typescript
{
  columnKey: 'pe',
  dataSource: 'Dashboard sheet, kolumn "P/E"',
  formula: 'Median(P/E per industry)',
  conditions: [
    'Filtrera bort N/A och ogiltiga värden',
    'Beräkna median för alla P/E-värden per industry',
    'Visa N/A om median är 0 eller inga giltiga värden finns',
    'Filtrera bort rader där Industry, Company Name eller Ticker är N/A'
  ]
}
```

### Komplex kolumn med färgkodning (score)
```typescript
{
  columnKey: 'score',
  dataSource: 'Beräknat från Score Board data med viktat poängsystem',
  formula: 'Summa av (vikt × färgfaktor) för alla metrics, där färgfaktor = 1.0 (grön), 0.7 (blå), 0.0 (röd/tom/N/A)',
  conditions: [
    'Poängsystem från 0-100',
    'Beräknas baserat på färgkodning i SCORE BOARD',
    'Fundamental metrics (50p totalt): ...',
    'Technical metrics (50p totalt): ...',
    'Färgmarkering: GRÖN om score >= 75, BLÅ om score >= 45, GRÅ om score < 45'
  ]
}
```

## Internationell stöd (i18n)

Systemet stödjer flerspråkighet via react-i18next:

**Översättningsnycklar:**
- `navigation.condition` - "Villkor" (meny)
- `conditions.dataSource` - "Datakälla"
- `conditions.formula` - "Formel"
- `conditions.conditions` - "Villkor"
- `conditions.close` - "Stäng"

Översättningar finns i:
- `src/locales/sv/translation.json` (Svenska)
- `src/locales/en/translation.json` (Engelska)

## Utveckling och underhåll

### Lägga till ny metadata

1. **Öppna `src/config/tableMetadata.ts`**
2. **Hitta eller skapa TableMetadata-objekt för din tabell**
3. **Lägg till ColumnMetadata för varje kolumn:**

```typescript
{
  tableId: 'min-tabell',
  columns: [
    {
      columnKey: 'minKolumn',
      dataSource: 'Beskrivning av datakälla',
      formula: 'Formel om det finns en', // Valfritt
      conditions: [
        'Villkor 1',
        'Villkor 2',
        // ... fler villkor
      ]
    }
  ]
}
```

4. **Lägg till ViewId → TableId-mappning i ConditionsSidebar.tsx** (om det är en ny vy)

### Uppdatera befintlig metadata

1. **Hitta rätt TableMetadata i `tableMetadata.ts`**
2. **Hitta rätt ColumnMetadata**
3. **Uppdatera dataSource, formula eller conditions**
4. **Ändringarna syns direkt i ConditionsModal**

### Best Practices

1. **Var specifik**: Beskriv exakt var data kommer ifrån
2. **Var tydlig**: Använd enkelt språk i conditions
3. **Var komplett**: Lista alla villkor, även de som verkar självklara
4. **Var konsekvent**: Använd samma terminologi genomgående
5. **Uppdatera regelbundet**: Håll metadata synkroniserad med kod

## Tekniska detaljer

### Prestanda
- Metadata laddas inte dynamiskt, utan är statisk data
- Inga API-anrop behövs för att visa conditions
- Modal renderas endast när den är öppen

### Tillgänglighet
- Keyboard-navigation (Escape för att stänga)
- ARIA-labels och semantisk HTML
- Touch-friendly knappar (min-h-[44px])
- Fokus-hantering

### Styling
- Tailwind CSS för styling
- Dark mode-stöd via dark: prefix
- Responsiv design (mobile-first)
- Animeringar med CSS transitions

## Framtida förbättringar

Potentiella förbättringar för systemet:

1. **Sökfunktion**: Sök i conditions för att hitta specifik information
2. **Export**: Exportera metadata som dokumentation
3. **Versionering**: Spåra ändringar i metadata över tid
4. **Validering**: Automatisk validering att metadata matchar faktiska kolumner
5. **Visualisering**: Diagram för komplexa formler
6. **Exempel**: Lägg till exempelvärden i metadata

## Relaterade filer

- `src/components/ConditionsModal.tsx` - Modal-komponent
- `src/components/ConditionsSidebar.tsx` - Sidebar-komponent
- `src/components/ColumnTooltip.tsx` - Tooltip-komponent
- `src/config/tableMetadata.ts` - Metadata-konfiguration
- `src/types/columnMetadata.ts` - TypeScript-typer
- `src/App.tsx` - Huvudapplikation (integration)
- `src/components/Sidebar.tsx` - Huvudsidebar (integration)
- `src/locales/sv/translation.json` - Svenska översättningar
- `src/locales/en/translation.json` - Engelska översättningar

```

## `src/components/ConditionsModal.tsx`

```tsx
import { useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { TableMetadata } from '../types/columnMetadata';

interface ConditionsModalProps {
  isOpen: boolean;
  onClose: () => void;
  metadata: TableMetadata | null;
  pageName: string;
}

export default function ConditionsModal({ isOpen, onClose, metadata, pageName }: ConditionsModalProps) {
  const { t } = useTranslation();

  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  if (!isOpen || !metadata) return null;

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 dark:bg-opacity-70 animate-fade-in transition-opacity duration-normal"
      onClick={onClose}
    >
      <div
        className="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-4xl w-full mx-4 max-h-[90vh] overflow-hidden flex flex-col animate-scale-in transition-all duration-normal"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between">
          <h2 className="text-2xl font-bold text-black dark:text-white">{pageName}</h2>
          <button
            onClick={onClose}
            className="text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 transition-all duration-200 hover:scale-110 active:scale-95 p-3 sm:p-2 min-h-[44px] min-w-[44px] touch-manipulation flex items-center justify-center"
            aria-label={t('aria.closeModal')}
          >
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-6">
          <div className="space-y-6">
            {metadata.columns.map((column, index) => (
              <div
                key={column.columnKey}
                className="border border-gray-200 dark:border-gray-700 rounded-lg p-4 bg-gray-50 dark:bg-gray-900 hover:shadow-lg hover:border-blue-300 dark:hover:border-blue-600 hover:scale-[1.02] transition-all duration-300 ease-in-out animate-fade-in-up cursor-default"
                style={{ animationDelay: `${index * 50}ms` }}
              >
                <h3 className="text-lg font-semibold text-black dark:text-white mb-3 capitalize">
                  {column.columnKey.replace(/([A-Z])/g, ' $1').trim()}
                </h3>
                
                <div className="space-y-3">
                  <div className="transition-all duration-200 hover:translate-x-1">
                    <div className="flex items-center gap-2">
                      <svg className="w-5 h-5 text-blue-700 dark:text-blue-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                      </svg>
                      <span className="font-semibold text-blue-700 dark:text-blue-400 transition-colors duration-200 hover:text-blue-700 dark:hover:text-blue-300">
                        {t('conditions.dataSource')}:
                      </span>
                    </div>
                    <p className="mt-1 ml-7 text-gray-700 dark:text-gray-300">{column.dataSource}</p>
                  </div>

                  {column.formula && (
                    <div className="transition-all duration-200 hover:translate-x-1">
                      <div className="flex items-center gap-2">
                        <svg className="w-5 h-5 text-green-700 dark:text-green-200 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                        </svg>
                        <span className="font-semibold text-green-700 dark:text-green-200 transition-colors duration-200 hover:text-green-700 dark:hover:text-green-300">
                          {t('conditions.formula')}:
                        </span>
                      </div>
                      <p className="mt-1 ml-7 text-gray-700 dark:text-gray-300 font-mono text-sm bg-gray-100 dark:bg-gray-800 p-2 rounded transition-all duration-200 hover:bg-gray-200 dark:hover:bg-gray-700 hover:shadow-sm">
                        {column.formula}
                      </p>
                    </div>
                  )}

                  {column.conditions && column.conditions.length > 0 && (
                    <div className="transition-all duration-200 hover:translate-x-1">
                      <div className="flex items-center gap-2">
                        <svg className="w-5 h-5 text-yellow-700 dark:text-yellow-300 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" />
                        </svg>
                        <span className="font-semibold text-yellow-700 dark:text-yellow-300 transition-colors duration-200 hover:text-yellow-700 dark:hover:text-yellow-300">
                          {t('conditions.conditions')}:
                        </span>
                      </div>
                      <ul className="mt-1 ml-7 list-disc list-inside space-y-1 text-gray-700 dark:text-gray-300">
                        {column.conditions.map((condition, conditionIndex) => (
                          <li key={conditionIndex} className="transition-all duration-200 hover:translate-x-1">{condition}</li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Footer */}
        <div className="px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex justify-end">
          <button
            onClick={onClose}
            className="px-5 py-3 sm:px-4 sm:py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 active:bg-blue-800 transition-all duration-200 hover:shadow-md active:scale-95 min-h-[44px] touch-manipulation inline-flex items-center gap-2"
          >
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
            <span>{t('conditions.close')}</span>
          </button>
        </div>
      </div>
    </div>
  );
}


```

## `src/components/ConditionsSidebar.tsx`

```tsx
import { useState } from 'react';
import { useTranslation } from 'react-i18next';
import { ViewId, NavigationSection } from '../types/navigation';
import { getTableMetadata } from '../config/tableMetadata';
import { getTableId } from '../config/viewTableMap';

interface ConditionsSidebarProps {
  onOpenModal: (viewId: ViewId) => void;
}

const getNavigationSections = (t: (key: string) => string): NavigationSection[] => [
  {
    id: 'score',
    label: t('navigation.score'),
    items: [{ id: 'score', label: t('navigation.score') }],
    collapsible: false,
  },
  {
    id: 'score-board',
    label: t('navigation.scoreBoard'),
    items: [{ id: 'score-board', label: t('navigation.scoreBoard') }],
    collapsible: false,
  },
  {
    id: 'entry-exit-benjamin-graham',
    label: t('navigation.benjaminGraham'),
    items: [{ id: 'entry-exit-benjamin-graham', label: t('navigation.benjaminGraham') }],
    collapsible: false,
  },
  {
    id: 'fundamental-pe-industry',
    label: t('navigation.peIndustry'),
    items: [{ id: 'fundamental-pe-industry', label: t('navigation.peIndustry') }],
    collapsible: false,
  },
  {
    id: 'threshold-industry',
    label: t('navigation.thresholdIndustry'),
    items: [{ id: 'threshold-industry', label: t('navigation.thresholdIndustry') }],
    collapsible: false,
  },
  {
    id: 'personal-portfolio',
    label: t('navigation.personalPortfolio'),
    items: [{ id: 'personal-portfolio', label: t('navigation.personalPortfolio') }],
    collapsible: false,
  },
];

export default function ConditionsSidebar({ onOpenModal }: ConditionsSidebarProps) {
  const { t } = useTranslation();
  const navigationSections = getNavigationSections(t);
  const [isConditionExpanded, setIsConditionExpanded] = useState(false);
  const [expandedSections, setExpandedSections] = useState<Set<string>>(
    new Set(['score'])
  );

  const [expandedSubmenus, setExpandedSubmenus] = useState<Set<string>>(
    new Set()
  );

  const toggleSection = (sectionId: string) => {
    setExpandedSections((prev) => {
      const next = new Set(prev);
      if (next.has(sectionId)) {
        next.delete(sectionId);
      } else {
        next.add(sectionId);
      }
      return next;
    });
  };

  const toggleSubmenu = (itemId: string) => {
    setExpandedSubmenus((prev) => {
      const next = new Set(prev);
      if (next.has(itemId)) {
        next.delete(itemId);
      } else {
        next.add(itemId);
      }
      return next;
    });
  };

  const hasMetadata = (viewId: ViewId): boolean => {
    const tableId = getTableId(viewId);
    return tableId !== null && getTableMetadata(tableId) !== undefined;
  };

  const handleItemClick = (viewId: ViewId) => {
    if (hasMetadata(viewId)) {
      onOpenModal(viewId);
    }
  };

  const isSectionExpanded = (sectionId: string) => expandedSections.has(sectionId);
  const isSubmenuExpanded = (itemId: string) => expandedSubmenus.has(itemId);

  return (
    <div>
      <button
        onClick={() => setIsConditionExpanded(!isConditionExpanded)}
        className="w-full flex items-center justify-between px-3 py-3 sm:py-2 text-left text-sm font-semibold text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded transition-all duration-200 hover:scale-[1.02] active:scale-95 min-h-[44px] touch-manipulation"
      >
        <span>{t('navigation.condition')}</span>
        <span className="text-gray-500 dark:text-gray-400 transition-transform duration-200">
          {isConditionExpanded ? '▼' : '▶'}
        </span>
      </button>

      {isConditionExpanded && (
        <div className="ml-2 space-y-1 mt-1">
          {navigationSections.map((section) => (
        <div key={section.id}>
          {section.collapsible && (
            <button
              onClick={() => toggleSection(section.id)}
              className="w-full flex items-center justify-between px-3 py-3 sm:py-2 text-left text-sm font-semibold text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded transition-all duration-200 hover:scale-[1.02] active:scale-95 min-h-[44px] touch-manipulation"
            >
              <span>{section.label}</span>
              <span className="text-gray-500 dark:text-gray-400 transition-transform duration-200">
                {isSectionExpanded(section.id) ? '▼' : '▶'}
              </span>
            </button>
          )}

          {(!section.collapsible || isSectionExpanded(section.id)) && (
            <div className="ml-2 space-y-1">
              {section.items.map((item) => {
                if (item.children) {
                  return (
                    <div key={item.id}>
                      <button
                        onClick={() => toggleSubmenu(item.id)}
                        className="w-full flex items-center justify-between px-3 py-3 sm:py-2 text-left text-sm text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 rounded transition-all duration-200 hover:scale-[1.02] active:scale-95 min-h-[44px] touch-manipulation"
                      >
                        <span>{item.label}</span>
                        <span className="text-gray-500 dark:text-gray-400 text-xs transition-transform duration-200">
                          {isSubmenuExpanded(item.id) ? '▼' : '▶'}
                        </span>
                      </button>
                      {isSubmenuExpanded(item.id) && (
                        <div className="ml-4 space-y-1">
                          {item.children.map((child) => (
                            <button
                              key={child.id}
                              onClick={() => handleItemClick(child.id)}
                              disabled={!hasMetadata(child.id)}
                              className={`w-full px-3 py-3 sm:py-2 text-left text-sm rounded transition-all duration-200 min-h-[44px] touch-manipulation ${
                                hasMetadata(child.id)
                                  ? 'text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 hover:scale-[1.02] active:scale-95'
                                  : 'text-gray-400 dark:text-gray-600 cursor-not-allowed opacity-50'
                              }`}
                            >
                              {child.label}
                            </button>
                          ))}
                        </div>
                      )}
                    </div>
                  );
                }

                return (
                  <button
                    key={item.id}
                    onClick={() => handleItemClick(item.id)}
                    disabled={!hasMetadata(item.id)}
                    className={`w-full px-3 py-3 sm:py-2 text-left text-sm rounded transition-all duration-200 min-h-[44px] touch-manipulation ${
                      hasMetadata(item.id)
                        ? 'text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 hover:scale-[1.02] active:scale-95'
                        : 'text-gray-400 dark:text-gray-600 cursor-not-allowed opacity-50'
                    }`}
                  >
                    {item.label}
                  </button>
                );
              })}
            </div>
          )}
        </div>
      ))}
        </div>
      )}
    </div>
  );
}

```

## `src/components/EmptyState.tsx`

```tsx
import React from 'react';

interface EmptyStateProps {
  hasSearch?: boolean;
  hasFilters?: boolean;
  hasData?: boolean;
  message?: string;
  searchTerm?: string;
  onClearSearch?: () => void;
  onClearFilters?: () => void;
  searchPlaceholder?: string;
  compact?: boolean; // For use in VirtualTableBody
}

export default function EmptyState({
  hasSearch = false,
  hasFilters = false,
  hasData = true,
  message,
  searchTerm = '',
  onClearSearch,
  onClearFilters,
  searchPlaceholder = 'Sök...',
  compact = false,
}: EmptyStateProps) {
  // Determine the scenario and appropriate message
  const getEmptyStateContent = () => {
    // Scenario 1: No data at all
    if (!hasData) {
      return {
        icon: (
          <svg
            className="w-12 h-12 sm:w-16 sm:h-16 text-gray-600 dark:text-gray-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
            />
          </svg>
        ),
        title: message || 'Ingen data tillgänglig',
        description: 'Försök uppdatera sidan eller kontakta support om problemet kvarstår.',
        actions: null,
      };
    }

    // Scenario 2: Search without results
    if (hasSearch && !hasFilters) {
      return {
        icon: (
          <svg
            className="w-12 h-12 sm:w-16 sm:h-16 text-gray-600 dark:text-gray-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
            />
          </svg>
        ),
        title: `Inga resultat hittades för "${searchTerm}"`,
        description: 'Försök med en annan sökterm eller rensa sökningen för att se alla resultat.',
        actions: onClearSearch ? (
          <button
            onClick={onClearSearch}
            className="mt-4 px-4 py-2 text-sm font-medium text-blue-700 dark:text-blue-400 bg-blue-50 dark:bg-blue-900/20 rounded-md hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors duration-200"
          >
            Rensa sökning
          </button>
        ) : null,
      };
    }

    // Scenario 3: Filters without results
    if (hasFilters && !hasSearch) {
      return {
        icon: (
          <svg
            className="w-12 h-12 sm:w-16 sm:h-16 text-gray-600 dark:text-gray-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"
            />
          </svg>
        ),
        title: 'Inga resultat matchar dina filter',
        description: 'Justera dina filter eller rensa alla filter för att se fler resultat.',
        actions: onClearFilters ? (
          <button
            onClick={onClearFilters}
            className="mt-4 px-4 py-2 text-sm font-medium text-blue-700 dark:text-blue-400 bg-blue-50 dark:bg-blue-900/20 rounded-md hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors duration-200"
          >
            Rensa alla filter
          </button>
        ) : null,
      };
    }

    // Scenario 4: Both search and filters
    if (hasSearch && hasFilters) {
      return {
        icon: (
          <div className="relative w-12 h-12 sm:w-16 sm:h-16">
            <svg
              className="absolute top-0 left-0 w-12 h-12 sm:w-16 sm:h-16 text-gray-600 dark:text-gray-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
              />
            </svg>
            <svg
              className="absolute top-2 left-2 w-6 h-6 sm:w-8 sm:h-8 text-gray-300 dark:text-gray-600"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"
              />
            </svg>
          </div>
        ),
        title: 'Inga resultat matchar din sökning och filter',
        description: 'Försök ändra din sökterm eller justera dina filter för att hitta fler resultat.',
        actions: (
          <div className="mt-4 flex flex-col sm:flex-row gap-2 justify-center">
            {onClearSearch && (
              <button
                onClick={onClearSearch}
                className="px-4 py-2 text-sm font-medium text-blue-700 dark:text-blue-400 bg-blue-50 dark:bg-blue-900/20 rounded-md hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors duration-200"
              >
                Rensa sökning
              </button>
            )}
            {onClearFilters && (
              <button
                onClick={onClearFilters}
                className="px-4 py-2 text-sm font-medium text-blue-700 dark:text-blue-400 bg-blue-50 dark:bg-blue-900/20 rounded-md hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors duration-200"
              >
                Rensa alla filter
              </button>
            )}
          </div>
        ),
      };
    }

    // Default: Generic no results
    return {
      icon: (
        <svg
          className="w-12 h-12 sm:w-16 sm:h-16 text-gray-400 dark:text-gray-500"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          />
        </svg>
      ),
      title: message || 'Inga resultat hittades',
      description: 'Försök ändra dina sökkriterier eller filter.',
      actions: null,
    };
  };

  const content = getEmptyStateContent();

  if (compact) {
    return (
      <div className="text-center py-8 text-gray-600 dark:text-gray-300">
        <p className="text-sm">{content.title}</p>
        {content.description && (
          <p className="text-xs mt-1 text-gray-600 dark:text-gray-400">{content.description}</p>
        )}
      </div>
    );
  }

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-8 sm:p-12" role="status" aria-live="polite">
      <div className="flex flex-col items-center justify-center text-center">
        <div className="mb-4">{content.icon}</div>
        <h3 className="text-lg sm:text-xl font-semibold text-black dark:text-white mb-2">
          {content.title}
        </h3>
        {content.description && (
          <p className="text-sm sm:text-base text-gray-600 dark:text-gray-300 max-w-md mb-4">
            {content.description}
          </p>
        )}
        {content.actions}
      </div>
    </div>
  );
}


```

## `src/components/EnhancedLoadingState.tsx`

```tsx
import React, { useMemo } from 'react';
import { useLoadingProgress } from '../contexts/LoadingProgressContext';
import ProgressIndicator from './ProgressIndicator';
import { useTranslation } from 'react-i18next';

interface EnhancedLoadingStateProps {
  dataSourceNames?: Record<string, string>; // Map of source keys to display names
}

export default function EnhancedLoadingState({ dataSourceNames }: EnhancedLoadingStateProps) {
  const { t } = useTranslation();
  const { dataSources, totalProgress, estimatedTimeRemaining, isAnyLoading } = useLoadingProgress();

  const defaultNames: Record<string, string> = {
    'score-board': 'Score Board',
    'benjamin-graham': 'Benjamin Graham',
    'sma': 'SMA',
    'pe-industry': 'P/E Industry',
    'threshold-industry': 'Threshold Industry',
    ...dataSourceNames,
  };

  const formatTime = (ms: number): string => {
    if (ms < 1000) {
      return '< 1s';
    }
    const seconds = Math.ceil(ms / 1000);
    if (seconds < 60) {
      return `~${seconds}s`;
    }
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return remainingSeconds > 0 ? `~${minutes}m ${remainingSeconds}s` : `~${minutes}m`;
  };

  const dataSourceList = useMemo(() => {
    return Array.from(dataSources.values()).sort((a, b) => {
      // Sort by status: loading first, then pending, then complete, then error
      const statusOrder = { loading: 0, pending: 1, complete: 2, error: 3 };
      return statusOrder[a.status] - statusOrder[b.status];
    });
  }, [dataSources]);

  if (!isAnyLoading && dataSourceList.length === 0) {
    return null;
  }

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-4">
      <div className="mb-4">
        <div className="flex items-center justify-between mb-2">
          <h3 className="text-sm font-semibold text-black dark:text-white">
            {t('loading.loadingData', 'Laddar data...')}
          </h3>
          {estimatedTimeRemaining > 0 && (
            <span className="text-xs text-gray-600 dark:text-gray-300">
              {t('loading.estimatedTime', 'Uppskattad tid')}: {formatTime(estimatedTimeRemaining)}
            </span>
          )}
        </div>
        <ProgressIndicator
          progress={totalProgress}
          isLoading={isAnyLoading}
          showPercentage={true}
          estimatedTimeRemaining={estimatedTimeRemaining}
        />
      </div>

      {dataSourceList.length > 0 && (
        <div className="space-y-2">
          {dataSourceList.map((source) => {
            const displayName = defaultNames[source.name] || source.name;
            const isComplete = source.status === 'complete';
            const isError = source.status === 'error';
            const isLoading = source.status === 'loading' || source.status === 'pending';

            return (
              <div key={source.name} className="flex items-center justify-between text-sm">
                <div className="flex items-center space-x-2 flex-1 min-w-0">
                  {isComplete ? (
                    <svg
                      className="w-4 h-4 text-green-700 dark:text-green-200 flex-shrink-0"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M5 13l4 4L19 7"
                      />
                    </svg>
                  ) : isError ? (
                    <svg
                      className="w-4 h-4 text-red-700 dark:text-red-400 flex-shrink-0"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M6 18L18 6M6 6l12 12"
                      />
                    </svg>
                  ) : (
                    <div className="w-4 h-4 flex-shrink-0">
                      <div className="w-4 h-4 border-2 border-blue-600 dark:border-blue-400 border-t-transparent rounded-full animate-spin" />
                    </div>
                  )}
                  <span
                    className={`font-medium truncate ${
                      isComplete
                        ? 'text-green-700 dark:text-green-400'
                        : isError
                        ? 'text-red-700 dark:text-red-400'
                        : 'text-black dark:text-white'
                    }`}
                  >
                    {displayName}
                  </span>
                </div>
                <div className="flex items-center space-x-3 ml-4">
                  {source.rowsLoaded !== undefined && source.totalRows !== undefined && (
                    <span className="text-xs text-gray-600 dark:text-gray-300 whitespace-nowrap">
                      {source.rowsLoaded}/{source.totalRows} rader
                    </span>
                  )}
                  {isLoading && (
                    <div className="w-24 bg-gray-200 dark:bg-gray-700 rounded-full h-1.5 overflow-hidden">
                      <div
                        className="h-full bg-blue-600 dark:bg-blue-500 transition-all duration-300"
                        style={{ width: `${Math.min(100, Math.max(0, source.progress))}%` }}
                      />
                    </div>
                  )}
                  {isLoading && (
                    <span className="text-xs text-gray-700 dark:text-gray-300 w-10 text-right">
                      {Math.round(source.progress)}%
                    </span>
                  )}
                  {isComplete && (
                    <span className="text-xs text-green-700 dark:text-green-200">
                      {t('loading.complete', 'Klar')}
                    </span>
                  )}
                  {isError && (
                    <span className="text-xs text-red-700 dark:text-red-400">
                      {t('loading.error', 'Fel')}
                    </span>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}


```

## `src/components/EntryExitTable.tsx`

```tsx
import React, { useState, useCallback, useMemo, useEffect } from 'react';
import { BenjaminGrahamData } from '../types/stock';
import BaseTable, { ColumnDefinition, HeaderRenderProps } from './BaseTable';
import ColumnTooltip from './ColumnTooltip';
import ColumnFilterMenu from './ColumnFilterMenu';
import { getColumnMetadata } from '../config/tableMetadata';
import { FilterConfig } from './AdvancedFilters';
import { useTranslation } from 'react-i18next';
import { useEntryExitValues } from '../contexts/EntryExitContext';
import { useUserRole } from '../hooks/useUserRole';
import { DATE_NEAR_OLD_THRESHOLD_DAYS } from '../config/constants';
import {
  PRICE_TOLERANCE_GREEN,
  PRICE_TOLERANCE_BLUE,
  RR1_GREEN_THRESHOLD_PERCENT,
  RR2_GREEN_THRESHOLD_PERCENT,
} from '../config/constants';
import { isNumber, isString } from '../utils/typeGuards';
import { validateEntryExitValue } from '../utils/inputValidator';

interface EntryExitTableProps {
  data: BenjaminGrahamData[];
  loading: boolean;
  error: string | null;
}

const CURRENCIES = ['USD', 'EUR', 'SEK', 'DKK', 'NOK', 'GBP', 'AUD', 'CAD', 'NZD'];

const ENTRY_EXIT_COLUMNS: ColumnDefinition<BenjaminGrahamData>[] = [
  { key: 'antal', label: 'Antal', required: true, sticky: true, sortable: false },
  { key: 'companyName', label: 'Company Name', required: true, sticky: true, sortable: true },
  { key: 'ticker', label: 'Ticker', required: true, sticky: true, sortable: true },
  { key: 'currency', label: 'Currency', required: true, sticky: true, sortable: true, align: 'center' },
  { key: 'price', label: 'Price', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'benjaminGraham', label: 'Benjamin Graham', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'entry1', label: 'ENTRY1', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'entry2', label: 'ENTRY2', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'exit1', label: 'EXIT1', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'exit2', label: 'EXIT2', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'ivFcf', label: 'IV (FCF)', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'irr1', label: 'RR1', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'rr2', label: 'RR2', defaultVisible: true, sortable: false, align: 'center' },
  { key: 'dateOfUpdate', label: 'Date of Update', defaultVisible: true, sortable: true, align: 'center' },
];

const ENTRY_EXIT_FILTERS: FilterConfig[] = [
  {
    key: 'companyName',
    label: 'Företagsnamn',
    type: 'text',
  },
  {
    key: 'ticker',
    label: 'Ticker',
    type: 'text',
  },
  {
    key: 'currency',
    label: 'Valuta',
    type: 'select',
    options: CURRENCIES.map(c => ({ value: c, label: c })),
  },
  {
    key: 'entry1',
    label: 'Entry1',
    type: 'numberRange',
    min: 0,
    step: 0.01,
  },
  {
    key: 'entry2',
    label: 'Entry2',
    type: 'numberRange',
    min: 0,
    step: 0.01,
  },
  {
    key: 'exit1',
    label: 'Exit1',
    type: 'numberRange',
    min: 0,
    step: 0.01,
  },
  {
    key: 'exit2',
    label: 'Exit2',
    type: 'numberRange',
    min: 0,
    step: 0.01,
  },
  {
    key: 'price',
    label: 'Pris',
    type: 'numberRange',
    min: 0,
    step: 0.01,
  },
  {
    key: 'benjaminGraham',
    label: 'Benjamin Graham',
    type: 'numberRange',
    min: 0,
    step: 0.01,
  },
  {
    key: 'ivFcf',
    label: 'IV (FCF)',
    type: 'numberRange',
    min: 0,
    step: 0.01,
  },
];

function EntryExitTable({ data, loading, error }: EntryExitTableProps) {
  const { t } = useTranslation();
  const [expandedRows, setExpandedRows] = useState<{ [key: string]: boolean }>({});
  const { getEntryExitValue, getFieldValue, setFieldValue, commitField, initializeFromData } = useEntryExitValues();
  const { isAdmin } = useUserRole();
  const [validationErrors, setValidationErrors] = useState<Record<string, string>>({});

  // Initialize entry/exit values from data
  useEffect(() => {
    const entryExitData = data.map((item) => ({
      companyName: item.companyName,
      ticker: item.ticker,
      currency: 'USD',
      entry1: 0,
      entry2: 0,
      exit1: 0,
      exit2: 0,
      dateOfUpdate: null,
    }));
    initializeFromData(entryExitData);
  }, [data, initializeFromData]);

  // Check if ivFcf column should be shown
  const hasIvFcf = useMemo(() => {
    return data.some(item => item.ivFcf !== undefined);
  }, [data]);

  const handleCurrencyChange = useCallback((ticker: string, companyName: string, currency: string) => {
    setFieldValue(ticker, companyName, 'currency', currency);
  }, [setFieldValue]);

  // Helper functions for date checking
  const isDateOld = useCallback((dateString: string | null): boolean => {
    if (!dateString) return false;
    try {
      const dateParts = dateString.split('-');
      const date = new Date(
        parseInt(dateParts[0]),
        parseInt(dateParts[1]) - 1,
        parseInt(dateParts[2])
      );
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      date.setHours(0, 0, 0, 0);
      const daysDiff = (today.getTime() - date.getTime()) / (1000 * 60 * 60 * 24);
      return daysDiff > DATE_NEAR_OLD_THRESHOLD_DAYS;
    } catch (error) {
      return false;
    }
  }, []);

  const isDateNearOld = useCallback((dateString: string | null): boolean => {
    if (!dateString) return false;
    try {
      const dateParts = dateString.split('-');
      const date = new Date(
        parseInt(dateParts[0]),
        parseInt(dateParts[1]) - 1,
        parseInt(dateParts[2])
      );
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      date.setHours(0, 0, 0, 0);
      const daysDiff = (today.getTime() - date.getTime()) / (1000 * 60 * 60 * 24);
      return daysDiff >= 0 && daysDiff <= DATE_NEAR_OLD_THRESHOLD_DAYS && !isDateOld(dateString);
    } catch (error) {
      return false;
    }
  }, [isDateOld]);

  const handleEntryExitChange = useCallback((ticker: string, companyName: string, field: 'entry1' | 'entry2' | 'exit1' | 'exit2', value: number) => {
    // Validate before setting
    const validation = validateEntryExitValue(field, value);
    const key = `${ticker}-${companyName}-${field}`;
    
    if (!validation.isValid) {
      setValidationErrors((prev) => ({ ...prev, [key]: validation.error || 'Invalid value' }));
    } else {
      setValidationErrors((prev) => {
        const next = { ...prev };
        delete next[key];
        return next;
      });
    }
    
    setFieldValue(ticker, companyName, field, value);
  }, [setFieldValue]);

  // Calculate RR1: (Exit1 - Entry1) / Entry1 * 100
  const calculateRR1 = useCallback((entry1: number, exit1: number): number | null => {
    if (!entry1 || !exit1 || entry1 === 0) return null;
    const rr1 = ((exit1 - entry1) / entry1) * 100;
    return isNaN(rr1) || !isFinite(rr1) ? null : rr1;
  }, []);

  // Get color for RR1 cell based on conditions
  const getRR1Color = useCallback((rr1: number | null, price: number | null, entry1: number): string | null => {
    if (rr1 !== null && rr1 > RR1_GREEN_THRESHOLD_PERCENT && price !== null && price > 0 && entry1 > 0 && price <= entry1 * PRICE_TOLERANCE_GREEN) {
      return 'text-green-700 dark:text-green-200 bg-green-50 dark:bg-green-900/20';
    }
    return null;
  }, []);

  // Calculate RR2: (Exit2 - Entry2) / Entry2 * 100
  const calculateRR2 = useCallback((entry2: number, exit2: number): number | null => {
    if (!entry2 || !exit2 || entry2 === 0) return null;
    const rr2 = ((exit2 - entry2) / entry2) * 100;
    return isNaN(rr2) || !isFinite(rr2) ? null : rr2;
  }, []);

  // Get color for RR2 cell based on conditions
  const getRR2Color = useCallback((rr2: number | null, price: number | null, entry2: number): string | null => {
    if (rr2 !== null && rr2 >= RR2_GREEN_THRESHOLD_PERCENT && price !== null && price > 0 && entry2 > 0 && price <= entry2 * PRICE_TOLERANCE_GREEN) {
      return 'text-green-700 dark:text-green-200 bg-green-50 dark:bg-green-900/20';
    }
    return null;
  }, []);

  // Custom header renderer with ColumnTooltip
  const renderHeader = useCallback((props: HeaderRenderProps<BenjaminGrahamData>) => {
    const { 
      column, 
      sortConfig, 
      handleSort, 
      getSortIcon, 
      getStickyPosition, 
      isColumnVisible,
      openFilterMenuColumn,
      setOpenFilterMenuColumn,
      hasActiveColumnFilter,
      getColumnUniqueValues,
      columnFilters,
      setColumnFilter,
      handleColumnSort,
      headerRefs,
    } = props;
    const metadata = getColumnMetadata('benjamin-graham', column.key);
    const isSticky = column.sticky;
    const isSorted = sortConfig.key === column.key;
    const sortIcon = getSortIcon(column.key);
    const stickyClass = isSticky ? `sm:sticky sm:top-0 ${getStickyPosition(column.key)} z-50` : '';
    const isFilterMenuOpen = openFilterMenuColumn === column.key;
    const hasActiveFilter = hasActiveColumnFilter(column.key);
    const headerRef = headerRefs.current[column.key] || null;

    const handleFilterIconClick = (e: React.MouseEvent) => {
      e.stopPropagation();
      if (isFilterMenuOpen) {
        setOpenFilterMenuColumn(null);
      } else {
        setOpenFilterMenuColumn(column.key);
      }
    };

    const handleSortClick = (e?: React.MouseEvent) => {
      if (e) {
        e.stopPropagation();
      }
      if (!isFilterMenuOpen) {
        handleSort(column.key);
      }
    };

    const filterIcon = (
      <button
        onClick={handleFilterIconClick}
        className={`ml-2 p-1 rounded hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors ${
          hasActiveFilter ? 'text-blue-600 dark:text-blue-400' : 'text-gray-500 dark:text-gray-400'
        }`}
        aria-label={`Filter ${column.label}`}
        aria-expanded={isFilterMenuOpen}
        title="Filter och sortering"
        type="button"
      >
        <svg
          className="w-4 h-4"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M4 6h16M4 12h16M4 18h16"
          />
        </svg>
      </button>
    );
    
    if (!column.sortable) {
      const headerContent = (
        <th
          ref={(el) => {
            headerRefs.current[column.key] = el;
          }}
          className={`px-6 py-3 text-left text-xs font-bold text-gray-700 dark:text-gray-200 uppercase tracking-wider ${stickyClass} bg-gray-50 dark:bg-gray-900`}
          scope="col"
          role="columnheader"
        >
          <div className="flex items-center justify-between relative w-full">
            <div className="flex items-center flex-1">
              {metadata ? (
                <ColumnTooltip metadata={metadata}>
                  <div className="flex items-center space-x-1">
                    <span>{column.label}</span>
                  </div>
                </ColumnTooltip>
              ) : (
                <div className="flex items-center space-x-1">
                  <span>{column.label}</span>
                </div>
              )}
            </div>
            <div className="flex items-center relative" style={{ minWidth: '40px' }}>
              <div className="relative">
                {filterIcon}
                {isFilterMenuOpen && headerRef && (
                  <ColumnFilterMenu
                    columnKey={column.key}
                    columnLabel={column.label}
                    isOpen={isFilterMenuOpen}
                    onClose={() => setOpenFilterMenuColumn(null)}
                    filter={columnFilters[column.key]}
                    onFilterChange={(filter) => setColumnFilter(column.key, filter)}
                    sortConfig={sortConfig}
                    onSort={handleColumnSort}
                    uniqueValues={getColumnUniqueValues(column.key)}
                    triggerRef={{ current: headerRef }}
                  />
                )}
              </div>
            </div>
          </div>
        </th>
      );
      return <React.Fragment key={column.key}>{headerContent}</React.Fragment>;
    }

    const headerContent = (
      <th
        ref={(el) => {
          headerRefs.current[column.key] = el;
        }}
        onClick={handleSortClick}
        className={`px-6 py-3 text-left text-xs font-bold text-gray-700 dark:text-gray-200 uppercase tracking-wider cursor-pointer hover:bg-blue-100 dark:hover:bg-blue-900/30 hover:text-blue-700 dark:hover:text-blue-200 transition-all duration-200 ${stickyClass} bg-gray-50 dark:bg-gray-900`}
        scope="col"
        role="columnheader"
      >
        <div className="flex items-center justify-between relative w-full">
          <div className="flex items-center flex-1" onClick={handleSortClick}>
            {metadata ? (
              <ColumnTooltip metadata={metadata}>
                <div className="flex items-center space-x-1">
                  <span>{column.label}</span>
                  {sortIcon && <span className="text-gray-600 dark:text-gray-300">{sortIcon}</span>}
                </div>
              </ColumnTooltip>
            ) : (
              <div className="flex items-center space-x-1">
                <span>{column.label}</span>
                {sortIcon && <span className="text-gray-600 dark:text-gray-300">{sortIcon}</span>}
              </div>
            )}
          </div>
          <div className="flex items-center relative" style={{ minWidth: '40px' }}>
            <div className="relative">
              {filterIcon}
              {isFilterMenuOpen && headerRef && (
                <ColumnFilterMenu
                  columnKey={column.key}
                  columnLabel={column.label}
                  isOpen={isFilterMenuOpen}
                  onClose={() => setOpenFilterMenuColumn(null)}
                  filter={columnFilters[column.key]}
                  onFilterChange={(filter) => setColumnFilter(column.key, filter)}
                  sortConfig={sortConfig}
                  onSort={handleColumnSort}
                  uniqueValues={getColumnUniqueValues(column.key)}
                  triggerRef={{ current: headerRef }}
                />
              )}
            </div>
          </div>
        </div>
      </th>
    );
    return <React.Fragment key={column.key}>{headerContent}</React.Fragment>;
  }, []);

  // Render cell content
  const renderCell = useCallback((item: BenjaminGrahamData, column: ColumnDefinition<BenjaminGrahamData>, index: number, globalIndex: number) => {
    // Use getFieldValue for individual fields (supports draft)
    const entry1Value = getFieldValue(item.ticker, item.companyName, 'entry1');
    const entry2Value = getFieldValue(item.ticker, item.companyName, 'entry2');
    const exit1Value = getFieldValue(item.ticker, item.companyName, 'exit1');
    const exit2Value = getFieldValue(item.ticker, item.companyName, 'exit2');
    const currencyValue = getFieldValue(item.ticker, item.companyName, 'currency');
    const dateOfUpdateValue = getFieldValue(item.ticker, item.companyName, 'dateOfUpdate');
    
    // Validate types with type guards
    const entry1 = isNumber(entry1Value) ? entry1Value : 0;
    const entry2 = isNumber(entry2Value) ? entry2Value : 0;
    const exit1 = isNumber(exit1Value) ? exit1Value : 0;
    const exit2 = isNumber(exit2Value) ? exit2Value : 0;
    const currency = isString(currencyValue) ? currencyValue : '';
    const dateOfUpdate = isString(dateOfUpdateValue) || dateOfUpdateValue === null ? dateOfUpdateValue : null;
    const values = { entry1, entry2, exit1, exit2, currency, dateOfUpdate };

    switch (column.key) {
      case 'antal':
        return globalIndex + 1;
      case 'companyName':
        return <span className="font-medium">{item.companyName}</span>;
      case 'ticker':
        return <span className="text-gray-600 dark:text-gray-300">{item.ticker}</span>;
      case 'currency':
        if (!isAdmin) {
          return <span className="text-black dark:text-white">{values.currency || 'USD'}</span>;
        }
        const currencyKey = `${item.ticker}-${item.companyName}-currency`;
        const currencyError = validationErrors[currencyKey];
        return (
          <div className="flex flex-col items-center">
            <select
              value={values.currency || 'USD'}
              onChange={(e) => {
                const validation = validateEntryExitValue('currency', e.target.value);
                if (validation.isValid) {
                  handleCurrencyChange(item.ticker, item.companyName, e.target.value);
                  setValidationErrors((prev) => {
                    const next = { ...prev };
                    delete next[currencyKey];
                    return next;
                  });
                } else {
                  setValidationErrors((prev) => ({ ...prev, [currencyKey]: validation.error || 'Invalid currency' }));
                }
              }}
              onBlur={() => {
                const validation = validateEntryExitValue('currency', values.currency);
                if (validation.isValid) {
                  commitField(item.ticker, item.companyName, 'currency');
                }
              }}
              className={`px-3 py-1 text-sm border rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:border-transparent ${
                currencyError
                  ? 'border-red-500 dark:border-red-500 focus:ring-red-500'
                  : 'border-gray-300 dark:border-gray-600 focus:ring-blue-500'
              }`}
              onClick={(e) => e.stopPropagation()}
              aria-invalid={!!currencyError}
            >
              {CURRENCIES.map((currency) => (
                <option key={currency} value={currency}>
                  {currency}
                </option>
              ))}
            </select>
            {currencyError && (
              <span className="text-xs text-red-600 dark:text-red-400 mt-1" role="alert">
                {currencyError}
              </span>
            )}
          </div>
        );
      case 'entry1':
        if (!isAdmin) {
          return <span className="text-black dark:text-white">{values.entry1 || '-'}</span>;
        }
        const entry1Key = `${item.ticker}-${item.companyName}-entry1`;
        const entry1Error = validationErrors[entry1Key];
        return (
          <div className="flex flex-col items-center">
            <input
              type="number"
              value={values.entry1 || ''}
              onChange={(e) => {
                const value = parseFloat(e.target.value) || 0;
                handleEntryExitChange(item.ticker, item.companyName, 'entry1', value);
              }}
              onBlur={() => {
                const validation = validateEntryExitValue('entry1', values.entry1);
                if (validation.isValid) {
                  commitField(item.ticker, item.companyName, 'entry1');
                }
              }}
              min={0}
              max={1000000}
              step={0.01}
              className={`px-3 py-1 text-sm border rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:border-transparent w-24 text-center ${
                entry1Error
                  ? 'border-red-500 dark:border-red-500 focus:ring-red-500'
                  : 'border-gray-300 dark:border-gray-600 focus:ring-blue-500'
              }`}
              onClick={(e) => e.stopPropagation()}
              aria-invalid={!!entry1Error}
            />
            {entry1Error && (
              <span className="text-xs text-red-600 dark:text-red-400 mt-1" role="alert">
                {entry1Error}
              </span>
            )}
          </div>
        );
      case 'entry2':
        if (!isAdmin) {
          return <span className="text-black dark:text-white">{values.entry2 || '-'}</span>;
        }
        const entry2Key = `${item.ticker}-${item.companyName}-entry2`;
        const entry2Error = validationErrors[entry2Key];
        return (
          <div className="flex flex-col items-center">
            <input
              type="number"
              value={values.entry2 || ''}
              onChange={(e) => {
                const value = parseFloat(e.target.value) || 0;
                handleEntryExitChange(item.ticker, item.companyName, 'entry2', value);
              }}
              onBlur={() => {
                const validation = validateEntryExitValue('entry2', values.entry2);
                if (validation.isValid) {
                  commitField(item.ticker, item.companyName, 'entry2');
                }
              }}
              min={0}
              max={1000000}
              step={0.01}
              className={`px-3 py-1 text-sm border rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:border-transparent w-24 text-center ${
                entry2Error
                  ? 'border-red-500 dark:border-red-500 focus:ring-red-500'
                  : 'border-gray-300 dark:border-gray-600 focus:ring-blue-500'
              }`}
              onClick={(e) => e.stopPropagation()}
              aria-invalid={!!entry2Error}
            />
            {entry2Error && (
              <span className="text-xs text-red-600 dark:text-red-400 mt-1" role="alert">
                {entry2Error}
              </span>
            )}
          </div>
        );
      case 'exit1':
        if (!isAdmin) {
          return <span className="text-black dark:text-white">{values.exit1 || '-'}</span>;
        }
        const exit1Key = `${item.ticker}-${item.companyName}-exit1`;
        const exit1Error = validationErrors[exit1Key];
        return (
          <div className="flex flex-col items-center">
            <input
              type="number"
              value={values.exit1 || ''}
              onChange={(e) => {
                const value = parseFloat(e.target.value) || 0;
                handleEntryExitChange(item.ticker, item.companyName, 'exit1', value);
              }}
              onBlur={() => {
                const validation = validateEntryExitValue('exit1', values.exit1);
                if (validation.isValid) {
                  commitField(item.ticker, item.companyName, 'exit1');
                }
              }}
              min={0}
              max={1000000}
              step={0.01}
              className={`px-3 py-1 text-sm border rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:border-transparent w-24 text-center ${
                exit1Error
                  ? 'border-red-500 dark:border-red-500 focus:ring-red-500'
                  : 'border-gray-300 dark:border-gray-600 focus:ring-blue-500'
              }`}
              onClick={(e) => e.stopPropagation()}
              aria-invalid={!!exit1Error}
            />
            {exit1Error && (
              <span className="text-xs text-red-600 dark:text-red-400 mt-1" role="alert">
                {exit1Error}
              </span>
            )}
          </div>
        );
      case 'exit2':
        if (!isAdmin) {
          return <span className="text-black dark:text-white">{values.exit2 || '-'}</span>;
        }
        const exit2Key = `${item.ticker}-${item.companyName}-exit2`;
        const exit2Error = validationErrors[exit2Key];
        return (
          <div className="flex flex-col items-center">
            <input
              type="number"
              value={values.exit2 || ''}
              onChange={(e) => {
                const value = parseFloat(e.target.value) || 0;
                handleEntryExitChange(item.ticker, item.companyName, 'exit2', value);
              }}
              onBlur={() => {
                const validation = validateEntryExitValue('exit2', values.exit2);
                if (validation.isValid) {
                  commitField(item.ticker, item.companyName, 'exit2');
                }
              }}
              min={0}
              max={1000000}
              step={0.01}
              className={`px-3 py-1 text-sm border rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:border-transparent w-24 text-center ${
                exit2Error
                  ? 'border-red-500 dark:border-red-500 focus:ring-red-500'
                  : 'border-gray-300 dark:border-gray-600 focus:ring-blue-500'
              }`}
              onClick={(e) => e.stopPropagation()}
              aria-invalid={!!exit2Error}
            />
            {exit2Error && (
              <span className="text-xs text-red-600 dark:text-red-400 mt-1" role="alert">
                {exit2Error}
              </span>
            )}
          </div>
        );
      case 'dateOfUpdate':
        return (
          <span className={
            values.dateOfUpdate && 
            !(values.entry1 === 0 && values.entry2 === 0 && values.exit1 === 0 && values.exit2 === 0) &&
            isDateOld(values.dateOfUpdate)
              ? 'text-red-600 dark:text-red-400'
              : 'text-black dark:text-white'
          }>
            {values.dateOfUpdate || '-'}
          </span>
        );
      case 'price':
        return <span className="text-black dark:text-white">{item.price !== null ? item.price.toLocaleString() : 'N/A'}</span>;
      case 'benjaminGraham':
        return (
          <span className={
            item.benjaminGraham === null
              ? 'text-black dark:text-white'
              : item.benjaminGraham < 0 
              ? 'text-red-700 dark:text-red-400'
              : item.benjaminGraham > 0 && 
                item.price !== null && item.price > 0 && 
                item.price <= item.benjaminGraham * PRICE_TOLERANCE_GREEN
              ? 'text-green-700 dark:text-green-200'
              : item.benjaminGraham > 0 && 
                item.price !== null && item.price > 0 && 
                item.price <= item.benjaminGraham * PRICE_TOLERANCE_BLUE
              ? 'text-blue-700 dark:text-blue-400'
              : 'text-black dark:text-white'
          }>
            {item.benjaminGraham !== null ? item.benjaminGraham.toLocaleString() : 'N/A'}
          </span>
        );
      case 'ivFcf':
        if (!hasIvFcf) return null;
        return <span className="text-black dark:text-white">{item.ivFcf !== null && item.ivFcf !== undefined ? item.ivFcf.toLocaleString() : 'N/A'}</span>;
      case 'irr1':
        {
          const entryExitValues = getEntryExitValue(item.ticker, item.companyName);
          const entry1 = entryExitValues?.entry1 || 0;
          const exit1 = entryExitValues?.exit1 || 0;
          const rr1 = calculateRR1(entry1, exit1);
          const colorClass = getRR1Color(rr1, item.price, entry1);
          return (
            <span className={colorClass || 'text-black dark:text-white'}>
              {rr1 !== null ? `${Math.round(rr1)}%` : 'N/A'}
            </span>
          );
        }
      case 'rr2':
        {
          const entryExitValues = getEntryExitValue(item.ticker, item.companyName);
          const entry2 = entryExitValues?.entry2 || 0;
          const exit2 = entryExitValues?.exit2 || 0;
          const rr2 = calculateRR2(entry2, exit2);
          const colorClass = getRR2Color(rr2, item.price, entry2);
          return (
            <span className={colorClass || 'text-black dark:text-white'}>
              {rr2 !== null ? `${Math.round(rr2)}%` : 'N/A'}
            </span>
          );
        }
      default:
        return null;
    }
  }, [getFieldValue, getEntryExitValue, calculateRR1, calculateRR2, getRR1Color, getRR2Color, hasIvFcf, handleCurrencyChange, handleEntryExitChange, commitField, isDateOld, isDateNearOld, isAdmin, validationErrors]);

  // Render mobile card
  const renderMobileCard = useCallback((item: BenjaminGrahamData, index: number, globalIndex: number, isExpanded: boolean, toggleExpand: () => void) => {
    const rowKey = `${item.ticker}-${item.companyName}-${globalIndex}`;
    const rowBgClass = globalIndex % 2 === 0 
      ? 'bg-white dark:bg-gray-800' 
      : 'bg-gray-50 dark:bg-gray-800/50';

    const entryExitValues = getEntryExitValue(item.ticker, item.companyName);
    const entry1 = entryExitValues?.entry1 || 0;
    const exit1 = entryExitValues?.exit1 || 0;
    const entry2 = entryExitValues?.entry2 || 0;
    const exit2 = entryExitValues?.exit2 || 0;
    const currency = entryExitValues?.currency || 'USD';
    const dateOfUpdate = entryExitValues?.dateOfUpdate || null;
    const rr1 = calculateRR1(entry1, exit1);
    const rr2 = calculateRR2(entry2, exit2);
    const rr1Color = getRR1Color(rr1, item.price, entry1);
    const rr2Color = getRR2Color(rr2, item.price, entry2);

    return (
      <div
        key={rowKey}
        className={`${rowBgClass} rounded-lg border border-gray-200 dark:border-gray-700 shadow-sm transition-all duration-300 ease-in-out`}
      >
        {/* Primary Columns - Always Visible */}
        <div className="p-4 flex items-start justify-between gap-4">
          <div className="flex-1 space-y-3">
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">Antal</span>
              <span className="text-sm font-medium text-black dark:text-white">{globalIndex + 1}</span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">Company Name</span>
              <span className="text-sm font-medium text-black dark:text-white text-right">{item.companyName}</span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">Ticker</span>
              <span className="text-sm text-gray-600 dark:text-gray-300">{item.ticker}</span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">Currency</span>
              {isAdmin ? (
                <select
                  value={currency || 'USD'}
                  onChange={(e) => handleCurrencyChange(item.ticker, item.companyName, e.target.value)}
                  onBlur={() => commitField(item.ticker, item.companyName, 'currency')}
                  className="px-3 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  onClick={(e) => e.stopPropagation()}
                >
                  {CURRENCIES.map((curr) => (
                    <option key={curr} value={curr}>
                      {curr}
                    </option>
                  ))}
                </select>
              ) : (
                <span className="text-sm text-black dark:text-white">{currency || 'USD'}</span>
              )}
            </div>
          </div>
          {/* Expand/Collapse Button */}
          <button
            onClick={toggleExpand}
            className="p-2 text-gray-600 dark:text-gray-300 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-all duration-200 flex-shrink-0"
            aria-label={isExpanded ? t('aria.collapseRow') : t('aria.expandRow')}
            aria-expanded={isExpanded}
          >
            <svg
              className={`w-5 h-5 transition-transform duration-200 ${isExpanded ? 'rotate-180' : ''}`}
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M19 9l-7 7-7-7"
              />
            </svg>
          </button>
        </div>

        {/* Secondary Columns - Expandable */}
        {isExpanded && (
          <div className="border-t border-gray-300 dark:border-gray-600 p-4 space-y-3 animate-fade-in">
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">ENTRY1</span>
              {isAdmin ? (
                <input
                  type="number"
                  value={entry1 || ''}
                  onChange={(e) => {
                    const value = parseFloat(e.target.value) || 0;
                    handleEntryExitChange(item.ticker, item.companyName, 'entry1', value);
                  }}
                  onBlur={() => commitField(item.ticker, item.companyName, 'entry1')}
                  className="px-3 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent w-24 text-center"
                  onClick={(e) => e.stopPropagation()}
                />
              ) : (
                <span className="text-sm text-black dark:text-white">{entry1 || '-'}</span>
              )}
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">ENTRY2</span>
              {isAdmin ? (
                <input
                  type="number"
                  value={entry2 || ''}
                  onChange={(e) => {
                    const value = parseFloat(e.target.value) || 0;
                    handleEntryExitChange(item.ticker, item.companyName, 'entry2', value);
                  }}
                  onBlur={() => commitField(item.ticker, item.companyName, 'entry2')}
                  className="px-3 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent w-24 text-center"
                  onClick={(e) => e.stopPropagation()}
                />
              ) : (
                <span className="text-sm text-black dark:text-white">{entry2 || '-'}</span>
              )}
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">EXIT1</span>
              {isAdmin ? (
                <input
                  type="number"
                  value={exit1 || ''}
                  onChange={(e) => {
                    const value = parseFloat(e.target.value) || 0;
                    handleEntryExitChange(item.ticker, item.companyName, 'exit1', value);
                  }}
                  onBlur={() => commitField(item.ticker, item.companyName, 'exit1')}
                  className="px-3 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent w-24 text-center"
                  onClick={(e) => e.stopPropagation()}
                />
              ) : (
                <span className="text-sm text-black dark:text-white">{exit1 || '-'}</span>
              )}
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">EXIT2</span>
              {isAdmin ? (
                <input
                  type="number"
                  value={exit2 || ''}
                  onChange={(e) => {
                    const value = parseFloat(e.target.value) || 0;
                    handleEntryExitChange(item.ticker, item.companyName, 'exit2', value);
                  }}
                  onBlur={() => commitField(item.ticker, item.companyName, 'exit2')}
                  className="px-3 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent w-24 text-center"
                  onClick={(e) => e.stopPropagation()}
                />
              ) : (
                <span className="text-sm text-black dark:text-white">{exit2 || '-'}</span>
              )}
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">Date of Update</span>
              <span className={`text-sm text-center ${
                dateOfUpdate && 
                !(entry1 === 0 && entry2 === 0 && exit1 === 0 && exit2 === 0) &&
                isDateOld(dateOfUpdate)
                  ? 'text-red-600 dark:text-red-400'
                  : 'text-black dark:text-white'
              }`}>
                {dateOfUpdate || '-'}
              </span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">Price</span>
              <span className="text-sm text-black dark:text-white">
                {item.price !== null ? item.price.toLocaleString() : 'N/A'}
              </span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">Benjamin Graham</span>
              <span className={`text-sm text-center ${
                item.benjaminGraham === null
                  ? 'text-black dark:text-white'
                  : item.benjaminGraham < 0 
                  ? 'text-red-700 dark:text-red-300'
                  : item.benjaminGraham > 0 && 
                    item.price !== null && item.price > 0 && 
                    item.price <= item.benjaminGraham * PRICE_TOLERANCE_GREEN
                  ? 'text-green-700 dark:text-green-200'
                  : item.benjaminGraham > 0 && 
                    item.price !== null && item.price > 0 && 
                    item.price <= item.benjaminGraham * PRICE_TOLERANCE_BLUE
                  ? 'text-blue-700 dark:text-blue-400'
                  : 'text-black dark:text-white'
              }`}>
                {item.benjaminGraham !== null ? item.benjaminGraham.toLocaleString() : 'N/A'}
              </span>
            </div>
            {hasIvFcf && (
              <div className="flex items-center justify-between">
                <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">IV (FCF)</span>
                <span className="text-sm text-black dark:text-white">
                  {item.ivFcf !== null && item.ivFcf !== undefined ? item.ivFcf.toLocaleString() : 'N/A'}
                </span>
              </div>
            )}
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">RR1</span>
              <span className={`text-sm ${rr1Color || 'text-black dark:text-white'}`}>
                {rr1 !== null ? `${Math.round(rr1)}%` : 'N/A'}
              </span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">RR2</span>
              <span className={`text-sm ${rr2Color || 'text-black dark:text-white'}`}>
                {rr2 !== null ? `${Math.round(rr2)}%` : 'N/A'}
              </span>
            </div>
          </div>
        )}
      </div>
    );
  }, [getEntryExitValue, calculateRR1, calculateRR2, getRR1Color, getRR2Color, hasIvFcf, handleCurrencyChange, handleEntryExitChange, commitField, isDateOld, isDateNearOld, isAdmin]);

  // Filter columns based on ivFcf availability
  const filteredColumns = useMemo(() => {
    if (hasIvFcf) {
      return ENTRY_EXIT_COLUMNS;
    }
    return ENTRY_EXIT_COLUMNS.filter(col => col.key !== 'ivFcf');
  }, [hasIvFcf]);

  return (
    <BaseTable<BenjaminGrahamData>
      data={data}
      loading={loading}
      error={error}
      columns={filteredColumns}
      filters={ENTRY_EXIT_FILTERS}
      tableId="benjamin-graham"
      renderCell={renderCell}
      renderHeader={renderHeader}
      renderMobileCard={renderMobileCard}
      enableVirtualScroll={true}
      virtualScrollRowHeight={60}
      virtualScrollOverscan={10}
      enableMobileExpand={true}
      searchFields={['companyName', 'ticker']}
      searchPlaceholder="Sök efter företag eller ticker..."
      defaultSortKey="companyName"
      defaultSortDirection="asc"
      stickyColumns={['antal', 'companyName', 'ticker', 'currency']}
      ariaLabel="Entry Exit"
      minTableWidth="800px"
      getRowKey={(item, index) => `${item.ticker}-${item.companyName}-${index}`}
    />
  );
}

export default React.memo(EntryExitTable);

```

## `src/components/ErrorBoundary.tsx`

```tsx
import { Component, ReactNode } from 'react';
import i18n from '../i18n/config';
import { formatError, logError } from '../utils/errorHandler';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    logError(error, {
      component: 'ErrorBoundary',
      operation: 'render component',
      additionalInfo: {
        componentStack: errorInfo.componentStack,
        errorBoundary: true,
      },
    });
  }

  render() {
    if (this.state.hasError && this.state.error) {
      const errorMessage = this.state.error.message || i18n.t('errorBoundary.unknownError');
      
      // Check if it's a Firebase configuration error
      const isFirebaseError = errorMessage.includes('Firebase') || errorMessage.includes('environment variables');
      
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 px-4">
          <div className="max-w-2xl w-full bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8">
            <div className="flex items-center mb-4">
              <svg
                className="w-8 h-8 text-red-500 mr-3"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                />
              </svg>
              <h2 className="text-2xl font-bold text-black dark:text-white">
                {i18n.t('errorBoundary.configurationError')}
              </h2>
            </div>
            
            <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md p-4 mb-4">
              <p className="text-red-800 dark:text-red-200 font-semibold mb-2">
                {errorMessage}
              </p>
            </div>

            {isFirebaseError && (
              <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-md p-4 mb-4">
                <h3 className="text-blue-900 dark:text-blue-200 font-semibold mb-2">
                  {i18n.t('errorBoundary.firebaseError.howToFix')}
                </h3>
                <ol className="list-decimal list-inside text-blue-800 dark:text-blue-200 space-y-2 text-sm">
                  <li>{i18n.t('errorBoundary.firebaseError.step1')}</li>
                  <li>
                    {i18n.t('errorBoundary.firebaseError.step2')}
                    <ul className="list-disc list-inside ml-4 mt-1">
                      <li>{i18n.t('errorBoundary.firebaseError.varApiKey')}</li>
                      <li>{i18n.t('errorBoundary.firebaseError.varAuthDomain')}</li>
                      <li>{i18n.t('errorBoundary.firebaseError.varProjectId')}</li>
                      <li>{i18n.t('errorBoundary.firebaseError.varStorageBucket')}</li>
                      <li>{i18n.t('errorBoundary.firebaseError.varMessagingSenderId')}</li>
                      <li>{i18n.t('errorBoundary.firebaseError.varAppId')}</li>
                    </ul>
                  </li>
                  <li>{i18n.t('errorBoundary.firebaseError.step3')}</li>
                  <li>{i18n.t('errorBoundary.firebaseError.step4')}</li>
                </ol>
              </div>
            )}

            {errorMessage.includes('useRefresh must be used within a RefreshProvider') && (
              <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-md p-4 mb-4">
                <h3 className="text-blue-900 dark:text-blue-200 font-semibold mb-2">
                  {i18n.t('errorBoundary.providerError.howToFix')}
                </h3>
                <p className="text-blue-800 dark:text-blue-200 text-sm mb-2">
                  {i18n.t('errorBoundary.providerError.description')}
                </p>
                <ol className="list-decimal list-inside text-blue-800 dark:text-blue-200 space-y-2 text-sm">
                  <li>{i18n.t('errorBoundary.providerError.step1')}</li>
                  <li>
                    {i18n.t('errorBoundary.providerError.step2')}
                    <pre className="bg-blue-100 dark:bg-blue-900 p-2 rounded mt-2 text-xs overflow-x-auto">
{`<LoadingProgressProvider>
  <RefreshProvider>
    <AutoRefreshProvider>
      ...
    </AutoRefreshProvider>
  </RefreshProvider>
</LoadingProgressProvider>`}
                    </pre>
                  </li>
                  <li>{i18n.t('errorBoundary.providerError.step3')}</li>
                  <li>{i18n.t('errorBoundary.providerError.step4')}</li>
                </ol>
              </div>
            )}

            <div className="flex justify-end space-x-3 mt-6">
              <button
                onClick={() => window.location.reload()}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
              >
                {i18n.t('errorBoundary.reloadPage')}
              </button>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}


```

## `src/components/GlobalSearch.tsx`

```tsx
import { useState, useRef, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useGlobalSearch, SearchResult } from '../hooks/useGlobalSearch';
import { ViewId } from '../types/navigation';
import { useDebounce } from '../hooks/useDebounce';
import { sanitizeSearchQuery } from '../utils/inputValidator';

interface GlobalSearchProps {
  onNavigate: (viewId: ViewId) => void;
}

export default function GlobalSearch({ onNavigate }: GlobalSearchProps) {
  const { t } = useTranslation();
  const { search } = useGlobalSearch();
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<SearchResult[]>([]);
  const [isOpen, setIsOpen] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const searchRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  
  // Debounce the search query with 300ms delay
  const debouncedQuery = useDebounce(query, 300);

  // Perform search when debounced query changes
  useEffect(() => {
    if (debouncedQuery.trim().length > 0) {
      // Sanitize the search query before using it
      const sanitizedQuery = sanitizeSearchQuery(debouncedQuery);
      const searchResults = search(sanitizedQuery);
      setResults(searchResults);
      setIsOpen(searchResults.length > 0);
      setSelectedIndex(-1);
    } else {
      setResults([]);
      setIsOpen(false);
    }
  }, [debouncedQuery, search]);

  // Close dropdown when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (searchRef.current && !searchRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    }

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen]);

  // Handle keyboard navigation
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (!isOpen || results.length === 0) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex((prev) => (prev < results.length - 1 ? prev + 1 : prev));
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex((prev) => (prev > 0 ? prev - 1 : -1));
        break;
      case 'Enter':
        e.preventDefault();
        if (selectedIndex >= 0 && selectedIndex < results.length) {
          handleSelectResult(results[selectedIndex]);
        } else if (results.length > 0) {
          handleSelectResult(results[0]);
        }
        break;
      case 'Escape':
        setIsOpen(false);
        setQuery('');
        inputRef.current?.blur();
        break;
    }
  };

  const handleSelectResult = (result: SearchResult) => {
    onNavigate(result.viewId);
    setIsOpen(false);
    setQuery('');
    inputRef.current?.blur();
  };

  const getTypeLabel = (type: SearchResult['type']): string => {
    const labels: Record<SearchResult['type'], string> = {
      'score-board': t('navigation.scoreBoard'),
      'benjamin-graham': t('navigation.benjaminGraham'),
      'pe-industry': t('navigation.peIndustry'),
      'entry-exit': t('navigation.tachart'),
      'threshold-industry': t('navigation.thresholdIndustry'),
    };
    return labels[type] || type;
  };

  return (
    <div ref={searchRef} className="relative w-full max-w-md">
      <div className="relative">
        <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
          <svg
            className="h-5 w-5 text-gray-600 dark:text-gray-300"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
            />
          </svg>
        </div>
        <input
          ref={inputRef}
          type="text"
          value={query}
          onChange={(e) => {
            // Sanitize input as user types
            const sanitized = sanitizeSearchQuery(e.target.value);
            setQuery(sanitized);
          }}
          onKeyDown={handleKeyDown}
          onFocus={() => {
            if (results.length > 0) {
              setIsOpen(true);
            }
          }}
          placeholder={t('globalSearch.placeholder', 'Sök i alla tabeller...')}
          maxLength={200}
          className="block w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-500 rounded-lg bg-white dark:bg-gray-700 text-black dark:text-white placeholder-gray-600 dark:placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200 text-sm"
        />
        {query && (
          <button
            onClick={() => {
              setQuery('');
              setIsOpen(false);
              inputRef.current?.focus();
            }}
            className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-600 dark:text-gray-300 hover:text-gray-700 dark:hover:text-gray-200 transition-all duration-200 hover:scale-110 active:scale-95 cursor-pointer min-h-[44px] min-w-[44px] touch-manipulation justify-center"
          >
            <svg className="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        )}
      </div>

      {isOpen && results.length > 0 && (
        <div className="absolute z-50 mt-1 w-full bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-300 dark:border-gray-500 max-h-96 overflow-y-auto animate-fade-in-up">
          <div className="p-2">
            {results.map((result, index) => (
              <button
                key={result.id}
                onClick={() => handleSelectResult(result)}
                className={`w-full text-left px-3 py-3 sm:py-2 rounded-md transition-all duration-200 min-h-[44px] touch-manipulation ${
                  index === selectedIndex
                    ? 'bg-blue-100 dark:bg-blue-900/30 text-blue-900 dark:text-blue-100 scale-[1.02]'
                    : 'hover:bg-gray-100 dark:hover:bg-gray-700 text-black dark:text-white hover:scale-[1.01] active:scale-95'
                }`}
              >
                <div className="flex items-center justify-between">
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center space-x-2">
                      <span className="text-xs font-semibold text-blue-700 dark:text-blue-400">
                        {getTypeLabel(result.type)}
                      </span>
                    </div>
                    <div className="mt-1 truncate">
                      <span className="font-medium">{result.label}</span>
                    </div>
                    {result.ticker && result.companyName && (
                      <div className="text-xs text-gray-600 dark:text-gray-300 mt-0.5">
                        {result.ticker}
                        {result.industry && ` • ${result.industry}`}
                      </div>
                    )}
                  </div>
                  <svg
                    className="w-4 h-4 text-gray-600 dark:text-gray-300 ml-2 flex-shrink-0"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                  </svg>
                </div>
              </button>
            ))}
          </div>
        </div>
      )}

      {isOpen && query.trim().length > 0 && results.length === 0 && (
        <div className="absolute z-50 mt-1 w-full bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-300 dark:border-gray-500 p-4 animate-fade-in-up">
          <p className="text-sm text-gray-600 dark:text-gray-300 text-center">
            {t('globalSearch.noResults', 'Inga resultat hittades')}
          </p>
        </div>
      )}
    </div>
  );
}


```

## `src/components/HamburgerMenu.tsx`

```tsx
interface HamburgerMenuProps {
  isOpen: boolean;
  onClick: () => void;
}

export default function HamburgerMenu({ isOpen, onClick }: HamburgerMenuProps) {
  return (
    <button
      onClick={onClick}
      className="p-3 sm:p-2 rounded-md text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-200 hover:scale-110 active:scale-95 min-h-[44px] min-w-[44px] touch-manipulation flex items-center justify-center"
      aria-label="Toggle menu"
      aria-expanded={isOpen}
    >
      <div className="w-6 h-6 sm:w-6 sm:h-6 flex flex-col justify-center items-center">
        <span
          className={`block h-0.5 w-6 bg-current transform transition-all duration-300 ${
            isOpen ? 'rotate-45 translate-y-1.5' : '-translate-y-0.5'
          }`}
        />
        <span
          className={`block h-0.5 w-6 bg-current transition-all duration-300 ${
            isOpen ? 'opacity-0' : 'opacity-100'
          }`}
        />
        <span
          className={`block h-0.5 w-6 bg-current transform transition-all duration-300 ${
            isOpen ? '-rotate-45 -translate-y-1.5' : 'translate-y-0.5'
          }`}
        />
      </div>
    </button>
  );
}


```

## `src/components/Header.tsx`

```tsx
import { useState, useRef, useEffect, lazy, Suspense } from 'react';
import { useTranslation } from 'react-i18next';
import { useTheme } from '../contexts/ThemeContext';
import { useRefresh } from '../contexts/RefreshContext';
import { useAuth } from '../contexts/AuthContext';
import { useToast } from '../contexts/ToastContext';
import { useNotifications } from '../contexts/NotificationContext';
import { useUserRole } from '../hooks/useUserRole';
import GlobalSearch from './GlobalSearch';
import NotificationCenter from './NotificationCenter';
import { ViewId } from '../types/navigation';
import { getTableId as getTableIdFromView } from '../config/viewTableMap';

// Lazy load help components
const OnboardingHelp = lazy(() => import('./OnboardingHelp'));

interface HeaderProps {
  onNavigate?: (viewId: ViewId) => void;
  activeView?: ViewId;
  sidebarCollapsed?: boolean;
}

export default function Header({ onNavigate, activeView, sidebarCollapsed = false }: HeaderProps) {
  const { i18n, t } = useTranslation();
  const { theme, setTheme } = useTheme();
  const { refreshAll, isRefreshing } = useRefresh();
  const { currentUser, logout } = useAuth();
  const { showToast } = useToast();
  const { unreadCount } = useNotifications();
  const { isAdmin } = useUserRole();
  const [themeMenuOpen, setThemeMenuOpen] = useState(false);
  const themeMenuRef = useRef<HTMLDivElement>(null);
  const [languageMenuOpen, setLanguageMenuOpen] = useState(false);
  const languageMenuRef = useRef<HTMLDivElement>(null);
  const [refreshMenuOpen, setRefreshMenuOpen] = useState(false);
  const refreshMenuRef = useRef<HTMLDivElement>(null);
  const [notificationCenterOpen, setNotificationCenterOpen] = useState(false);
  const [showHelp, setShowHelp] = useState(false);

  // Determine if help button should be shown (only for score and score-board views)
  const shouldShowHelp = activeView === 'score' || activeView === 'score-board';

  // Get tableId based on activeView (from shared config)
  const tableIdForHelp = activeView ? getTableIdFromView(activeView) ?? undefined : undefined;

  const handleLogout = async () => {
    try {
      await logout();
      showToast(t('auth.logoutSuccess'), 'success');
    } catch (error: unknown) {
      showToast(t('auth.logoutFailed'), 'error');
    }
  };

  const changeLanguage = (language: string) => {
    i18n.changeLanguage(language);
    localStorage.setItem('stockScoreLanguage', language);
  };

  const handleRefreshNow = async () => {
    if (!isAdmin) {
      return; // Only admin can refresh
    }
    setRefreshMenuOpen(false);
    await refreshAll();
  };

  // Close menus when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (themeMenuRef.current && !themeMenuRef.current.contains(event.target as Node)) {
        setThemeMenuOpen(false);
      }
      if (languageMenuRef.current && !languageMenuRef.current.contains(event.target as Node)) {
        setLanguageMenuOpen(false);
      }
      if (refreshMenuRef.current && !refreshMenuRef.current.contains(event.target as Node)) {
        setRefreshMenuOpen(false);
      }
    };

    if (themeMenuOpen || languageMenuOpen || refreshMenuOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [themeMenuOpen, languageMenuOpen, refreshMenuOpen]);

  const getThemeIcon = () => {
    switch (theme) {
      case 'dark':
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
          </svg>
        );
      case 'light':
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
          </svg>
        );
      default:
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
          </svg>
        );
    }
  };

  const handleThemeChange = (newTheme: 'light' | 'dark' | 'system') => {
    setTheme(newTheme);
    setThemeMenuOpen(false);
  };

  const handleLanguageChange = (language: string) => {
    changeLanguage(language);
    setLanguageMenuOpen(false);
  };

  const getLanguageIcon = () => {
    return (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129" />
      </svg>
    );
  };

  return (
    <div className={`h-16 bg-white dark:bg-gray-800 border-b border-gray-300 dark:border-gray-400 fixed top-0 ${sidebarCollapsed ? 'left-16' : 'left-64'} right-0 z-30 flex items-center justify-between px-4`}>
      {/* Left side: Personal Portfolio button and Global Search */}
      <div className="flex items-center gap-2 sm:gap-3 flex-1">
        {/* Personal Portfolio Button - only shown for authenticated users */}
        {currentUser && onNavigate && (
          <button
            onClick={() => onNavigate('personal-portfolio')}
            className={`w-10 h-10 flex items-center justify-center rounded-full bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 min-h-[44px] min-w-[44px] touch-manipulation ${
              activeView === 'personal-portfolio' ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-200' : ''
            }`}
            title={t('navigation.personalPortfolio', 'Personal Portfolio')}
            aria-label={t('navigation.personalPortfolio', 'Personal Portfolio')}
            aria-current={activeView === 'personal-portfolio' ? 'page' : undefined}
          >
            <svg
              className="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              aria-hidden="true"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"
              />
            </svg>
          </button>
        )}
        {/* Global Search */}
        <div className="flex-1 max-w-md mx-2 sm:mx-4">
          {onNavigate && <GlobalSearch onNavigate={onNavigate} />}
        </div>
      </div>

      {/* Right side controls */}
      <div className="flex items-center space-x-2 sm:space-x-3">
        {/* Help Button - only shown for score and score-board views */}
        {shouldShowHelp && (
          <button
            onClick={() => setShowHelp(true)}
            className="w-10 h-10 flex items-center justify-center rounded-full bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 min-h-[44px] min-w-[44px] touch-manipulation"
            title={i18n.language === 'sv' ? 'Hjälp och onboarding' : 'Help and onboarding'}
            aria-label={i18n.language === 'sv' ? 'Öppna hjälp' : 'Open help'}
          >
            <svg
              className="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              aria-hidden="true"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              />
            </svg>
          </button>
        )}
        {/* Notification Button */}
        {currentUser && (
          <button
            onClick={() => setNotificationCenterOpen(true)}
            className="relative w-10 h-10 flex items-center justify-center rounded-full bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 min-h-[44px] min-w-[44px] touch-manipulation"
            title={t('notifications.title', 'Notifications')}
            aria-label={t('notifications.title', 'Notifications')}
          >
            <svg
              className="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              aria-hidden="true"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"
              />
            </svg>
            {unreadCount > 0 && (
              <span className="absolute top-0 right-0 w-5 h-5 bg-red-600 dark:bg-red-500 text-white text-xs font-semibold rounded-full flex items-center justify-center border-2 border-white dark:border-gray-800">
                {unreadCount > 99 ? '99+' : unreadCount}
              </span>
            )}
          </button>
        )}
        {/* Refresh Button - Admin Only */}
        {isAdmin && (
          <div className="relative" ref={refreshMenuRef}>
            <button
              onClick={() => setRefreshMenuOpen(!refreshMenuOpen)}
              disabled={isRefreshing}
              className="w-10 h-10 flex items-center justify-center rounded-full bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-blue-500 min-h-[44px] min-w-[44px] touch-manipulation relative"
              title={t('refresh.refreshAllTooltip')}
              aria-label={t('refresh.refreshAllTooltip')}
              aria-expanded={refreshMenuOpen}
            >
              <svg
                className={`w-5 h-5 ${isRefreshing ? 'animate-spin' : ''}`}
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
                aria-hidden="true"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                />
              </svg>
            </button>

            {/* Dropdown Menu - Only Refresh Now */}
            {refreshMenuOpen && (
              <div 
                className="absolute right-0 mt-2 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 overflow-hidden z-50 animate-scale-in"
                role="menu"
                aria-label={t('aria.refreshMenu')}
              >
                {/* Refresh Now */}
                <button
                  onClick={handleRefreshNow}
                  disabled={isRefreshing}
                  className="w-full px-4 py-3 text-left flex items-center space-x-3 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                  role="menuitem"
                  aria-label={t('aria.refreshNowButton')}
                >
                  <svg className="w-5 h-5 text-gray-700 dark:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                  <span className="text-sm font-medium text-black dark:text-white">
                    {isRefreshing ? t('refresh.refreshing') : t('refresh.refreshNow')}
                  </span>
                </button>
              </div>
            )}
          </div>
        )}
        {/* Language Selector */}
        <div className="relative" ref={languageMenuRef}>
          <button
            onClick={() => setLanguageMenuOpen(!languageMenuOpen)}
            className="w-10 h-10 flex items-center justify-center rounded-full bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 min-h-[44px] min-w-[44px] touch-manipulation"
            title={t('aria.selectLanguage') || 'Välj språk'}
            aria-label={t('aria.selectLanguage') || 'Välj språk'}
            aria-expanded={languageMenuOpen}
          >
            {getLanguageIcon()}
          </button>

          {/* Dropdown Menu */}
          {languageMenuOpen && (
            <div 
              className="absolute right-0 mt-2 w-40 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 overflow-hidden z-50 animate-scale-in"
              role="menu"
              aria-label={t('aria.languageMenu')}
            >
              <button
                onClick={() => handleLanguageChange('en')}
                className={`w-full px-4 py-3 text-left flex items-center space-x-3 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors ${
                  i18n.language === 'en' ? 'bg-gray-100 dark:bg-gray-700' : ''
                }`}
                role="menuitem"
                aria-label={t('aria.englishLanguage')}
                aria-checked={i18n.language === 'en'}
              >
                <span className="text-sm font-medium text-black dark:text-white">Engelska</span>
              </button>
              <button
                onClick={() => handleLanguageChange('sv')}
                className={`w-full px-4 py-3 text-left flex items-center space-x-3 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors ${
                  i18n.language === 'sv' ? 'bg-gray-100 dark:bg-gray-700' : ''
                }`}
                role="menuitem"
                aria-label={t('aria.swedishLanguage')}
                aria-checked={i18n.language === 'sv'}
              >
                <span className="text-sm font-medium text-black dark:text-white">Svenska</span>
              </button>
            </div>
          )}
        </div>
        {/* Theme Selector */}
        <div className="relative" ref={themeMenuRef}>
          <button
            onClick={() => setThemeMenuOpen(!themeMenuOpen)}
            className="w-10 h-10 flex items-center justify-center rounded-full bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 min-h-[44px] min-w-[44px] touch-manipulation"
            title={t('aria.selectTheme') || 'Välj tema'}
            aria-label={t('aria.selectTheme') || 'Välj tema'}
            aria-expanded={themeMenuOpen}
          >
            {getThemeIcon()}
          </button>

          {/* Dropdown Menu */}
          {themeMenuOpen && (
            <div 
              className="absolute right-0 mt-2 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 overflow-hidden z-50 animate-scale-in"
              role="menu"
              aria-label={t('aria.themeMenu')}
            >
              <button
                onClick={() => handleThemeChange('light')}
                className={`w-full px-4 py-3 text-left flex items-center space-x-3 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors ${
                  theme === 'light' ? 'bg-gray-100 dark:bg-gray-700' : ''
                }`}
                role="menuitem"
                aria-label={t('aria.lightTheme')}
                aria-checked={theme === 'light'}
              >
                <svg className="w-5 h-5 text-gray-700 dark:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
                <span className="text-sm font-medium text-black dark:text-white">Light Theme</span>
              </button>
              <button
                onClick={() => handleThemeChange('dark')}
                className={`w-full px-4 py-3 text-left flex items-center space-x-3 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors ${
                  theme === 'dark' ? 'bg-gray-100 dark:bg-gray-700' : ''
                }`}
                role="menuitem"
                aria-label={t('aria.darkTheme')}
                aria-checked={theme === 'dark'}
              >
                <svg className="w-5 h-5 text-gray-700 dark:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                </svg>
                <span className="text-sm font-medium text-black dark:text-white">Dark Theme</span>
              </button>
            </div>
          )}
        </div>
        {currentUser && (
          <button
            onClick={handleLogout}
            className="w-10 h-10 flex items-center justify-center rounded-full bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 min-h-[44px] min-w-[44px] touch-manipulation"
            title={t('auth.logout')}
            aria-label={t('aria.logoutButton')}
          >
            <svg
              className="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              aria-hidden="true"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"
              />
            </svg>
          </button>
        )}
      </div>
      {currentUser && (
        <NotificationCenter
          isOpen={notificationCenterOpen}
          onClose={() => setNotificationCenterOpen(false)}
        />
      )}
      {shouldShowHelp && (
        <Suspense fallback={null}>
          <OnboardingHelp tableId={tableIdForHelp} isOpen={showHelp} onClose={() => setShowHelp(false)} />
        </Suspense>
      )}
    </div>
  );
}

```

## `src/components/HelpButton.tsx`

```tsx
import { useState } from 'react';
import { useTranslation } from 'react-i18next';

interface HelpButtonProps {
  onOpenHelp: () => void;
}

export default function HelpButton({ onOpenHelp }: HelpButtonProps) {
  const { t, i18n } = useTranslation();
  const language = i18n.language;

  return (
    <button
      onClick={onOpenHelp}
      className="px-3 sm:px-4 py-2.5 sm:py-2 text-sm font-medium rounded-md border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 transition-all duration-200 hover:shadow-md hover:scale-105 active:scale-95 flex items-center gap-2 min-h-[44px] touch-manipulation"
      title={language === 'sv' ? 'Hjälp och onboarding' : 'Help and onboarding'}
      aria-label={language === 'sv' ? 'Öppna hjälp' : 'Open help'}
    >
      <svg
        className="w-5 h-5"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth={2}
          d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
        />
      </svg>
      <span className="hidden sm:inline">
        {language === 'sv' ? 'Hjälp' : 'Help'}
      </span>
    </button>
  );
}


```

## `src/components/LastUpdated.tsx`

```tsx
import { useTranslation } from 'react-i18next';

interface LastUpdatedProps {
  lastUpdated: Date | null;
  onRefresh: () => void;
  loading: boolean;
}

export default function LastUpdated({ lastUpdated, onRefresh, loading }: LastUpdatedProps) {
  const { t, i18n } = useTranslation();

  const formatDate = (date: Date) => {
    const locale = i18n.language === 'sv' ? 'sv-SE' : 'en-US';
    const options: Intl.DateTimeFormatOptions = {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    };
    return date.toLocaleDateString(locale, options);
  };

  return (
    <div className="mb-6 text-sm font-medium text-gray-600 dark:text-gray-300">
      <span>
        {t('lastUpdated.lastUpdated')}:{' '}
        <span className="font-semibold text-gray-700 dark:text-gray-300">
          {lastUpdated ? formatDate(lastUpdated) : t('lastUpdated.never')}
        </span>
      </span>
      <button
        onClick={onRefresh}
        disabled={loading}
        className="ml-2 py-2 px-2 -mx-2 text-blue-700 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 font-semibold underline disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 hover:scale-105 active:scale-95 min-h-[44px] touch-manipulation inline-flex items-center gap-1.5"
        aria-label={t('aria.refreshButton')}
      >
        <svg
          className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`}
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          aria-hidden="true"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
          />
        </svg>
        <span>{loading ? t('lastUpdated.updating') : t('lastUpdated.auto')}</span>
      </button>
    </div>
  );
}

```

## `src/components/LoadingFallback.tsx`

```tsx
import { TableSkeleton } from './SkeletonLoader';

export default function LoadingFallback() {
  return (
    <div className="h-full bg-gray-100 dark:bg-gray-900 py-4 sm:py-6 lg:py-8 px-3 sm:px-4 lg:px-6 flex flex-col">
      <div className="w-full flex flex-col flex-1 min-h-0">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6 sm:mb-8 flex-shrink-0 gap-4">
          <div>
            <div className="h-8 w-48 bg-gray-200 dark:bg-gray-700 rounded animate-pulse mb-2"></div>
            <div className="h-4 w-64 bg-gray-200 dark:bg-gray-700 rounded animate-pulse"></div>
          </div>
          <div className="h-10 w-24 bg-gray-200 dark:bg-gray-700 rounded animate-pulse"></div>
        </div>
        <div className="flex-1 min-h-0">
          <TableSkeleton rows={10} columns={6} hasStickyColumns={true} />
        </div>
      </div>
    </div>
  );
}


```

## `src/components/Login.tsx`

```tsx
import { useState, FormEvent } from 'react';
import { useNavigate } from 'react-router-dom';
import { sendPasswordResetEmail } from 'firebase/auth';
import { httpsCallable } from 'firebase/functions';
import { auth } from '../config/firebase';
import { functions } from '../config/firebase';
import { useAuth } from '../contexts/AuthContext';
import { useTranslation } from 'react-i18next';
import { useToast } from '../contexts/ToastContext';

export interface LoginProps {
  returnUrl?: string;
}

export default function Login(props: LoginProps) {
  const { returnUrl } = props;
  const [mode, setMode] = useState<'login' | 'signup'>('login');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const [showReset, setShowReset] = useState(false);
  const [resetEmail, setResetEmail] = useState('');
  const [resetLoading, setResetLoading] = useState(false);
  const [resetMessage, setResetMessage] = useState('');
  const { login, signup, refreshUserRole } = useAuth();
  const { t } = useTranslation();
  const { showToast } = useToast();
  const navigate = useNavigate();

  const handleLogin = async (e: FormEvent) => {
    e.preventDefault();
    try {
      setError('');
      setLoading(true);
      await login(email, password);
      showToast(t('auth.loginSuccess'), 'success');
      navigate(returnUrl || '/', { replace: true });
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : t('auth.loginFailed');
      setError(errorMessage);
      showToast(errorMessage, 'error');
    } finally {
      setLoading(false);
    }
  };

  const handleSignup = async (e: FormEvent) => {
    e.preventDefault();
    if (password !== confirmPassword) {
      setError(t('auth.passwordMismatch') || 'Passwords do not match');
      showToast(t('auth.passwordMismatch') || 'Passwords do not match', 'error');
      return;
    }
    if (password.length < 6) {
      setError(t('auth.passwordTooShort') || 'Password must be at least 6 characters');
      showToast(t('auth.passwordTooShort') || 'Password must be at least 6 characters', 'error');
      return;
    }
    try {
      setError('');
      setLoading(true);
      const userCredential = await signup(email, password);
      const claimViewerRole = httpsCallable(functions, 'claimViewerRole');
      await claimViewerRole();
      const user = userCredential.user;
      await user.getIdToken(true);
      await refreshUserRole();
      showToast(t('auth.signupSuccess'), 'success');
      navigate(returnUrl || '/', { replace: true });
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : t('auth.signupFailed');
      setError(errorMessage);
      showToast(errorMessage, 'error');
    } finally {
      setLoading(false);
    }
  };

  const handleSubmit = mode === 'login' ? handleLogin : handleSignup;

  const handlePasswordReset = async (e: React.MouseEvent) => {
    e.preventDefault();
    const emailToReset = resetEmail || email;

    if (!emailToReset) {
      setError(t('auth.emailRequired') || 'Please enter your email address');
      return;
    }

    try {
      setError('');
      setResetMessage('');
      setResetLoading(true);
      await sendPasswordResetEmail(auth, emailToReset);
      setResetMessage(t('auth.resetEmailSent') || 'Password reset email sent! Check your inbox.');
      showToast(t('auth.resetEmailSent') || 'Password reset email sent!', 'success');
      setShowReset(false);
      setResetEmail('');
    } catch (err: unknown) {
      const errorMsg =
        err instanceof Error ? err.message : (t('auth.resetFailed') || 'Failed to send reset email');
      setError(errorMsg);
      showToast(errorMsg, 'error');
    } finally {
      setResetLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900 px-4">
      <div className="max-w-md w-full bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8">
        <h2 className="text-3xl font-bold text-center mb-6 text-black dark:text-white">
          {mode === 'login' ? t('auth.login') : t('auth.createAccount')}
        </h2>

        {error && (
          <div className="bg-red-100 dark:bg-red-900 border border-red-400 text-red-700 dark:text-red-200 px-4 py-3 rounded mb-4">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label
              htmlFor="email"
              className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
            >
              {t('auth.email')}
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder={t('auth.emailPlaceholder')}
            />
          </div>

          <div>
            <div className="flex items-center justify-between mb-2">
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                {t('auth.password')}
              </label>
              {mode === 'login' && (
                <button
                  type="button"
                  onClick={() => {
                    setShowReset(!showReset);
                    setResetEmail(email);
                    setError('');
                    setResetMessage('');
                  }}
                  className="text-sm text-blue-700 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 font-medium"
                >
                  {t('auth.forgotPassword')}
                </button>
              )}
            </div>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              minLength={6}
              className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder={t('auth.passwordPlaceholder')}
            />
            {mode === 'signup' && (
              <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
                {t('auth.passwordMinLength')}
              </p>
            )}
          </div>

          {mode === 'signup' && (
            <div>
              <label
                htmlFor="confirmPassword"
                className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
              >
                {t('auth.confirmPassword')}
              </label>
              <input
                id="confirmPassword"
                type="password"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                required
                minLength={6}
                className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                placeholder={t('auth.confirmPasswordPlaceholder')}
              />
            </div>
          )}

          {showReset && (
            <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-md p-4">
              <p className="text-sm text-gray-700 dark:text-gray-300 mb-3">
                {t('auth.enterEmailForReset')}
              </p>
              <div className="flex gap-2">
                <input
                  type="email"
                  value={resetEmail}
                  onChange={(e) => setResetEmail(e.target.value)}
                  placeholder={t('auth.emailPlaceholder')}
                  className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
                />
                <button
                  type="button"
                  onClick={handlePasswordReset}
                  disabled={resetLoading || !resetEmail}
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200 font-semibold text-sm"
                >
                  {resetLoading ? t('auth.sending') : t('auth.sendResetEmail')}
                </button>
              </div>
              {resetMessage && (
                <p className="mt-2 text-sm text-green-700 dark:text-green-200">{resetMessage}</p>
              )}
              <button
                type="button"
                onClick={() => {
                  setShowReset(false);
                  setResetEmail('');
                  setResetMessage('');
                }}
                className="mt-2 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200"
              >
                {t('auth.cancel') || 'Cancel'}
              </button>
            </div>
          )}

          <button
            type="submit"
            disabled={loading || showReset}
            className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200 font-semibold"
          >
            {loading
              ? mode === 'login'
                ? t('auth.loggingIn')
                : t('auth.creatingAccount')
              : mode === 'login'
                ? t('auth.login')
                : t('auth.createAccount')}
          </button>
        </form>

        <p className="mt-6 text-center text-sm text-gray-600 dark:text-gray-400">
          {mode === 'login' ? (
            <>
              {t('auth.noAccount') || "Don't have an account? "}
              <button
                type="button"
                onClick={() => {
                  setMode('signup');
                  setError('');
                  setConfirmPassword('');
                }}
                className="text-blue-600 dark:text-blue-400 hover:underline font-medium"
              >
                {t('auth.createAccount')}
              </button>
            </>
          ) : (
            <>
              {t('auth.alreadyHaveAccount')}
              <button
                type="button"
                onClick={() => {
                  setMode('login');
                  setError('');
                  setConfirmPassword('');
                }}
                className="ml-1 text-blue-600 dark:text-blue-400 hover:underline font-medium"
              >
                {t('auth.login')}
              </button>
            </>
          )}
        </p>
      </div>
    </div>
  );
}

```

## `src/components/NotificationCenter.tsx`

```tsx
import { useState, useCallback } from 'react';
import { useNotifications } from '../contexts/NotificationContext';
import { Notification, NotificationType } from '../services/notificationService';
import { useTranslation } from 'react-i18next';

interface NotificationCenterProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function NotificationCenter({ isOpen, onClose }: NotificationCenterProps) {
  const { t } = useTranslation();
  const {
    notifications,
    unreadCount,
    permissionState,
    requestPermission,
    markAsRead,
    markAllAsRead,
    removeNotification,
    clearAll,
  } = useNotifications();

  const [filter, setFilter] = useState<NotificationType | 'all'>('all');

  const getNotificationIcon = (type: NotificationType): string => {
    switch (type) {
      case 'success':
        return '✓';
      case 'error':
        return '✕';
      case 'warning':
        return '⚠';
      case 'info':
        return 'ℹ';
      case 'data-update':
        return '🔄';
      default:
        return '•';
    }
  };

  const getNotificationColor = (type: NotificationType): string => {
    switch (type) {
      case 'success':
        return 'bg-green-100 dark:bg-green-900/20 text-green-800 dark:text-green-200 border-green-300 dark:border-green-700';
      case 'error':
        return 'bg-red-100 dark:bg-red-900/20 text-red-800 dark:text-red-200 border-red-300 dark:border-red-700';
      case 'warning':
        return 'bg-yellow-100 dark:bg-yellow-900/20 text-yellow-800 dark:text-yellow-200 border-yellow-300 dark:border-yellow-700';
      case 'info':
        return 'bg-blue-100 dark:bg-blue-900/20 text-blue-800 dark:text-blue-200 border-blue-300 dark:border-blue-700';
      case 'data-update':
        return 'bg-purple-100 dark:bg-purple-900/20 text-purple-800 dark:text-purple-200 border-purple-300 dark:border-purple-700';
      default:
        return 'bg-gray-100 dark:bg-gray-800 text-gray-800 dark:text-gray-200 border-gray-300 dark:border-gray-700';
    }
  };

  const formatTimestamp = (timestamp: number): string => {
    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) {
      return t('notifications.justNow', 'Just now');
    } else if (diffMins < 60) {
      return t('notifications.minutesAgo', { count: diffMins }, `${diffMins} min ago`);
    } else if (diffHours < 24) {
      return t('notifications.hoursAgo', { count: diffHours }, `${diffHours} h ago`);
    } else if (diffDays < 7) {
      return t('notifications.daysAgo', { count: diffDays }, `${diffDays} d ago`);
    } else {
      return date.toLocaleDateString();
    }
  };

  const filteredNotifications =
    filter === 'all'
      ? notifications
      : notifications.filter((n) => n.type === filter);

  const handleNotificationClick = useCallback(
    (notification: Notification) => {
      if (!notification.read) {
        markAsRead(notification.id);
      }
    },
    [markAsRead]
  );

  const handleRequestPermission = useCallback(async () => {
    await requestPermission();
  }, [requestPermission]);

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 dark:bg-opacity-70 animate-fade-in transition-opacity duration-300"
      onClick={onClose}
    >
      <div
        className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl max-h-[80vh] flex flex-col m-4 animate-scale-in transition-all duration-300"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-gray-300 dark:border-gray-600">
          <div className="flex items-center gap-3">
            <h2 className="text-xl font-bold text-black dark:text-white">
              {t('notifications.title', 'Notifications')}
            </h2>
            {unreadCount > 0 && (
              <span className="px-2 py-1 text-xs font-semibold text-white bg-blue-600 dark:bg-blue-500 rounded-full">
                {unreadCount}
              </span>
            )}
          </div>
          <div className="flex items-center gap-2">
            {permissionState !== 'granted' && (
              <button
                onClick={handleRequestPermission}
                className="px-3 py-1.5 text-sm font-medium text-blue-600 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-md transition-colors"
              >
                {t('notifications.enableDesktop', 'Enable Desktop')}
              </button>
            )}
            {notifications.length > 0 && (
              <>
                {unreadCount > 0 && (
                  <button
                    onClick={markAllAsRead}
                    className="px-3 py-1.5 text-sm font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-colors"
                  >
                    {t('notifications.markAllRead', 'Mark all read')}
                  </button>
                )}
                <button
                  onClick={clearAll}
                  className="px-3 py-1.5 text-sm font-medium text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-md transition-colors"
                >
                  {t('notifications.clearAll', 'Clear all')}
                </button>
              </>
            )}
            <button
              onClick={onClose}
              className="p-2 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-colors"
              aria-label={t('common.close', 'Close')}
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>

        {/* Filters */}
        <div className="flex items-center gap-2 p-4 border-b border-gray-300 dark:border-gray-600 overflow-x-auto">
          <button
            onClick={() => setFilter('all')}
            className={`px-3 py-1.5 text-sm font-medium rounded-md transition-colors whitespace-nowrap ${
              filter === 'all'
                ? 'bg-blue-600 text-white dark:bg-blue-500'
                : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
            }`}
          >
            {t('notifications.all', 'All')}
          </button>
          <button
            onClick={() => setFilter('data-update')}
            className={`px-3 py-1.5 text-sm font-medium rounded-md transition-colors whitespace-nowrap ${
              filter === 'data-update'
                ? 'bg-blue-600 text-white dark:bg-blue-500'
                : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
            }`}
          >
            {t('notifications.dataUpdates', 'Data Updates')}
          </button>
          <button
            onClick={() => setFilter('error')}
            className={`px-3 py-1.5 text-sm font-medium rounded-md transition-colors whitespace-nowrap ${
              filter === 'error'
                ? 'bg-blue-600 text-white dark:bg-blue-500'
                : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
            }`}
          >
            {t('notifications.errors', 'Errors')}
          </button>
          <button
            onClick={() => setFilter('success')}
            className={`px-3 py-1.5 text-sm font-medium rounded-md transition-colors whitespace-nowrap ${
              filter === 'success'
                ? 'bg-blue-600 text-white dark:bg-blue-500'
                : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
            }`}
          >
            {t('notifications.success', 'Success')}
          </button>
        </div>

        {/* Notifications List */}
        <div className="flex-1 overflow-y-auto p-4">
          {filteredNotifications.length === 0 ? (
            <div className="text-center py-12 text-gray-500 dark:text-gray-400">
              <svg
                className="w-16 h-16 mx-auto mb-4 text-gray-400 dark:text-gray-500"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"
                />
              </svg>
                <p className="text-lg font-medium">{t('notifications.noNotifications', 'No notifications')}</p>
                <p className="text-sm mt-2">{t('notifications.noNotificationsDesc', "You're all caught up!")}</p>
            </div>
          ) : (
            <div className="space-y-3">
              {filteredNotifications.map((notification) => (
                <div
                  key={notification.id}
                  onClick={() => handleNotificationClick(notification)}
                  className={`p-4 rounded-lg border-2 cursor-pointer transition-all ${
                    notification.read
                      ? 'bg-gray-50 dark:bg-gray-800/50 border-gray-200 dark:border-gray-700'
                      : 'bg-white dark:bg-gray-800 border-blue-300 dark:border-blue-700 shadow-sm'
                  } ${getNotificationColor(notification.type)}`}
                >
                  <div className="flex items-start justify-between gap-3">
                    <div className="flex items-start gap-3 flex-1">
                      <div className="flex-shrink-0 w-8 h-8 rounded-full bg-white dark:bg-gray-700 flex items-center justify-center text-lg font-bold">
                        {getNotificationIcon(notification.type)}
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 mb-1">
                          <h3 className="text-sm font-semibold">{notification.title}</h3>
                          {!notification.read && (
                            <span className="w-2 h-2 bg-blue-600 dark:bg-blue-400 rounded-full"></span>
                          )}
                        </div>
                        <p className="text-sm opacity-90">{notification.message}</p>
                        <p className="text-xs opacity-75 mt-1">{formatTimestamp(notification.timestamp)}</p>
                      </div>
                    </div>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        removeNotification(notification.id);
                      }}
                      className="flex-shrink-0 p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded transition-colors"
                      aria-label={t('notifications.remove', 'Remove notification')}
                    >
                      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

```

## `src/components/OfflineIndicator.tsx`

```tsx
import { useTranslation } from 'react-i18next';
import { useOnlineStatus } from '../hooks/useOnlineStatus';

export default function OfflineIndicator() {
  const { t } = useTranslation();
  const isOnline = useOnlineStatus();

  if (isOnline) {
    return null;
  }

  return (
    <div
      className="fixed bottom-4 right-4 z-50 bg-yellow-500 dark:bg-yellow-600 text-white px-4 py-2 rounded-lg shadow-lg flex items-center gap-2 animate-fade-in"
      role="alert"
      aria-live="polite"
    >
      <svg
        className="w-5 h-5"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
        aria-hidden="true"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth={2}
          d="M18.364 5.636a9 9 0 010 12.728m0 0l-2.829-2.829m2.829 2.829L21 21M15.536 8.464a5 5 0 010 7.072m0 0l-2.829-2.829m-4.243 2.829a4.978 4.978 0 01-1.414-2.83m-1.414 5.658a9 9 0 01-2.167-9.238m7.824 2.167a1 1 0 111.414 1.414m-1.414-1.414L3 3m8.293 8.293l1.414 1.414"
        />
      </svg>
      <span className="text-sm font-medium">
        {t('offline.indicator', 'Offline - Visar cachad data')}
      </span>
    </div>
  );
}

```

## `src/components/OnboardingHelp.tsx`

```tsx
import { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';

interface OnboardingHelpProps {
  tableId?: string;
  isOpen?: boolean;
  onClose?: () => void;
}

export default function OnboardingHelp({ tableId, isOpen: externalIsOpen, onClose: externalOnClose }: OnboardingHelpProps) {
  const [internalIsOpen, setInternalIsOpen] = useState(false);
  const [currentStep, setCurrentStep] = useState(0);
  const { t, i18n } = useTranslation();
  const language = i18n.language;

  // Use external control if provided, otherwise use internal state
  const isOpen = externalIsOpen !== undefined ? externalIsOpen : internalIsOpen;

  // Check if user has completed onboarding (only for auto-open behavior when not externally controlled)
  useEffect(() => {
    if (externalIsOpen === undefined) {
      const onboardingCompleted = localStorage.getItem('stockScoreOnboardingCompleted');
      if (!onboardingCompleted) {
        // Show onboarding for first-time users after a short delay
        const timer = setTimeout(() => {
          setInternalIsOpen(true);
        }, 1000);
        return () => clearTimeout(timer);
      }
    }
  }, [externalIsOpen]);

  const markCompleted = () => {
    localStorage.setItem('stockScoreOnboardingCompleted', 'true');
    if (externalOnClose) {
      externalOnClose();
    } else {
      setInternalIsOpen(false);
    }
  };

  const onboardingSteps = language === 'sv' ? [
    {
      title: 'Välkommen till Stock Score!',
      content: 'Detta är din guide för att komma igång med Stock Score-applikationen. Klicka på "Nästa" för att lära dig mer.',
      icon: '👋'
    },
    {
      title: 'Tabellfunktioner',
      content: 'Alla tabeller stöder sökning, filtrering, sortering och kolumnsynlighet. Använd verktygsfälten ovanför varje tabell för att anpassa din vy.',
      icon: '📊'
    },
    {
      title: 'Kolumnfilter',
      content: 'Varje kolumn har ett filter-ikon i headern. Klicka på ikonen för att filtrera data direkt i kolumnen. Filter kan kombineras för mer avancerad filtrering.',
      icon: '🔍'
    },
    {
      title: 'Tooltips & Information',
      content: 'Hovra över kolumnnamn eller klicka på ikoner för att se detaljerad information om datakällor, formler och villkor. Information-ikonen (ℹ️) visar ytterligare detaljer.',
      icon: 'ℹ️'
    },
    {
      title: 'Färgkodning',
      content: 'Värden är färgkodade: GRÖN = bra, BLÅ = medel, RÖD = dåligt. Färger baseras på thresholds och branschstandarder.',
      icon: '🎨'
    },
    {
      title: 'Klar att börja!',
      content: 'Du kan alltid öppna denna guide igen genom att klicka på hjälp-ikonen i sidofältet eller header. Lycka till med din analys!',
      icon: '✅'
    }
  ] : [
    {
      title: 'Welcome to Stock Score!',
      content: 'This is your guide to get started with the Stock Score application. Click "Next" to learn more.',
      icon: '👋'
    },
    {
      title: 'Table Features',
      content: 'All tables support search, filtering, sorting, and column visibility. Use the toolbars above each table to customize your view.',
      icon: '📊'
    },
    {
      title: 'Column Filters',
      content: 'Each column has a filter icon in the header. Click the icon to filter data directly in the column. Filters can be combined for advanced filtering.',
      icon: '🔍'
    },
    {
      title: 'Tooltips & Information',
      content: 'Hover over column names or click icons to see detailed information about data sources, formulas, and conditions. The info icon (ℹ️) shows additional details.',
      icon: 'ℹ️'
    },
    {
      title: 'Color Coding',
      content: 'Values are color-coded: GREEN = good, BLUE = medium, RED = bad. Colors are based on thresholds and industry standards.',
      icon: '🎨'
    },
    {
      title: 'Ready to Start!',
      content: 'You can always open this guide again by clicking the help icon in the sidebar or header. Good luck with your analysis!',
      icon: '✅'
    }
  ];

  const handleClose = () => {
    if (externalOnClose) {
      externalOnClose();
    } else {
      setInternalIsOpen(false);
    }
  };

  const handleNext = () => {
    if (currentStep < onboardingSteps.length - 1) {
      setCurrentStep(currentStep + 1);
    } else {
      markCompleted();
    }
  };

  const handlePrevious = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };

  const handleSkip = () => {
    markCompleted();
  };

  if (!isOpen) {
    return null;
  }

  const currentStepData = onboardingSteps[currentStep];

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 animate-fade-in">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-2xl max-w-lg w-full p-6 animate-fade-in-up">
        {/* Header */}
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-3">
            <span className="text-3xl">{currentStepData.icon}</span>
            <div>
              <h3 className="text-xl font-bold text-black dark:text-white">
                {currentStepData.title}
              </h3>
              <p className="text-sm text-gray-500 dark:text-gray-400">
                {currentStep + 1} / {onboardingSteps.length}
              </p>
            </div>
          </div>
          <button
            onClick={handleClose}
            className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors min-h-[44px] min-w-[44px] flex items-center justify-center"
            aria-label={t('aria.closeModal')}
          >
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Content */}
        <div className="mb-6">
          <p className="text-gray-700 dark:text-gray-300 leading-relaxed">
            {currentStepData.content}
          </p>
        </div>

        {/* Progress Bar */}
        <div className="mb-6">
          <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
            <div
              className="bg-blue-600 dark:bg-blue-500 h-2 rounded-full transition-all duration-300"
              style={{ width: `${((currentStep + 1) / onboardingSteps.length) * 100}%` }}
            />
          </div>
        </div>

        {/* Footer Buttons */}
        <div className="flex items-center justify-between gap-3">
          <button
            onClick={handleSkip}
            className="px-4 py-2 text-sm font-medium text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors min-h-[44px]"
          >
            {language === 'sv' ? 'Hoppa över' : 'Skip'}
          </button>
          <div className="flex gap-2">
            {currentStep > 0 && (
              <button
                onClick={handlePrevious}
                className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-200 dark:bg-gray-700 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors min-h-[44px]"
              >
                {language === 'sv' ? 'Föregående' : 'Previous'}
              </button>
            )}
            <button
              onClick={handleNext}
              className="px-4 py-2 text-sm font-medium text-white bg-blue-600 dark:bg-blue-500 rounded-md hover:bg-blue-700 dark:hover:bg-blue-600 transition-colors min-h-[44px] flex items-center gap-2"
            >
              {currentStep === onboardingSteps.length - 1
                ? (language === 'sv' ? 'Klar' : 'Done')
                : (language === 'sv' ? 'Nästa' : 'Next')}
              {currentStep < onboardingSteps.length - 1 && (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}


```

## `src/components/Pagination.tsx`

```tsx
interface PaginationProps {
  currentPage: number;
  totalPages: number;
  totalItems: number;
  itemsPerPage: number;
  startIndex: number;
  endIndex: number;
  onPageChange: (page: number) => void;
  onNextPage: () => void;
  onPreviousPage: () => void;
  onFirstPage: () => void;
  onLastPage: () => void;
}

export default function Pagination({
  currentPage,
  totalPages,
  totalItems,
  itemsPerPage,
  startIndex,
  endIndex,
  onPageChange,
  onNextPage,
  onPreviousPage,
  onFirstPage,
  onLastPage,
}: PaginationProps) {
  if (totalPages <= 1) {
    return null;
  }

  const getPageNumbers = () => {
    const pages: (number | string)[] = [];
    const maxVisible = 7;

    if (totalPages <= maxVisible) {
      // Show all pages
      for (let i = 1; i <= totalPages; i++) {
        pages.push(i);
      }
    } else {
      // Always show first page
      pages.push(1);

      if (currentPage > 3) {
        pages.push('...');
      }

      // Show pages around current page
      const start = Math.max(2, currentPage - 1);
      const end = Math.min(totalPages - 1, currentPage + 1);

      for (let i = start; i <= end; i++) {
        if (i !== 1 && i !== totalPages) {
          pages.push(i);
        }
      }

      if (currentPage < totalPages - 2) {
        pages.push('...');
      }

      // Always show last page
      if (totalPages > 1) {
        pages.push(totalPages);
      }
    }

    return pages;
  };

  return (
    <div className="bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 px-4 py-3 flex items-center justify-between flex-shrink-0" style={{ minHeight: '60px' }}>
      {/* Mobile view */}
      <div className="flex-1 flex justify-between sm:hidden gap-3">
        <button
          onClick={onPreviousPage}
          disabled={currentPage === 1}
          className="relative inline-flex items-center justify-center px-5 py-3 border border-gray-300 dark:border-gray-500 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 hover:scale-105 active:scale-95 min-h-[44px] min-w-[120px] touch-manipulation flex-1 gap-2"
        >
          <svg
            className="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M15 19l-7-7 7-7"
            />
          </svg>
          <span>Föregående</span>
        </button>
        <button
          onClick={onNextPage}
          disabled={currentPage === totalPages}
          className="relative inline-flex items-center justify-center px-5 py-3 border border-gray-300 dark:border-gray-500 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 hover:scale-105 active:scale-95 min-h-[44px] min-w-[120px] touch-manipulation flex-1 gap-2"
        >
          <span>Nästa</span>
          <svg
            className="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M9 5l7 7-7 7"
            />
          </svg>
        </button>
      </div>

      {/* Desktop view */}
      <div className="hidden sm:flex-1 sm:flex sm:items-center sm:justify-between">
        <div>
          <p className="text-sm font-medium text-gray-700 dark:text-gray-300">
            Visar <span className="font-bold text-black dark:text-white">{startIndex}</span> till{' '}
            <span className="font-bold text-black dark:text-white">{endIndex}</span> av{' '}
            <span className="font-bold text-black dark:text-white">{totalItems}</span> resultat
          </p>
        </div>
        <div>
          <nav className="relative z-0 inline-flex rounded-md shadow-sm -space-x-px" aria-label="Pagination">
            {/* First page button */}
            <button
              onClick={onFirstPage}
              disabled={currentPage === 1}
              className="relative inline-flex items-center justify-center px-3 py-2.5 sm:px-2 sm:py-2 rounded-l-md border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-700 text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 hover:scale-105 active:scale-95 min-h-[44px] min-w-[44px] touch-manipulation"
              title="Första sidan"
            >
              <span className="sr-only">Första sidan</span>
              <svg
                className="h-5 w-5"
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path
                  fillRule="evenodd"
                  d="M15.707 15.707a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 010 1.414zm-6 0a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 011.414 1.414L5.414 10l4.293 4.293a1 1 0 010 1.414z"
                  clipRule="evenodd"
                />
              </svg>
            </button>

            {/* Previous page button */}
            <button
              onClick={onPreviousPage}
              disabled={currentPage === 1}
              className="relative inline-flex items-center justify-center px-3 py-2.5 sm:px-2 sm:py-2 border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-700 text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 hover:scale-105 active:scale-95 min-h-[44px] min-w-[44px] touch-manipulation"
              title="Föregående"
            >
              <span className="sr-only">Föregående</span>
              <svg
                className="h-5 w-5"
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path
                  fillRule="evenodd"
                  d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                  clipRule="evenodd"
                />
              </svg>
            </button>

            {/* Page numbers */}
            {getPageNumbers().map((page, index) => {
              if (page === '...') {
                return (
                  <span
                    key={`ellipsis-${index}`}
                    className="relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-700 text-sm font-medium text-gray-700 dark:text-gray-300"
                  >
                    ...
                  </span>
                );
              }

              const pageNum = page as number;
              const isCurrent = pageNum === currentPage;

              return (
                <button
                  key={pageNum}
                  onClick={() => onPageChange(pageNum)}
                  className={`relative inline-flex items-center justify-center px-4 py-2.5 sm:px-4 sm:py-2 border text-sm font-medium transition-all duration-200 min-h-[44px] min-w-[44px] touch-manipulation ${
                    isCurrent
                      ? 'z-10 bg-blue-50 dark:bg-blue-900 border-blue-500 dark:border-blue-400 text-blue-700 dark:text-blue-200 scale-105'
                      : 'bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-500 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 hover:scale-105 active:scale-95'
                  }`}
                >
                  {pageNum}
                </button>
              );
            })}

            {/* Next page button */}
            <button
              onClick={onNextPage}
              disabled={currentPage === totalPages}
              className="relative inline-flex items-center justify-center px-3 py-2.5 sm:px-2 sm:py-2 border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-700 text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 hover:scale-105 active:scale-95 min-h-[44px] min-w-[44px] touch-manipulation"
              title="Nästa"
            >
              <span className="sr-only">Nästa</span>
              <svg
                className="h-5 w-5"
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path
                  fillRule="evenodd"
                  d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
                  clipRule="evenodd"
                />
              </svg>
            </button>

            {/* Last page button */}
            <button
              onClick={onLastPage}
              disabled={currentPage === totalPages}
              className="relative inline-flex items-center justify-center px-3 py-2.5 sm:px-2 sm:py-2 rounded-r-md border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-700 text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 hover:scale-105 active:scale-95 min-h-[44px] min-w-[44px] touch-manipulation"
              title="Sista sidan"
            >
              <span className="sr-only">Sista sidan</span>
              <svg
                className="h-5 w-5"
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path
                  fillRule="evenodd"
                  d="M4.293 4.293a1 1 0 011.414 0l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414zm6 0a1 1 0 011.414 0l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414-1.414L14.586 10l-4.293-4.293a1 1 0 010-1.414z"
                  clipRule="evenodd"
                />
              </svg>
            </button>
          </nav>
        </div>
      </div>
    </div>
  );
}


```

## `src/components/PEIndustryTable.tsx`

```tsx
import React, { useMemo, useCallback } from 'react';
import { PEIndustryData } from '../types/stock';
import BaseTable, { ColumnDefinition, HeaderRenderProps } from './BaseTable';
import ColumnTooltip from './ColumnTooltip';
import ColumnFilterMenu from './ColumnFilterMenu';
import { getColumnMetadata } from '../config/tableMetadata';
import { FilterConfig } from './AdvancedFilters';
import { useTranslation } from 'react-i18next';

interface PEIndustryTableProps {
  data: PEIndustryData[];
  loading: boolean;
  error: string | null;
}

const PE_INDUSTRY_COLUMNS: ColumnDefinition<PEIndustryData>[] = [
  { key: 'antal', label: 'Antal', required: true, sticky: true, sortable: false },
  { key: 'industry', label: 'Industry', required: true, sticky: true, sortable: true },
  { key: 'pe', label: 'P/E INDUSTRY', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'pe1', label: 'P/E1 INDUSTRY', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'pe2', label: 'P/E2 INDUSTRY', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'companyCount', label: 'Antal bolag', defaultVisible: true, sortable: true, align: 'center' },
];

export default function PEIndustryTable({ data, loading, error }: PEIndustryTableProps) {
  const { t } = useTranslation();
  
  // Get unique industries for filter dropdown
  const uniqueIndustries = useMemo(() => {
    const industries = new Set<string>();
    data.forEach((item) => {
      if (item.industry && item.industry.trim()) {
        industries.add(item.industry);
      }
    });
    return Array.from(industries).sort().map((ind) => ({ value: ind, label: ind }));
  }, [data]);

  const peIndustryFilters: FilterConfig[] = useMemo(() => [
    {
      key: 'industry',
      label: 'Industri',
      type: 'select',
      options: uniqueIndustries,
    },
    {
      key: 'pe',
      label: 'P/E INDUSTRY',
      type: 'numberRange',
      step: 0.1,
    },
    {
      key: 'pe1',
      label: 'P/E1 INDUSTRY',
      type: 'numberRange',
      step: 0.1,
    },
    {
      key: 'pe2',
      label: 'P/E2 INDUSTRY',
      type: 'numberRange',
      step: 0.1,
    },
    {
      key: 'companyCount',
      label: 'Antal bolag',
      type: 'numberRange',
      min: 0,
      step: 1,
    },
  ], [uniqueIndustries]);

  // Custom header renderer with ColumnTooltip
  const renderHeader = useCallback((props: HeaderRenderProps<PEIndustryData>) => {
    const { 
      column, 
      sortConfig, 
      handleSort, 
      getSortIcon, 
      getStickyPosition, 
      isColumnVisible,
      openFilterMenuColumn,
      setOpenFilterMenuColumn,
      hasActiveColumnFilter,
      getColumnUniqueValues,
      columnFilters,
      setColumnFilter,
      handleColumnSort,
      headerRefs,
    } = props;
    const metadata = getColumnMetadata('pe-industry', column.key);
    const isSticky = column.sticky;
    const sortIcon = getSortIcon(column.key);
    const stickyClass = isSticky ? `sm:sticky sm:top-0 ${getStickyPosition(column.key)} z-50` : '';
    const isFilterMenuOpen = openFilterMenuColumn === column.key;
    const hasActiveFilter = hasActiveColumnFilter(column.key);
    const headerRef = headerRefs.current[column.key] || null;

    const handleFilterIconClick = (e: React.MouseEvent) => {
      e.stopPropagation();
      if (isFilterMenuOpen) {
        setOpenFilterMenuColumn(null);
      } else {
        setOpenFilterMenuColumn(column.key);
      }
    };

    const handleSortClick = (e?: React.MouseEvent) => {
      if (e) {
        e.stopPropagation();
      }
      if (!isFilterMenuOpen) {
        handleSort(column.key);
      }
    };

    const filterIcon = (
      <button
        onClick={handleFilterIconClick}
        className={`ml-2 p-1 rounded hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors ${
          hasActiveFilter ? 'text-blue-600 dark:text-blue-400' : 'text-gray-500 dark:text-gray-400'
        }`}
        aria-label={`Filter ${column.label}`}
        aria-expanded={isFilterMenuOpen}
        title="Filter och sortering"
        type="button"
      >
        <svg
          className="w-4 h-4"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M4 6h16M4 12h16M4 18h16"
          />
        </svg>
      </button>
    );
    
    if (!column.sortable) {
      const headerContent = (
        <th
          ref={(el) => {
            headerRefs.current[column.key] = el;
          }}
          className={`px-6 py-3 text-left text-xs font-bold text-gray-700 dark:text-gray-200 uppercase tracking-wider ${stickyClass} bg-gray-50 dark:bg-gray-900`}
          scope="col"
          role="columnheader"
        >
          <div className="flex items-center justify-between relative w-full">
            <div className="flex items-center flex-1">
              {metadata ? (
                <ColumnTooltip metadata={metadata}>
                  <div className="flex items-center space-x-1">
                    <span>{column.label}</span>
                  </div>
                </ColumnTooltip>
              ) : (
                <div className="flex items-center space-x-1">
                  <span>{column.label}</span>
                </div>
              )}
            </div>
            <div className="flex items-center relative" style={{ minWidth: '40px' }}>
              <div className="relative">
                {filterIcon}
                {isFilterMenuOpen && headerRef && (
                  <ColumnFilterMenu
                    columnKey={column.key}
                    columnLabel={column.label}
                    isOpen={isFilterMenuOpen}
                    onClose={() => setOpenFilterMenuColumn(null)}
                    filter={columnFilters[column.key]}
                    onFilterChange={(filter) => setColumnFilter(column.key, filter)}
                    sortConfig={sortConfig}
                    onSort={handleColumnSort}
                    uniqueValues={getColumnUniqueValues(column.key)}
                    triggerRef={{ current: headerRef }}
                  />
                )}
              </div>
            </div>
          </div>
        </th>
      );
      return <React.Fragment key={column.key}>{headerContent}</React.Fragment>;
    }

    const headerContent = (
      <th
        ref={(el) => {
          headerRefs.current[column.key] = el;
        }}
        onClick={handleSortClick}
        className={`px-6 py-3 text-left text-xs font-bold text-gray-700 dark:text-gray-200 uppercase tracking-wider cursor-pointer hover:bg-blue-100 dark:hover:bg-blue-900/30 hover:text-blue-700 dark:hover:text-blue-200 transition-all duration-200 ${stickyClass} bg-gray-50 dark:bg-gray-900`}
        scope="col"
        role="columnheader"
      >
        <div className="flex items-center justify-between relative w-full">
          <div className="flex items-center flex-1" onClick={handleSortClick}>
            {metadata ? (
              <ColumnTooltip metadata={metadata}>
                <div className="flex items-center space-x-1">
                  <span>{column.label}</span>
                  {sortIcon && <span className="text-gray-600 dark:text-gray-300">{sortIcon}</span>}
                </div>
              </ColumnTooltip>
            ) : (
              <div className="flex items-center space-x-1">
                <span>{column.label}</span>
                {sortIcon && <span className="text-gray-400 dark:text-gray-300">{sortIcon}</span>}
              </div>
            )}
          </div>
          <div className="flex items-center relative" style={{ minWidth: '40px' }}>
            <div className="relative">
              {filterIcon}
              {isFilterMenuOpen && headerRef && (
                <ColumnFilterMenu
                  columnKey={column.key}
                  columnLabel={column.label}
                  isOpen={isFilterMenuOpen}
                  onClose={() => setOpenFilterMenuColumn(null)}
                  filter={columnFilters[column.key]}
                  onFilterChange={(filter) => setColumnFilter(column.key, filter)}
                  sortConfig={sortConfig}
                  onSort={handleColumnSort}
                  uniqueValues={getColumnUniqueValues(column.key)}
                  triggerRef={{ current: headerRef }}
                />
              )}
            </div>
          </div>
        </div>
      </th>
    );
    return <React.Fragment key={column.key}>{headerContent}</React.Fragment>;
  }, []);

  // Render cell content
  const renderCell = useCallback((item: PEIndustryData, column: ColumnDefinition<PEIndustryData>, index: number, globalIndex: number) => {
    switch (column.key) {
      case 'antal':
        return globalIndex + 1;
      case 'industry':
        return <span className="font-medium">{item.industry}</span>;
      case 'pe':
        return <span className="text-black dark:text-white">{item.pe !== null ? item.pe.toFixed(2) : 'N/A'}</span>;
      case 'pe1':
        return <span className="text-black dark:text-white">{item.pe1 !== null ? item.pe1.toFixed(2) : 'N/A'}</span>;
      case 'pe2':
        return <span className="text-black dark:text-white">{item.pe2 !== null ? item.pe2.toFixed(2) : 'N/A'}</span>;
      case 'companyCount':
        return <span className="text-black dark:text-white">{item.companyCount}</span>;
      default:
        return null;
    }
  }, []);

  // Render mobile card
  const renderMobileCard = useCallback((item: PEIndustryData, index: number, globalIndex: number, isExpanded: boolean, toggleExpand: () => void) => {
    const rowKey = `${item.industry}-${globalIndex}`;
    const rowBgClass = globalIndex % 2 === 0 
      ? 'bg-white dark:bg-gray-800' 
      : 'bg-gray-50 dark:bg-gray-800';

    return (
      <div
        key={rowKey}
        className={`${rowBgClass} rounded-lg border border-gray-300 dark:border-gray-600 shadow-sm transition-all duration-300 ease-in-out`}
      >
        {/* Primary Columns - Always Visible */}
        <div className="p-4 flex items-start justify-between gap-4">
          <div className="flex-1 space-y-3">
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">Antal</span>
              <span className="text-sm font-medium text-black dark:text-white">{globalIndex + 1}</span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">Industry</span>
              <span className="text-sm font-medium text-black dark:text-white text-right">{item.industry}</span>
            </div>
          </div>
          {/* Expand/Collapse Button */}
          <button
            onClick={toggleExpand}
            className="p-2 text-gray-600 dark:text-gray-300 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-all duration-200 flex-shrink-0"
            aria-label={isExpanded ? t('aria.collapseRow') : t('aria.expandRow')}
            aria-expanded={isExpanded}
          >
            <svg
              className={`w-5 h-5 transition-transform duration-200 ${isExpanded ? 'rotate-180' : ''}`}
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M19 9l-7 7-7-7"
              />
            </svg>
          </button>
        </div>

        {/* Secondary Columns - Expandable */}
        {isExpanded && (
          <div className="border-t border-gray-300 dark:border-gray-600 p-4 space-y-3 animate-fade-in">
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">P/E INDUSTRY</span>
              <span className="text-sm text-black dark:text-white">
                {item.pe !== null ? item.pe.toFixed(2) : 'N/A'}
              </span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">P/E1 INDUSTRY</span>
              <span className="text-sm text-black dark:text-white">
                {item.pe1 !== null ? item.pe1.toFixed(2) : 'N/A'}
              </span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">P/E2 INDUSTRY</span>
              <span className="text-sm text-black dark:text-white">
                {item.pe2 !== null ? item.pe2.toFixed(2) : 'N/A'}
              </span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">Antal bolag</span>
              <span className="text-sm text-black dark:text-white">
                {item.companyCount}
              </span>
            </div>
          </div>
        )}
      </div>
    );
  }, []);

  return (
    <BaseTable<PEIndustryData>
      data={data}
      loading={loading}
      error={error}
      columns={PE_INDUSTRY_COLUMNS}
      filters={peIndustryFilters}
      tableId="pe-industry"
      renderCell={renderCell}
      renderHeader={renderHeader}
      renderMobileCard={renderMobileCard}
      enableVirtualScroll={true}
      virtualScrollRowHeight={60}
      virtualScrollOverscan={10}
      enableMobileExpand={true}
      searchFields={['industry']}
      searchPlaceholder="Sök efter bransch..."
      defaultSortKey="companyCount"
      defaultSortDirection="desc"
      stickyColumns={['antal', 'industry']}
      ariaLabel="P/E Industry"
      minTableWidth="800px"
      getRowKey={(item, index) => `${item.industry}-${index}`}
    />
  );
}

```

## `src/components/ProgressIndicator.tsx`

```tsx
interface ProgressIndicatorProps {
  progress?: number;
  isLoading?: boolean;
  label?: string;
  estimatedTimeRemaining?: number; // milliseconds
  showPercentage?: boolean;
}

export default function ProgressIndicator({
  progress,
  isLoading = false,
  label,
  estimatedTimeRemaining,
  showPercentage = true,
}: ProgressIndicatorProps) {
  if (!isLoading && progress === undefined) {
    return null;
  }

  const formatTime = (ms: number): string => {
    if (ms < 1000) {
      return '< 1s';
    }
    const seconds = Math.ceil(ms / 1000);
    if (seconds < 60) {
      return `~${seconds}s`;
    }
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return remainingSeconds > 0 ? `~${minutes}m ${remainingSeconds}s` : `~${minutes}m`;
  };

  const displayProgress = isLoading ? 0 : (progress || 0);
  const displayLabel = label || (showPercentage ? `${Math.round(displayProgress)}%` : '');

  return (
    <div className="w-full">
      <div className="flex items-center justify-between mb-1">
        {displayLabel && (
          <span className="text-xs font-medium text-gray-700 dark:text-gray-300">
            {displayLabel}
          </span>
        )}
        {estimatedTimeRemaining !== undefined && estimatedTimeRemaining > 0 && (
          <span className="text-xs text-gray-600 dark:text-gray-300">
            {formatTime(estimatedTimeRemaining)} kvar
          </span>
        )}
      </div>
      <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2 overflow-hidden">
        <div
          className={`h-full transition-all duration-500 ease-out ${
            isLoading
              ? 'bg-blue-600 dark:bg-blue-500 animate-pulse'
              : displayProgress < 50
              ? 'bg-red-500 dark:bg-red-400'
              : displayProgress < 80
              ? 'bg-yellow-500 dark:bg-yellow-400'
              : 'bg-green-500 dark:bg-green-400'
          }`}
          style={{
            width: isLoading ? '100%' : `${Math.min(100, Math.max(0, displayProgress))}%`,
          }}
        />
      </div>
    </div>
  );
}


```

## `src/components/QuickFilters.tsx`

```tsx
import { useCallback, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { FilterValues, FilterConfig } from '../types/filters';
import Button from './ui/Button';

interface QuickFilter {
  id: string;
  label: string;
  icon?: string;
  filter: FilterValues;
}

interface QuickFiltersProps {
  filters: FilterConfig[];
  values: FilterValues;
  onChange: (values: FilterValues) => void;
  tableId?: string;
}

export default function QuickFilters({ filters, values, onChange, tableId }: QuickFiltersProps) {
  const { t } = useTranslation();

  // Generate quick filters based on available filter configs
  const quickFilters: QuickFilter[] = useMemo(() => {
    const result: QuickFilter[] = [];

    // Find score filter
    const scoreFilter = filters.find((f) => f.key === 'score' || f.key.toLowerCase().includes('score'));
    if (scoreFilter) {
      result.push({
        id: 'high-score',
        label: t('quickFilters.highScore', 'High Score (>80)'),
        filter: { [scoreFilter.key]: { min: 80 } },
      });
      result.push({
        id: 'medium-score',
        label: t('quickFilters.mediumScore', 'Medium Score (50-80)'),
        filter: { [scoreFilter.key]: { min: 50, max: 80 } },
      });
      result.push({
        id: 'low-score',
        label: t('quickFilters.lowScore', 'Low Score (<50)'),
        filter: { [scoreFilter.key]: { max: 50 } },
      });
    }

    // Find P/E filter
    const peFilter = filters.find((f) => f.key === 'pe' || f.key.toLowerCase().includes('pe'));
    if (peFilter) {
      result.push({
        id: 'low-pe',
        label: t('quickFilters.lowPE', 'Low P/E (<10)'),
        filter: { [peFilter.key]: { max: 10 } },
      });
      result.push({
        id: 'medium-pe',
        label: t('quickFilters.mediumPE', 'Medium P/E (10-20)'),
        filter: { [peFilter.key]: { min: 10, max: 20 } },
      });
      result.push({
        id: 'high-pe',
        label: t('quickFilters.highPE', 'High P/E (>20)'),
        filter: { [peFilter.key]: { min: 20 } },
      });
    }

    // Find price filter
    const priceFilter = filters.find((f) => f.key === 'price' || f.key.toLowerCase().includes('price'));
    if (priceFilter) {
      result.push({
        id: 'low-price',
        label: t('quickFilters.lowPrice', 'Low Price (<50)'),
        filter: { [priceFilter.key]: { max: 50 } },
      });
    }

    return result;
  }, [filters, t]);

  const handleQuickFilterClick = useCallback(
    (quickFilter: QuickFilter) => {
      // Merge with existing filters
      const newValues: FilterValues = {
        ...values,
        ...quickFilter.filter,
      };
      onChange(newValues);
    },
    [values, onChange]
  );

  const isQuickFilterActive = useCallback(
    (quickFilter: QuickFilter): boolean => {
      // Check if all filter keys from quick filter are present and match in current values
      return Object.entries(quickFilter.filter).every(([key, value]) => {
        const currentValue = values[key];
        if (value === null || value === undefined) return true;

        // For range filters
        if (typeof value === 'object' && value !== null && ('min' in value || 'max' in value)) {
          const rangeValue = value as { min?: number; max?: number };
          const currentRange = typeof currentValue === 'object' && currentValue !== null ? (currentValue as { min?: number; max?: number }) : null;
          
          if (!currentRange) return false;
          
          if (rangeValue.min !== undefined && currentRange.min !== rangeValue.min) return false;
          if (rangeValue.max !== undefined && currentRange.max !== rangeValue.max) return false;
          
          return true;
        }

        // For other types
        return currentValue === value;
      });
    },
    [values]
  );

  if (quickFilters.length === 0) {
    return null;
  }

  return (
    <div className="flex flex-wrap items-center gap-2 p-2 border-b border-gray-200 dark:border-gray-700">
      <span className="text-xs font-semibold text-gray-600 dark:text-gray-400 uppercase tracking-wider mr-2">
        {t('quickFilters.title', 'Quick Filters')}:
      </span>
      {quickFilters.map((quickFilter) => {
        const isActive = isQuickFilterActive(quickFilter);
        return (
          <Button
            key={quickFilter.id}
            variant={isActive ? 'primary' : 'outline'}
            size="sm"
            onClick={() => handleQuickFilterClick(quickFilter)}
            className="text-xs"
          >
            {quickFilter.label}
          </Button>
        );
      })}
    </div>
  );
}

```

## `src/components/ResponsiveTableWrapper.tsx`

```tsx
import { useState } from 'react';
import { useTranslation } from 'react-i18next';
import { ResponsiveTableWrapperProps, ExpandedRowState } from '../types/responsiveTable';

export default function ResponsiveTableWrapper<T extends Record<string, unknown>>({
  primaryColumns,
  secondaryColumns,
  data,
  renderPrimaryCell,
  renderSecondaryContent,
  onRowClick,
  rowClassName,
  renderTableHeader,
  emptyMessage = 'Inga data tillgängliga.',
  isLoading = false,
}: ResponsiveTableWrapperProps<T>) {
  const { t } = useTranslation();
  const [expandedRows, setExpandedRows] = useState<ExpandedRowState>({});

  const toggleRow = (index: number) => {
    setExpandedRows((prev) => ({
      ...prev,
      [index]: !prev[index],
    }));
  };

  const getRowKey = (item: T, index: number): string => {
    // Try to find a unique identifier
    if ('ticker' in item && 'companyName' in item) {
      return `${item.ticker}-${item.companyName}`;
    }
    if ('industry' in item) {
      return `${item.industry}`;
    }
    return `row-${index}`;
  };

  if (isLoading) {
    return (
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-8">
        <p className="text-gray-600 dark:text-gray-300 text-center">Laddar...</p>
      </div>
    );
  }

  if (data.length === 0) {
    return (
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-8">
        <p className="text-gray-600 dark:text-gray-300 text-center">{emptyMessage}</p>
      </div>
    );
  }

  return (
    <div className="w-full">
      {/* Table View */}
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
          {renderTableHeader && <thead className="sticky top-0 z-40 bg-gray-50 dark:bg-gray-900">{renderTableHeader()}</thead>}
          <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
            {data.map((item, index) => {
              const rowKey = getRowKey(item, index);
              const className = rowClassName ? rowClassName(item, index) : '';
              return (
                <tr
                  key={rowKey}
                  onClick={() => onRowClick?.(item)}
                  className={`${className} ${
                    onRowClick ? 'cursor-pointer' : ''
                  } transition-all duration-300 ease-in-out hover:bg-blue-50 dark:hover:bg-blue-900/20`}
                >
                  {primaryColumns.map((column) => (
                    <td
                      key={column.key}
                      className="px-6 py-4 whitespace-nowrap text-sm text-black dark:text-white"
                    >
                      {renderPrimaryCell(item, column, index)}
                    </td>
                  ))}
                  {secondaryColumns.map((column) => (
                    <td
                      key={column.key}
                      className="px-6 py-4 whitespace-nowrap text-sm text-black dark:text-white"
                    >
                      {renderSecondaryContent(item, index)}
                    </td>
                  ))}
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
}


```

## `src/components/ScoreBoardTable.tsx`

```tsx
import React, { useMemo, useCallback } from 'react';
import { ScoreBoardData, ThresholdIndustryData } from '../types/stock';
import BaseTable, { ColumnDefinition, HeaderRenderProps } from './BaseTable';
import ColumnTooltip from './ColumnTooltip';
import ColumnFilterMenu from './ColumnFilterMenu';
import { getColumnMetadata } from '../config/tableMetadata';
import { FilterConfig } from './AdvancedFilters';
import { useTranslation } from 'react-i18next';
import { useEntryExitValues } from '../contexts/EntryExitContext';
import { useBenjaminGrahamData } from '../hooks/useBenjaminGrahamData';
import {
  getIRRColor,
  getMungerQualityScoreColor,
  getValueCreationColor,
  getRo40Color,
  getLeverageF2Color,
  getCashSdebtColor,
  getCurrentRatioColor,
  getPEPercentageColor,
  getTBSPPriceColor,
  getSMAColor,
  getSMACrossColorDetailed,
  isTheoEntryGreen,
  colorTypeToCssClass,
} from '../utils/colorThresholds';

interface ScoreBoardTableProps {
  data: ScoreBoardData[];
  loading: boolean;
  error: string | null;
  thresholdData?: ThresholdIndustryData[];
}

const SCORE_BOARD_COLUMNS: ColumnDefinition[] = [
  { key: 'antal', label: 'Antal', required: true, sticky: true, sortable: false },
  { key: 'companyName', label: 'Company Name', required: true, sticky: true, sortable: true },
  { key: 'ticker', label: 'Ticker', required: true, sticky: true, sortable: true },
  { key: 'irr', label: 'IRR', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'mungerQualityScore', label: 'Munger Quality Score', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'valueCreation', label: 'Value Creation', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'tbSPrice', label: '(TB/S)/Price', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'ro40F1', label: 'Ro40 F1', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'ro40F2', label: 'Ro40 F2', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'currentRatio', label: 'Current Ratio', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'cashSdebt', label: 'Cash/SDebt', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'leverageF2', label: 'Leverage F2', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'pe1Industry', label: 'P/E1 Industry', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'pe2Industry', label: 'P/E2 Industry', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'sma100', label: 'SMA(100)', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'sma200', label: 'SMA(200)', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'smaCross', label: 'SMA Cross', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'theoEntry', label: 'TheoEntry', defaultVisible: true, sortable: false, align: 'center' },
];

export default function ScoreBoardTable({ data, loading, error, thresholdData = [] }: ScoreBoardTableProps) {
  const { t } = useTranslation();
  const { getEntryExitValue } = useEntryExitValues();
  const { data: benjaminGrahamData } = useBenjaminGrahamData();
  
  // Get unique industries for filter dropdown
  const uniqueIndustries = useMemo(() => {
    const industries = new Set<string>();
    data.forEach((item) => {
      if (item.industry && item.industry.trim()) {
        industries.add(item.industry);
      }
    });
    return Array.from(industries).sort().map((ind) => ({ value: ind, label: ind }));
  }, [data]);

  // Define filter configurations
  const scoreBoardFilters: FilterConfig[] = useMemo(() => [
    {
      key: 'companyName',
      label: 'Företagsnamn',
      type: 'text',
    },
    {
      key: 'ticker',
      label: 'Ticker',
      type: 'text',
    },
    {
      key: 'industry',
      label: 'Industri',
      type: 'select',
      options: uniqueIndustries,
    },
    {
      key: 'irr',
      label: 'IRR (%)',
      type: 'numberRange',
      step: 0.1,
    },
    {
      key: 'mungerQualityScore',
      label: 'Munger Quality Score',
      type: 'numberRange',
      min: 0,
      max: 100,
      step: 1,
    },
    {
      key: 'valueCreation',
      label: 'Value Creation (%)',
      type: 'numberRange',
      step: 0.1,
    },
    {
      key: 'ro40F1',
      label: 'Ro40 F1 (%)',
      type: 'numberRange',
      step: 0.1,
    },
    {
      key: 'ro40F2',
      label: 'Ro40 F2 (%)',
      type: 'numberRange',
      step: 0.1,
    },
    {
      key: 'currentRatio',
      label: 'Current Ratio',
      type: 'numberRange',
      step: 0.01,
    },
  ], [uniqueIndustries]);

  // Get Price from BenjaminGrahamData
  const getPriceFromBenjaminGraham = useCallback((ticker: string, companyName: string): number | null => {
    const match = benjaminGrahamData.find(
      item => item.ticker?.toLowerCase() === ticker.toLowerCase() ||
              item.companyName?.toLowerCase() === companyName.toLowerCase()
    );
    return match?.price ?? null;
  }, [benjaminGrahamData]);

  // Check if TheoEntry should show "B" (either RR1+Entry1 OR RR2+Entry2 are green)
  const isTheoEntryGreenForRow = useCallback((ticker: string, companyName: string): boolean => {
    const entryExitValues = getEntryExitValue(ticker, companyName);
    const price = getPriceFromBenjaminGraham(ticker, companyName);
    return isTheoEntryGreen(entryExitValues, price);
  }, [getEntryExitValue, getPriceFromBenjaminGraham, isTheoEntryGreen]);

  // Custom header renderer with ColumnTooltip
  const renderHeader = useCallback((props: HeaderRenderProps) => {
    const { 
      column, 
      sortConfig, 
      handleSort, 
      getSortIcon, 
      getStickyPosition, 
      isColumnVisible,
      openFilterMenuColumn,
      setOpenFilterMenuColumn,
      hasActiveColumnFilter,
      getColumnUniqueValues,
      columnFilters,
      setColumnFilter,
      handleColumnSort,
      headerRefs,
    } = props;
    const metadata = getColumnMetadata('score-board', column.key);
    const isSticky = column.sticky;
    const isSorted = sortConfig.key === column.key;
    const sortIcon = getSortIcon(column.key);
    const stickyClass = isSticky ? `sm:sticky sm:top-0 ${getStickyPosition(column.key)} z-50` : '';
    const isFilterMenuOpen = openFilterMenuColumn === column.key;
    const hasActiveFilter = hasActiveColumnFilter(column.key);
    const headerRef = headerRefs.current[column.key] || null;

    const handleFilterIconClick = (e: React.MouseEvent) => {
      e.stopPropagation();
      if (isFilterMenuOpen) {
        setOpenFilterMenuColumn(null);
      } else {
        setOpenFilterMenuColumn(column.key);
      }
    };

    const handleSortClick = (e?: React.MouseEvent) => {
      if (e) {
        e.stopPropagation();
      }
      if (!isFilterMenuOpen) {
        handleSort(column.key);
      }
    };

    const handleKeyDown = (e: React.KeyboardEvent) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        handleSortClick();
      }
    };

    const filterIcon = (
      <button
        onClick={handleFilterIconClick}
        className={`ml-2 p-1 rounded hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors ${
          hasActiveFilter ? 'text-blue-600 dark:text-blue-400' : 'text-gray-500 dark:text-gray-400'
        }`}
        aria-label={`Filter ${column.label}`}
        aria-expanded={isFilterMenuOpen}
        title="Filter och sortering"
        type="button"
      >
        <svg
          className="w-4 h-4"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M4 6h16M4 12h16M4 18h16"
          />
        </svg>
      </button>
    );
    
    if (!column.sortable) {
      const headerContent = (
        <th
          ref={(el) => {
            headerRefs.current[column.key] = el;
          }}
          className={`px-6 py-3 text-left text-xs font-bold text-gray-700 dark:text-gray-200 uppercase tracking-wider ${stickyClass} bg-gray-50 dark:bg-gray-900`}
          scope="col"
          role="columnheader"
        >
          <div className="flex items-center justify-between relative w-full">
            <div className="flex items-center flex-1">
              {metadata ? (
                <ColumnTooltip metadata={metadata}>
                  <div>{column.label}</div>
                </ColumnTooltip>
              ) : (
                column.label
              )}
            </div>
            <div className="flex items-center relative" style={{ minWidth: '40px' }}>
              <div className="relative">
                {filterIcon}
                {isFilterMenuOpen && headerRef && (
                  <ColumnFilterMenu
                    columnKey={column.key}
                    columnLabel={column.label}
                    isOpen={isFilterMenuOpen}
                    onClose={() => setOpenFilterMenuColumn(null)}
                    filter={columnFilters[column.key]}
                    onFilterChange={(filter) => setColumnFilter(column.key, filter)}
                    sortConfig={sortConfig}
                    onSort={handleColumnSort}
                    uniqueValues={getColumnUniqueValues(column.key)}
                    triggerRef={{ current: headerRef }}
                  />
                )}
              </div>
            </div>
          </div>
        </th>
      );
      return headerContent;
    }

    return (
      <th
        ref={(el) => {
          headerRefs.current[column.key] = el;
        }}
        onClick={handleSortClick}
        onKeyDown={handleKeyDown}
        className={`px-6 py-3 text-left text-xs font-bold text-gray-700 dark:text-gray-200 uppercase tracking-wider cursor-pointer hover:bg-blue-100 dark:hover:bg-blue-900/30 hover:text-blue-700 dark:hover:text-blue-200 transition-all duration-200 ${stickyClass} bg-gray-50 dark:bg-gray-900`}
        scope="col"
        role="columnheader"
        aria-label={`${t('aria.sortColumn')}: ${column.label}`}
        aria-sort={isSorted ? (sortConfig.direction === 'asc' ? 'ascending' : 'descending') : 'none'}
        tabIndex={0}
      >
        <div className="flex items-center justify-between relative w-full">
          <div className="flex items-center flex-1" onClick={handleSortClick}>
            {metadata ? (
              <ColumnTooltip metadata={metadata}>
                <div className="flex items-center space-x-1">
                  <span>{column.label === 'VALUE CREATION' ? 'VALUE CREATION' : column.label}</span>
                  {sortIcon && <span className="text-gray-600 dark:text-gray-300">{sortIcon}</span>}
                </div>
              </ColumnTooltip>
            ) : (
              <div className="flex items-center space-x-1">
                <span>{column.label}</span>
                {sortIcon && <span className="text-gray-400 dark:text-gray-300">{sortIcon}</span>}
              </div>
            )}
          </div>
          <div className="flex items-center relative" style={{ minWidth: '40px' }}>
            <div className="relative">
              {filterIcon}
              {isFilterMenuOpen && headerRef && (
                <ColumnFilterMenu
                  columnKey={column.key}
                  columnLabel={column.label}
                  isOpen={isFilterMenuOpen}
                  onClose={() => setOpenFilterMenuColumn(null)}
                  filter={columnFilters[column.key]}
                  onFilterChange={(filter) => setColumnFilter(column.key, filter)}
                  sortConfig={sortConfig}
                  onSort={handleColumnSort}
                  uniqueValues={getColumnUniqueValues(column.key)}
                  triggerRef={{ current: headerRef }}
                />
              )}
            </div>
          </div>
        </div>
      </th>
    );
  }, [t]);

  // Render cell content
  const renderCell = useCallback((item: ScoreBoardData, column: ColumnDefinition, index: number, globalIndex: number) => {
    switch (column.key) {
      case 'antal':
        return globalIndex + 1;
      case 'companyName':
        return <span className="font-medium">{item.companyName}</span>;
      case 'ticker':
        return <span className="text-gray-600 dark:text-gray-300">{item.ticker}</span>;
      case 'irr':
        return (
          <span className={colorTypeToCssClass(getIRRColor(item.irr, item.industry, thresholdData)) || 'text-black dark:text-white'}>
            {item.irr !== null ? `${item.irr.toFixed(2)}%` : 'N/A'}
          </span>
        );
      case 'mungerQualityScore':
        return (
          <span className={colorTypeToCssClass(getMungerQualityScoreColor(item.mungerQualityScore), { orangeVariant: 'blue' }) || 'text-black dark:text-white'}>
            {item.mungerQualityScore !== null ? item.mungerQualityScore.toLocaleString() : 'N/A'}
          </span>
        );
      case 'valueCreation':
        return (
          <span className={colorTypeToCssClass(getValueCreationColor(item.valueCreation)) || 'text-black dark:text-white'}>
            {item.valueCreation !== null ? `${item.valueCreation.toFixed(2)}%` : 'N/A'}
          </span>
        );
      case 'tbSPrice':
        return (
          <span className={colorTypeToCssClass(getTBSPPriceColor(item.tbSPrice)) || 'text-black dark:text-white'}>
            {item.tbSPrice !== null ? item.tbSPrice.toFixed(2) : 'N/A'}
          </span>
        );
      case 'ro40F1':
        return (
          <span className={colorTypeToCssClass(getRo40Color(item.ro40F1, item.industry, thresholdData)) || 'text-black dark:text-white'}>
            {item.ro40F1 !== null ? `${item.ro40F1.toFixed(2)}%` : 'N/A'}
          </span>
        );
      case 'ro40F2':
        return (
          <span className={colorTypeToCssClass(getRo40Color(item.ro40F2, item.industry, thresholdData)) || 'text-black dark:text-white'}>
            {item.ro40F2 !== null ? `${item.ro40F2.toFixed(2)}%` : 'N/A'}
          </span>
        );
      case 'currentRatio':
        return (
          <span className={colorTypeToCssClass(getCurrentRatioColor(item.currentRatio, item.industry, thresholdData)) || 'text-black dark:text-white'}>
            {item.currentRatio !== null ? item.currentRatio.toFixed(2) : 'N/A'}
          </span>
        );
      case 'cashSdebt':
        return (
          <span className={colorTypeToCssClass(getCashSdebtColor(item.cashSdebt, item.isCashSdebtDivZero, item.industry, thresholdData)) || 'text-black dark:text-white'}>
            {item.cashSdebt !== null ? item.cashSdebt.toFixed(2) : 'N/A'}
          </span>
        );
      case 'leverageF2':
        return (
          <span className={colorTypeToCssClass(getLeverageF2Color(item.leverageF2, item.industry, thresholdData)) || 'text-black dark:text-white'}>
            {item.leverageF2 !== null ? item.leverageF2.toLocaleString() : 'N/A'}
          </span>
        );
      case 'pe1Industry':
        return (
          <span className={colorTypeToCssClass(getPEPercentageColor(item.pe1Industry)) || 'text-black dark:text-white'}>
            {item.pe1Industry !== null ? `${item.pe1Industry.toFixed(1)}%` : 'N/A'}
          </span>
        );
      case 'pe2Industry':
        return (
          <span className={colorTypeToCssClass(getPEPercentageColor(item.pe2Industry)) || 'text-black dark:text-white'}>
            {item.pe2Industry !== null ? `${item.pe2Industry.toFixed(1)}%` : 'N/A'}
          </span>
        );
      case 'sma100':
        return (
          <span className={colorTypeToCssClass(getSMAColor(item.price, item.sma100), { orangeVariant: 'yellow' }) || 'text-black dark:text-white'}>
            {item.sma100 !== null ? item.sma100.toFixed(2) : 'N/A'}
          </span>
        );
      case 'sma200':
        return (
          <span className={colorTypeToCssClass(getSMAColor(item.price, item.sma200), { orangeVariant: 'yellow' }) || 'text-black dark:text-white'}>
            {item.sma200 !== null ? item.sma200.toFixed(2) : 'N/A'}
          </span>
        );
      case 'smaCross':
        return (
          <span className={colorTypeToCssClass(getSMACrossColorDetailed(item.smaCross)) || 'text-black dark:text-white'}>
            {item.smaCross || 'N/A'}
          </span>
        );
      case 'theoEntry':
        return (
          <span className={
            isTheoEntryGreenForRow(item.ticker, item.companyName)
              ? 'bg-green-50 dark:bg-green-900/20 text-green-700 dark:text-green-200'
              : ''
          }>
            {isTheoEntryGreenForRow(item.ticker, item.companyName) ? 'B' : ''}
          </span>
        );
      default:
        return null;
    }
  }, [thresholdData, isTheoEntryGreenForRow]);

  // Render mobile card with expandable view
  const renderMobileCard = useCallback((item: ScoreBoardData, index: number, globalIndex: number, isExpanded: boolean, toggleExpand: () => void) => {
    const rowBgClass = globalIndex % 2 === 0 
      ? 'bg-white dark:bg-gray-800' 
      : 'bg-gray-50 dark:bg-gray-800/50';

    return (
      <div className={`${rowBgClass} rounded-lg border border-gray-300 dark:border-gray-600 shadow-sm transition-all duration-300 ease-in-out`}>
        <div className="p-4 flex items-start justify-between gap-4">
          <div className="flex-1 space-y-3">
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">Antal</span>
              <span className="text-sm font-medium text-black dark:text-white">{globalIndex + 1}</span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">Company Name</span>
              <span className="text-sm font-medium text-black dark:text-white text-right">{item.companyName}</span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">Ticker</span>
              <span className="text-sm text-gray-600 dark:text-gray-300">{item.ticker}</span>
            </div>
          </div>
          <button
            onClick={toggleExpand}
            className="p-2 text-gray-600 dark:text-gray-300 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-all duration-200 flex-shrink-0"
            aria-label={isExpanded ? t('aria.collapseRow') : t('aria.expandRow')}
            aria-expanded={isExpanded}
          >
            <svg
              className={`w-5 h-5 transition-transform duration-200 ${isExpanded ? 'rotate-180' : ''}`}
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
            </svg>
          </button>
        </div>
        {isExpanded && (
          <div className="border-t border-gray-200 dark:border-gray-700 p-4 space-y-3 animate-fade-in">
            {['irr', 'mungerQualityScore', 'valueCreation', 'tbSPrice', 'ro40F1', 'ro40F2', 'currentRatio', 'cashSdebt', 'leverageF2', 'pe1Industry', 'pe2Industry', 'sma100', 'sma200', 'smaCross', 'theoEntry'].map((key) => {
              const column = SCORE_BOARD_COLUMNS.find(c => c.key === key);
              if (!column) return null;
              return (
                <div key={key} className="flex items-center justify-between">
                  <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">{column.label}</span>
                  <span className="text-sm text-black dark:text-white text-right">
                    {renderCell(item, column, index, globalIndex)}
                  </span>
                </div>
              );
            })}
          </div>
        )}
      </div>
    );
  }, [renderCell]);

  return (
    <BaseTable<ScoreBoardData>
      data={data}
      loading={loading}
      error={error}
      columns={SCORE_BOARD_COLUMNS}
      filters={scoreBoardFilters}
      tableId="score-board"
      renderCell={renderCell}
      renderHeader={renderHeader}
      renderMobileCard={renderMobileCard}
      enableVirtualScroll={true}
      virtualScrollRowHeight={60}
      virtualScrollOverscan={10}
      enableMobileExpand={true}
      searchFields={['companyName', 'ticker', 'industry']}
      searchPlaceholder="Sök efter företag, ticker eller bransch..."
      defaultSortKey="companyName"
      defaultSortDirection="asc"
      stickyColumns={['antal', 'companyName', 'ticker']}
      ariaLabel={t('navigation.scoreBoard')}
      minTableWidth="800px"
      getRowKey={(item, index) => `${item.ticker}-${item.companyName}-${index}`}
      enableExport={true}
      enablePrint={true}
      enableShareableLink={true}
      viewId="score-board"
    />
  );
}

```

## `src/components/ScoreBreakdownRow.tsx`

```tsx
import { useMemo } from 'react';
import { ResponsiveContainer, BarChart, Bar, Cell, XAxis, YAxis, Tooltip } from 'recharts';
import { ScoreBreakdown } from '../utils/calculateScoreDetailed';
import { useTheme } from '../contexts/ThemeContext';

interface ScoreBreakdownRowProps {
  breakdown: ScoreBreakdown;
}

interface StackedBarDataItem {
  name: string;
  value: number;
  color: string;
  darkColor: string;
}

export default function ScoreBreakdownRow({ breakdown }: ScoreBreakdownRowProps) {
  const { resolvedTheme } = useTheme();
  const isDarkMode = resolvedTheme === 'dark';

  // Stacked bar data: Fundamental vs Teknisk
  const stackedBarData: StackedBarDataItem[] = useMemo(() => [
    { 
      name: 'Fundamental', 
      value: breakdown.fundamentalTotal, 
      color: '#3b82f6', // blue-600
      darkColor: '#93c5fd' // blue-300
    },
    { 
      name: 'Teknisk', 
      value: breakdown.technicalTotal, 
      color: '#16a34a', // green-700
      darkColor: '#86efac' // green-300
    },
  ], [breakdown.fundamentalTotal, breakdown.technicalTotal]);

  const getBarColors = () => {
    return stackedBarData.map(item => isDarkMode ? item.darkColor : item.color);
  };

  // Group metrics by category
  const fundamentalItems = useMemo(() => 
    breakdown.items.filter(item => item.category === 'Fundamental'),
    [breakdown.items]
  );
  
  const technicalItems = useMemo(() => 
    breakdown.items.filter(item => item.category === 'Technical'),
    [breakdown.items]
  );

  // Helper functions for color indicators and multiplier text
  const getColorIndicator = (color: string) => {
    switch (color) {
      case 'GREEN':
        return <span className="text-green-500">●</span>;
      case 'BLUE':
        return <span className="text-blue-500">●</span>;
      case 'RED':
        return <span className="text-red-500">●</span>;
      case 'BLANK':
        return <span className="text-gray-400">○</span>;
      default:
        return <span className="text-gray-400">○</span>;
    }
  };

  const getMultiplierText = (factor: number) => {
    if (factor === 1.00) return '100%';
    if (factor === 0.70) return '70%';
    return '0%';
  };

  // Custom tooltip for stacked bar
  const StackedBarTooltip = ({ active, payload }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0];
      return (
        <div className="bg-white dark:bg-gray-800 p-3 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg">
          <p className="font-semibold text-black dark:text-white">{data.name}</p>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Poäng: {data.value.toFixed(1)} / 50
          </p>
        </div>
      );
    }
    return null;
  };

  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 p-4 bg-gray-50 dark:bg-gray-900/50">
      {/* Stacked Bar Chart */}
      <div>
        <h4 className="text-sm font-semibold text-black dark:text-white mb-3">
          Fundamental vs Teknisk poäng
        </h4>
        <ResponsiveContainer width="100%" height={200}>
          <BarChart 
            data={stackedBarData} 
            layout="vertical"
            margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
          >
            <XAxis 
              type="number" 
              domain={[0, 50]}
              tick={{ fill: isDarkMode ? '#e5e7eb' : '#374151', fontSize: 12 }}
            />
            <YAxis 
              type="category" 
              dataKey="name"
              tick={{ fill: isDarkMode ? '#e5e7eb' : '#374151', fontSize: 12 }}
              width={80}
            />
            <Tooltip content={<StackedBarTooltip />} />
            <Bar dataKey="value" radius={[0, 8, 8, 0]}>
              {stackedBarData.map((entry, index) => (
                <Cell 
                  key={`bar-cell-${index}`} 
                  fill={getBarColors()[index]}
                />
              ))}
            </Bar>
          </BarChart>
        </ResponsiveContainer>
      </div>

      {/* Metric List */}
      <div>
        <h4 className="text-sm font-semibold text-black dark:text-white mb-3">
          Metric Detaljer
        </h4>
        <div className="space-y-4 max-h-[200px] overflow-y-auto pr-2">
          {/* Fundamental Section */}
          <div>
            <div className="flex items-center justify-between mb-2">
              <span className="text-xs font-semibold text-blue-600 dark:text-blue-400">Fundamental</span>
              <span className="text-xs text-gray-600 dark:text-gray-400">
                ({breakdown.fundamentalTotal.toFixed(1)} / 50p)
              </span>
            </div>
            <div className="space-y-1">
              {fundamentalItems.map((item, index) => (
                <div 
                  key={index} 
                  className="flex items-center justify-between text-xs py-1.5 px-2 rounded border-b border-gray-200 dark:border-gray-700 last:border-0 hover:bg-gray-100 dark:hover:bg-gray-800/50 transition-colors"
                >
                  <div className="flex items-center space-x-2 flex-1 min-w-0">
                    <span className="flex-shrink-0">{getColorIndicator(item.color)}</span>
                    <span className="text-gray-700 dark:text-gray-300 truncate">{item.metric}</span>
                  </div>
                  <div className="flex items-center space-x-3 flex-shrink-0 ml-2">
                    <span className="text-gray-500 dark:text-gray-400 w-8 text-right text-[10px]">v:{item.weight}</span>
                    <span className="text-gray-500 dark:text-gray-400 w-10 text-right text-[10px]">{getMultiplierText(item.factor)}</span>
                    <span className="text-gray-900 dark:text-gray-100 font-medium w-12 text-right">{item.points.toFixed(1)}</span>
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Technical Section */}
          <div>
            <div className="flex items-center justify-between mb-2">
              <span className="text-xs font-semibold text-green-600 dark:text-green-400">Technical</span>
              <span className="text-xs text-gray-600 dark:text-gray-400">
                ({breakdown.technicalTotal.toFixed(1)} / 50p)
              </span>
            </div>
            <div className="space-y-1">
              {technicalItems.map((item, index) => (
                <div 
                  key={index} 
                  className="flex items-center justify-between text-xs py-1.5 px-2 rounded border-b border-gray-200 dark:border-gray-700 last:border-0 hover:bg-gray-100 dark:hover:bg-gray-800/50 transition-colors"
                >
                  <div className="flex items-center space-x-2 flex-1 min-w-0">
                    <span className="flex-shrink-0">{getColorIndicator(item.color)}</span>
                    <span className="text-gray-700 dark:text-gray-300 truncate">{item.metric}</span>
                  </div>
                  <div className="flex items-center space-x-3 flex-shrink-0 ml-2">
                    <span className="text-gray-500 dark:text-gray-400 w-8 text-right text-[10px]">v:{item.weight}</span>
                    <span className="text-gray-500 dark:text-gray-400 w-10 text-right text-[10px]">{getMultiplierText(item.factor)}</span>
                    <span className="text-gray-900 dark:text-gray-100 font-medium w-12 text-right">{item.points.toFixed(1)}</span>
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Legend */}
          <div className="border-t border-gray-200 dark:border-gray-700 pt-2 mt-2">
            <div className="flex items-center space-x-4 text-[10px] text-gray-500 dark:text-gray-400">
              <span>v = vikt</span>
              <span>● = färg</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

```

## `src/components/ScoreBreakdownTooltip.tsx`

```tsx
import { useState, useRef, useEffect, useId } from 'react';
import { ScoreBreakdown } from '../utils/calculateScoreDetailed';

interface ScoreBreakdownTooltipProps {
  breakdown: ScoreBreakdown;
  children: React.ReactNode;
}

export default function ScoreBreakdownTooltip({ breakdown, children }: ScoreBreakdownTooltipProps) {
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const tooltipRef = useRef<HTMLDivElement>(null);
  const triggerRef = useRef<HTMLDivElement>(null);
  const tooltipId = useId();

  useEffect(() => {
    if (isVisible && triggerRef.current) {
      const triggerRect = triggerRef.current.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Initial positioning (will be adjusted after tooltip renders)
      let top = triggerRect.bottom + 8;
      let left = triggerRect.left + triggerRect.width / 2;

      // Adjust if tooltip would go off screen horizontally
      const estimatedWidth = 400; // Estimated width for the breakdown tooltip
      if (left - estimatedWidth / 2 < 8) {
        left = 8 + estimatedWidth / 2;
      } else if (left + estimatedWidth / 2 > viewportWidth - 8) {
        left = viewportWidth - 8 - estimatedWidth / 2;
      }

      // If tooltip would go below viewport, show above instead
      const estimatedHeight = 500; // rough estimate for breakdown tooltip
      if (top + estimatedHeight > viewportHeight - 8) {
        top = triggerRect.top - estimatedHeight - 8;
        if (top < 8) {
          top = 8; // Fallback to top of viewport
        }
      }

      setPosition({ top, left });
    }
  }, [isVisible]);

  const handleMouseEnter = () => {
    setIsVisible(true);
  };

  const handleMouseLeave = () => {
    setIsVisible(false);
  };

  const getColorIndicator = (color: string) => {
    switch (color) {
      case 'GREEN':
        return <span className="text-green-500">●</span>;
      case 'BLUE':
        return <span className="text-blue-500">●</span>;
      case 'RED':
        return <span className="text-red-500">●</span>;
      case 'BLANK':
        return <span className="text-gray-400">○</span>;
      default:
        return <span className="text-gray-400">○</span>;
    }
  };

  const getMultiplierText = (factor: number) => {
    if (factor === 1.00) return '100%';
    if (factor === 0.70) return '70%';
    return '0%';
  };

  const fundamentalItems = breakdown.items.filter(item => item.category === 'Fundamental');
  const technicalItems = breakdown.items.filter(item => item.category === 'Technical');

  return (
    <>
      <div
        ref={triggerRef}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        className="relative cursor-help"
        aria-describedby={isVisible ? tooltipId : undefined}
      >
        {children}
      </div>
      {isVisible && (
        <div
          ref={tooltipRef}
          id={tooltipId}
          role="tooltip"
          className="fixed z-50 bg-gray-900 dark:bg-gray-800 text-white dark:text-gray-100 rounded-lg shadow-xl p-4 max-w-md border border-gray-700"
          style={{
            top: `${position.top}px`,
            left: `${position.left}px`,
            transform: 'translateX(-50%)',
            pointerEvents: 'none',
          }}
          onMouseEnter={handleMouseEnter}
          onMouseLeave={handleMouseLeave}
        >
          <div className="space-y-4 text-sm">
            {/* Total Score Header */}
            <div className="border-b border-gray-700 pb-2">
              <div className="text-xs text-gray-400 mb-1">Total Score</div>
              <div className="text-2xl font-bold text-white">{breakdown.totalScore.toFixed(1)}</div>
            </div>

            {/* Fundamental Section */}
            <div>
              <div className="flex items-center justify-between mb-2">
                <span className="font-semibold text-blue-400">Fundamental</span>
                <span className="text-gray-300 text-xs">({breakdown.fundamentalTotal.toFixed(1)} / 50p)</span>
              </div>
              <div className="space-y-1 max-h-48 overflow-y-auto">
                {fundamentalItems.map((item, index) => (
                  <div key={index} className="flex items-center justify-between text-xs py-1 border-b border-gray-800 last:border-0">
                    <div className="flex items-center space-x-2 flex-1 min-w-0">
                      <span className="flex-shrink-0">{getColorIndicator(item.color)}</span>
                      <span className="text-gray-300 truncate">{item.metric}</span>
                    </div>
                    <div className="flex items-center space-x-3 flex-shrink-0 ml-2">
                      <span className="text-gray-400 w-8 text-right">v:{item.weight}</span>
                      <span className="text-gray-400 w-10 text-right">{getMultiplierText(item.factor)}</span>
                      <span className="text-gray-200 font-medium w-12 text-right">{item.points.toFixed(1)}</span>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            {/* Technical Section */}
            <div>
              <div className="flex items-center justify-between mb-2">
                <span className="font-semibold text-green-400">Technical</span>
                <span className="text-gray-300 text-xs">({breakdown.technicalTotal.toFixed(1)} / 50p)</span>
              </div>
              <div className="space-y-1 max-h-48 overflow-y-auto">
                {technicalItems.map((item, index) => (
                  <div key={index} className="flex items-center justify-between text-xs py-1 border-b border-gray-800 last:border-0">
                    <div className="flex items-center space-x-2 flex-1 min-w-0">
                      <span className="flex-shrink-0">{getColorIndicator(item.color)}</span>
                      <span className="text-gray-300 truncate">{item.metric}</span>
                    </div>
                    <div className="flex items-center space-x-3 flex-shrink-0 ml-2">
                      <span className="text-gray-400 w-8 text-right">v:{item.weight}</span>
                      <span className="text-gray-400 w-10 text-right">{getMultiplierText(item.factor)}</span>
                      <span className="text-gray-200 font-medium w-12 text-right">{item.points.toFixed(1)}</span>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            {/* Legend */}
            <div className="border-t border-gray-700 pt-2 text-xs text-gray-400">
              <div className="flex items-center space-x-4">
                <span>v = vikt</span>
                <span>● = färg</span>
              </div>
            </div>
          </div>
        </div>
      )}
    </>
  );
}


```

## `src/components/ScoreDashboard.tsx`

```tsx
import { useMemo, useState } from 'react';
import { Card, CardContent } from './ui/Card';
import { ScoreData } from './views/ScoreView';
import { useTheme } from '../contexts/ThemeContext';
import ScoreScatterPlot from './ScoreScatterPlot';
import { ThresholdIndustryData, BenjaminGrahamData } from '../types/stock';
import { EntryExitValues } from '../contexts/EntryExitContext';

interface ScoreDashboardProps {
  data: ScoreData[];
  loading?: boolean;
  thresholdData?: ThresholdIndustryData[];
  benjaminGrahamData?: BenjaminGrahamData[];
  entryExitValues?: Map<string, EntryExitValues>;
}

interface CategoryStats {
  high: number; // ≥70
  medium: number; // 50-69
  low: number; // <50
}

interface HeatMapDataItem {
  ticker: string;
  companyName: string;
  score: number;
}

export default function ScoreDashboard({ 
  data, 
  loading = false,
  thresholdData = [],
  benjaminGrahamData = [],
  entryExitValues = new Map()
}: ScoreDashboardProps) {
  const { resolvedTheme } = useTheme();
  const isDarkMode = resolvedTheme === 'dark';
  const [hoveredStock, setHoveredStock] = useState<string | null>(null);

  const stats = useMemo(() => {
    if (!data || data.length === 0) {
      return {
        categories: { high: 0, medium: 0, low: 0 } as CategoryStats,
      };
    }

    const categories: CategoryStats = {
      high: data.filter(item => item.score >= 70).length,
      medium: data.filter(item => item.score >= 50 && item.score < 70).length,
      low: data.filter(item => item.score < 50).length,
    };

    return { categories };
  }, [data]);

  // Heat map data: Sorted by score
  const heatMapData: HeatMapDataItem[] = useMemo(() => {
    if (!data || data.length === 0) {
      return [];
    }

    return data
      .map(item => ({
        ticker: item.ticker,
        companyName: item.companyName,
        score: item.score,
      }))
      .sort((a, b) => b.score - a.score);
  }, [data]);

  // Get heat map color based on score
  const getHeatMapColor = (score: number) => {
    if (score < 50) {
      // Red gradient
      const intensity = score / 50;
      return isDarkMode 
        ? `rgba(239, 68, 68, ${0.3 + intensity * 0.5})` 
        : `rgba(239, 68, 68, ${0.2 + intensity * 0.6})`;
    } else if (score < 70) {
      // Yellow/orange gradient
      const intensity = (score - 50) / 20;
      return isDarkMode
        ? `rgba(251, 191, 36, ${0.3 + intensity * 0.5})`
        : `rgba(251, 191, 36, ${0.2 + intensity * 0.6})`;
    } else {
      // Green gradient
      const intensity = (score - 70) / 30;
      return isDarkMode
        ? `rgba(34, 197, 94, ${0.3 + intensity * 0.5})`
        : `rgba(34, 197, 94, ${0.2 + intensity * 0.6})`;
    }
  };

  if (loading || data.length === 0) {
    return null;
  }

  return (
    <div className="mb-4 space-y-4">
      {/* KPI Cards */}
      <div className="grid grid-cols-1 gap-3">
        {/* Category Breakdown */}
        <Card variant="elevated" padding="md">
          <CardContent>
            <div className="flex flex-col space-y-2">
              <span className="text-sm font-medium text-gray-600 dark:text-gray-400 mb-1">
                Antal per kategori
              </span>
              <div className="space-y-1">
                <div className="flex items-center justify-between">
                  <span className="text-xs text-gray-500 dark:text-gray-400">Hög (≥70)</span>
                  <span className="text-sm font-semibold text-green-700 dark:text-green-200">
                    {stats.categories.high}
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-xs text-gray-500 dark:text-gray-400">Medium (50-69)</span>
                  <span className="text-sm font-semibold text-blue-700 dark:text-blue-400">
                    {stats.categories.medium}
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-xs text-gray-500 dark:text-gray-400">Låg (&lt;50)</span>
                  <span className="text-sm font-semibold text-black dark:text-white">
                    {stats.categories.low}
                  </span>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Interactive Visualizations */}
      <div className="grid grid-cols-1 gap-4">
        {/* Heat Map */}
        <Card variant="elevated" padding="md" className="overflow-visible">
          <CardContent className="overflow-visible">
            <h3 className="text-base font-semibold text-black dark:text-white mb-3">
              Heat Map - Färgintensitet per aktie
            </h3>
            <div className="relative overflow-visible">
              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-3 xl:grid-cols-4 gap-2 max-h-[400px] overflow-y-auto overflow-x-visible">
                {heatMapData.map((item, index) => {
                  // Determine if item is in first row (top row) - approximate based on common breakpoints
                  // For responsive grid: 2 cols (mobile), 3 cols (sm), 4 cols (md), 3 cols (lg), 4 cols (xl)
                  // We'll use a conservative estimate - first 4 items are likely in top row on most screens
                  const isTopRow = index < 4;
                  
                  return (
                    <div
                      key={`${item.ticker}-${item.companyName}-${index}`}
                      className="relative group cursor-pointer transition-transform hover:scale-105"
                      style={{
                        backgroundColor: getHeatMapColor(item.score),
                        minHeight: '60px',
                        borderRadius: '4px',
                        border: hoveredStock === item.ticker ? '2px solid' : '1px solid',
                        borderColor: hoveredStock === item.ticker 
                          ? (isDarkMode ? '#60a5fa' : '#3b82f6')
                          : (isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'),
                      }}
                      onMouseEnter={() => setHoveredStock(item.ticker)}
                      onMouseLeave={() => setHoveredStock(null)}
                    >
                      <div className="p-2 h-full flex flex-col justify-between">
                        <div className="text-xs font-semibold text-black dark:text-white truncate">
                          {item.ticker}
                        </div>
                        <div className="text-xs text-black dark:text-white font-bold">
                          {item.score.toFixed(1)}
                        </div>
                      </div>
                      {hoveredStock === item.ticker && (
                        <div 
                          className={`absolute z-[100] left-1/2 transform -translate-x-1/2 ${
                            isTopRow ? 'top-full mt-2' : 'bottom-full mb-2'
                          } text-white text-xs rounded px-2 py-1 whitespace-nowrap shadow-lg pointer-events-none`}
                          style={{
                            opacity: 1,
                            backgroundColor: isDarkMode ? 'rgb(31, 41, 55)' : 'rgb(17, 24, 39)', // Explicit solid colors (gray-800/gray-900)
                          }}
                        >
                          <div className="font-semibold">{item.companyName}</div>
                          <div className="text-gray-300">{item.ticker} - {item.score.toFixed(1)}</div>
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Scatter Plot */}
        <ScoreScatterPlot 
          data={data}
          thresholdData={thresholdData}
          benjaminGrahamData={benjaminGrahamData}
          entryExitValues={entryExitValues}
        />
      </div>
    </div>
  );
}

```

## `src/components/ScoreHistogram.tsx`

```tsx
import { useMemo } from 'react';
import { ResponsiveContainer, BarChart, Bar, Cell, XAxis, YAxis, Tooltip } from 'recharts';
import { Card, CardContent } from './ui/Card';
import { useTheme } from '../contexts/ThemeContext';
import { ScoreData } from './views/ScoreView';

interface ScoreHistogramProps {
  data: ScoreData[];
}

interface HistogramBin {
  range: string;
  count: number;
  min: number;
  max: number;
}

export default function ScoreHistogram({ data }: ScoreHistogramProps) {
  const { resolvedTheme } = useTheme();
  const isDarkMode = resolvedTheme === 'dark';

  // Create histogram bins: 0-10, 10-20, 20-30, ..., 90-100
  const histogramData: HistogramBin[] = useMemo(() => {
    if (!data || data.length === 0) {
      return [];
    }

    // Initialize bins
    const bins: HistogramBin[] = [];
    const binSize = 10;
    for (let i = 0; i < 100; i += binSize) {
      bins.push({
        range: `${i}-${i + binSize}`,
        count: 0,
        min: i,
        max: i + binSize,
      });
    }

    // Count scores in each bin
    data.forEach((item) => {
      const score = item.score;
      const binIndex = Math.floor(score / binSize);
      // Handle edge case: score of exactly 100 goes into last bin
      const safeIndex = Math.min(binIndex, bins.length - 1);
      if (bins[safeIndex]) {
        bins[safeIndex].count++;
      }
    });

    return bins;
  }, [data]);

  // Get color for each bar based on score range
  const getBarColor = (min: number) => {
    if (min < 50) {
      // Red gradient for low scores
      return isDarkMode ? 'rgba(239, 68, 68, 0.6)' : 'rgba(239, 68, 68, 0.7)';
    } else if (min < 70) {
      // Yellow/orange gradient for medium scores
      return isDarkMode ? 'rgba(251, 191, 36, 0.6)' : 'rgba(251, 191, 36, 0.7)';
    } else {
      // Green gradient for high scores
      return isDarkMode ? 'rgba(34, 197, 94, 0.6)' : 'rgba(34, 197, 94, 0.7)';
    }
  };

  // Custom tooltip
  const HistogramTooltip = ({ active, payload }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload as HistogramBin;
      return (
        <div className="bg-white dark:bg-gray-800 p-3 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg">
          <p className="font-semibold text-black dark:text-white">
            Score: {data.range}
          </p>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Antal: {data.count}
          </p>
        </div>
      );
    }
    return null;
  };

  if (!data || data.length === 0) {
    return null;
  }

  return (
    <Card variant="elevated" padding="md">
      <CardContent>
        <h3 className="text-base font-semibold text-black dark:text-white mb-3">
          Histogram - Scorefördelning
        </h3>
        <ResponsiveContainer width="100%" height={400}>
          <BarChart
            data={histogramData}
            margin={{ top: 5, right: 10, left: 0, bottom: 5 }}
          >
            <XAxis
              dataKey="range"
              tick={{ fill: isDarkMode ? '#e5e7eb' : '#374151', fontSize: 11 }}
              angle={-45}
              textAnchor="end"
              height={60}
            />
            <YAxis
              tick={{ fill: isDarkMode ? '#e5e7eb' : '#374151', fontSize: 11 }}
            />
            <Tooltip content={<HistogramTooltip />} />
            <Bar dataKey="count" radius={[4, 4, 0, 0]}>
              {histogramData.map((entry, index) => (
                <Cell
                  key={`bar-cell-${index}`}
                  fill={getBarColor(entry.min)}
                />
              ))}
            </Bar>
          </BarChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  );
}

```

## `src/components/ScoreScatterPlot.tsx`

```tsx
import { useMemo } from 'react';
import { ResponsiveContainer, ScatterChart, Scatter, XAxis, YAxis, Tooltip, CartesianGrid } from 'recharts';
import { Card, CardContent } from './ui/Card';
import { useTheme } from '../contexts/ThemeContext';
import { ScoreData } from './views/ScoreView';
import { ThresholdIndustryData, BenjaminGrahamData } from '../types/stock';
import { EntryExitValues } from '../contexts/EntryExitContext';
import { calculateDetailedScoreBreakdown } from '../utils/calculateScoreDetailed';

interface ScoreScatterPlotProps {
  data: ScoreData[];
  thresholdData?: ThresholdIndustryData[];
  benjaminGrahamData?: BenjaminGrahamData[];
  entryExitValues?: Map<string, EntryExitValues>;
}

interface ScatterDataPoint {
  x: number; // Fundamental score
  y: number; // Technical score
  ticker: string;
  companyName: string;
  score: number; // Total score for color coding
}

export default function ScoreScatterPlot({ 
  data, 
  thresholdData = [], 
  benjaminGrahamData = [], 
  entryExitValues = new Map() 
}: ScoreScatterPlotProps) {
  const { resolvedTheme } = useTheme();
  const isDarkMode = resolvedTheme === 'dark';

  // Calculate scatter plot data points, separated by color based on total score
  const { greenPoints, bluePoints, grayPoints } = useMemo(() => {
    if (!data || data.length === 0) {
      return { greenPoints: [], bluePoints: [], grayPoints: [] };
    }

    const green: ScatterDataPoint[] = [];
    const blue: ScatterDataPoint[] = [];
    const gray: ScatterDataPoint[] = [];

    data.forEach((item) => {
      // Calculate breakdown to get fundamental and technical scores
      const breakdown = calculateDetailedScoreBreakdown(
        item.scoreBoardData,
        thresholdData,
        benjaminGrahamData,
        entryExitValues
      );

      const point: ScatterDataPoint = {
        x: breakdown.fundamentalTotal,
        y: breakdown.technicalTotal,
        ticker: item.ticker,
        companyName: item.companyName,
        score: item.score, // Total score for color coding
      };

      // Filter out invalid points
      if (isNaN(point.x) || isNaN(point.y) || !isFinite(point.x) || !isFinite(point.y)) {
        return;
      }

      // Separate by color based on total score (matching SCORE column logic):
      // Green: score >= 70
      // Blue: score >= 50 && score < 70
      // Gray: score < 50
      if (item.score >= 70) {
        green.push(point);
      } else if (item.score >= 50 && item.score < 70) {
        blue.push(point);
      } else {
        gray.push(point);
      }
    });

    return { greenPoints: green, bluePoints: blue, grayPoints: gray };
  }, [data, thresholdData, benjaminGrahamData, entryExitValues]);

  // Custom tooltip
  const ScatterTooltip = ({ active, payload }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload as ScatterDataPoint;
      return (
        <div className="bg-white dark:bg-gray-800 p-3 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg">
          <p className="font-semibold text-black dark:text-white">
            {data.companyName}
          </p>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            {data.ticker}
          </p>
          <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
            Total poäng: {data.score.toFixed(1)}
          </p>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Fundamental: {data.x.toFixed(1)}
          </p>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Teknisk: {data.y.toFixed(1)}
          </p>
        </div>
      );
    }
    return null;
  };

  if (!data || data.length === 0) {
    return null;
  }

  // Color values matching SCORE column (from ScoreTable.tsx):
  // Green: text-green-700 dark:text-green-200
  // Blue: text-blue-700 dark:text-blue-400
  // Gray: text-black dark:text-white (using gray for better visibility)
  const grayColor = isDarkMode ? '#ffffff' : '#000000';
  const blueColor = isDarkMode ? '#60a5fa' : '#1d4ed8'; // blue-400 / blue-700
  const greenColor = isDarkMode ? '#86efac' : '#15803d'; // green-300 / green-700

  return (
    <Card variant="elevated" padding="md">
      <CardContent>
        <h3 className="text-base font-semibold text-black dark:text-white mb-3">
          Fundamental vs Teknisk poäng
        </h3>
        <ResponsiveContainer width="100%" height={400}>
          <ScatterChart
            margin={{ top: 5, right: 10, left: 0, bottom: 5 }}
          >
            <CartesianGrid 
              strokeDasharray="3 3" 
              stroke={isDarkMode ? '#374151' : '#e5e7eb'} 
            />
            <XAxis
              type="number"
              dataKey="x"
              name="Fundamental poäng"
              label={{ value: 'Fundamental poäng', position: 'insideBottom', offset: -5 }}
              domain={[0, 50]}
              tick={{ fill: isDarkMode ? '#e5e7eb' : '#374151', fontSize: 11 }}
            />
            <YAxis
              type="number"
              dataKey="y"
              name="Tekniska poäng"
              label={{ value: 'Tekniska poäng', angle: -90, position: 'insideLeft' }}
              domain={[0, 50]}
              tick={{ fill: isDarkMode ? '#e5e7eb' : '#374151', fontSize: 11 }}
            />
            <Tooltip content={<ScatterTooltip />} />
            {/* Gray points (score < 50) - rendered first as background */}
            <Scatter
              data={grayPoints}
              dataKey="y"
              fill={grayColor}
            />
            {/* Blue points (score >= 50 && score < 70) */}
            <Scatter
              data={bluePoints}
              dataKey="y"
              fill={blueColor}
            />
            {/* Green points (score >= 70) - rendered last on top */}
            <Scatter
              data={greenPoints}
              dataKey="y"
              fill={greenColor}
            />
          </ScatterChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  );
}

```

## `src/components/ScoreTable.tsx`

```tsx
import { useCallback } from 'react';
import BaseTable, { ColumnDefinition } from './BaseTable';
import { ScoreData } from './views/ScoreView';
import { ThresholdIndustryData, BenjaminGrahamData } from '../types/stock';
import { EntryExitValues } from '../contexts/EntryExitContext';
import { calculateDetailedScoreBreakdown } from '../utils/calculateScoreDetailed';
import { FilterConfig } from '../types/filters';
import { ChevronDownIcon } from '@heroicons/react/24/outline';
import ScoreBreakdownRow from './ScoreBreakdownRow';

interface ScoreTableProps {
  data: ScoreData[];
  loading: boolean;
  error: string | null;
  thresholdData?: ThresholdIndustryData[];
  benjaminGrahamData?: BenjaminGrahamData[];
  entryExitValues?: Map<string, EntryExitValues>;
}

const SCORE_COLUMNS: ColumnDefinition[] = [
  { key: 'antal', label: 'Antal', required: true, sticky: true, sortable: false },
  { key: 'companyName', label: 'Company Name', required: true, sticky: true, sortable: true },
  { key: 'ticker', label: 'Ticker', required: true, sticky: true, sortable: true },
  { key: 'currency', label: 'Currency', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'price', label: 'Price', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'entry1', label: 'ENTRY1', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'entry2', label: 'ENTRY2', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'exit1', label: 'EXIT1', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'exit2', label: 'EXIT2', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'score', label: 'Score', defaultVisible: true, sortable: true, align: 'center' },
];

const SCORE_FILTERS: FilterConfig[] = [
  {
    key: 'score',
    label: 'Score',
    type: 'numberRange',
    min: 0,
    max: 100,
    step: 0.1,
  },
  {
    key: 'companyName',
    label: 'Företagsnamn',
    type: 'text',
  },
  {
    key: 'ticker',
    label: 'Ticker',
    type: 'text',
  },
];

export default function ScoreTable({ data, loading, error, thresholdData = [], benjaminGrahamData = [], entryExitValues = new Map() }: ScoreTableProps) {
  // Helper function to generate row key - must be used consistently everywhere
  const generateRowKey = useCallback((item: ScoreData, index: number): string => {
    return `${item.ticker}-${item.companyName}-${index}`;
  }, []);

  const getScoreColorClass = useCallback((score: number): string => {
    if (score >= 70) return 'text-green-700 dark:text-green-200 font-bold';
    if (score >= 50 && score < 70) return 'text-blue-700 dark:text-blue-400 font-semibold';
    return 'text-black dark:text-white';
  }, []);

  const renderCell = useCallback((item: ScoreData, column: ColumnDefinition, index: number, globalIndex: number, expandedRows?: { [key: string]: boolean }, toggleRow?: (rowKey: string) => void) => {
    // Use the same format as getRowKey: ticker-companyName-index (where index is globalIndex)
    // IMPORTANT: This must match exactly with getRowKey function below
    const rowKey = generateRowKey(item, globalIndex);
    const isExpanded = expandedRows?.[rowKey] || false;

    switch (column.key) {
      case 'antal':
        return (
          <div className="flex items-center gap-2">
            <button
              onClick={(e) => {
                e.stopPropagation();
                e.preventDefault();
                if (toggleRow) {
                  toggleRow(rowKey);
                }
              }}
              className="p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition-colors"
              aria-label={isExpanded ? 'Collapse row' : 'Expand row'}
              aria-expanded={isExpanded}
              title={isExpanded ? 'Collapse' : 'Expand'}
              type="button"
            >
              <ChevronDownIcon 
                className={`w-4 h-4 text-gray-600 dark:text-gray-400 transition-transform duration-200 ${isExpanded ? 'rotate-180' : ''}`} 
              />
            </button>
            <span>{globalIndex + 1}</span>
          </div>
        );
      case 'companyName':
        return <span className="font-medium">{item.companyName}</span>;
      case 'ticker':
        return <span className="text-gray-500 dark:text-gray-300">{item.ticker}</span>;
      case 'currency':
        return <span className="text-black dark:text-white">{item.currency || 'USD'}</span>;
      case 'price':
        return <span className="text-black dark:text-white">{item.price !== null ? item.price.toLocaleString() : 'N/A'}</span>;
      case 'entry1':
        return <span className="text-black dark:text-white">{item.entry1 || '-'}</span>;
      case 'entry2':
        return <span className="text-black dark:text-white">{item.entry2 || '-'}</span>;
      case 'exit1':
        return <span className="text-black dark:text-white">{item.exit1 || '-'}</span>;
      case 'exit2':
        return <span className="text-black dark:text-white">{item.exit2 || '-'}</span>;
      case 'score':
        return (
          <span className={getScoreColorClass(item.score)}>
            {item.score.toFixed(1)}
          </span>
        );
      default:
        return null;
    }
  }, [getScoreColorClass, generateRowKey]);

  const renderMobileCard = useCallback((item: ScoreData, index: number, globalIndex: number, isExpanded: boolean, toggleExpand: () => void) => {
    return (
      <div
        className={`rounded-lg border border-gray-200 dark:border-gray-700 shadow-sm p-4 transition-all duration-300 ease-in-out ${
          globalIndex % 2 === 0 
            ? 'bg-white dark:bg-gray-800' 
            : 'bg-gray-50 dark:bg-gray-800/50'
        }`}
      >
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">Antal</span>
            <span className="text-sm font-medium text-black dark:text-white">{globalIndex + 1}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">Company Name</span>
            <span className="text-sm font-medium text-black dark:text-white text-right">{item.companyName}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">Ticker</span>
            <span className="text-sm text-gray-500 dark:text-gray-400">{item.ticker}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">Currency</span>
            <span className="text-sm text-black dark:text-white">{item.currency || 'USD'}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">Price</span>
            <span className="text-sm text-black dark:text-white">{item.price !== null ? item.price.toLocaleString() : 'N/A'}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">ENTRY1</span>
            <span className="text-sm text-black dark:text-white">{item.entry1 || '-'}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">ENTRY2</span>
            <span className="text-sm text-black dark:text-white">{item.entry2 || '-'}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">EXIT1</span>
            <span className="text-sm text-black dark:text-white">{item.exit1 || '-'}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">EXIT2</span>
            <span className="text-sm text-black dark:text-white">{item.exit2 || '-'}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">Score</span>
            <span className={`text-sm ${getScoreColorClass(item.score)}`}>{item.score.toFixed(1)}</span>
          </div>
        </div>
      </div>
    );
  }, [getScoreColorClass]);

  const renderExpandedRow = useCallback((item: ScoreData, index: number, globalIndex: number) => {
    const breakdown = calculateDetailedScoreBreakdown(
      item.scoreBoardData,
      thresholdData,
      benjaminGrahamData,
      entryExitValues
    );

    return <ScoreBreakdownRow breakdown={breakdown} />;
  }, [thresholdData, benjaminGrahamData, entryExitValues]);

  return (
    <BaseTable<ScoreData>
      data={data}
      loading={loading}
      error={error}
      columns={SCORE_COLUMNS}
      filters={SCORE_FILTERS}
      tableId="score"
      renderCell={renderCell}
      renderMobileCard={renderMobileCard}
      renderExpandedRow={renderExpandedRow}
      enableVirtualScroll={true}
      searchFields={['companyName', 'ticker']}
      searchPlaceholder="Sök efter företag eller ticker..."
      defaultSortKey="score"
      defaultSortDirection="desc"
      stickyColumns={['antal', 'companyName', 'ticker', 'currency']}
      ariaLabel="Score"
      minTableWidth="600px"
      getRowKey={(item, index) => {
        // index parameter is globalIndex when called from BaseTable
        // Use the same function to ensure consistency
        return generateRowKey(item, index);
      }}
      enableExport={true}
      enablePrint={true}
      enableShareableLink={true}
      viewId="score"
    />
  );
}


```

## `src/components/ShareableLinkModal.tsx`

```tsx
import { useState, useCallback, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useAuth } from '../contexts/AuthContext';
import { useNotifications } from '../contexts/NotificationContext';
import {
  saveShareableLink,
  generateShareableUrl,
  getUserShareableLinks,
  deleteShareableLink,
  ShareableLink,
} from '../services/shareableLinkService';
import { FilterValues } from '../types/filters';
import Button from './ui/Button';

interface ShareableLinkModalProps {
  isOpen: boolean;
  onClose: () => void;
  filterState: FilterValues;
  viewId: string;
  tableId: string;
  sortConfig?: { key: string; direction: 'asc' | 'desc' };
}

export default function ShareableLinkModal({
  isOpen,
  onClose,
  filterState,
  viewId,
  tableId,
  sortConfig,
}: ShareableLinkModalProps) {
  const { t } = useTranslation();
  const { currentUser } = useAuth();
  const { createNotification } = useNotifications();
  const [linkName, setLinkName] = useState('');
  const [linkDescription, setLinkDescription] = useState('');
  const [expiresInDays, setExpiresInDays] = useState(30);
  const [saving, setSaving] = useState(false);
  const [savedLinkId, setSavedLinkId] = useState<string | null>(null);
  const [userLinks, setUserLinks] = useState<ShareableLink[]>([]);
  const [loadingLinks, setLoadingLinks] = useState(false);

  // Load user's existing links
  useEffect(() => {
    if (isOpen && currentUser) {
      loadUserLinks();
    }
  }, [isOpen, currentUser]);

  const loadUserLinks = useCallback(async () => {
    if (!currentUser) return;

    try {
      setLoadingLinks(true);
      const links = await getUserShareableLinks(currentUser.uid, 10);
      setUserLinks(links);
    } catch (error) {
      createNotification(
        'error',
        'Error Loading Links',
        'Failed to load your shareable links',
        { showDesktop: false }
      );
    } finally {
      setLoadingLinks(false);
    }
  }, [currentUser, createNotification]);

  const handleSaveLink = useCallback(async () => {
    if (!currentUser || saving) return;

    try {
      setSaving(true);
      const linkId = await saveShareableLink(filterState, viewId, tableId, currentUser.uid, {
        name: linkName.trim() || undefined,
        description: linkDescription.trim() || undefined,
        expiresInDays,
        sortConfig,
      });

      setSavedLinkId(linkId);
      createNotification(
        'success',
        'Link Created',
        'Shareable link created successfully',
        { showDesktop: false }
      );

      // Reload user links
      await loadUserLinks();
    } catch (error) {
      createNotification(
        'error',
        'Error Creating Link',
        error instanceof Error ? error.message : 'Failed to create shareable link',
        { showDesktop: true }
      );
    } finally {
      setSaving(false);
    }
  }, [currentUser, filterState, viewId, tableId, linkName, linkDescription, expiresInDays, sortConfig, saving, createNotification, loadUserLinks]);

  const handleCopyLink = useCallback((linkId: string) => {
    const url = generateShareableUrl(linkId);
    navigator.clipboard.writeText(url).then(() => {
      createNotification('success', 'Link Copied', 'Shareable link copied to clipboard', {
        showDesktop: false,
      });
    });
  }, [createNotification]);

  const handleDeleteLink = useCallback(async (linkId: string) => {
    if (!currentUser) return;

    if (!window.confirm(t('shareableLinks.confirmDelete', 'Are you sure you want to delete this link?'))) {
      return;
    }

    try {
      await deleteShareableLink(linkId, currentUser.uid);
      createNotification('success', 'Link Deleted', 'Shareable link deleted successfully', {
        showDesktop: false,
      });
      await loadUserLinks();
    } catch (error) {
      createNotification(
        'error',
        'Error Deleting Link',
        error instanceof Error ? error.message : 'Failed to delete shareable link',
        { showDesktop: true }
      );
    }
  }, [currentUser, createNotification, loadUserLinks, t]);

  if (!isOpen) return null;

  const shareableUrl = savedLinkId ? generateShareableUrl(savedLinkId) : '';

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 dark:bg-opacity-70 animate-fade-in transition-opacity duration-300"
      onClick={onClose}
    >
      <div
        className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto m-4 animate-scale-in transition-all duration-300"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="p-6">
          <div className="flex items-center justify-between mb-6">
            <h2 className="text-2xl font-bold text-black dark:text-white">
              {t('shareableLinks.title', 'Create Shareable Link')}
            </h2>
            <button
              onClick={onClose}
              className="p-2 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-colors"
              aria-label={t('common.close', 'Close')}
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>

          {!savedLinkId ? (
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                  {t('shareableLinks.linkName', 'Link Name (optional)')}
                </label>
                <input
                  type="text"
                  value={linkName}
                  onChange={(e) => setLinkName(e.target.value)}
                  placeholder={t('shareableLinks.linkNamePlaceholder', 'e.g., High Score Stocks')}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                  {t('shareableLinks.description', 'Description (optional)')}
                </label>
                <textarea
                  value={linkDescription}
                  onChange={(e) => setLinkDescription(e.target.value)}
                  placeholder={t('shareableLinks.descriptionPlaceholder', 'Add a description...')}
                  rows={3}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                  {t('shareableLinks.expiresIn', 'Expires In (days)')}
                </label>
                <select
                  value={expiresInDays}
                  onChange={(e) => setExpiresInDays(Number(e.target.value))}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white"
                >
                  <option value={7}>7 days</option>
                  <option value={30}>30 days</option>
                  <option value={90}>90 days</option>
                  <option value={365}>1 year</option>
                </select>
              </div>

              <div className="flex justify-end gap-3 pt-4">
                <Button variant="outline" onClick={onClose}>
                  {t('common.cancel', 'Cancel')}
                </Button>
                <Button variant="primary" onClick={handleSaveLink} disabled={saving}>
                  {saving ? t('shareableLinks.saving', 'Saving...') : t('shareableLinks.create', 'Create Link')}
                </Button>
              </div>
            </div>
          ) : (
            <div className="space-y-4">
              <div className="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-4">
                <p className="text-sm font-medium text-green-800 dark:text-green-200 mb-2">
                  {t('shareableLinks.linkCreated', 'Link created successfully!')}
                </p>
                <div className="flex items-center gap-2">
                  <input
                    type="text"
                    value={shareableUrl}
                    readOnly
                    className="flex-1 px-3 py-2 border border-green-300 dark:border-green-700 rounded-md bg-white dark:bg-gray-800 text-black dark:text-white text-sm"
                  />
                  <Button
                    variant="primary"
                    size="sm"
                    onClick={() => handleCopyLink(savedLinkId)}
                  >
                    {t('shareableLinks.copy', 'Copy')}
                  </Button>
                </div>
              </div>

              <div className="flex justify-end gap-3 pt-4">
                <Button variant="outline" onClick={onClose}>
                  {t('common.close', 'Close')}
                </Button>
              </div>
            </div>
          )}

          {/* User's existing links */}
          {currentUser && (
            <div className="mt-8 border-t border-gray-300 dark:border-gray-600 pt-6">
              <h3 className="text-lg font-semibold text-black dark:text-white mb-4">
                {t('shareableLinks.myLinks', 'My Shareable Links')}
              </h3>
              {loadingLinks ? (
                <p className="text-sm text-gray-600 dark:text-gray-400">{t('common.loading', 'Loading...')}</p>
              ) : userLinks.length === 0 ? (
                <p className="text-sm text-gray-600 dark:text-gray-400">
                  {t('shareableLinks.noLinks', 'No shareable links yet')}
                </p>
              ) : (
                <div className="space-y-2">
                  {userLinks.map((link) => (
                    <div
                      key={link.id}
                      className="flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-700 rounded-md"
                    >
                      <div className="flex-1 min-w-0">
                        <p className="text-sm font-medium text-black dark:text-white truncate">
                          {link.name || t('shareableLinks.unnamed', 'Unnamed Link')}
                        </p>
                        <p className="text-xs text-gray-600 dark:text-gray-400">
                          {link.createdAt.toLocaleDateString()} • {link.tableId}
                        </p>
                      </div>
                      <div className="flex items-center gap-2 ml-4">
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleCopyLink(link.id)}
                        >
                          {t('shareableLinks.copy', 'Copy')}
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleDeleteLink(link.id)}
                        >
                          {t('shareableLinks.delete', 'Delete')}
                        </Button>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

```

## `src/components/Sidebar.tsx`

```tsx
import { useState, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { ViewId, NavigationSection } from '../types/navigation';
import ConditionsSidebar from './ConditionsSidebar';
import { useUserRole } from '../hooks/useUserRole';
import { useAuth } from '../contexts/AuthContext';
import { useToast } from '../contexts/ToastContext';
import { 
  TrophyIcon, 
  ChartBarIcon, 
  CursorArrowRaysIcon, 
  ChartPieIcon,
  BuildingOfficeIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  UserIcon,
  UserGroupIcon,
  KeyIcon
} from '@heroicons/react/24/outline';
import ApiKeysModal from './ApiKeysModal';
import { setApiKeysInFirestore } from '../services/appConfigService';
import { setApiKeysCache } from '../config/apiKeys';
import type { ApiKeys } from '../config/apiKeys';

interface SidebarProps {
  activeView: ViewId;
  onViewChange: (viewId: ViewId) => void;
  onOpenConditionsModal: (viewId: ViewId) => void;
  isOpen: boolean;
  onClose: () => void;
  isCollapsed: boolean;
  onToggleCollapse: () => void;
  onOpenUserProfile?: () => void;
}

const getAllNavigationSections = (t: (key: string) => string): NavigationSection[] => [
  {
    id: 'score',
    label: t('navigation.score'),
    items: [{ id: 'score', label: t('navigation.score') }],
    collapsible: false,
  },
  {
    id: 'score-board',
    label: t('navigation.scoreBoard'),
    items: [{ id: 'score-board', label: t('navigation.scoreBoard') }],
    collapsible: false,
  },
  {
    id: 'entry-exit-benjamin-graham',
    label: t('navigation.benjaminGraham'),
    items: [{ id: 'entry-exit-benjamin-graham', label: t('navigation.benjaminGraham') }],
    collapsible: false,
  },
  {
    id: 'fundamental-pe-industry',
    label: t('navigation.peIndustry'),
    items: [{ id: 'fundamental-pe-industry', label: t('navigation.peIndustry') }],
    collapsible: false,
  },
  {
    id: 'threshold-industry',
    label: t('navigation.thresholdIndustry'),
    items: [{ id: 'threshold-industry', label: t('navigation.thresholdIndustry') }],
    collapsible: false,
  },
];

// Icon mapping for each view
const getViewIcon = (viewId: ViewId) => {
  switch (viewId) {
    case 'score':
      return TrophyIcon;
    case 'score-board':
      return ChartBarIcon;
    case 'entry-exit-benjamin-graham':
      return CursorArrowRaysIcon;
    case 'fundamental-pe-industry':
      return ChartPieIcon;
    case 'threshold-industry':
      return BuildingOfficeIcon;
    default:
      return null;
  }
};

export default function Sidebar({ activeView, onViewChange, onOpenConditionsModal, isOpen, onClose, isCollapsed, onToggleCollapse, onOpenUserProfile }: SidebarProps) {
  const { t } = useTranslation();
  const { canView, isAdmin } = useUserRole();
  const { currentUser } = useAuth();
  const { showToast } = useToast();
  
  // Filter navigation sections based on user permissions
  const navigationSections = useMemo(() => {
    const allSections = getAllNavigationSections(t);
    
    // Filter sections based on what views user can access
    return allSections.filter(section => {
      // Check if user can view any item in this section
      return section.items.some(item => canView(item.id));
    });
  }, [t, canView]);
  const [expandedSections, setExpandedSections] = useState<Set<string>>(
    new Set(['score'])
  );

  const [expandedSubmenus, setExpandedSubmenus] = useState<Set<string>>(
    new Set()
  );
  const [apiKeysModalOpen, setApiKeysModalOpen] = useState(false);

  const toggleSection = (sectionId: string) => {
    setExpandedSections((prev) => {
      const next = new Set(prev);
      if (next.has(sectionId)) {
        next.delete(sectionId);
      } else {
        next.add(sectionId);
      }
      return next;
    });
  };

  const toggleSubmenu = (itemId: string) => {
    setExpandedSubmenus((prev) => {
      const next = new Set(prev);
      if (next.has(itemId)) {
        next.delete(itemId);
      } else {
        next.add(itemId);
      }
      return next;
    });
  };

  const handleItemClick = (viewId: ViewId) => {
    onViewChange(viewId);
  };

  const handleSaveApiKeys = async (keys: ApiKeys) => {
    await setApiKeysInFirestore(keys);
    setApiKeysCache(keys);
    setApiKeysModalOpen(false);
    showToast(t('apiKeys.saved', 'API-nycklar sparade.'), 'success');
  };

  const isSectionExpanded = (sectionId: string) => expandedSections.has(sectionId);
  const isSubmenuExpanded = (itemId: string) => expandedSubmenus.has(itemId);
  const isActive = (viewId: ViewId) => activeView === viewId;

  // Sidebar always visible - no swipe gesture needed
  const sidebarRef = null;

  return (
    <>
      {/* Sidebar - always visible */}
      <nav
        ref={sidebarRef}
        id="navigation"
        className={`fixed top-0 left-0 h-screen bg-white dark:bg-gray-800 border-r border-gray-300 dark:border-gray-500 overflow-y-auto pt-6 z-50 flex flex-col ${isCollapsed ? 'w-16' : 'w-64'}`}
        aria-label={t('navigation.title')}
      >
        <div className={`${isCollapsed ? 'px-2' : 'px-4'} pb-4 pt-0 flex flex-col flex-1`}>
          {/* Toggle button */}
          <div className={`flex items-center ${isCollapsed ? 'justify-center' : 'justify-end'} mb-4`}>
            <button
              onClick={onToggleCollapse}
              className="p-1.5 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors min-h-[44px] min-w-[44px] touch-manipulation flex items-center justify-center"
              aria-label={isCollapsed ? t('aria.expandSidebar') : t('aria.collapseSidebar')}
              title={isCollapsed ? t('aria.expandSidebar') : t('aria.collapseSidebar')}
            >
              {isCollapsed ? (
                <ChevronRightIcon className="w-5 h-5 text-gray-600 dark:text-gray-300" />
              ) : (
                <ChevronLeftIcon className="w-5 h-5 text-gray-600 dark:text-gray-300" />
              )}
            </button>
          </div>
          
          {/* Title */}
          {!isCollapsed && (
            <h2 className="text-2xl font-bold text-black dark:text-white mb-6 tracking-tight">
              {t('navigation.title')}
            </h2>
          )}
        
        <nav className="space-y-2 flex-1 overflow-y-auto">
          {navigationSections.map((section) => (
            <div key={section.id}>
              {section.collapsible && (
                <button
                  onClick={() => toggleSection(section.id)}
                  className="w-full flex items-center justify-between px-3 py-3 sm:py-2.5 text-left text-sm font-semibold text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-all duration-200 hover:scale-[1.02] active:scale-95 min-h-[44px] touch-manipulation"
                  aria-expanded={isSectionExpanded(section.id)}
                  aria-label={`${section.label}, ${isSectionExpanded(section.id) ? t('aria.closeMenu') : t('aria.openMenu')}`}
                >
                  <span className="tracking-wide">{section.label}</span>
                  <span className="text-gray-600 dark:text-gray-300 text-xs" aria-hidden="true">
                    {isSectionExpanded(section.id) ? '▼' : '▶'}
                  </span>
                </button>
              )}

              {(!section.collapsible || isSectionExpanded(section.id)) && (
                <div className="ml-2 space-y-1">
                  {section.items.map((item) => {
                    if (item.children) {
                      return (
                        <div key={item.id}>
                          <button
                            onClick={() => toggleSubmenu(item.id)}
                            className="w-full flex items-center justify-between px-3 py-3 sm:py-2 text-left text-sm text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 rounded transition-all duration-200 hover:scale-[1.02] active:scale-95 min-h-[44px] touch-manipulation"
                            aria-expanded={isSubmenuExpanded(item.id)}
                            aria-label={`${item.label}, ${isSubmenuExpanded(item.id) ? t('aria.closeMenu') : t('aria.openMenu')}`}
                          >
                            <span>{item.label}</span>
                            <span className="text-gray-600 dark:text-gray-300 text-xs" aria-hidden="true">
                              {isSubmenuExpanded(item.id) ? '▼' : '▶'}
                            </span>
                          </button>
                          {isSubmenuExpanded(item.id) && (
                            <div className="ml-4 space-y-1">
                              {item.children.map((child) => (
                                <button
                                  key={child.id}
                                  onClick={() => handleItemClick(child.id)}
                                  className={`w-full px-3 py-3 sm:py-2 text-left text-sm rounded transition-colors min-h-[44px] touch-manipulation ${
                                    isActive(child.id)
                                      ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-200 font-medium'
                                      : 'text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 transition-all duration-200 hover:scale-[1.02] active:scale-95'
                                  }`}
                                  aria-label={`${t('aria.navigateTo')} ${child.label}`}
                                  aria-current={isActive(child.id) ? 'page' : undefined}
                                >
                                  {child.label}
                                </button>
                              ))}
                            </div>
                          )}
                        </div>
                      );
                    }

                    const IconComponent = getViewIcon(item.id);
                    return (
                      <button
                        key={item.id}
                        onClick={() => handleItemClick(item.id)}
                        className={`w-full ${isCollapsed ? 'px-2 justify-center' : 'px-3'} py-3 sm:py-2.5 ${isCollapsed ? '' : 'text-left'} text-sm rounded-md transition-colors min-h-[44px] touch-manipulation flex items-center gap-3 ${
                          isActive(item.id)
                            ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-200 font-semibold'
                            : 'text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 font-medium transition-all duration-200 hover:scale-[1.02] active:scale-95'
                        }`}
                        aria-label={`${t('aria.navigateTo')} ${item.label}`}
                        aria-current={isActive(item.id) ? 'page' : undefined}
                        title={isCollapsed ? item.label : undefined}
                      >
                        {IconComponent && (
                          <IconComponent className={`${isCollapsed ? 'w-6 h-6' : 'w-5 h-5'} flex-shrink-0`} />
                        )}
                        {!isCollapsed && <span>{item.label}</span>}
                      </button>
                    );
                  })}
                </div>
              )}
            </div>
          ))}
          
          {/* Conditions Section */}
          {!isCollapsed && (
            <div className="mt-4 pt-4 border-t border-gray-300 dark:border-gray-500">
              <ConditionsSidebar onOpenModal={onOpenConditionsModal} />
            </div>
          )}
        </nav>
        
        {/* User Management, API Keys and Profile - at bottom */}
        {currentUser && (
          <div className="mt-auto pt-4 border-t border-gray-300 dark:border-gray-500 space-y-1">
            {isAdmin && (
              <button
                onClick={() => onViewChange('admin')}
                className={`w-full ${isCollapsed ? 'px-2 justify-center' : 'px-3'} py-3 sm:py-2.5 ${isCollapsed ? '' : 'text-left'} text-sm rounded-md transition-colors min-h-[44px] touch-manipulation flex items-center gap-3 text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 font-medium transition-all duration-200 hover:scale-[1.02] active:scale-95 ${
                  activeView === 'admin' ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-200' : ''
                }`}
                title={isCollapsed ? t('navigation.userManagement') : undefined}
                aria-label={t('navigation.userManagement')}
                aria-current={activeView === 'admin' ? 'page' : undefined}
              >
                <UserGroupIcon className={`${isCollapsed ? 'w-6 h-6' : 'w-5 h-5'} flex-shrink-0`} />
                {!isCollapsed && <span>{t('navigation.userManagement')}</span>}
              </button>
            )}
            {isAdmin && (
              <button
                onClick={() => setApiKeysModalOpen(true)}
                className={`w-full ${isCollapsed ? 'px-2 justify-center' : 'px-3'} py-3 sm:py-2.5 ${isCollapsed ? '' : 'text-left'} text-sm rounded-md transition-colors min-h-[44px] touch-manipulation flex items-center gap-3 text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 font-medium transition-all duration-200 hover:scale-[1.02] active:scale-95`}
                title={isCollapsed ? t('header.apiKeys', 'API-nycklar') : undefined}
                aria-label={t('header.apiKeys', 'API-nycklar')}
              >
                <KeyIcon className={`${isCollapsed ? 'w-6 h-6' : 'w-5 h-5'} flex-shrink-0`} />
                {!isCollapsed && <span>{t('header.apiKeys', 'API-nycklar')}</span>}
              </button>
            )}
            {onOpenUserProfile && (
              <button
                onClick={() => onOpenUserProfile()}
                className={`w-full ${isCollapsed ? 'px-2 justify-center' : 'px-3'} py-3 sm:py-2.5 ${isCollapsed ? '' : 'text-left'} text-sm rounded-md transition-colors min-h-[44px] touch-manipulation flex items-center gap-3 text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 font-medium transition-all duration-200 hover:scale-[1.02] active:scale-95`}
                title={isCollapsed ? t('profile.title') : undefined}
                aria-label={t('aria.userProfileButton')}
              >
                <UserIcon className={`${isCollapsed ? 'w-6 h-6' : 'w-5 h-5'} flex-shrink-0`} />
                {!isCollapsed && <span>{t('profile.title')}</span>}
              </button>
            )}
          </div>
        )}
      </div>
      </nav>
      {isAdmin && (
        <ApiKeysModal
          isOpen={apiKeysModalOpen}
          onClose={() => setApiKeysModalOpen(false)}
          onSave={handleSaveApiKeys}
        />
      )}
    </>
  );
}

```

## `src/components/SkeletonLoader.tsx`

```tsx
interface SkeletonLoaderProps {
  className?: string;
  width?: string;
  height?: string;
}

export default function SkeletonLoader({ className = '', width, height }: SkeletonLoaderProps) {
  return (
    <div
      className={`animate-shimmer bg-gradient-to-r from-gray-200 via-gray-300 to-gray-200 dark:from-gray-700 dark:via-gray-600 dark:to-gray-700 rounded ${className}`}
      style={{
        width: width || '100%',
        height: height || '1rem',
        backgroundSize: '200% 100%',
      }}
    />
  );
}

interface TableSkeletonProps {
  rows?: number;
  columns?: number;
  hasStickyColumns?: boolean;
}

export function TableSkeleton({ rows = 10, columns = 5, hasStickyColumns = false }: TableSkeletonProps) {
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-x-auto h-full flex flex-col">
      <div className="flex-1 overflow-y-auto min-h-0">
        <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
          <thead className="sticky top-0 z-40 bg-gray-50 dark:bg-gray-900">
            <tr>
              {hasStickyColumns && (
                <th className="px-6 py-3 text-left text-xs font-bold text-gray-500 dark:text-gray-400 uppercase tracking-wider sticky top-0 left-0 bg-gray-50 dark:bg-gray-900 z-30">
                  <SkeletonLoader height="0.75rem" width="3rem" />
                </th>
              )}
              {Array.from({ length: columns }).map((_, colIndex) => (
                <th
                  key={colIndex}
                  className={`px-6 py-3 text-left text-xs font-bold text-gray-500 dark:text-gray-400 uppercase tracking-wider sticky top-0 bg-gray-50 dark:bg-gray-900 z-20 ${
                    hasStickyColumns && colIndex === 0 ? 'left-[60px] z-30' : ''
                  } ${hasStickyColumns && colIndex === 1 ? 'left-[260px] z-30' : ''}`}
                >
                  <SkeletonLoader height="0.75rem" width={colIndex === 0 ? '8rem' : '6rem'} />
                </th>
              ))}
            </tr>
          </thead>
          <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
            {Array.from({ length: rows }).map((_, rowIndex) => (
              <tr key={rowIndex} className="hover:bg-gray-50 dark:hover:bg-gray-700">
                {hasStickyColumns && (
                  <td className="px-6 py-4 whitespace-nowrap sticky left-0 bg-white dark:bg-gray-800 z-20">
                    <SkeletonLoader height="1rem" width="2rem" />
                  </td>
                )}
                {Array.from({ length: columns }).map((_, colIndex) => (
                  <td
                    key={colIndex}
                    className={`px-6 py-4 whitespace-nowrap ${
                      hasStickyColumns && colIndex === 0
                        ? 'sticky left-[60px] bg-white dark:bg-gray-800 z-20'
                        : ''
                    } ${
                      hasStickyColumns && colIndex === 1
                        ? 'sticky left-[260px] bg-white dark:bg-gray-800 z-20'
                        : ''
                    }`}
                  >
                    <SkeletonLoader
                      height="1rem"
                      width={colIndex === 0 ? '10rem' : colIndex === 1 ? '4rem' : '6rem'}
                    />
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}


```

## `src/components/SkipLinks.tsx`

```tsx
import { useTranslation } from 'react-i18next';

export default function SkipLinks() {
  const { t } = useTranslation();

  return (
    <div className="sr-only focus-within:not-sr-only focus-within:absolute focus-within:z-50 focus-within:top-4 focus-within:left-4">
      <a
        href="#main-content"
        className="block px-4 py-2 bg-blue-600 text-white rounded-md shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
      >
        {t('aria.skipToContent', 'Hoppa till huvudinnehåll')}
      </a>
      <a
        href="#navigation"
        className="block px-4 py-2 bg-blue-600 text-white rounded-md shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 mt-2"
      >
        {t('aria.skipToNavigation', 'Hoppa till navigation')}
      </a>
    </div>
  );
}


```

## `src/components/SortableTableHeader.tsx`

```tsx
import React from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

interface SortableTableHeaderProps {
  id: string;
  children: React.ReactNode;
  className?: string;
  style?: React.CSSProperties;
  isResizing?: boolean;
  enableResize?: boolean;
  onResizeStart?: (e: React.MouseEvent) => void;
}

export function SortableTableHeader({
  id,
  children,
  className = '',
  style,
  isResizing = false,
  enableResize = false,
  onResizeStart,
}: SortableTableHeaderProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id });

  const dragStyle = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  return (
    <th
      ref={setNodeRef}
      style={{ ...style, ...dragStyle }}
      className={`${className} ${isDragging ? 'z-50' : ''} ${isResizing ? 'bg-blue-100 dark:bg-blue-900/50' : ''}`}
      {...attributes}
    >
      <div className="flex items-center justify-between relative">
        <div
          {...listeners}
          className="flex-1 flex items-center cursor-grab active:cursor-grabbing"
          style={{ touchAction: 'none' }}
        >
          {children}
        </div>
        {enableResize && (
          <div
            className="absolute right-0 top-0 bottom-0 w-1 cursor-col-resize hover:bg-blue-500 dark:hover:bg-blue-400 transition-colors duration-base"
            onMouseDown={(e) => {
              e.stopPropagation();
              if (onResizeStart) {
                onResizeStart(e);
              }
            }}
            role="separator"
            aria-orientation="vertical"
          />
        )}
      </div>
    </th>
  );
}

```

## `src/components/TableSearchBar.tsx`

```tsx
import { sanitizeSearchQuery } from '../utils/inputValidator';

interface TableSearchBarProps {
  searchValue: string;
  onSearchChange: (value: string) => void;
  totalRows: number;
  filteredRows: number;
  placeholder?: string;
}

export default function TableSearchBar({
  searchValue,
  onSearchChange,
  totalRows,
  filteredRows,
  placeholder = 'Sök...',
}: TableSearchBarProps) {
  return (
    <div className="flex flex-col sm:flex-row items-stretch sm:items-center justify-between gap-3 sm:gap-4 flex-shrink-0">
      {/* Search */}
      <div className="flex-1 min-w-0 sm:min-w-[200px] sm:max-w-md">
        <div className="relative">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg
              className="h-5 w-5 text-gray-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
              />
            </svg>
          </div>
          <input
            type="text"
            value={searchValue}
            onChange={(e) => {
              // Sanitize input as user types
              const sanitized = sanitizeSearchQuery(e.target.value);
              onSearchChange(sanitized);
            }}
            placeholder={placeholder}
            maxLength={200}
            className="block w-full pl-10 pr-10 py-2 border border-gray-300 dark:border-gray-500 rounded-md leading-5 bg-white dark:bg-gray-700 text-black dark:text-white placeholder-gray-500 dark:placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200 focus:shadow-sm"
          />
          {searchValue && (
            <button
              onClick={() => onSearchChange('')}
              className="absolute inset-y-0 right-0 pr-3 flex items-center hover:text-gray-600 dark:hover:text-gray-300 transition-all duration-200 hover:scale-110 active:scale-95 min-h-[44px] min-w-[44px] touch-manipulation justify-center"
              title="Rensa sökning"
            >
              <svg
                className="h-5 w-5 text-gray-400"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M6 18L18 6M6 6l12 12"
                />
              </svg>
            </button>
          )}
        </div>
      </div>

      {/* Results count */}
      <div className="text-xs sm:text-sm font-medium text-gray-600 dark:text-gray-300 whitespace-nowrap text-center sm:text-left">
        {filteredRows !== totalRows ? (
          <>
            Visar <span className="font-bold text-black dark:text-white">{filteredRows}</span> av{' '}
            <span className="font-bold text-black dark:text-white">{totalRows}</span> rader
          </>
        ) : (
          <>
            <span className="font-bold text-black dark:text-white">{totalRows}</span> rader
          </>
        )}
      </div>
    </div>
  );
}


```

## `src/components/ThresholdIndustryTable.tsx`

```tsx
import React, { useEffect, useMemo, useCallback } from 'react';
import { ThresholdIndustryData } from '../types/stock';
import BaseTable, { ColumnDefinition, HeaderRenderProps } from './BaseTable';
import ColumnTooltip from './ColumnTooltip';
import ColumnFilterMenu from './ColumnFilterMenu';
import { getColumnMetadata } from '../config/tableMetadata';
import { FilterConfig } from './AdvancedFilters';
import { useTranslation } from 'react-i18next';
import { useThresholdValues, ThresholdValues } from '../contexts/ThresholdContext';
import { useAuth } from '../contexts/AuthContext';

interface ThresholdIndustryTableProps {
  data: ThresholdIndustryData[];
  loading: boolean;
  error: string | null;
}

const THRESHOLD_INDUSTRY_COLUMNS: ColumnDefinition<ThresholdIndustryData>[] = [
  { key: 'antal', label: 'Antal', required: true, sticky: true, sortable: false },
  { key: 'industry', label: 'INDUSTRY', required: true, sticky: true, sortable: true },
  { key: 'irr', label: 'IRR', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'leverageF2Min', label: 'LEVERAGE F2 MIN', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'leverageF2Max', label: 'LEVERAGE F2 MAX', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'ro40Min', label: 'RO40 MIN', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'ro40Max', label: 'RO40 MAX', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'cashSdebtMin', label: 'Cash/SDebt MIN', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'cashSdebtMax', label: 'Cash/SDebt MAX', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'currentRatioMin', label: 'Current Ratio MIN', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'currentRatioMax', label: 'Current Ratio MAX', defaultVisible: true, sortable: true, align: 'center' },
];

export default function ThresholdIndustryTable({ data, loading, error }: ThresholdIndustryTableProps) {
  const { t } = useTranslation();
  const { userRole } = useAuth();
  const { thresholdValues, getThresholdValue, getFieldValue, setFieldValue, commitField, initializeFromData } = useThresholdValues();
  const isReadOnly = userRole !== 'admin';

  // Get unique industries for filter dropdown
  const uniqueIndustries = useMemo(() => {
    const industries = new Set<string>();
    data.forEach((item) => {
      if (item.industry && item.industry.trim()) {
        industries.add(item.industry);
      }
    });
    return Array.from(industries).sort().map((ind) => ({ value: ind, label: ind }));
  }, [data]);

  const thresholdFilters: FilterConfig[] = useMemo(() => [
    {
      key: 'industry',
      label: 'Industri',
      type: 'select',
      options: uniqueIndustries,
    },
    {
      key: 'irr',
      label: 'IRR',
      type: 'numberRange',
      step: 0.1,
    },
    {
      key: 'leverageF2Min',
      label: 'Leverage F2 Min',
      type: 'numberRange',
      step: 0.01,
    },
    {
      key: 'leverageF2Max',
      label: 'Leverage F2 Max',
      type: 'numberRange',
      step: 0.01,
    },
    {
      key: 'ro40Min',
      label: 'Ro40 Min',
      type: 'numberRange',
      step: 0.1,
    },
    {
      key: 'ro40Max',
      label: 'Ro40 Max',
      type: 'numberRange',
      step: 0.1,
    },
  ], [uniqueIndustries]);

  // Initialize threshold values from data
  useEffect(() => {
    initializeFromData(data);
  }, [data, initializeFromData]);

  const handleThresholdChange = useCallback((industry: string, field: keyof ThresholdValues, value: number) => {
    setFieldValue(industry, field, value);
  }, [setFieldValue]);

  const inputClass = 'px-3 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent w-24 text-center';

  const renderThresholdField = useCallback(
    (industry: string, field: keyof ThresholdValues, value: number | string, step: string) =>
      isReadOnly ? (
        <span className="text-sm text-black dark:text-white">{value}</span>
      ) : (
        <input
          type="number"
          step={step}
          value={value || ''}
          onChange={(e) => {
            const v = parseFloat(e.target.value) || 0;
            handleThresholdChange(industry, field, v);
          }}
          onBlur={() => commitField(industry, field)}
          className={inputClass}
          onClick={(e) => e.stopPropagation()}
        />
      ),
    [isReadOnly, handleThresholdChange, commitField]
  );

  // Custom header renderer with ColumnTooltip
  const renderHeader = useCallback((props: HeaderRenderProps<ThresholdIndustryData>) => {
    const { 
      column, 
      sortConfig, 
      handleSort, 
      getSortIcon, 
      getStickyPosition, 
      isColumnVisible,
      openFilterMenuColumn,
      setOpenFilterMenuColumn,
      hasActiveColumnFilter,
      getColumnUniqueValues,
      columnFilters,
      setColumnFilter,
      handleColumnSort,
      headerRefs,
    } = props;
    const metadata = getColumnMetadata('threshold-industry', column.key);
    const isSticky = column.sticky;
    const sortIcon = getSortIcon(column.key);
    const stickyClass = isSticky ? `sm:sticky sm:top-0 ${getStickyPosition(column.key)} z-50` : '';
    const isFilterMenuOpen = openFilterMenuColumn === column.key;
    const hasActiveFilter = hasActiveColumnFilter(column.key);
    const headerRef = headerRefs.current[column.key] || null;

    const handleFilterIconClick = (e: React.MouseEvent) => {
      e.stopPropagation();
      if (isFilterMenuOpen) {
        setOpenFilterMenuColumn(null);
      } else {
        setOpenFilterMenuColumn(column.key);
      }
    };

    const handleSortClick = (e?: React.MouseEvent) => {
      if (e) {
        e.stopPropagation();
      }
      if (!isFilterMenuOpen) {
        handleSort(column.key);
      }
    };

    const filterIcon = (
      <button
        onClick={handleFilterIconClick}
        className={`ml-2 p-1 rounded hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors ${
          hasActiveFilter ? 'text-blue-600 dark:text-blue-400' : 'text-gray-500 dark:text-gray-400'
        }`}
        aria-label={`Filter ${column.label}`}
        aria-expanded={isFilterMenuOpen}
        title="Filter och sortering"
        type="button"
      >
        <svg
          className="w-4 h-4"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M4 6h16M4 12h16M4 18h16"
          />
        </svg>
      </button>
    );
    
    if (!column.sortable) {
      const headerContent = (
        <th
          ref={(el) => {
            headerRefs.current[column.key] = el;
          }}
          className={`px-6 py-3 text-left text-xs font-bold text-gray-700 dark:text-gray-200 uppercase tracking-wider ${stickyClass} bg-gray-50 dark:bg-gray-900`}
          scope="col"
          role="columnheader"
        >
          <div className="flex items-center justify-between relative w-full">
            <div className="flex items-center flex-1">
              {metadata ? (
                <ColumnTooltip metadata={metadata}>
                  <div className="flex items-center space-x-1">
                    <span>{column.label}</span>
                  </div>
                </ColumnTooltip>
              ) : (
                <div className="flex items-center space-x-1">
                  <span>{column.label}</span>
                </div>
              )}
            </div>
            <div className="flex items-center relative" style={{ minWidth: '40px' }}>
              <div className="relative">
                {filterIcon}
                {isFilterMenuOpen && headerRef && (
                  <ColumnFilterMenu
                    columnKey={column.key}
                    columnLabel={column.label}
                    isOpen={isFilterMenuOpen}
                    onClose={() => setOpenFilterMenuColumn(null)}
                    filter={columnFilters[column.key]}
                    onFilterChange={(filter) => setColumnFilter(column.key, filter)}
                    sortConfig={sortConfig}
                    onSort={handleColumnSort}
                    uniqueValues={getColumnUniqueValues(column.key)}
                    triggerRef={{ current: headerRef }}
                  />
                )}
              </div>
            </div>
          </div>
        </th>
      );
      return <React.Fragment key={column.key}>{headerContent}</React.Fragment>;
    }

    const headerContent = (
      <th
        ref={(el) => {
          headerRefs.current[column.key] = el;
        }}
        onClick={handleSortClick}
        className={`px-6 py-3 text-left text-xs font-bold text-gray-700 dark:text-gray-200 uppercase tracking-wider cursor-pointer hover:bg-blue-100 dark:hover:bg-blue-900/30 hover:text-blue-700 dark:hover:text-blue-200 transition-all duration-200 ${stickyClass} bg-gray-50 dark:bg-gray-900`}
        scope="col"
        role="columnheader"
      >
        <div className="flex items-center justify-between relative w-full">
          <div className="flex items-center flex-1" onClick={handleSortClick}>
            {metadata ? (
              <ColumnTooltip metadata={metadata}>
                <div className="flex items-center space-x-1">
                  <span>{column.label}</span>
                  {sortIcon && <span className="text-gray-600 dark:text-gray-300">{sortIcon}</span>}
                </div>
              </ColumnTooltip>
            ) : (
              <div className="flex items-center space-x-1">
                <span>{column.label}</span>
                {sortIcon && <span className="text-gray-400 dark:text-gray-300">{sortIcon}</span>}
              </div>
            )}
          </div>
          <div className="flex items-center relative" style={{ minWidth: '40px' }}>
            <div className="relative">
              {filterIcon}
              {isFilterMenuOpen && headerRef && (
                <ColumnFilterMenu
                  columnKey={column.key}
                  columnLabel={column.label}
                  isOpen={isFilterMenuOpen}
                  onClose={() => setOpenFilterMenuColumn(null)}
                  filter={columnFilters[column.key]}
                  onFilterChange={(filter) => setColumnFilter(column.key, filter)}
                  sortConfig={sortConfig}
                  onSort={handleColumnSort}
                  uniqueValues={getColumnUniqueValues(column.key)}
                  triggerRef={{ current: headerRef }}
                />
              )}
            </div>
          </div>
        </div>
      </th>
    );
    return <React.Fragment key={column.key}>{headerContent}</React.Fragment>;
  }, []);

  // Render cell content with editable inputs
  const renderCell = useCallback((item: ThresholdIndustryData, column: ColumnDefinition<ThresholdIndustryData>, index: number, globalIndex: number) => {
    // Use getFieldValue for individual fields (supports draft)
    const irr = getFieldValue(item.industry, 'irr');
    const leverageF2Min = getFieldValue(item.industry, 'leverageF2Min');
    const leverageF2Max = getFieldValue(item.industry, 'leverageF2Max');
    const ro40Min = getFieldValue(item.industry, 'ro40Min');
    const ro40Max = getFieldValue(item.industry, 'ro40Max');
    const cashSdebtMin = getFieldValue(item.industry, 'cashSdebtMin');
    const cashSdebtMax = getFieldValue(item.industry, 'cashSdebtMax');
    const currentRatioMin = getFieldValue(item.industry, 'currentRatioMin');
    const currentRatioMax = getFieldValue(item.industry, 'currentRatioMax');
    const values = { irr, leverageF2Min, leverageF2Max, ro40Min, ro40Max, cashSdebtMin, cashSdebtMax, currentRatioMin, currentRatioMax };

    switch (column.key) {
      case 'antal':
        return globalIndex + 1;
      case 'industry':
        return <span className="font-medium">{item.industry}</span>;
      case 'irr':
        return renderThresholdField(item.industry, 'irr', values.irr, '0.1');
      case 'leverageF2Min':
        return renderThresholdField(item.industry, 'leverageF2Min', values.leverageF2Min, '0.1');
      case 'leverageF2Max':
        return renderThresholdField(item.industry, 'leverageF2Max', values.leverageF2Max, '0.1');
      case 'ro40Min':
        return renderThresholdField(item.industry, 'ro40Min', values.ro40Min, '0.01');
      case 'ro40Max':
        return renderThresholdField(item.industry, 'ro40Max', values.ro40Max, '0.01');
      case 'cashSdebtMin':
        return renderThresholdField(item.industry, 'cashSdebtMin', values.cashSdebtMin, '0.1');
      case 'cashSdebtMax':
        return renderThresholdField(item.industry, 'cashSdebtMax', values.cashSdebtMax, '0.1');
      case 'currentRatioMin':
        return renderThresholdField(item.industry, 'currentRatioMin', values.currentRatioMin, '0.1');
      case 'currentRatioMax':
        return renderThresholdField(item.industry, 'currentRatioMax', values.currentRatioMax, '0.1');
      default:
        return null;
    }
  }, [getFieldValue, renderThresholdField]);

  // Render mobile card
  const renderMobileCard = useCallback((item: ThresholdIndustryData, index: number, globalIndex: number, isExpanded: boolean, toggleExpand: () => void) => {
    const rowKey = `${item.industry}-${globalIndex}`;
    const rowBgClass = globalIndex % 2 === 0 
      ? 'bg-white dark:bg-gray-800' 
      : 'bg-gray-50 dark:bg-gray-800/50';
    
    // Use getFieldValue for individual fields (supports draft)
    const values = {
      irr: getFieldValue(item.industry, 'irr'),
      leverageF2Min: getFieldValue(item.industry, 'leverageF2Min'),
      leverageF2Max: getFieldValue(item.industry, 'leverageF2Max'),
      ro40Min: getFieldValue(item.industry, 'ro40Min'),
      ro40Max: getFieldValue(item.industry, 'ro40Max'),
      cashSdebtMin: getFieldValue(item.industry, 'cashSdebtMin'),
      cashSdebtMax: getFieldValue(item.industry, 'cashSdebtMax'),
      currentRatioMin: getFieldValue(item.industry, 'currentRatioMin'),
      currentRatioMax: getFieldValue(item.industry, 'currentRatioMax'),
    };

    return (
      <div
        key={rowKey}
        className={`${rowBgClass} rounded-lg border border-gray-300 dark:border-gray-600 shadow-sm transition-all duration-300 ease-in-out`}
      >
        {/* Primary Columns - Always Visible */}
        <div className="p-4 flex items-start justify-between gap-4">
          <div className="flex-1 space-y-3">
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">Antal</span>
              <span className="text-sm font-medium text-black dark:text-white">{globalIndex + 1}</span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">INDUSTRY</span>
              <span className="text-sm font-medium text-black dark:text-white text-right">{item.industry}</span>
            </div>
          </div>
          {/* Expand/Collapse Button */}
          <button
            onClick={toggleExpand}
            className="p-2 text-gray-600 dark:text-gray-300 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-all duration-200 flex-shrink-0"
            aria-label={isExpanded ? t('aria.collapseRow') : t('aria.expandRow')}
            aria-expanded={isExpanded}
          >
            <svg
              className={`w-5 h-5 transition-transform duration-200 ${isExpanded ? 'rotate-180' : ''}`}
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M19 9l-7 7-7-7"
              />
            </svg>
          </button>
        </div>

        {/* Secondary Columns - Expandable */}
        {isExpanded && (
          <div className="border-t border-gray-300 dark:border-gray-600 p-4 space-y-3 animate-fade-in">
            {Object.entries({
              irr: { label: 'IRR', step: '0.1' as const },
              leverageF2Min: { label: 'LEVERAGE F2 MIN', step: '0.1' as const },
              leverageF2Max: { label: 'LEVERAGE F2 MAX', step: '0.1' as const },
              ro40Min: { label: 'RO40 MIN', step: '0.01' as const },
              ro40Max: { label: 'RO40 MAX', step: '0.01' as const },
              cashSdebtMin: { label: 'Cash/SDebt MIN', step: '0.1' as const },
              cashSdebtMax: { label: 'Cash/SDebt MAX', step: '0.1' as const },
              currentRatioMin: { label: 'Current Ratio MIN', step: '0.1' as const },
              currentRatioMax: { label: 'Current Ratio MAX', step: '0.1' as const },
            }).map(([key, config]) => (
              <div key={key} className="flex items-center justify-between">
                <span className="text-xs font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider">{config.label}</span>
                {renderThresholdField(item.industry, key as keyof ThresholdValues, values[key as keyof ThresholdValues], config.step)}
              </div>
            ))}
          </div>
        )}
      </div>
    );
  }, [getFieldValue, renderThresholdField]);

  return (
    <BaseTable<ThresholdIndustryData>
      data={data}
      loading={loading}
      error={error}
      columns={THRESHOLD_INDUSTRY_COLUMNS}
      filters={thresholdFilters}
      tableId="threshold-industry"
      renderCell={renderCell}
      renderHeader={renderHeader}
      renderMobileCard={renderMobileCard}
      enableVirtualScroll={true}
      virtualScrollRowHeight={60}
      virtualScrollOverscan={10}
      enableMobileExpand={true}
      searchFields={['industry']}
      searchPlaceholder="Sök efter bransch..."
      defaultSortKey="industry"
      defaultSortDirection="asc"
      stickyColumns={['antal', 'industry']}
      ariaLabel="Threshold Industry"
      minTableWidth="800px"
      getRowKey={(item, index) => `${item.industry}-${index}`}
    />
  );
}

```

## `src/components/Toast.tsx`

```tsx
import { useEffect } from 'react';
import { useTranslation } from 'react-i18next';

export type ToastType = 'success' | 'error' | 'info' | 'warning';

export interface Toast {
  id: string;
  message: string;
  type: ToastType;
  duration?: number;
}

interface ToastProps {
  toast: Toast;
  onClose: (id: string) => void;
}

export default function ToastComponent({ toast, onClose }: ToastProps) {
  const { t } = useTranslation();

  useEffect(() => {
    if (toast.duration !== 0) {
      const timer = setTimeout(() => {
        onClose(toast.id);
      }, toast.duration || 5000);

      return () => clearTimeout(timer);
    }
  }, [toast.id, toast.duration, onClose]);

  const getToastStyles = () => {
    const baseStyles = 'flex items-center justify-between p-4 rounded-lg shadow-lg border min-w-[300px] max-w-md transition-all duration-normal ease-in-out animate-fade-in-up animate-slide-in-right';
    
    switch (toast.type) {
      case 'success':
        return `${baseStyles} bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800 text-green-800 dark:text-green-200`;
      case 'error':
        return `${baseStyles} bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 text-red-800 dark:text-red-200`;
      case 'warning':
        return `${baseStyles} bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800 text-yellow-800 dark:text-yellow-200`;
      case 'info':
      default:
        return `${baseStyles} bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800 text-blue-800 dark:text-blue-200`;
    }
  };

  const getIcon = () => {
    switch (toast.type) {
      case 'success':
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
          </svg>
        );
      case 'error':
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        );
      case 'warning':
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
          </svg>
        );
      case 'info':
      default:
        return (
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        );
    }
  };

  return (
    <div className={getToastStyles()}>
      <div className="flex items-center space-x-3 flex-1">
        <div className="flex-shrink-0">
          {getIcon()}
        </div>
        <p className="text-sm font-medium flex-1">{toast.message}</p>
      </div>
      <button
        onClick={() => onClose(toast.id)}
        className="ml-4 flex-shrink-0 text-current opacity-70 hover:opacity-100 transition-opacity duration-200 hover:scale-110 active:scale-95 p-2 -m-2 min-h-[44px] min-w-[44px] touch-manipulation flex items-center justify-center"
        aria-label={t('toast.close', 'Stäng')}
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </div>
  );
}


```

## `src/components/ToastContainer.tsx`

```tsx
import { Toast } from './Toast';
import ToastComponent from './Toast';

interface ToastContainerProps {
  toasts: Toast[];
  onClose: (id: string) => void;
}

export default function ToastContainer({ toasts, onClose }: ToastContainerProps) {
  if (toasts.length === 0) {
    return null;
  }

  return (
    <div 
      className="fixed top-20 right-4 z-50 flex flex-col gap-3 pointer-events-none"
      role="region"
      aria-live="polite"
      aria-atomic="false"
      aria-label="Notifications"
    >
      {toasts.map((toast) => (
        <div key={toast.id} className="pointer-events-auto">
          <ToastComponent toast={toast} onClose={onClose} />
        </div>
      ))}
    </div>
  );
}


```

## `src/components/ui/Badge.stories.tsx`

```tsx
import type { Meta, StoryObj } from '@storybook/react';
import { Badge } from './Badge';

const meta: Meta<typeof Badge> = {
  title: 'UI/Badge',
  component: Badge,
  tags: ['autodocs'],
  argTypes: {
    variant: {
      control: 'select',
      options: ['default', 'primary', 'success', 'error', 'warning', 'info'],
    },
    size: {
      control: 'select',
      options: ['sm', 'md', 'lg'],
    },
  },
};

export default meta;
type Story = StoryObj<typeof Badge>;

export const Default: Story = {
  args: {
    children: 'Badge',
  },
};

export const Primary: Story = {
  args: {
    children: 'Primary',
    variant: 'primary',
  },
};

export const Success: Story = {
  args: {
    children: 'Success',
    variant: 'success',
  },
};

export const Error: Story = {
  args: {
    children: 'Error',
    variant: 'error',
  },
};

export const Warning: Story = {
  args: {
    children: 'Warning',
    variant: 'warning',
  },
};

export const WithDot: Story = {
  args: {
    children: 'New',
    variant: 'primary',
    dot: true,
  },
};

export const Sizes: Story = {
  render: () => (
    <div className="flex items-center gap-4">
      <Badge size="sm">Small</Badge>
      <Badge size="md">Medium</Badge>
      <Badge size="lg">Large</Badge>
    </div>
  ),
};

```

## `src/components/ui/Badge.tsx`

```tsx
import React, { HTMLAttributes } from 'react';

export interface BadgeProps extends HTMLAttributes<HTMLSpanElement> {
  variant?: 'default' | 'primary' | 'success' | 'error' | 'warning' | 'info';
  size?: 'sm' | 'md' | 'lg';
  dot?: boolean;
}

export const Badge: React.FC<BadgeProps> = ({
  variant = 'default',
  size = 'md',
  dot = false,
  className = '',
  children,
  ...props
}) => {
  const baseStyles = 'inline-flex items-center font-medium rounded-full';

  const variantStyles = {
    default:
      'bg-secondary-100 text-secondary-800 dark:bg-secondary-800 dark:text-secondary-200',
    primary:
      'bg-primary-100 text-primary-800 dark:bg-primary-900 dark:text-primary-200',
    success:
      'bg-success-100 text-success-800 dark:bg-success-900 dark:text-success-200',
    error: 'bg-error-100 text-error-800 dark:bg-error-900 dark:text-error-200',
    warning:
      'bg-warning-100 text-warning-800 dark:bg-warning-900 dark:text-warning-200',
    info: 'bg-info-100 text-info-800 dark:bg-info-900 dark:text-info-200',
  };

  const sizeStyles = {
    sm: 'px-2 py-0.5 text-xs',
    md: 'px-2.5 py-0.5 text-sm',
    lg: 'px-3 py-1 text-base',
  };

  const dotSizeStyles = {
    sm: 'w-1.5 h-1.5',
    md: 'w-2 h-2',
    lg: 'w-2.5 h-2.5',
  };

  const combinedClassName = `${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${className}`;

  return (
    <span className={combinedClassName} {...props}>
      {dot && (
        <span
          className={`${dotSizeStyles[size]} rounded-full mr-1.5 ${
            variant === 'default'
              ? 'bg-secondary-400 dark:bg-secondary-500'
              : variant === 'primary'
              ? 'bg-primary-400 dark:bg-primary-500'
              : variant === 'success'
              ? 'bg-success-400 dark:bg-success-500'
              : variant === 'error'
              ? 'bg-error-400 dark:bg-error-500'
              : variant === 'warning'
              ? 'bg-warning-400 dark:bg-warning-500'
              : 'bg-info-400 dark:bg-info-500'
          }`}
        />
      )}
      {children}
    </span>
  );
};

export default Badge;

```

## `src/components/ui/Button.stories.tsx`

```tsx
import type { Meta, StoryObj } from '@storybook/react';
import Button from './Button';

const meta: Meta<typeof Button> = {
  title: 'UI/Button',
  component: Button,
  tags: ['autodocs'],
  argTypes: {
    variant: {
      control: 'select',
      options: ['primary', 'secondary', 'outline', 'ghost', 'danger'],
    },
    size: {
      control: 'select',
      options: ['sm', 'md', 'lg'],
    },
    isLoading: {
      control: 'boolean',
    },
    disabled: {
      control: 'boolean',
    },
    fullWidth: {
      control: 'boolean',
    },
  },
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Primary: Story = {
  args: {
    children: 'Button',
    variant: 'primary',
    size: 'md',
  },
};

export const Secondary: Story = {
  args: {
    children: 'Button',
    variant: 'secondary',
    size: 'md',
  },
};

export const Outline: Story = {
  args: {
    children: 'Button',
    variant: 'outline',
    size: 'md',
  },
};

export const Ghost: Story = {
  args: {
    children: 'Button',
    variant: 'ghost',
    size: 'md',
  },
};

export const Danger: Story = {
  args: {
    children: 'Button',
    variant: 'danger',
    size: 'md',
  },
};

export const Small: Story = {
  args: {
    children: 'Small Button',
    size: 'sm',
  },
};

export const Large: Story = {
  args: {
    children: 'Large Button',
    size: 'lg',
  },
};

export const Loading: Story = {
  args: {
    children: 'Loading...',
    isLoading: true,
  },
};

export const Disabled: Story = {
  args: {
    children: 'Disabled',
    disabled: true,
  },
};

export const WithIcons: Story = {
  args: {
    children: 'Button',
    leftIcon: (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
      </svg>
    ),
    rightIcon: (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
      </svg>
    ),
  },
};

export const FullWidth: Story = {
  args: {
    children: 'Full Width Button',
    fullWidth: true,
  },
};

```

## `src/components/ui/Button.tsx`

```tsx
import React, { ButtonHTMLAttributes, forwardRef } from 'react';
import { Spinner } from './Spinner';

export interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  isLoading?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  fullWidth?: boolean;
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      variant = 'primary',
      size = 'md',
      isLoading = false,
      leftIcon,
      rightIcon,
      fullWidth = false,
      className = '',
      disabled,
      children,
      ...props
    },
    ref
  ) => {
    const baseStyles =
      'inline-flex items-center justify-center font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-base hover:scale-[1.02] active:scale-[0.98] touch-manipulation disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100 disabled:active:scale-100';

    const variantStyles = {
      primary:
        'bg-primary-600 text-white hover:bg-primary-700 active:bg-primary-800 focus:ring-primary-500 dark:bg-primary-500 dark:hover:bg-primary-600 dark:active:bg-primary-700',
      secondary:
        'bg-secondary-600 text-white hover:bg-secondary-700 active:bg-secondary-800 focus:ring-secondary-500 dark:bg-secondary-500 dark:hover:bg-secondary-600 dark:active:bg-secondary-700',
      outline:
        'border-2 border-primary-600 text-primary-600 hover:bg-primary-50 active:bg-primary-100 focus:ring-primary-500 dark:border-primary-400 dark:text-primary-400 dark:hover:bg-primary-900/20 dark:active:bg-primary-900/30',
      ghost:
        'text-primary-600 hover:bg-primary-50 active:bg-primary-100 focus:ring-primary-500 dark:text-primary-400 dark:hover:bg-primary-900/20 dark:active:bg-primary-900/30',
      danger:
        'bg-error-600 text-white hover:bg-error-700 active:bg-error-800 focus:ring-error-500 dark:bg-error-500 dark:hover:bg-error-600 dark:active:bg-error-700',
    };

    const sizeStyles = {
      sm: 'px-3 py-1.5 text-sm min-h-[36px]',
      md: 'px-4 py-2 text-base min-h-[44px]',
      lg: 'px-6 py-3 text-lg min-h-[52px]',
    };

    const widthStyles = fullWidth ? 'w-full' : '';

    const combinedClassName = `${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${widthStyles} ${className}`;

    return (
      <button
        ref={ref}
        className={combinedClassName}
        disabled={disabled || isLoading}
        {...props}
      >
        {isLoading && (
          <span className="mr-2">
            <Spinner size={size === 'sm' ? 'sm' : 'md'} />
          </span>
        )}
        {!isLoading && leftIcon && <span className="mr-2">{leftIcon}</span>}
        {children}
        {!isLoading && rightIcon && <span className="ml-2">{rightIcon}</span>}
      </button>
    );
  }
);

Button.displayName = 'Button';

export default Button;

```

## `src/components/ui/Card.stories.tsx`

```tsx
import type { Meta, StoryObj } from '@storybook/react';
import { Card, CardHeader, CardContent, CardFooter } from './Card';
import Button from './Button';

const meta: Meta<typeof Card> = {
  title: 'UI/Card',
  component: Card,
  tags: ['autodocs'],
};

export default meta;
type Story = StoryObj<typeof Card>;

export const Default: Story = {
  args: {
    children: 'Card content',
  },
};

export const Outlined: Story = {
  args: {
    variant: 'outlined',
    children: 'Outlined card',
  },
};

export const Elevated: Story = {
  args: {
    variant: 'elevated',
    children: 'Elevated card',
  },
};

export const WithHeader: Story = {
  render: () => (
    <Card>
      <CardHeader title="Card Title" subtitle="Card subtitle" />
      <CardContent>Card content goes here</CardContent>
    </Card>
  ),
};

export const Complete: Story = {
  render: () => (
    <Card>
      <CardHeader
        title="Complete Card"
        subtitle="This is a complete card example"
        action={<Button size="sm">Action</Button>}
      />
      <CardContent>
        <p>This is the main content of the card.</p>
      </CardContent>
      <CardFooter>
        <Button variant="outline" size="sm">
          Cancel
        </Button>
        <Button size="sm">Save</Button>
      </CardFooter>
    </Card>
  ),
};

```

## `src/components/ui/Card.tsx`

```tsx
import React, { HTMLAttributes } from 'react';

export interface CardProps extends HTMLAttributes<HTMLDivElement> {
  variant?: 'default' | 'outlined' | 'elevated';
  padding?: 'none' | 'sm' | 'md' | 'lg';
}

export const Card: React.FC<CardProps> = ({
  variant = 'default',
  padding = 'md',
  className = '',
  children,
  ...props
}) => {
  const baseStyles = 'rounded-lg transition-all duration-base';

  const variantStyles = {
    default: 'bg-white dark:bg-gray-800',
    outlined: 'bg-white dark:bg-gray-800 border border-secondary-300 dark:border-secondary-600',
    elevated: 'bg-white dark:bg-gray-800 shadow-md',
  };

  const paddingStyles = {
    none: '',
    sm: 'p-3',
    md: 'p-4',
    lg: 'p-6',
  };

  const combinedClassName = `${baseStyles} ${variantStyles[variant]} ${paddingStyles[padding]} ${className}`;

  return (
    <div className={combinedClassName} {...props}>
      {children}
    </div>
  );
};

export interface CardHeaderProps extends HTMLAttributes<HTMLDivElement> {
  title?: string;
  subtitle?: string;
  action?: React.ReactNode;
}

export const CardHeader: React.FC<CardHeaderProps> = ({
  title,
  subtitle,
  action,
  className = '',
  children,
  ...props
}) => {
  return (
    <div className={`mb-4 ${className}`} {...props}>
      {(title || subtitle || action) && (
        <div className="flex items-start justify-between">
          <div>
            {title && (
              <h3 className="text-lg font-semibold text-black dark:text-white">
                {title}
              </h3>
            )}
            {subtitle && (
              <p className="mt-1 text-sm text-secondary-600 dark:text-secondary-400">
                {subtitle}
              </p>
            )}
          </div>
          {action && <div>{action}</div>}
        </div>
      )}
      {children}
    </div>
  );
};

export interface CardContentProps extends HTMLAttributes<HTMLDivElement> {}

export const CardContent: React.FC<CardContentProps> = ({
  className = '',
  children,
  ...props
}) => {
  return (
    <div className={className} {...props}>
      {children}
    </div>
  );
};

export interface CardFooterProps extends HTMLAttributes<HTMLDivElement> {}

export const CardFooter: React.FC<CardFooterProps> = ({
  className = '',
  children,
  ...props
}) => {
  return (
    <div className={`mt-4 ${className}`} {...props}>
      {children}
    </div>
  );
};

export default Card;

```

## `src/components/ui/Checkbox.tsx`

```tsx
import React, { InputHTMLAttributes, forwardRef } from 'react';

export interface CheckboxProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'type'> {
  label?: string;
  error?: string;
  helperText?: string;
}

const Checkbox = forwardRef<HTMLInputElement, CheckboxProps>(
  (
    { label, error, helperText, className = '', id, ...props },
    ref
  ) => {
    const checkboxId = id || `checkbox-${Math.random().toString(36).substr(2, 9)}`;

    return (
      <div className={className}>
        <div className="flex items-start">
          <div className="flex items-center h-5">
            <input
              ref={ref}
              id={checkboxId}
              type="checkbox"
              className="w-4 h-4 text-primary-600 border-secondary-300 rounded focus:ring-primary-500 focus:ring-2 transition-all duration-base disabled:opacity-50 disabled:cursor-not-allowed dark:border-secondary-600 dark:bg-gray-800"
              aria-invalid={error ? 'true' : 'false'}
              aria-describedby={
                error
                  ? `${checkboxId}-error`
                  : helperText
                  ? `${checkboxId}-helper`
                  : undefined
              }
              {...props}
            />
          </div>
          {label && (
            <div className="ml-3 text-sm">
              <label
                htmlFor={checkboxId}
                className="font-medium text-gray-700 dark:text-gray-300 cursor-pointer"
              >
                {label}
                {props.required && (
                  <span className="text-error-500 ml-1" aria-label="required">
                    *
                  </span>
                )}
              </label>
            </div>
          )}
        </div>
        {error && (
          <p
            id={`${checkboxId}-error`}
            className="mt-1.5 text-sm text-error-600 dark:text-error-400"
            role="alert"
          >
            {error}
          </p>
        )}
        {helperText && !error && (
          <p
            id={`${checkboxId}-helper`}
            className="mt-1.5 text-sm text-secondary-500 dark:text-secondary-400"
          >
            {helperText}
          </p>
        )}
      </div>
    );
  }
);

Checkbox.displayName = 'Checkbox';

export default Checkbox;

```

## `src/components/ui/index.ts`

```typescript
export { default as Button } from './Button';
export type { ButtonProps } from './Button';

export { default as Input } from './Input';
export type { InputProps } from './Input';

export { default as Select } from './Select';
export type { SelectProps, SelectOption } from './Select';

export { default as Checkbox } from './Checkbox';
export type { CheckboxProps } from './Checkbox';

export { default as Radio, RadioGroup } from './Radio';
export type { RadioProps, RadioGroupProps } from './Radio';

export { Card, CardHeader, CardContent, CardFooter } from './Card';
export type { CardProps, CardHeaderProps, CardContentProps, CardFooterProps } from './Card';

export { Badge } from './Badge';
export type { BadgeProps } from './Badge';

export { Spinner } from './Spinner';
export type { SpinnerProps } from './Spinner';

```

## `src/components/ui/Input.stories.tsx`

```tsx
import type { Meta, StoryObj } from '@storybook/react';
import Input from './Input';

const meta: Meta<typeof Input> = {
  title: 'UI/Input',
  component: Input,
  tags: ['autodocs'],
  argTypes: {
    type: {
      control: 'select',
      options: ['text', 'email', 'password', 'number', 'tel', 'url'],
    },
  },
};

export default meta;
type Story = StoryObj<typeof Input>;

export const Default: Story = {
  args: {
    placeholder: 'Enter text...',
  },
};

export const WithLabel: Story = {
  args: {
    label: 'Email',
    type: 'email',
    placeholder: 'Enter your email',
  },
};

export const WithError: Story = {
  args: {
    label: 'Email',
    type: 'email',
    placeholder: 'Enter your email',
    error: 'Please enter a valid email address',
  },
};

export const WithHelperText: Story = {
  args: {
    label: 'Password',
    type: 'password',
    placeholder: 'Enter your password',
    helperText: 'Must be at least 8 characters',
  },
};

export const WithIcons: Story = {
  args: {
    label: 'Search',
    placeholder: 'Search...',
    leftIcon: (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
      </svg>
    ),
  },
};

export const Required: Story = {
  args: {
    label: 'Username',
    required: true,
    placeholder: 'Enter username',
  },
};

export const Disabled: Story = {
  args: {
    label: 'Disabled Input',
    value: 'Cannot edit',
    disabled: true,
  },
};

```

## `src/components/ui/Input.tsx`

```tsx
import React, { InputHTMLAttributes, forwardRef } from 'react';

export interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
  helperText?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  fullWidth?: boolean;
}

const Input = forwardRef<HTMLInputElement, InputProps>(
  (
    {
      label,
      error,
      helperText,
      leftIcon,
      rightIcon,
      fullWidth = false,
      className = '',
      id,
      ...props
    },
    ref
  ) => {
    const inputId = id || `input-${Math.random().toString(36).substr(2, 9)}`;

    const baseStyles =
      'block w-full rounded-md border transition-all duration-base focus:outline-none focus:ring-2 focus:ring-offset-0 focus:scale-[1.01] disabled:opacity-50 disabled:cursor-not-allowed disabled:focus:scale-100';

    const stateStyles = error
      ? 'border-error-500 focus:border-error-500 focus:ring-error-500 dark:border-error-400 dark:focus:border-error-400'
      : 'border-secondary-300 focus:border-primary-500 focus:ring-primary-500 dark:border-secondary-600 dark:focus:border-primary-400';

    const paddingStyles = leftIcon
      ? 'pl-10 pr-4'
      : rightIcon
      ? 'pl-4 pr-10'
      : leftIcon && rightIcon
      ? 'pl-10 pr-10'
      : 'px-4';

    const inputStyles = `${baseStyles} ${stateStyles} ${paddingStyles} py-2 text-base text-black dark:text-white bg-white dark:bg-gray-800 placeholder:text-secondary-400 dark:placeholder:text-secondary-500 ${className}`;

    const widthStyles = fullWidth ? 'w-full' : '';

    return (
      <div className={widthStyles}>
        {label && (
          <label
            htmlFor={inputId}
            className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1.5"
          >
            {label}
            {props.required && (
              <span className="text-error-500 ml-1" aria-label="required">
                *
              </span>
            )}
          </label>
        )}
        <div className="relative">
          {leftIcon && (
            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none text-secondary-400 dark:text-secondary-500">
              {leftIcon}
            </div>
          )}
          <input
            ref={ref}
            id={inputId}
            className={inputStyles}
            aria-invalid={error ? 'true' : 'false'}
            aria-describedby={
              error ? `${inputId}-error` : helperText ? `${inputId}-helper` : undefined
            }
            {...props}
          />
          {rightIcon && (
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none text-secondary-400 dark:text-secondary-500">
              {rightIcon}
            </div>
          )}
        </div>
        {error && (
          <p
            id={`${inputId}-error`}
            className="mt-1.5 text-sm text-error-600 dark:text-error-400"
            role="alert"
          >
            {error}
          </p>
        )}
        {helperText && !error && (
          <p
            id={`${inputId}-helper`}
            className="mt-1.5 text-sm text-secondary-500 dark:text-secondary-400"
          >
            {helperText}
          </p>
        )}
      </div>
    );
  }
);

Input.displayName = 'Input';

export default Input;

```

## `src/components/ui/Radio.tsx`

```tsx
import React, { InputHTMLAttributes, forwardRef } from 'react';

export interface RadioProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'type'> {
  label?: string;
  error?: string;
  helperText?: string;
}

const Radio = forwardRef<HTMLInputElement, RadioProps>(
  ({ label, error, helperText, className = '', id, ...props }, ref) => {
    const radioId = id || `radio-${Math.random().toString(36).substr(2, 9)}`;

    return (
      <div className={className}>
        <div className="flex items-start">
          <div className="flex items-center h-5">
            <input
              ref={ref}
              id={radioId}
              type="radio"
              className="w-4 h-4 text-primary-600 border-secondary-300 focus:ring-primary-500 focus:ring-2 transition-all duration-base disabled:opacity-50 disabled:cursor-not-allowed dark:border-secondary-600 dark:bg-gray-800"
              aria-invalid={error ? 'true' : 'false'}
              aria-describedby={
                error
                  ? `${radioId}-error`
                  : helperText
                  ? `${radioId}-helper`
                  : undefined
              }
              {...props}
            />
          </div>
          {label && (
            <div className="ml-3 text-sm">
              <label
                htmlFor={radioId}
                className="font-medium text-gray-700 dark:text-gray-300 cursor-pointer"
              >
                {label}
                {props.required && (
                  <span className="text-error-500 ml-1" aria-label="required">
                    *
                  </span>
                )}
              </label>
            </div>
          )}
        </div>
        {error && (
          <p
            id={`${radioId}-error`}
            className="mt-1.5 text-sm text-error-600 dark:text-error-400"
            role="alert"
          >
            {error}
          </p>
        )}
        {helperText && !error && (
          <p
            id={`${radioId}-helper`}
            className="mt-1.5 text-sm text-secondary-500 dark:text-secondary-400"
          >
            {helperText}
          </p>
        )}
      </div>
    );
  }
);

Radio.displayName = 'Radio';

export interface RadioGroupProps {
  label?: string;
  error?: string;
  helperText?: string;
  children: React.ReactNode;
  className?: string;
}

export const RadioGroup: React.FC<RadioGroupProps> = ({
  label,
  error,
  helperText,
  children,
  className = '',
}) => {
  const groupId = `radio-group-${Math.random().toString(36).substr(2, 9)}`;

  return (
    <div className={className} role="radiogroup" aria-labelledby={label ? `${groupId}-label` : undefined}>
      {label && (
        <label
          id={`${groupId}-label`}
          className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
        >
          {label}
        </label>
      )}
      <div className="space-y-2">{children}</div>
      {error && (
        <p className="mt-1.5 text-sm text-error-600 dark:text-error-400" role="alert">
          {error}
        </p>
      )}
      {helperText && !error && (
        <p className="mt-1.5 text-sm text-secondary-500 dark:text-secondary-400">
          {helperText}
        </p>
      )}
    </div>
  );
};

export default Radio;

```

## `src/components/ui/Select.stories.tsx`

```tsx
import type { Meta, StoryObj } from '@storybook/react';
import Select from './Select';

const meta: Meta<typeof Select> = {
  title: 'UI/Select',
  component: Select,
  tags: ['autodocs'],
};

export default meta;
type Story = StoryObj<typeof Select>;

const options = [
  { value: '1', label: 'Option 1' },
  { value: '2', label: 'Option 2' },
  { value: '3', label: 'Option 3' },
  { value: '4', label: 'Option 4' },
];

export const Default: Story = {
  args: {
    options,
    placeholder: 'Select an option',
  },
};

export const WithLabel: Story = {
  args: {
    label: 'Choose an option',
    options,
    placeholder: 'Select...',
  },
};

export const WithError: Story = {
  args: {
    label: 'Choose an option',
    options,
    error: 'Please select an option',
  },
};

export const Required: Story = {
  args: {
    label: 'Country',
    options: [
      { value: 'se', label: 'Sweden' },
      { value: 'no', label: 'Norway' },
      { value: 'dk', label: 'Denmark' },
    ],
    required: true,
  },
};

```

## `src/components/ui/Select.tsx`

```tsx
import React, { SelectHTMLAttributes, forwardRef } from 'react';

export interface SelectOption {
  value: string | number;
  label: string;
  disabled?: boolean;
}

export interface SelectProps extends SelectHTMLAttributes<HTMLSelectElement> {
  label?: string;
  error?: string;
  helperText?: string;
  options: SelectOption[];
  placeholder?: string;
  fullWidth?: boolean;
}

const Select = forwardRef<HTMLSelectElement, SelectProps>(
  (
    {
      label,
      error,
      helperText,
      options,
      placeholder,
      fullWidth = false,
      className = '',
      id,
      ...props
    },
    ref
  ) => {
    const selectId = id || `select-${Math.random().toString(36).substr(2, 9)}`;

    const baseStyles =
      'block w-full rounded-md border transition-all duration-base focus:outline-none focus:ring-2 focus:ring-offset-0 disabled:opacity-50 disabled:cursor-not-allowed appearance-none bg-white dark:bg-gray-800';

    const stateStyles = error
      ? 'border-error-500 focus:border-error-500 focus:ring-error-500 dark:border-error-400 dark:focus:border-error-400'
      : 'border-secondary-300 focus:border-primary-500 focus:ring-primary-500 dark:border-secondary-600 dark:focus:border-primary-400';

    const selectStyles = `${baseStyles} ${stateStyles} px-4 py-2 text-base text-black dark:text-white ${className}`;

    const widthStyles = fullWidth ? 'w-full' : '';

    return (
      <div className={widthStyles}>
        {label && (
          <label
            htmlFor={selectId}
            className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1.5"
          >
            {label}
            {props.required && (
              <span className="text-error-500 ml-1" aria-label="required">
                *
              </span>
            )}
          </label>
        )}
        <div className="relative">
          <select
            ref={ref}
            id={selectId}
            className={selectStyles}
            aria-invalid={error ? 'true' : 'false'}
            aria-describedby={
              error ? `${selectId}-error` : helperText ? `${selectId}-helper` : undefined
            }
            {...props}
          >
            {placeholder && (
              <option value="" disabled>
                {placeholder}
              </option>
            )}
            {options.map((option) => (
              <option
                key={option.value}
                value={option.value}
                disabled={option.disabled}
              >
                {option.label}
              </option>
            ))}
          </select>
          <div className="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
            <svg
              className="w-5 h-5 text-secondary-400 dark:text-secondary-500"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M19 9l-7 7-7-7"
              />
            </svg>
          </div>
        </div>
        {error && (
          <p
            id={`${selectId}-error`}
            className="mt-1.5 text-sm text-error-600 dark:text-error-400"
            role="alert"
          >
            {error}
          </p>
        )}
        {helperText && !error && (
          <p
            id={`${selectId}-helper`}
            className="mt-1.5 text-sm text-secondary-500 dark:text-secondary-400"
          >
            {helperText}
          </p>
        )}
      </div>
    );
  }
);

Select.displayName = 'Select';

export default Select;

```

## `src/components/ui/Spinner.stories.tsx`

```tsx
import type { Meta, StoryObj } from '@storybook/react';
import { Spinner } from './Spinner';

const meta: Meta<typeof Spinner> = {
  title: 'UI/Spinner',
  component: Spinner,
  tags: ['autodocs'],
};

export default meta;
type Story = StoryObj<typeof Spinner>;

export const Default: Story = {
  args: {},
};

export const Small: Story = {
  args: {
    size: 'sm',
  },
};

export const Large: Story = {
  args: {
    size: 'lg',
  },
};

export const Sizes: Story = {
  render: () => (
    <div className="flex items-center gap-8">
      <Spinner size="sm" />
      <Spinner size="md" />
      <Spinner size="lg" />
    </div>
  ),
};

```

## `src/components/ui/Spinner.tsx`

```tsx
import React from 'react';

export interface SpinnerProps {
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

export const Spinner: React.FC<SpinnerProps> = ({
  size = 'md',
  className = '',
}) => {
  const sizeStyles = {
    sm: 'w-4 h-4 border-2',
    md: 'w-5 h-5 border-2',
    lg: 'w-8 h-8 border-3',
  };

  return (
    <div
      className={`${sizeStyles[size]} border-current border-t-transparent rounded-full animate-spin ${className}`}
      role="status"
      aria-label="Loading"
    >
      <span className="sr-only">Loading...</span>
    </div>
  );
};

export default Spinner;

```

## `src/components/UserProfile.tsx`

```tsx
import { useState, useCallback, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useToast } from '../contexts/ToastContext';
import { useAuth } from '../contexts/AuthContext';
import { useUserRole } from '../hooks/useUserRole';
import { useNotifications } from '../contexts/NotificationContext';
import { httpsCallable } from 'firebase/functions';
import { functions } from '../config/firebase';
import { logger } from '../utils/logger';
import {
  getUserPreferences,
  updateNotificationPreferences,
  NotificationPreferences,
  DEFAULT_NOTIFICATION_PREFERENCES,
} from '../services/userPreferencesService';
import Checkbox from './ui/Checkbox';

interface UserProfileProps {
  onClose?: () => void;
}

export default function UserProfile({ onClose }: UserProfileProps) {
  const { t } = useTranslation();
  const { showToast } = useToast();
  const { currentUser, logout } = useAuth();
  const { userRole, isAdmin } = useUserRole();
  const { requestPermission, permissionState } = useNotifications();
  const [showDeregisterConfirm, setShowDeregisterConfirm] = useState(false);
  const [deregistering, setDeregistering] = useState(false);
  const [notificationPrefs, setNotificationPrefs] = useState<NotificationPreferences>(DEFAULT_NOTIFICATION_PREFERENCES);
  const [loadingPrefs, setLoadingPrefs] = useState(true);
  const [savingPrefs, setSavingPrefs] = useState(false);

  const handleDeregister = useCallback(async () => {
    if (!currentUser || deregistering) return;

    try {
      setDeregistering(true);
      // Call Cloud Function to delete user account
      const deleteUserAccount = httpsCallable(functions, 'deleteUserAccount');
      await deleteUserAccount({ userId: currentUser.uid });
      
      showToast(t('profile.deregisterSuccess') || 'Ditt konto har tagits bort', 'success');
      // Log out user after account deletion
      await logout();
    } catch (error: unknown) {
      logger.error('Error deregistering', error, { component: 'UserProfile', operation: 'deregister' });
      const errorMessage = error instanceof Error 
        ? (error.message || (error as { code?: string }).code || t('profile.deregisterError') || 'Kunde inte ta bort kontot')
        : (t('profile.deregisterError') || 'Kunde inte ta bort kontot');
      showToast(errorMessage, 'error');
    } finally {
      setDeregistering(false);
      setShowDeregisterConfirm(false);
    }
  }, [currentUser, deregistering, showToast, t, logout]);

  // Load user preferences
  useEffect(() => {
    const loadPreferences = async () => {
      if (!currentUser) return;

      try {
        setLoadingPrefs(true);
        const prefs = await getUserPreferences(currentUser.uid);
        if (prefs) {
          setNotificationPrefs(prefs.notifications);
        }
      } catch (error) {
        logger.error('Error loading preferences', error, { component: 'UserProfile' });
      } finally {
        setLoadingPrefs(false);
      }
    };

    loadPreferences();
  }, [currentUser]);

  const handleNotificationPrefChange = useCallback(
    async (key: keyof NotificationPreferences, value: boolean | string) => {
      if (!currentUser || savingPrefs) return;

      const updatedPrefs = {
        ...notificationPrefs,
        [key]: value,
      };

      setNotificationPrefs(updatedPrefs);

      try {
        setSavingPrefs(true);
        await updateNotificationPreferences(currentUser.uid, updatedPrefs);
      } catch (error) {
        logger.error('Error saving notification preferences', error, { component: 'UserProfile' });
        showToast(t('profile.preferencesSaveError', 'Failed to save preferences'), 'error');
        // Revert on error
        const prefs = await getUserPreferences(currentUser.uid);
        if (prefs) {
          setNotificationPrefs(prefs.notifications);
        }
      } finally {
        setSavingPrefs(false);
      }
    },
    [currentUser, notificationPrefs, savingPrefs, showToast, t]
  );

  const handleRequestDesktopPermission = useCallback(async () => {
    const granted = await requestPermission();
    if (granted) {
      handleNotificationPrefChange('desktopNotifications', true);
    }
  }, [requestPermission, handleNotificationPrefChange]);

  const getRoleLabel = (): string => {
    if (isAdmin) return t('roles.admin');
    if (userRole === 'viewer') return t('roles.viewer');
    return t('roles.noRole');
  };

  return (
    <div className="p-6 bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-2xl mx-auto">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-2xl font-bold text-black dark:text-white">
          {t('profile.title')}
        </h2>
        {onClose && (
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
          >
            {t('common.close') || 'Stäng'}
          </button>
        )}
      </div>

      <div className="space-y-6">
        {/* Current Role */}
        <div className="border-b border-gray-300 dark:border-gray-600 pb-4">
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            {t('profile.currentRole')}
          </label>
          <div className="flex items-center gap-3">
            <span className="px-4 py-2 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded-md font-medium">
              {getRoleLabel()}
            </span>
          </div>
        </div>

        {/* User Email */}
        {currentUser?.email && (
          <div className="border-b border-gray-300 dark:border-gray-600 pb-4">
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              {t('auth.email')}
            </label>
            <p className="text-black dark:text-white">{currentUser.email}</p>
          </div>
        )}

        {/* Notification Preferences */}
        <div className="border-t border-gray-300 dark:border-gray-600 pt-4">
          <h3 className="text-lg font-semibold text-black dark:text-white mb-4">
            {t('profile.notificationPreferences', 'Notification Preferences')}
          </h3>
          
          {loadingPrefs ? (
            <p className="text-sm text-gray-600 dark:text-gray-400">{t('common.loading', 'Loading...')}</p>
          ) : (
            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <div>
                  <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                    {t('profile.notificationsEnabled', 'Enable Notifications')}
                  </label>
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    {t('profile.notificationsEnabledDesc', 'Enable all notifications')}
                  </p>
                </div>
                <Checkbox
                  checked={notificationPrefs.enabled}
                  onChange={(e) => handleNotificationPrefChange('enabled', e.target.checked)}
                  disabled={savingPrefs}
                />
              </div>

              {notificationPrefs.enabled && (
                <>
                  <div className="flex items-center justify-between">
                    <div>
                      <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                        {t('profile.desktopNotifications', 'Desktop Notifications')}
                      </label>
                      <p className="text-xs text-gray-500 dark:text-gray-400">
                        {t('profile.desktopNotificationsDesc', 'Show browser notifications')}
                      </p>
                    </div>
                    <div className="flex items-center gap-2">
                      {permissionState !== 'granted' && (
                        <button
                          onClick={handleRequestDesktopPermission}
                          className="px-3 py-1 text-xs font-medium text-blue-600 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-md transition-colors"
                        >
                          {t('profile.enableDesktop', 'Enable')}
                        </button>
                      )}
                      <Checkbox
                        checked={notificationPrefs.desktopNotifications && permissionState === 'granted'}
                        onChange={(e) => handleNotificationPrefChange('desktopNotifications', e.target.checked)}
                        disabled={savingPrefs || permissionState !== 'granted'}
                      />
                    </div>
                  </div>

                  <div className="pl-4 border-l-2 border-gray-200 dark:border-gray-700 space-y-3">
                    <div className="flex items-center justify-between">
                      <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                        {t('profile.dataUpdates', 'Data Updates')}
                      </label>
                      <Checkbox
                        checked={notificationPrefs.dataUpdates}
                        onChange={(checked) => handleNotificationPrefChange('dataUpdates', checked)}
                        disabled={savingPrefs}
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                        {t('profile.errors', 'Errors')}
                      </label>
                      <Checkbox
                        checked={notificationPrefs.errors}
                        onChange={(checked) => handleNotificationPrefChange('errors', checked)}
                        disabled={savingPrefs}
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                        {t('profile.success', 'Success Messages')}
                      </label>
                      <Checkbox
                        checked={notificationPrefs.success}
                        onChange={(checked) => handleNotificationPrefChange('success', checked)}
                        disabled={savingPrefs}
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                        {t('profile.warnings', 'Warnings')}
                      </label>
                      <Checkbox
                        checked={notificationPrefs.warning}
                        onChange={(checked) => handleNotificationPrefChange('warning', checked)}
                        disabled={savingPrefs}
                      />
                    </div>
                  </div>

                  <div className="flex items-center justify-between">
                    <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                      {t('profile.soundEnabled', 'Sound Notifications')}
                    </label>
                    <Checkbox
                      checked={notificationPrefs.soundEnabled}
                      onChange={(e) => handleNotificationPrefChange('soundEnabled', e.target.checked)}
                      disabled={savingPrefs}
                    />
                  </div>

                  <div className="flex items-center justify-between">
                    <div>
                      <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                        {t('profile.doNotDisturb', 'Do Not Disturb')}
                      </label>
                      <p className="text-xs text-gray-500 dark:text-gray-400">
                        {t('profile.doNotDisturbDesc', 'Silence notifications during specified hours')}
                      </p>
                    </div>
                    <Checkbox
                      checked={notificationPrefs.doNotDisturb}
                      onChange={(e) => handleNotificationPrefChange('doNotDisturb', e.target.checked)}
                      disabled={savingPrefs}
                    />
                  </div>
                </>
              )}
            </div>
          )}
        </div>

        {/* Deregister Section */}
        <div className="border-t border-gray-300 dark:border-gray-600 pt-4">
            <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4 mb-4">
              <h3 className="text-sm font-medium text-red-800 dark:text-red-200 mb-2">
                {t('profile.deregisterTitle') || 'Avregistrera konto'}
              </h3>
              <p className="text-xs text-red-700 dark:text-red-300 mb-3">
                {t('profile.deregisterWarning') || 'Om du avregistrerar ditt konto kommer det att tas bort permanent. Denna åtgärd kan inte ångras.'}
              </p>
              <button
                onClick={() => setShowDeregisterConfirm(true)}
                disabled={deregistering}
                className="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                {t('profile.deregister') || 'Avregistrera mig'}
              </button>
            </div>
          </div>
        </div>

      {/* Deregister Confirmation Dialog */}
      {showDeregisterConfirm && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 max-w-md mx-4">
            <h3 className="text-lg font-bold text-black dark:text-white mb-4">
              {t('profile.confirmDeregister') || 'Bekräfta avregistrering'}
            </h3>
            <p className="text-gray-600 dark:text-gray-300 mb-6">
              {t('profile.confirmDeregisterMessage') || 'Är du säker på att du vill avregistrera ditt konto? Ditt konto och all data kommer att tas bort permanent. Denna åtgärd kan inte ångras.'}
            </p>
            <div className="flex gap-3 justify-end">
              <button
                onClick={() => setShowDeregisterConfirm(false)}
                disabled={deregistering}
                className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                {t('common.cancel') || 'Avbryt'}
              </button>
              <button
                onClick={handleDeregister}
                disabled={deregistering}
                className="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                {deregistering 
                  ? (t('profile.deregistering') || 'Tar bort...')
                  : (t('profile.confirmDeregisterButton') || 'Ja, avregistrera')
                }
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

```

## `src/components/UserProfileModal.tsx`

```tsx
import { useEffect } from 'react';
import UserProfile from './UserProfile';

interface UserProfileModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function UserProfileModal({ isOpen, onClose }: UserProfileModalProps) {
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 dark:bg-opacity-70 animate-fade-in transition-opacity duration-300 p-4 overflow-y-auto"
      onClick={onClose}
    >
      <div
        className="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto my-8 animate-scale-in transition-all duration-300"
        onClick={(e) => e.stopPropagation()}
      >
        <UserProfile onClose={onClose} />
      </div>
    </div>
  );
}

```

## `src/components/views/AdminView.tsx`

```tsx
import { useState, useEffect, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { httpsCallable } from 'firebase/functions';
import { functions } from '../../config/firebase';
import { useAuth } from '../../contexts/AuthContext';
import { useToast } from '../../contexts/ToastContext';
import { logger } from '../../utils/logger';

const EXTRA_TABLE_VIEW_IDS = [
  'score-board',
  'entry-exit-benjamin-graham',
  'fundamental-pe-industry',
  'threshold-industry',
] as const;

export interface AdminUser {
  uid: string;
  email: string;
  role: string | null;
  allowedViews: string[];
}

export default function AdminView() {
  const { t } = useTranslation();
  const { currentUser } = useAuth();
  const { showToast } = useToast();
  const [users, setUsers] = useState<AdminUser[]>([]);
  const [loading, setLoading] = useState(true);
  const [savingUid, setSavingUid] = useState<string | null>(null);
  const [selectedViews, setSelectedViews] = useState<Record<string, string[]>>({});

  const loadUsers = useCallback(async () => {
    try {
      setLoading(true);
      const listUsers = httpsCallable<unknown, { users: AdminUser[] }>(functions, 'listUsers');
      const result = await listUsers({});
      const data = result.data;
      if (data?.users) {
        setUsers(data.users);
        const initial: Record<string, string[]> = {};
        data.users.forEach((u) => {
          initial[u.uid] = Array.isArray(u.allowedViews) ? [...u.allowedViews] : [];
        });
        setSelectedViews(initial);
      }
    } catch (error: unknown) {
      const message =
        error && typeof error === 'object' && 'message' in error && typeof (error as { message: unknown }).message === 'string'
          ? (error as { message: string }).message
          : t('admin.error') || 'Failed to load users';
      logger.error('Error loading users', error, { component: 'AdminView', operation: 'loadUsers' });
      showToast(message, 'error');
    } finally {
      setLoading(false);
    }
  }, [showToast, t]);

  useEffect(() => {
    loadUsers();
  }, [loadUsers]);

  const handleToggleView = (uid: string, viewId: string) => {
    setSelectedViews((prev) => {
      const current = prev[uid] ?? [];
      const next = current.includes(viewId)
        ? current.filter((id) => id !== viewId)
        : [...current, viewId];
      return { ...prev, [uid]: next };
    });
  };

  const handleSave = async (uid: string) => {
    if (uid === currentUser?.uid) return;
    try {
      setSavingUid(uid);
      const setUserRole = httpsCallable(functions, 'setUserRole');
      await setUserRole({ userId: uid, role: 'viewer', allowedViews: selectedViews[uid] ?? [] });
      showToast(t('admin.saved'), 'success');
      await loadUsers();
    } catch (error) {
      logger.error('Error saving user role', error, { component: 'AdminView', operation: 'handleSave', uid });
      showToast(t('admin.error'), 'error');
    } finally {
      setSavingUid(null);
    }
  };

  const getViewLabel = (viewId: string) => {
    const key = viewId === 'score-board' ? 'scoreBoard' : viewId === 'entry-exit-benjamin-graham' ? 'benjaminGraham' : viewId === 'fundamental-pe-industry' ? 'peIndustry' : viewId === 'threshold-industry' ? 'thresholdIndustry' : viewId;
    return t(`navigation.${key}`, viewId);
  };

  if (loading) {
    return (
      <div className="h-full bg-gray-100 dark:bg-gray-900 py-8 px-4 flex items-center justify-center">
        <p className="text-gray-600 dark:text-gray-400">{t('admin.loading')}</p>
      </div>
    );
  }

  return (
    <div className="h-full bg-gray-100 dark:bg-gray-900 py-6 px-4 sm:px-6 lg:px-8 overflow-y-auto">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-2xl sm:text-3xl font-bold text-black dark:text-white mb-2">
          {t('admin.title')}
        </h1>
        <p className="text-sm text-gray-600 dark:text-gray-400 mb-6">
          {t('admin.description')}
        </p>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow overflow-hidden">
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
              <thead className="bg-gray-50 dark:bg-gray-700">
                <tr>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-700 dark:text-gray-300 uppercase">
                    {t('admin.email')}
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-700 dark:text-gray-300 uppercase">
                    {t('admin.role')}
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-700 dark:text-gray-300 uppercase">
                    {t('admin.extraTables')}
                  </th>
                  <th className="px-4 py-3 text-right text-xs font-medium text-gray-700 dark:text-gray-300 uppercase">
                    {t('admin.save')}
                  </th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                {users.map((user) => {
                  const isSelf = user.uid === currentUser?.uid;
                  const isViewer = user.role === 'viewer' || user.role === null;
                  const canEdit = isViewer && !isSelf;
                  const views = selectedViews[user.uid] ?? [];
                  return (
                    <tr key={user.uid} className="bg-white dark:bg-gray-800">
                      <td className="px-4 py-3 text-sm text-gray-900 dark:text-white">
                        {user.email || user.uid}
                      </td>
                      <td className="px-4 py-3 text-sm text-gray-700 dark:text-gray-300">
                        {user.role === 'admin' ? t('roles.admin') : t('roles.viewer')}
                      </td>
                      <td className="px-4 py-3">
                        {canEdit ? (
                          <div className="flex flex-wrap gap-3">
                            {EXTRA_TABLE_VIEW_IDS.map((viewId) => (
                              <label
                                key={viewId}
                                className="inline-flex items-center gap-2 text-sm text-gray-700 dark:text-gray-300 cursor-pointer"
                              >
                                <input
                                  type="checkbox"
                                  checked={views.includes(viewId)}
                                  onChange={() => handleToggleView(user.uid, viewId)}
                                  className="rounded border-gray-300 dark:border-gray-600 text-blue-600 focus:ring-blue-500"
                                />
                                {getViewLabel(viewId)}
                              </label>
                            ))}
                          </div>
                        ) : (
                          <span className="text-sm text-gray-500 dark:text-gray-400">
                            {isSelf ? '—' : user.role === 'admin' ? '—' : views.length ? views.map(getViewLabel).join(', ') : '—'}
                          </span>
                        )}
                      </td>
                      <td className="px-4 py-3 text-right">
                        {canEdit && (
                          <button
                            type="button"
                            onClick={() => handleSave(user.uid)}
                            disabled={savingUid === user.uid}
                            className="px-3 py-1.5 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                          >
                            {savingUid === user.uid ? '…' : t('admin.save')}
                          </button>
                        )}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  );
}

```

## `src/components/views/EntryExitView.tsx`

```tsx
import { lazy, Suspense } from 'react';
import { useTranslation } from 'react-i18next';
import { ViewId } from '../../types/navigation';
import { useBenjaminGrahamData } from '../../hooks/useBenjaminGrahamData';
import { TableSkeleton } from '../SkeletonLoader';
import { EntryExitProvider } from '../../contexts/EntryExitContext';

// Lazy load table components
const EntryExitTable = lazy(() => import('../EntryExitTable'));

interface EntryExitViewProps {
  viewId: ViewId;
}

export default function EntryExitView({ viewId }: EntryExitViewProps) {
  const { t } = useTranslation();
  const isBenjaminGraham = viewId === 'entry-exit-benjamin-graham';
  const { data: benjaminGrahamData, loading: benjaminGrahamLoading, error: benjaminGrahamError } = useBenjaminGrahamData();
  
  const getViewTitle = () => {
    const titles: Partial<Record<ViewId, string>> = {
      'entry-exit-benjamin-graham': t('navigation.benjaminGraham'),
      'entry-exit-irr1': t('navigation.irr1'),
      'entry-exit-iv-fcf': t('navigation.ivFcf'),
    };
    return titles[viewId] || t('navigation.entryExit');
  };

  if (isBenjaminGraham) {
    // Benjamin Graham view only depends on benjaminGrahamData, so no progressive loading needed
    return (
      <EntryExitProvider>
        <div className="h-full bg-gray-100 dark:bg-gray-900 py-4 sm:py-6 lg:py-8 px-3 sm:px-4 lg:px-6 flex flex-col transition-all duration-300 ease-in-out">
          <div className="w-full flex flex-col flex-1 min-h-0">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6 sm:mb-8 flex-shrink-0 gap-4">
              <div>
                <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-black dark:text-white mb-1 tracking-tight">{getViewTitle()}</h1>
                <p className="text-xs sm:text-sm text-gray-500 dark:text-gray-400 font-medium">Entry och exit-punkter för aktier</p>
              </div>
            </div>
            <div className="flex-1 min-h-0 transition-all duration-300 ease-in-out">
              {!benjaminGrahamLoading && benjaminGrahamData.length > 0 ? (
                <Suspense fallback={<TableSkeleton rows={10} columns={5} hasStickyColumns={true} />}>
                  <EntryExitTable data={benjaminGrahamData} loading={false} error={benjaminGrahamError} />
                </Suspense>
              ) : benjaminGrahamLoading ? (
                <TableSkeleton rows={10} columns={5} hasStickyColumns={true} />
              ) : benjaminGrahamError ? (
                <div className="text-red-600 dark:text-red-400 p-4">{benjaminGrahamError}</div>
              ) : null}
            </div>
          </div>
        </div>
      </EntryExitProvider>
    );
  }

  return (
    <div className="min-h-screen bg-gray-100 dark:bg-gray-900 py-8 px-4">
      <div className="max-w-7xl mx-auto">
        <h1 className="text-3xl font-bold text-black dark:text-white mb-6">{getViewTitle()}</h1>
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-8 transition-all duration-300 ease-in-out hover:shadow-lg hover:scale-[1.01]">
          <p className="text-gray-600 dark:text-gray-400">{t('common.underConstruction')}</p>
          <p className="text-sm text-gray-500 dark:text-gray-500 mt-2">{t('common.viewId')} {viewId}</p>
        </div>
      </div>
    </div>
  );
}

```

## `src/components/views/FundamentalView.tsx`

```tsx
import { useTranslation } from 'react-i18next';
import { lazy, Suspense } from 'react';
import { ViewId } from '../../types/navigation';
import { usePEIndustryData } from '../../hooks/usePEIndustryData';
import { TableSkeleton } from '../SkeletonLoader';

// Lazy load table component
const PEIndustryTable = lazy(() => import('../PEIndustryTable'));

interface FundamentalViewProps {
  viewId: ViewId;
}

export default function FundamentalView({ viewId }: FundamentalViewProps) {
  const { t } = useTranslation();
  const isPEIndustry = viewId === 'fundamental-pe-industry';
  const { data, loading, error } = usePEIndustryData();
  
  const getViewTitle = () => {
    const titles: Partial<Record<ViewId, string>> = {
      'fundamental-pe-industry': t('navigation.peIndustry'),
      'fundamental-current-ratio': t('navigation.currentRatio'),
      'fundamental-cash-sdebt': t('navigation.cashSdebt'),
      'fundamental-ro40-cy': t('navigation.ro40Cy'),
      'fundamental-ro40-f1': t('navigation.ro40F1'),
      'fundamental-ro40-f2': t('navigation.ro40F2'),
    };
    return titles[viewId] || t('navigation.fundamental');
  };

  if (isPEIndustry) {
    return (
      <div className="h-full bg-gray-100 dark:bg-gray-900 py-4 sm:py-6 lg:py-8 px-3 sm:px-4 lg:px-6 flex flex-col transition-all duration-300 ease-in-out">
        <div className="w-full flex flex-col flex-1 min-h-0">
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6 sm:mb-8 flex-shrink-0 gap-4">
            <div>
              <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-black dark:text-white mb-1 tracking-tight">{getViewTitle()}</h1>
              <p className="text-xs sm:text-sm text-gray-500 dark:text-gray-400 font-medium">Fundamentala analyser per bransch</p>
            </div>
          </div>
          <div className="flex-1 min-h-0 transition-all duration-300 ease-in-out">
            <Suspense fallback={<TableSkeleton rows={10} columns={5} hasStickyColumns={true} />}>
              <PEIndustryTable data={data} loading={loading} error={error} />
            </Suspense>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-100 dark:bg-gray-900 py-8 px-4">
      <div className="max-w-7xl mx-auto">
        <h1 className="text-3xl font-bold text-black dark:text-white mb-6">{getViewTitle()}</h1>
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-8 transition-all duration-300 ease-in-out hover:shadow-lg hover:scale-[1.01]">
          <p className="text-gray-600 dark:text-gray-400">{t('common.underConstruction')}</p>
          <p className="text-sm text-gray-500 dark:text-gray-500 mt-2">{t('common.viewId')} {viewId}</p>
        </div>
      </div>
    </div>
  );
}

```

## `src/components/views/PersonalPortfolioColumns.tsx`

```tsx
/**
 * Column definitions and table item type for Personal Portfolio view.
 * Refactored out of PersonalPortfolioView (refactor-only, no behavior change).
 */

import type { ColumnDefinition } from '../BaseTable';
import type { PortfolioItem } from '../../types/portfolio';

export interface PortfolioTableItem extends PortfolioItem {
  rowNumber?: number;
  currentPrice?: number | null;
  currentPriceUSD?: number | null;
  invested?: number | null;
  marketValue?: number | null;
  profitLoss?: number | null;
  profitLossPercent?: number | null;
  marketWeight?: number | null;
}

export const PORTFOLIO_COLUMNS: ColumnDefinition<PortfolioTableItem>[] = [
  { key: 'rowNumber', label: 'Antal', required: true, sticky: true, sortable: false },
  { key: 'companyName', label: 'Company Name', required: true, sticky: true, sortable: true },
  { key: 'ticker', label: 'Ticker', required: true, sticky: true, sortable: true },
  { key: 'currency', label: 'Currency', defaultVisible: false, sticky: true, sortable: true, align: 'center' },
  { key: 'currentPrice', label: 'Current Price', defaultVisible: false, sortable: true, align: 'center' },
  { key: 'currentPriceUSD', label: 'Current Price($)', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'quantity', label: 'Quantity', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'average', label: 'Average ($)', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'invested', label: 'Invested ($)', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'marketValue', label: 'Market Value ($)', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'profitLoss', label: 'P/L ($)', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'profitLossPercent', label: 'P/L%', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'marketWeight', label: 'Market Weight', defaultVisible: true, sortable: true, align: 'center' },
  { key: 'actions', label: 'Actions', required: false, sortable: false, align: 'right' },
];

```

## `src/components/views/PersonalPortfolioExpandedRow.tsx`

```tsx
/**
 * Expanded row content for Personal Portfolio: per-broker breakdown table.
 * Refactored out of PersonalPortfolioView (refactor-only, no behavior change).
 */

import React from 'react';
import { useTranslation } from 'react-i18next';
import type { PortfolioPosition } from '../../types/portfolio';
import type { PortfolioTableItem } from './PersonalPortfolioColumns';

interface PersonalPortfolioExpandedRowProps {
  item: PortfolioTableItem;
  formatCurrency: (amount: number, currency: string) => string;
}

export function PersonalPortfolioExpandedRow({
  item,
  formatCurrency,
}: PersonalPortfolioExpandedRowProps) {
  const { t } = useTranslation();
  const positions: PortfolioPosition[] =
    item.positions && item.positions.length > 0 ? item.positions : [];

  return (
    <div className="px-6 py-4">
      <table className="w-full text-sm text-left text-gray-700 dark:text-gray-300">
        <thead>
          <tr className="border-b border-gray-200 dark:border-gray-600">
            <th className="py-2 pr-4 font-semibold">{t('portfolio.broker', 'Broker')}</th>
            <th className="py-2 pr-4 font-semibold">{t('portfolio.quantity', 'Antal')}</th>
            <th className="py-2 pr-4 font-semibold">{t('portfolio.investedAmount', 'Investerat belopp')}</th>
            <th className="py-2 font-semibold">{t('portfolio.investmentCurrency', 'Valuta')}</th>
          </tr>
        </thead>
        <tbody>
          {positions.map((pos, i) => (
            <tr
              key={`${pos.broker}-${i}`}
              className="border-b border-gray-100 dark:border-gray-700 last:border-0"
            >
              <td className="py-2 pr-4">{pos.broker}</td>
              <td className="py-2 pr-4">{pos.quantity}</td>
              <td className="py-2 pr-4">
                {pos.investedAmount != null && pos.investedAmount > 0
                  ? formatCurrency(pos.investedAmount, pos.investmentCurrency || 'USD')
                  : '-'}
              </td>
              <td className="py-2">{pos.investmentCurrency || 'USD'}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

```

## `src/components/views/PersonalPortfolioView.tsx`

```tsx
import React, { useState, useEffect, useRef, useCallback, useMemo, Fragment } from 'react';
import { useTranslation } from 'react-i18next';
import { useAuth } from '../../contexts/AuthContext';
import { useBenjaminGrahamData } from '../../hooks/useBenjaminGrahamData';
import { EntryExitProvider, useEntryExitValues } from '../../contexts/EntryExitContext';
import { getUserPortfolio, addPortfolioItem, removePortfolioItem, updatePortfolioItem, getCurrencyForStock, computeAveragePriceUSD } from '../../services/personalPortfolioService';
import { getExchangeRate, refreshCurrencyRatesCache } from '../../services/currencyService';
import { PortfolioItem, PortfolioPosition } from '../../types/portfolio';
import { usePortfolioSearch, StockSearchResult } from '../../hooks/usePortfolioSearch';
import { useDebounce } from '../../hooks/useDebounce';
import { TableSkeleton } from '../SkeletonLoader';
import ProgressIndicator from '../ProgressIndicator';
import BaseTable, { ColumnDefinition, HeaderRenderProps } from '../BaseTable';
import ColumnFilterMenu from '../ColumnFilterMenu';
import ColumnTooltip from '../ColumnTooltip';
import { getColumnMetadata } from '../../config/tableMetadata';
import { DEFAULT_BROKERS, BROKER_OTHER } from '../../config/brokers';
import { PORTFOLIO_COLUMNS, type PortfolioTableItem } from './PersonalPortfolioColumns';
import { PersonalPortfolioExpandedRow } from './PersonalPortfolioExpandedRow';

// Inner component that uses EntryExitContext
function PersonalPortfolioViewInner() {
  const { t } = useTranslation();
  const { currentUser } = useAuth();
  const { data: benjaminGrahamData, loading: benjaminGrahamLoading } = useBenjaminGrahamData();
  const { entryExitValues, initializeFromData } = useEntryExitValues();
  const [portfolio, setPortfolio] = useState<PortfolioItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedStock, setSelectedStock] = useState<StockSearchResult | null>(null);
  const [quantity, setQuantity] = useState('');
  const [showSearchResults, setShowSearchResults] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const [investedAmount, setInvestedAmount] = useState('');
  const [investmentCurrency, setInvestmentCurrency] = useState<string>('USD');
  const [brokerSelect, setBrokerSelect] = useState<string>(DEFAULT_BROKERS[0]);
  const [brokerCustom, setBrokerCustom] = useState('');
  const [editingItem, setEditingItem] = useState<PortfolioTableItem | null>(null);
  const [editPositions, setEditPositions] = useState<PortfolioPosition[]>([]);
  const [editAveragePreview, setEditAveragePreview] = useState<number | null>(null);
  const [editAverageLoading, setEditAverageLoading] = useState(false);
  const [exchangeRatesByCurrency, setExchangeRatesByCurrency] = useState<Record<string, number>>({ USD: 1 });
  const searchRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const headerRefs = useRef<{ [key: string]: HTMLElement | null }>({});

  const debouncedSearchQuery = useDebounce(searchQuery, 300);
  const searchResults = usePortfolioSearch(benjaminGrahamData || [], debouncedSearchQuery);

  // Initialize EntryExitContext with benjaminGrahamData
  useEffect(() => {
    if (benjaminGrahamData && benjaminGrahamData.length > 0) {
      const entryExitData = benjaminGrahamData.map((item) => ({
        companyName: item.companyName,
        ticker: item.ticker,
        currency: 'USD',
        entry1: 0,
        entry2: 0,
        exit1: 0,
        exit2: 0,
        dateOfUpdate: null,
      }));
      initializeFromData(entryExitData);
    }
  }, [benjaminGrahamData, initializeFromData]);

  const loadPortfolio = useCallback(async () => {
    if (!currentUser) return;

    try {
      setLoading(true);
      setError(null);
      const userPortfolio = await getUserPortfolio(currentUser.uid);
      setPortfolio(userPortfolio?.portfolio || []);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load portfolio';
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  }, [currentUser]);

  useEffect(() => {
    if (!currentUser) {
      setLoading(false);
      return;
    }

    loadPortfolio();
  }, [currentUser, loadPortfolio]);

  // Periodic update of exchange rates and average recalculation from positions (every 15 minutes)
  useEffect(() => {
    if (!portfolio.length || !currentUser) return;

    const updateInterval = setInterval(async () => {
      try {
        await refreshCurrencyRatesCache();
      } catch {
        // ignore
      }

      const itemsWithPositions = portfolio.filter((item) => item.positions && item.positions.length > 0);
      for (const item of itemsWithPositions) {
        try {
          const newAveragePrice = await computeAveragePriceUSD(item.positions!);
          const currentAvg = item.averagePrice ?? null;
          const changed =
            newAveragePrice === null
              ? currentAvg !== null
              : currentAvg === null || Math.abs(currentAvg - newAveragePrice) > 0.01;
          if (changed) {
            await updatePortfolioItem(currentUser.uid, item.ticker, { positions: item.positions });
          }
        } catch {
          // ignore errors for individual items
        }
      }

      await loadPortfolio();
    }, 15 * 60 * 1000);

    return () => clearInterval(updateInterval);
  }, [portfolio, currentUser, loadPortfolio]);

  // Close search results when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (searchRef.current && !searchRef.current.contains(event.target as Node)) {
        setShowSearchResults(false);
      }
    }

    if (showSearchResults) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [showSearchResults]);

  // Fetch exchange rates for non-USD currencies used in portfolio
  useEffect(() => {
    if (!portfolio.length) {
      setExchangeRatesByCurrency({ USD: 1 });
      return;
    }
    const currencies = new Set<string>();
    for (const item of portfolio) {
      const ccy = getCurrencyForStock(item.ticker, item.companyName, entryExitValues);
      if (ccy !== 'USD') currencies.add(ccy);
    }
    if (currencies.size === 0) {
      setExchangeRatesByCurrency({ USD: 1 });
      return;
    }
    let cancelled = false;
    (async () => {
      const rates: Record<string, number> = { USD: 1 };
      for (const ccy of currencies) {
        if (cancelled) return;
        const rate = await getExchangeRate(ccy, 'USD');
        if (rate !== null) rates[ccy] = rate;
      }
      if (!cancelled) setExchangeRatesByCurrency(rates);
    })();
    return () => {
      cancelled = true;
    };
  }, [portfolio, entryExitValues]);

  // Fetch any missing exchange rates (e.g. when entryExitValues loads after portfolio)
  useEffect(() => {
    if (!portfolio.length) return;
    const missing: string[] = [];
    for (const item of portfolio) {
      const ccy = getCurrencyForStock(item.ticker, item.companyName, entryExitValues);
      if (ccy !== 'USD' && exchangeRatesByCurrency[ccy] == null && !missing.includes(ccy)) {
        missing.push(ccy);
      }
    }
    if (missing.length === 0) return;
    let cancelled = false;
    (async () => {
      const next: Record<string, number> = { ...exchangeRatesByCurrency };
      for (const ccy of missing) {
        if (cancelled) return;
        const rate = await getExchangeRate(ccy, 'USD');
        if (rate !== null) next[ccy] = rate;
      }
      if (!cancelled) setExchangeRatesByCurrency(next);
    })();
    return () => {
      cancelled = true;
    };
  }, [portfolio, entryExitValues, exchangeRatesByCurrency]);

  // Show search results when query changes
  useEffect(() => {
    if (debouncedSearchQuery.trim().length >= 2 && searchResults.length > 0) {
      setShowSearchResults(true);
      setSelectedIndex(-1);
    } else {
      setShowSearchResults(false);
    }
  }, [debouncedSearchQuery, searchResults]);

  // Auto-calculate aggregate average (USD) from editPositions
  useEffect(() => {
    if (!editingItem || editPositions.length === 0) {
      setEditAveragePreview(null);
      return;
    }

    let cancelled = false;
    setEditAverageLoading(true);
    computeAveragePriceUSD(editPositions).then((avg) => {
      if (!cancelled) {
        setEditAveragePreview(avg);
      }
    }).finally(() => {
      if (!cancelled) setEditAverageLoading(false);
    });
    return () => { cancelled = true; };
  }, [editingItem, editPositions]);

  // Handle keyboard navigation in search results
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (!showSearchResults || searchResults.length === 0) return;

    if (e.key === 'ArrowDown') {
      e.preventDefault();
      setSelectedIndex((prev) => (prev < searchResults.length - 1 ? prev + 1 : prev));
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      setSelectedIndex((prev) => (prev > 0 ? prev - 1 : -1));
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (selectedIndex >= 0 && selectedIndex < searchResults.length) {
        handleSelectStock(searchResults[selectedIndex]);
      }
    } else if (e.key === 'Escape') {
      setShowSearchResults(false);
      setSelectedIndex(-1);
    }
  };

  const handleSelectStock = (stock: StockSearchResult) => {
    setSelectedStock(stock);
    setSearchQuery(`${stock.ticker} - ${stock.companyName}`);
    setShowSearchResults(false);
    setSelectedIndex(-1);
    // Focus quantity input
    setTimeout(() => {
      const quantityInput = document.getElementById('quantity-input');
      quantityInput?.focus();
    }, 100);
  };

  const handleAddItem = async () => {
    if (!currentUser || !selectedStock || !quantity.trim()) return;

    const quantityNum = parseFloat(quantity);
    if (isNaN(quantityNum) || quantityNum < 0) {
      setError(t('portfolio.quantityInvalid', 'Ogiltigt antal'));
      return;
    }

    try {
      setError(null);
      const currency = getCurrencyForStock(
        selectedStock.ticker,
        selectedStock.companyName,
        entryExitValues
      );

      let calculatedAveragePrice: number | null = null;
      let investedAmountValue: number | null = null;
      let investmentCurrencyValue: string | null = null;

      if (investedAmount.trim()) {
        const investedAmountNum = parseFloat(investedAmount);
        if (!isNaN(investedAmountNum) && investedAmountNum > 0) {
          investedAmountValue = investedAmountNum;
          investmentCurrencyValue = investmentCurrency;
          const averagePerShare = investedAmountNum / quantityNum;
          if (investmentCurrency === 'USD') {
            calculatedAveragePrice = averagePerShare;
          } else {
            const exchangeRate = await getExchangeRate(investmentCurrency, 'USD');
            if (exchangeRate !== null) {
              calculatedAveragePrice = averagePerShare * exchangeRate;
            } else {
              calculatedAveragePrice = selectedStock.price;
              setError(t('portfolio.exchangeRateUnavailable', 'Valutakurs kunde inte hämtas. Använder nuvarande pris.'));
            }
          }
        }
      }

      if (calculatedAveragePrice === null) {
        if (currency === 'USD') {
          calculatedAveragePrice = selectedStock.price;
        } else if (selectedStock.price != null) {
          const rate = await getExchangeRate(currency, 'USD');
          if (rate !== null) {
            calculatedAveragePrice = selectedStock.price * rate;
          } else {
            calculatedAveragePrice = selectedStock.price;
            setError(t('portfolio.exchangeRateUnavailable', 'Valutakurs kunde inte hämtas. Använder nuvarande pris.'));
          }
        } else {
          calculatedAveragePrice = selectedStock.price;
        }
      }

      const brokerName = brokerSelect === BROKER_OTHER ? brokerCustom.trim() : brokerSelect;
      if (!brokerName) {
        setError(t('portfolio.brokerRequired', 'Ange broker eller välj från listan'));
        return;
      }

      const item: PortfolioItem = {
        ticker: selectedStock.ticker,
        companyName: selectedStock.companyName,
        quantity: quantityNum,
        currency,
        price: selectedStock.price,
        averagePrice: calculatedAveragePrice,
        investedAmount: investedAmountValue ?? undefined,
        investmentCurrency: investmentCurrencyValue ?? undefined,
        positions: [
          {
            broker: brokerName,
            quantity: quantityNum,
            investedAmount: investedAmountValue ?? undefined,
            investmentCurrency: investmentCurrencyValue ?? 'USD',
          },
        ],
      };

      await addPortfolioItem(currentUser.uid, item);
      await loadPortfolio();

      setSelectedStock(null);
      setSearchQuery('');
      setQuantity('');
      setInvestedAmount('');
      setInvestmentCurrency('USD');
      setBrokerSelect(DEFAULT_BROKERS[0]);
      setBrokerCustom('');
      setShowSearchResults(false);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to add item';
      setError(errorMessage);
    }
  };

  const handleRemoveItem = async (ticker: string) => {
    if (!currentUser) return;

    try {
      await removePortfolioItem(currentUser.uid, ticker);
      await loadPortfolio();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to remove item';
      setError(errorMessage);
    }
  };

  const handleUpdateItem = async () => {
    if (!currentUser || !editingItem) return;

    if (editPositions.length === 0) {
      setError(t('portfolio.atLeastOnePosition', 'Minst en position krävs'));
      return;
    }
    const invalid = editPositions.some((p) => typeof p.quantity !== 'number' || p.quantity < 0);
    if (invalid) {
      setError(t('portfolio.quantityInvalid', 'Ogiltigt antal'));
      return;
    }

    try {
      setError(null);
      await updatePortfolioItem(currentUser.uid, editingItem.ticker, { positions: editPositions });
      await loadPortfolio();
      setEditingItem(null);
      setEditPositions([]);
      setEditAveragePreview(null);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to update item';
      setError(errorMessage);
    }
  };

  const updateEditPosition = useCallback((index: number, updates: Partial<PortfolioPosition>) => {
    setEditPositions((prev) => prev.map((p, i) => (i === index ? { ...p, ...updates } : p)));
  }, []);

  const removeEditPosition = useCallback((index: number) => {
    setEditPositions((prev) => (prev.length <= 1 ? prev : prev.filter((_, i) => i !== index)));
  }, []);

  const addEditPosition = useCallback(() => {
    setEditPositions((prev) => [...prev, { broker: DEFAULT_BROKERS[0], quantity: 0, investedAmount: undefined, investmentCurrency: 'USD' }]);
  }, []);

  const formatPrice = (price: number | null): string => {
    if (price === null) return '-';
    return price.toFixed(2);
  };

  const formatCurrency = (value: number, currency: string): string => {
    return `${value.toFixed(2)} ${currency}`;
  };

  const formatUSD = (value: number | null | undefined): string => {
    if (value === null || value === undefined) return '-';
    return `$${value.toFixed(2)}`;
  };

  // Transform portfolio data and compute total market value (both in USD)
  // CURRENT PRICE: lookup from benjaminGrahamData (same source as Entry/Exit Price), fallback to stored item.price
  const { transformedPortfolio, totalMarketValue, totalInvested } = useMemo(() => {
    const bgData = benjaminGrahamData ?? [];
    const withUSD = portfolio.map((item, index) => {
      const match = bgData.find(
        (bg) => bg.ticker === item.ticker && bg.companyName === item.companyName
      );
      const currentPrice = match?.price ?? item.price;
      const quantity = item.quantity;
      const averagePrice = item.averagePrice;
      const currency = getCurrencyForStock(item.ticker, item.companyName, entryExitValues);
      let currentPriceUSD: number | null = null;
      if (currentPrice !== null && currentPrice !== undefined) {
        if (currency === 'USD') {
          currentPriceUSD = currentPrice;
        } else {
          const rate = exchangeRatesByCurrency[currency];
          if (rate != null) currentPriceUSD = currentPrice * rate;
        }
      }
      return {
        ...item,
        rowNumber: index + 1,
        currentPrice,
        currentPriceUSD,
        currency,
        quantity,
        averagePrice,
      };
    });
    const total = withUSD.reduce((sum, x) => {
      if (x.currentPriceUSD != null && x.quantity > 0) return sum + x.currentPriceUSD * x.quantity;
      return sum;
    }, 0);
    const transformed: PortfolioTableItem[] = withUSD.map((x) => {
      const invested =
        x.averagePrice != null && x.averagePrice !== undefined && x.quantity > 0
          ? x.averagePrice * x.quantity
          : null;
      const marketValue =
        x.currentPriceUSD != null && x.currentPriceUSD !== undefined && x.quantity > 0
          ? x.currentPriceUSD * x.quantity
          : null;
      const profitLoss = invested != null && marketValue != null ? marketValue - invested : null;
      const profitLossPercent =
        invested != null && invested !== 0 && profitLoss != null ? (profitLoss / invested) * 100 : null;
      // Market Weight (%) = this stock's market value / total portfolio market value
      const marketWeight = total > 0 && marketValue != null ? (marketValue / total) * 100 : null;
      return {
        ...x,
        invested,
        marketValue,
        profitLoss,
        profitLossPercent,
        marketWeight,
      };
    });
    const totalInvested = transformed.reduce((sum, x) => {
      if (x.invested != null && x.invested > 0) return sum + x.invested;
      return sum;
    }, 0);
    return { transformedPortfolio: transformed, totalMarketValue: total, totalInvested };
  }, [portfolio, benjaminGrahamData, entryExitValues, exchangeRatesByCurrency]);

  // Row key for expand; must match getRowKey passed to BaseTable
  const getRowKey = useCallback((item: PortfolioTableItem, index: number) => `${item.ticker}-${index}`, []);

  // Render cell content
  const renderCell = useCallback((
    item: PortfolioTableItem,
    column: ColumnDefinition<PortfolioTableItem>,
    index: number,
    globalIndex: number,
    expandedRows?: { [key: string]: boolean },
    toggleRow?: (rowKey: string) => void
  ) => {
    const rowKey = getRowKey(item, globalIndex);
    const isExpanded = expandedRows?.[rowKey] ?? false;

    // Get currency from entryExitValues in real-time
    const currency = getCurrencyForStock(
      item.ticker,
      item.companyName,
      entryExitValues
    );

    switch (column.key) {
      case 'rowNumber':
        return (
          <div className="flex items-center gap-2">
            <button
              type="button"
              onClick={(e) => {
                e.stopPropagation();
                e.preventDefault();
                toggleRow?.(rowKey);
              }}
              className="p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition-colors"
              aria-label={isExpanded ? t('aria.collapseRow', 'Fäll ihop rad') : t('aria.expandRow', 'Expandera rad')}
              aria-expanded={isExpanded}
              title={isExpanded ? t('aria.collapseRow', 'Fäll ihop') : t('aria.expandRow', 'Expandera')}
            >
              <svg
                className={`w-4 h-4 text-gray-600 dark:text-gray-400 transition-transform duration-200 ${isExpanded ? 'rotate-180' : ''}`}
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
              </svg>
            </button>
            <span>{globalIndex + 1}</span>
          </div>
        );
      case 'companyName':
        return <span className="font-medium">{item.companyName}</span>;
      case 'ticker':
        return <span className="text-gray-600 dark:text-gray-300">{item.ticker}</span>;
      case 'currency':
        return <span className="text-black dark:text-white">{currency}</span>;
      case 'currentPrice':
        return item.currentPrice !== null && item.currentPrice !== undefined 
          ? <span className="text-black dark:text-white">{formatPrice(item.currentPrice)}</span>
          : <span className="text-gray-500 dark:text-gray-400">-</span>;
      case 'currentPriceUSD':
        return item.currentPriceUSD !== null && item.currentPriceUSD !== undefined
          ? <span className="text-black dark:text-white">{formatUSD(item.currentPriceUSD)}</span>
          : <span className="text-gray-500 dark:text-gray-400">-</span>;
      case 'quantity':
        return <span className="text-black dark:text-white">{item.quantity}</span>;
      case 'average':
        return item.averagePrice !== null && item.averagePrice !== undefined
          ? <span className="text-black dark:text-white">{formatUSD(item.averagePrice)}</span>
          : <span className="text-gray-500 dark:text-gray-400">-</span>;
      case 'invested':
        return item.invested !== null && item.invested !== undefined
          ? <span className="text-black dark:text-white">{formatUSD(item.invested)}</span>
          : <span className="text-gray-500 dark:text-gray-400">-</span>;
      case 'marketValue':
        return item.marketValue !== null && item.marketValue !== undefined
          ? <span className="text-black dark:text-white">{formatUSD(item.marketValue)}</span>
          : <span className="text-gray-500 dark:text-gray-400">-</span>;
      case 'profitLoss':
        if (item.profitLoss === null || item.profitLoss === undefined) {
          return <span className="text-gray-500 dark:text-gray-400">-</span>;
        }
        const profitLossColor = item.profitLoss >= 0 
          ? 'text-green-600 dark:text-green-400' 
          : 'text-red-600 dark:text-red-400';
        return (
          <span className={profitLossColor}>
            {formatUSD(item.profitLoss)}
          </span>
        );
      case 'profitLossPercent':
        if (item.profitLossPercent === null || item.profitLossPercent === undefined) {
          return <span className="text-gray-500 dark:text-gray-400">-</span>;
        }
        const percentColor = item.profitLossPercent >= 0 
          ? 'text-green-600 dark:text-green-400' 
          : 'text-red-600 dark:text-red-400';
        return (
          <span className={percentColor}>
            {item.profitLossPercent.toFixed(2)}%
          </span>
        );
      case 'marketWeight':
        return item.marketWeight !== null && item.marketWeight !== undefined
          ? <span className="text-black dark:text-white">{item.marketWeight.toFixed(2)}%</span>
          : <span className="text-gray-500 dark:text-gray-400">-</span>;
      case 'actions':
        return (
          <div className="flex items-center gap-2 justify-end">
            <button
              onClick={() => {
                setEditingItem(item);
                const positions = item.positions && item.positions.length > 0
                  ? item.positions.map((p) => ({ ...p }))
                  : [{ broker: '—', quantity: item.quantity, investedAmount: item.investedAmount ?? undefined, investmentCurrency: item.investmentCurrency ?? 'USD' }];
                setEditPositions(positions);
              }}
              className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300 transition-colors min-h-[44px] min-w-[44px] touch-manipulation px-3 py-1 rounded"
              aria-label={t('portfolio.edit', 'Redigera')}
            >
              {t('portfolio.edit', 'Redigera')}
            </button>
            <button
              onClick={() => handleRemoveItem(item.ticker)}
              className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300 transition-colors min-h-[44px] min-w-[44px] touch-manipulation px-3 py-1 rounded"
              aria-label={t('portfolio.remove', 'Ta bort')}
            >
              {t('portfolio.remove', 'Ta bort')}
            </button>
          </div>
        );
      default:
        return null;
    }
  }, [entryExitValues, formatPrice, formatUSD, t, handleRemoveItem, getRowKey]);

  // Expanded row: per-broker breakdown (delegated to PersonalPortfolioExpandedRow)
  const renderExpandedRow = useCallback(
    (item: PortfolioTableItem) => (
      <PersonalPortfolioExpandedRow item={item} formatCurrency={formatCurrency} />
    ),
    [formatCurrency]
  );

  // Custom header renderer with ColumnFilterMenu
  const renderHeader = useCallback((props: HeaderRenderProps<PortfolioTableItem>) => {
    const { 
      column, 
      sortConfig, 
      handleSort, 
      getSortIcon, 
      getStickyPosition, 
      isColumnVisible,
      openFilterMenuColumn,
      setOpenFilterMenuColumn,
      hasActiveColumnFilter,
      getColumnUniqueValues,
      columnFilters,
      setColumnFilter,
      handleColumnSort,
      headerRefs,
    } = props;
    const metadata = getColumnMetadata('personal-portfolio', column.key);
    const isSticky = column.sticky;
    const isSorted = sortConfig.key === column.key;
    const sortIcon = getSortIcon(column.key);
    const stickyClass = isSticky ? `sm:sticky sm:top-0 ${getStickyPosition(column.key)} z-50` : '';
    const isFilterMenuOpen = openFilterMenuColumn === column.key;
    const hasActiveFilter = hasActiveColumnFilter(column.key);
    const headerRef = headerRefs.current[column.key] || null;

    const handleFilterIconClick = (e: React.MouseEvent) => {
      e.stopPropagation();
      if (isFilterMenuOpen) {
        setOpenFilterMenuColumn(null);
      } else {
        setOpenFilterMenuColumn(column.key);
      }
    };

    const handleSortClick = (e?: React.MouseEvent) => {
      if (e) {
        e.stopPropagation();
      }
      if (!isFilterMenuOpen) {
        handleSort(column.key);
      }
    };

    const filterIcon = (
      <button
        onClick={handleFilterIconClick}
        className={`ml-2 p-1 rounded hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors ${
          hasActiveFilter ? 'text-blue-600 dark:text-blue-400' : 'text-gray-500 dark:text-gray-400'
        }`}
        aria-label={`Filter ${column.label}`}
        aria-expanded={isFilterMenuOpen}
        title="Filter och sortering"
        type="button"
      >
        <svg
          className="w-4 h-4"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M4 6h16M4 12h16M4 18h16"
          />
        </svg>
      </button>
    );
    
    if (!column.sortable) {
      const headerContent = (
        <th
          ref={(el) => {
            headerRefs.current[column.key] = el;
          }}
          className={`px-6 py-3 text-left text-xs font-bold text-gray-700 dark:text-gray-200 uppercase tracking-wider ${stickyClass} bg-gray-50 dark:bg-gray-900`}
          scope="col"
          role="columnheader"
        >
          <div className="flex items-center justify-between relative w-full">
            <div className="flex items-center flex-1">
              {metadata ? (
                <ColumnTooltip metadata={metadata}>
                  <div className="flex items-center space-x-1">
                    <span>{column.label}</span>
                  </div>
                </ColumnTooltip>
              ) : (
                <div className="flex items-center space-x-1">
                  <span>{column.label}</span>
                </div>
              )}
            </div>
            <div className="flex items-center relative" style={{ minWidth: '40px' }}>
              <div className="relative">
                {filterIcon}
                {isFilterMenuOpen && headerRef && (
                  <ColumnFilterMenu
                    columnKey={column.key}
                    columnLabel={column.label}
                    isOpen={isFilterMenuOpen}
                    onClose={() => setOpenFilterMenuColumn(null)}
                    filter={columnFilters[column.key]}
                    onFilterChange={(filter) => setColumnFilter(column.key, filter)}
                    sortConfig={sortConfig}
                    onSort={handleColumnSort}
                    uniqueValues={getColumnUniqueValues(column.key)}
                    triggerRef={{ current: headerRef }}
                  />
                )}
              </div>
            </div>
          </div>
        </th>
      );
      return <Fragment key={column.key}>{headerContent}</Fragment>;
    }

    const headerContent = (
      <th
        ref={(el) => {
          headerRefs.current[column.key] = el;
        }}
        onClick={handleSortClick}
        className={`px-6 py-3 text-left text-xs font-bold text-gray-700 dark:text-gray-200 uppercase tracking-wider cursor-pointer hover:bg-blue-100 dark:hover:bg-blue-900/30 hover:text-blue-700 dark:hover:text-blue-200 transition-all duration-200 ${stickyClass} bg-gray-50 dark:bg-gray-900`}
        scope="col"
        role="columnheader"
      >
        <div className="flex items-center justify-between relative w-full">
          <div className="flex items-center flex-1" onClick={handleSortClick}>
            {metadata ? (
              <ColumnTooltip metadata={metadata}>
                <div className="flex items-center space-x-1">
                  <span>{column.label}</span>
                  {sortIcon && <span className="text-gray-600 dark:text-gray-300">{sortIcon}</span>}
                </div>
              </ColumnTooltip>
            ) : (
              <div className="flex items-center space-x-1">
                <span>{column.label}</span>
                {sortIcon && <span className="text-gray-600 dark:text-gray-300">{sortIcon}</span>}
              </div>
            )}
          </div>
          <div className="flex items-center relative" style={{ minWidth: '40px' }}>
            <div className="relative">
              {filterIcon}
              {isFilterMenuOpen && headerRef && (
                <ColumnFilterMenu
                  columnKey={column.key}
                  columnLabel={column.label}
                  isOpen={isFilterMenuOpen}
                  onClose={() => setOpenFilterMenuColumn(null)}
                  filter={columnFilters[column.key]}
                  onFilterChange={(filter) => setColumnFilter(column.key, filter)}
                  sortConfig={sortConfig}
                  onSort={handleColumnSort}
                  uniqueValues={getColumnUniqueValues(column.key)}
                  triggerRef={{ current: headerRef }}
                />
              )}
            </div>
          </div>
        </div>
      </th>
    );
    return <Fragment key={column.key}>{headerContent}</Fragment>;
  }, []);

  if (!currentUser) {
    return (
      <div className="h-full bg-gray-100 dark:bg-gray-900 py-4 sm:py-6 lg:py-8 px-3 sm:px-4 lg:px-6 flex flex-col items-center justify-center">
        <p className="text-gray-600 dark:text-gray-400">
          {t('common.pleaseLogin', 'Please log in to view your personal portfolio')}
        </p>
      </div>
    );
  }

  return (
    <div className="h-full bg-gray-100 dark:bg-gray-900 py-4 sm:py-6 lg:py-8 px-3 sm:px-4 lg:px-6 flex flex-col transition-all duration-300 ease-in-out">
      <div className="w-full flex flex-col flex-1 min-h-0">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6 sm:mb-8 flex-shrink-0 gap-4">
          <div>
            <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-black dark:text-white mb-1 tracking-tight">
              {t('navigation.personalPortfolio', 'Personal Portfolio')}
            </h1>
            <p className="text-xs sm:text-sm text-gray-500 dark:text-gray-400 font-medium">
              {t('portfolio.description', 'Hantera din personliga aktieportfölj')}
            </p>
          </div>
        </div>

        {loading && (
          <div className="mb-4 flex-shrink-0">
            <ProgressIndicator isLoading={true} label={t('common.loading', 'Loading...')} />
          </div>
        )}

        {error && (
          <div className="mb-4 p-4 bg-red-100 dark:bg-red-900/20 border border-red-300 dark:border-red-700 rounded-lg text-red-700 dark:text-red-400 flex-shrink-0">
            {error}
          </div>
        )}

        {/* Add new item form with search */}
        <div className="mb-6 p-4 bg-white dark:bg-gray-800 rounded-lg border border-gray-300 dark:border-gray-600 flex-shrink-0">
          <h2 className="text-lg font-semibold text-black dark:text-white mb-4">
            {t('portfolio.addItem', 'Lägg till aktie')}
          </h2>
          
          {/* Search field */}
          <div className="mb-3">
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              {t('portfolio.searchPlaceholder', 'Sök på ticker eller företagsnamn...')}
            </label>
            <div ref={searchRef} className="relative">
              <input
                ref={inputRef}
                type="text"
                value={searchQuery}
                onChange={(e) => {
                  setSearchQuery(e.target.value);
                  setSelectedStock(null);
                  setQuantity('');
                }}
                onFocus={() => {
                  if (searchResults.length > 0 && debouncedSearchQuery.trim().length >= 2) {
                    setShowSearchResults(true);
                  }
                }}
                onKeyDown={handleKeyDown}
                placeholder={t('portfolio.searchPlaceholder', 'Sök på ticker eller företagsnamn...')}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              
              {/* Search results dropdown */}
              {showSearchResults && searchResults.length > 0 && (
                <div className="absolute z-50 w-full mt-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md shadow-lg max-h-60 overflow-auto">
                  {searchResults.map((result, index) => (
                    <button
                      key={`${result.ticker}-${index}`}
                      type="button"
                      onClick={() => handleSelectStock(result)}
                      className={`w-full px-4 py-3 text-left hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors ${
                        index === selectedIndex ? 'bg-gray-100 dark:bg-gray-700' : ''
                      }`}
                    >
                      <div className="flex items-center justify-between">
                        <div>
                          <div className="font-medium text-black dark:text-white">
                            {result.companyName}
                          </div>
                          <div className="text-sm text-gray-600 dark:text-gray-400">
                            {result.ticker}
                          </div>
                        </div>
                        {result.price !== null && (
                          <div className="text-sm font-medium text-gray-700 dark:text-gray-300">
                            {formatPrice(result.price)}
                          </div>
                        )}
                      </div>
                    </button>
                  ))}
                </div>
              )}
              
              {showSearchResults && debouncedSearchQuery.trim().length >= 2 && searchResults.length === 0 && (
                <div className="absolute z-50 w-full mt-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md shadow-lg p-4">
                  <p className="text-gray-600 dark:text-gray-400 text-sm">
                    {t('portfolio.noResults', 'Inga resultat hittades')}
                  </p>
                </div>
              )}
            </div>
          </div>

          {/* Selected stock and quantity input */}
          {selectedStock && (
            <div className="mb-3 p-3 bg-gray-50 dark:bg-gray-700 rounded-md">
              <div className="mb-3">
                <div className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  {t('portfolio.selectStock', 'Vald aktie')}
                </div>
                <div className="text-sm text-black dark:text-white">
                  {selectedStock.companyName} ({selectedStock.ticker})
                </div>
                {selectedStock.price !== null && (
                  <div className="text-xs text-gray-600 dark:text-gray-400">
                    {t('portfolio.columns.currentPrice', 'Nuvarande Pris')}: {formatPrice(selectedStock.price)}
                  </div>
                )}
              </div>

              <div className="mb-3">
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  {t('portfolio.broker', 'Broker')} *
                </label>
                <select
                  value={brokerSelect}
                  onChange={(e) => setBrokerSelect(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  {DEFAULT_BROKERS.map((b) => (
                    <option key={b} value={b}>{b}</option>
                  ))}
                  <option value={BROKER_OTHER}>{t('portfolio.brokerOther', 'Annan')}</option>
                </select>
                {brokerSelect === BROKER_OTHER && (
                  <input
                    type="text"
                    value={brokerCustom}
                    onChange={(e) => setBrokerCustom(e.target.value)}
                    placeholder={t('portfolio.brokerCustomPlaceholder', 'Skriv brokernamn')}
                    className="mt-2 w-full px-3 py-2 border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                )}
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  {t('portfolio.quantity', 'Antal')} *
                </label>
                <input
                  id="quantity-input"
                  type="number"
                  value={quantity}
                  onChange={(e) => setQuantity(e.target.value)}
                  placeholder={t('portfolio.quantityPlaceholder', 'Ange antal')}
                  min="0"
                  step="0.01"
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && quantity.trim()) {
                      handleAddItem();
                    }
                  }}
                />
              </div>
            </div>
          )}

          {/* Investment Amount and Currency */}
          {selectedStock && (
            <div className="mb-3">
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                {t('portfolio.investedAmount', 'Investerat belopp')} ({t('portfolio.optional', 'Valfritt')})
              </label>
              <div className="flex gap-2">
                <input
                  type="number"
                  value={investedAmount}
                  onChange={(e) => setInvestedAmount(e.target.value)}
                  placeholder={t('portfolio.investedAmountPlaceholder', 'T.ex. 10000')}
                  min="0"
                  step="0.01"
                  className="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
                <select
                  value={investmentCurrency}
                  onChange={(e) => setInvestmentCurrency(e.target.value)}
                  className="px-3 py-2 border border-gray-300 dark:border-gray-500 rounded-md bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="USD">USD</option>
                  <option value="SEK">SEK</option>
                  <option value="EUR">EUR</option>
                  <option value="GBP">GBP</option>
                  <option value="DKK">DKK</option>
                  <option value="NOK">NOK</option>
                  <option value="CHF">CHF</option>
                  <option value="AUD">AUD</option>
                  <option value="CAD">CAD</option>
                </select>
              </div>
              <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                {t('portfolio.investedAmountHelp', 'Totalt investerat belopp. Om tomt används nuvarande pris.')}
              </p>
            </div>
          )}

          {/* Add button */}
          <div className="flex justify-end">
            <button
              onClick={handleAddItem}
              disabled={!selectedStock || !quantity.trim() || loading || benjaminGrahamLoading}
              className="px-6 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white rounded-md transition-colors min-h-[44px] touch-manipulation"
            >
              {t('portfolio.addToPortfolio', 'Lägg till i portfölj')}
            </button>
          </div>
        </div>

        {/* Edit Modal – positions per broker */}
        {editingItem && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 overflow-y-auto py-8" role="dialog" aria-modal="true" aria-labelledby="edit-investment-title">
            <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-2xl w-full mx-4 shadow-xl my-auto">
              <h3 id="edit-investment-title" className="text-lg font-semibold text-black dark:text-white mb-2">
                {t('portfolio.editInvestment', 'Redigera investering')}
              </h3>
              <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
                {editingItem.companyName} ({editingItem.ticker})
              </p>
              <div className="space-y-4 mb-4 max-h-[50vh] overflow-y-auto">
                {editPositions.map((pos, index) => (
                  <div key={`pos-${index}`} className="p-3 border border-gray-300 dark:border-gray-600 rounded-md bg-gray-50 dark:bg-gray-700/50 space-y-2">
                    <div className="flex items-center justify-between gap-2">
                      <label className="text-xs font-medium text-gray-600 dark:text-gray-400 shrink-0 w-20">{t('portfolio.broker', 'Broker')}</label>
                      <input
                        type="text"
                        value={pos.broker}
                        onChange={(e) => updateEditPosition(index, { broker: e.target.value })}
                        className="flex-1 px-2 py-1.5 text-sm border border-gray-300 dark:border-gray-500 rounded bg-white dark:bg-gray-700 text-black dark:text-white"
                      />
                      <button
                        type="button"
                        onClick={() => removeEditPosition(index)}
                        disabled={editPositions.length <= 1}
                        className="shrink-0 px-2 py-1 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 rounded disabled:opacity-50 disabled:cursor-not-allowed"
                        aria-label={t('portfolio.removePosition', 'Ta bort position')}
                      >
                        {t('portfolio.removePosition', 'Ta bort')}
                      </button>
                    </div>
                    <div className="flex flex-wrap gap-2 items-center">
                      <div className="flex items-center gap-1">
                        <label className="text-xs text-gray-600 dark:text-gray-400">{t('portfolio.quantity', 'Antal')}</label>
                        <input
                          type="number"
                          value={pos.quantity}
                          onChange={(e) => updateEditPosition(index, { quantity: parseFloat(e.target.value) || 0 })}
                          min="0"
                          step="0.01"
                          className="w-24 px-2 py-1.5 text-sm border border-gray-300 dark:border-gray-500 rounded bg-white dark:bg-gray-700 text-black dark:text-white"
                        />
                      </div>
                      <div className="flex items-center gap-1">
                        <label className="text-xs text-gray-600 dark:text-gray-400">{t('portfolio.investedAmount', 'Investerat')}</label>
                        <input
                          type="number"
                          value={pos.investedAmount ?? ''}
                          onChange={(e) => updateEditPosition(index, { investedAmount: e.target.value === '' ? undefined : parseFloat(e.target.value) })}
                          min="0"
                          step="0.01"
                          placeholder="—"
                          className="w-28 px-2 py-1.5 text-sm border border-gray-300 dark:border-gray-500 rounded bg-white dark:bg-gray-700 text-black dark:text-white"
                        />
                      </div>
                      <div className="flex items-center gap-1">
                        <label className="text-xs text-gray-600 dark:text-gray-400">{t('portfolio.investmentCurrency', 'Valuta')}</label>
                        <select
                          value={pos.investmentCurrency ?? 'USD'}
                          onChange={(e) => updateEditPosition(index, { investmentCurrency: e.target.value })}
                          className="px-2 py-1.5 text-sm border border-gray-300 dark:border-gray-500 rounded bg-white dark:bg-gray-700 text-black dark:text-white"
                        >
                          <option value="USD">USD</option>
                          <option value="SEK">SEK</option>
                          <option value="EUR">EUR</option>
                          <option value="GBP">GBP</option>
                          <option value="DKK">DKK</option>
                          <option value="NOK">NOK</option>
                          <option value="CHF">CHF</option>
                          <option value="AUD">AUD</option>
                          <option value="CAD">CAD</option>
                        </select>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
              <div className="mb-4">
                <button
                  type="button"
                  onClick={addEditPosition}
                  className="text-sm text-blue-600 dark:text-blue-400 hover:underline"
                >
                  {t('portfolio.addPosition', 'Lägg till position')}
                </button>
              </div>
              {editAveragePreview !== null && (
                <div className="mb-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-md">
                  <p className="text-sm text-gray-700 dark:text-gray-300">
                    <span className="font-medium">{t('portfolio.calculatedAverage', 'Beräknat genomsnitt:')}</span>{' '}
                    {editAverageLoading ? (
                      <span className="text-gray-500 dark:text-gray-400">{t('common.loading', 'Laddar...')}</span>
                    ) : (
                      <span className="text-blue-600 dark:text-blue-400">${editAveragePreview.toFixed(2)}</span>
                    )}
                  </p>
                </div>
              )}
              <div className="flex gap-2">
                <button
                  onClick={handleUpdateItem}
                  className="flex-1 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors min-h-[44px] touch-manipulation"
                >
                  {t('common.save', 'Spara')}
                </button>
                <button
                  onClick={() => {
                    setEditingItem(null);
                    setEditPositions([]);
                    setEditAveragePreview(null);
                  }}
                  className="flex-1 px-4 py-2 bg-gray-300 dark:bg-gray-600 hover:bg-gray-400 dark:hover:bg-gray-500 text-black dark:text-white rounded-md transition-colors min-h-[44px] touch-manipulation"
                >
                  {t('common.cancel', 'Avbryt')}
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Summary: Total Invested and Market Value */}
        {!loading && portfolio.length > 0 && (
          <div className="mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg border border-gray-300 dark:border-gray-600 flex-shrink-0 flex flex-wrap items-center gap-6">
            <div className="flex items-baseline gap-2">
              <span className="text-sm font-medium text-gray-600 dark:text-gray-400">
                {t('portfolio.totalInvested', 'Total Invested ($)')}:
              </span>
              <span className="text-lg font-semibold text-black dark:text-white">
                {formatUSD(totalInvested)}
              </span>
            </div>
            <div className="flex items-baseline gap-2">
              <span className="text-sm font-medium text-gray-600 dark:text-gray-400">
                {t('portfolio.totalMarketValue', 'Market Value ($)')}:
              </span>
              <span className="text-lg font-semibold text-black dark:text-white">
                {formatUSD(totalMarketValue)}
              </span>
            </div>
          </div>
        )}

        {/* Portfolio table */}
        {loading ? (
          <div className="flex-1 min-h-0">
            <TableSkeleton rows={10} columns={7} />
          </div>
        ) : portfolio.length === 0 ? (
          <div className="flex-1 flex items-center justify-center p-8">
            <div className="text-center">
              <p className="text-gray-600 dark:text-gray-400 text-lg mb-2">
                {t('portfolio.empty', 'Din portfölj är tom')}
              </p>
              <p className="text-gray-500 dark:text-gray-500 text-sm">
                {t('portfolio.emptyDescription', 'Lägg till aktier ovan för att börja bygga din portfölj')}
              </p>
            </div>
          </div>
        ) : (
          <div className="flex-1 min-h-0">
            <BaseTable
              data={transformedPortfolio}
              loading={false}
              error={error}
              columns={PORTFOLIO_COLUMNS}
              filters={[]}
              tableId="personal-portfolio"
              renderCell={renderCell}
              renderHeader={renderHeader}
              searchFields={['companyName', 'ticker']}
              searchPlaceholder={t('portfolio.searchPlaceholder', 'Sök på ticker eller företagsnamn...')}
              defaultSortKey="marketWeight"
              defaultSortDirection="desc"
              stickyColumns={['rowNumber', 'companyName', 'ticker', 'currency']}
              enablePagination={false}
              enableVirtualScroll={false}
              ariaLabel={t('portfolio.description', 'Personal Portfolio')}
              emptyMessage={t('portfolio.empty', 'Din portfölj är tom')}
              headerActions={({ toggleColumn, isColumnVisible }) => {
                const bothVisible = isColumnVisible('currency') && isColumnVisible('currentPrice');
                const handleToggle = () => {
                  toggleColumn('currency');
                  toggleColumn('currentPrice');
                };
                return (
                  <div className="flex items-center gap-2">
                    <button
                      type="button"
                      onClick={handleToggle}
                      className="flex items-center justify-center w-9 h-9 text-lg font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition-colors min-h-[44px] min-w-[44px] touch-manipulation"
                      aria-label={bothVisible ? t('portfolio.hideCurrencyAndPrice', 'Dölj valuta och nuvarande pris') : t('portfolio.showCurrencyAndPrice', 'Visa valuta och nuvarande pris')}
                      title={bothVisible ? t('portfolio.hideCurrencyAndPrice', 'Dölj valuta och nuvarande pris') : t('portfolio.showCurrencyAndPrice', 'Visa valuta och nuvarande pris')}
                    >
                      {bothVisible ? '−' : '+'}
                    </button>
                  </div>
                );
              }}
              getRowKey={getRowKey}
              renderExpandedRow={renderExpandedRow}
            />
          </div>
        )}
      </div>
    </div>
  );
}

export default function PersonalPortfolioView() {
  return (
    <EntryExitProvider>
      <PersonalPortfolioViewInner />
    </EntryExitProvider>
  );
}

```

## `src/components/views/ScoreBoardView.tsx`

```tsx
import { useTranslation } from 'react-i18next';
import { useMemo, lazy, Suspense, useEffect } from 'react';
import { useScoreBoardData } from '../../hooks/useScoreBoardData';
import { useThresholdIndustryData } from '../../hooks/useThresholdIndustryData';
import { useBenjaminGrahamData } from '../../hooks/useBenjaminGrahamData';
import { ScoreBoardData, EntryExitData } from '../../types/stock';
import ProgressIndicator from '../ProgressIndicator';
import EnhancedLoadingState from '../EnhancedLoadingState';
import { TableSkeleton } from '../SkeletonLoader';
import { EntryExitProvider, useEntryExitValues } from '../../contexts/EntryExitContext';

// Lazy load table component
const ScoreBoardTable = lazy(() => import('../ScoreBoardTable'));

// Inner component that uses EntryExitContext
function ScoreBoardViewInner() {
  const { t } = useTranslation();
  const { data, loading, error } = useScoreBoardData();
  const { data: thresholdData, loading: thresholdLoading } = useThresholdIndustryData();
  const { data: benjaminGrahamData, loading: bgLoading } = useBenjaminGrahamData();
  const { initializeFromData } = useEntryExitValues();
  
  // Progressive loading: Only block rendering on main data (scoreBoardData)
  // Allow thresholdData and benjaminGrahamData to load in background
  const isLoading = loading;
  const isBackgroundLoading = thresholdLoading || bgLoading;

  // Initialize EntryExitContext with ScoreBoardData (same as EntryExitTable)
  useEffect(() => {
    if (data && data.length > 0) {
      const entryExitData: EntryExitData[] = data.map((item) => ({
        companyName: item.companyName,
        ticker: item.ticker,
        currency: 'USD',
        entry1: 0,
        entry2: 0,
        exit1: 0,
        exit2: 0,
        dateOfUpdate: null,
      }));
      initializeFromData(entryExitData);
    }
  }, [data, initializeFromData]);

  // Match Price data with Score Board data based on ticker (SMA(100) and SMA(200) are now fetched directly in fetchScoreBoardData)
  const dataWithPrice: ScoreBoardData[] = useMemo(() => {
    // Create a map of Price data by ticker (case-insensitive)
    const priceMap = new Map<string, number | null>();
    if (benjaminGrahamData && benjaminGrahamData.length > 0) {
      benjaminGrahamData.forEach(bg => {
        const tickerKey = bg.ticker.toLowerCase().trim();
        priceMap.set(tickerKey, bg.price);
      });
    }

    // Match Score Board data with Price data (SMA(100) and SMA(200) are already included from fetchScoreBoardData)
    return data.map(item => {
      const tickerKey = item.ticker.toLowerCase().trim();
      const price = priceMap.get(tickerKey) ?? null;
      
      return {
        ...item,
        price: price, // Add price for color comparison
      };
    });
  }, [data, benjaminGrahamData]);

  return (
    <div className="h-full bg-gray-100 dark:bg-gray-900 py-4 sm:py-6 lg:py-8 px-3 sm:px-4 lg:px-6 flex flex-col transition-all duration-300 ease-in-out">
      <div className="w-full flex flex-col flex-1 min-h-0">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6 sm:mb-8 flex-shrink-0 gap-4">
          <div>
            <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-black dark:text-white mb-1 tracking-tight">Score Board</h1>
            <p className="text-xs sm:text-sm text-gray-500 dark:text-gray-400 font-medium">Översikt över alla aktier och deras värderingar</p>
          </div>
        </div>
        {isLoading && (
          <div className="mb-4 flex-shrink-0">
            <EnhancedLoadingState />
          </div>
        )}
        {!isLoading && isBackgroundLoading && (
          <div className="mb-2 flex-shrink-0">
            <p className="text-xs text-blue-600 dark:text-blue-400">
              {t('common.loadingAdditionalData', 'Laddar ytterligare data i bakgrunden...')}
            </p>
          </div>
        )}
        <div className="flex-1 min-h-0 transition-all duration-300 ease-in-out">
          {!isLoading && dataWithPrice.length > 0 ? (
            <Suspense fallback={<TableSkeleton rows={15} columns={12} hasStickyColumns={true} />}>
              <ScoreBoardTable data={dataWithPrice} loading={false} error={error} thresholdData={thresholdData} />
            </Suspense>
          ) : isLoading ? (
            <TableSkeleton rows={15} columns={12} hasStickyColumns={true} />
          ) : error ? (
            <div className="text-red-600 dark:text-red-400 p-4">{error}</div>
          ) : null}
        </div>
      </div>
    </div>
  );
}

export default function ScoreBoardView() {
  return (
    <EntryExitProvider>
      <ScoreBoardViewInner />
    </EntryExitProvider>
  );
}


```

## `src/components/views/ScoreView.tsx`

```tsx
import { useTranslation } from 'react-i18next';
import { useMemo, lazy, Suspense, useEffect } from 'react';
import { useScoreBoardData } from '../../hooks/useScoreBoardData';
import { useThresholdIndustryData } from '../../hooks/useThresholdIndustryData';
import { useBenjaminGrahamData } from '../../hooks/useBenjaminGrahamData';
import { EntryExitData, ScoreBoardData } from '../../types/stock';
import ProgressIndicator from '../ProgressIndicator';
import { TableSkeleton } from '../SkeletonLoader';
import { EntryExitProvider, useEntryExitValues } from '../../contexts/EntryExitContext';
import { calculateDetailedScore } from '../../utils/calculateScoreDetailed';
import ScoreDashboard from '../ScoreDashboard';

// Lazy load table component
const ScoreTable = lazy(() => import('../ScoreTable'));

export interface ScoreData extends Record<string, unknown> {
  companyName: string;
  ticker: string;
  currency: string;
  price: number | null;
  entry1: number;
  entry2: number;
  exit1: number;
  exit2: number;
  score: number;
  scoreBoardData: ScoreBoardData; // Full data for breakdown calculation
}

// Inner component that uses EntryExitContext
function ScoreViewInner() {
  const { t } = useTranslation();
  const { data: scoreBoardData, loading, error } = useScoreBoardData();
  const { data: thresholdData, loading: thresholdLoading } = useThresholdIndustryData();
  const { data: benjaminGrahamData, loading: bgLoading } = useBenjaminGrahamData();
  const { initializeFromData, entryExitValues } = useEntryExitValues();
  
  // Progressive loading: Only block rendering on main data (scoreBoardData)
  // Allow thresholdData and benjaminGrahamData to load in background
  const isLoading = loading;
  const isBackgroundLoading = thresholdLoading || bgLoading;

  // Initialize EntryExitContext with ScoreBoardData (same as EntryExitTable)
  useEffect(() => {
    if (scoreBoardData && scoreBoardData.length > 0) {
      const entryExitData: EntryExitData[] = scoreBoardData.map((item) => ({
        companyName: item.companyName,
        ticker: item.ticker,
        currency: 'USD',
        entry1: 0,
        entry2: 0,
        exit1: 0,
        exit2: 0,
        dateOfUpdate: null,
      }));
      initializeFromData(entryExitData);
    }
  }, [scoreBoardData, initializeFromData]);

  // Match Price data with Score Board data based on ticker, then calculate scores
  // SMA data is already included in ScoreBoardData from fetchScoreBoardData
  const scoreData: ScoreData[] = useMemo(() => {
    if (!scoreBoardData || scoreBoardData.length === 0) return [];

    // Create a map of Price data by ticker (case-insensitive)
    const priceMap = new Map<string, number | null>();
    if (benjaminGrahamData && benjaminGrahamData.length > 0) {
      benjaminGrahamData.forEach(bg => {
        const tickerKey = bg.ticker.toLowerCase().trim();
        priceMap.set(tickerKey, bg.price);
      });
    }

    // Match Score Board data with Price data, then calculate scores
    // SMA data (sma100, sma200, smaCross) is already included in ScoreBoardData
    return scoreBoardData.map(item => {
      const tickerKey = item.ticker.toLowerCase().trim();
      const price = priceMap.get(tickerKey) ?? null;
      
      // Create enhanced ScoreBoardData with price
      const enhancedData = {
        ...item,
        price: price,
      };

      // Get currency and entry/exit values from entryExitValues
      const key = `${item.ticker}-${item.companyName}`;
      const entryExitValue = entryExitValues.get(key);
      const currency = entryExitValue?.currency || 'USD';
      const entry1 = entryExitValue?.entry1 || 0;
      const entry2 = entryExitValue?.entry2 || 0;
      const exit1 = entryExitValue?.exit1 || 0;
      const exit2 = entryExitValue?.exit2 || 0;

      // Calculate detailed score
      const score = calculateDetailedScore(
        enhancedData,
        thresholdData || [],
        benjaminGrahamData || [],
        entryExitValues
      );

      return {
        companyName: item.companyName,
        ticker: item.ticker,
        currency: currency,
        price: price,
        entry1: entry1,
        entry2: entry2,
        exit1: exit1,
        exit2: exit2,
        score: score,
        scoreBoardData: enhancedData,
      };
    });
  }, [scoreBoardData, benjaminGrahamData, thresholdData, entryExitValues]);

  return (
    <div className="h-full bg-gray-100 dark:bg-gray-900 py-4 sm:py-6 lg:py-8 px-3 sm:px-4 lg:px-6 flex flex-col transition-all duration-300 ease-in-out">
      <div className="w-full flex flex-col flex-1 min-h-0">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6 sm:mb-8 flex-shrink-0 gap-4">
          <div>
            <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-black dark:text-white mb-1 tracking-tight">Score</h1>
            <p className="text-xs sm:text-sm text-gray-500 dark:text-gray-400 font-medium">Poängsystem baserat på färgkodning (0-100)</p>
          </div>
        </div>
        {isLoading && (
          <div className="mb-4 flex-shrink-0">
            <ProgressIndicator isLoading={true} label="Loading data..." />
          </div>
        )}
        {!isLoading && isBackgroundLoading && (
          <div className="mb-2 flex-shrink-0">
            <p className="text-xs text-blue-600 dark:text-blue-400">
              {t('common.loadingAdditionalData', 'Laddar ytterligare data i bakgrunden...')}
            </p>
          </div>
        )}
        {!isLoading && scoreData.length > 0 ? (
          <div className="flex-1 min-h-0 flex flex-col lg:flex-row gap-4 transition-all duration-300 ease-in-out">
            {/* Left side: Table */}
            <div className="flex-[3] min-h-0 min-w-0">
              <Suspense fallback={<TableSkeleton rows={15} columns={4} hasStickyColumns={true} />}>
                <ScoreTable 
                  data={scoreData} 
                  loading={false}
                  error={error}
                  thresholdData={thresholdData || []}
                  benjaminGrahamData={benjaminGrahamData || []}
                  entryExitValues={entryExitValues}
                />
              </Suspense>
            </div>
            {/* Right side: Dashboard with Heatmap and Scatter Plot */}
            <div className="flex-[2] lg:flex-shrink-0 flex flex-col min-h-0">
              <ScoreDashboard 
                data={scoreData} 
                loading={false}
                thresholdData={thresholdData || []}
                benjaminGrahamData={benjaminGrahamData || []}
                entryExitValues={entryExitValues}
              />
            </div>
          </div>
        ) : isLoading ? (
          <div className="flex-1 min-h-0">
            <TableSkeleton rows={15} columns={4} hasStickyColumns={true} />
          </div>
        ) : error ? (
          <div className="text-red-600 dark:text-red-400 p-4">{error}</div>
        ) : null}
      </div>
    </div>
  );
}

export default function ScoreView() {
  return (
    <EntryExitProvider>
      <ScoreViewInner />
    </EntryExitProvider>
  );
}


```

## `src/components/views/ShareableView.tsx`

```tsx
import { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { loadShareableLink, ShareableLink } from '../../services/shareableLinkService';
import { useNotifications } from '../../contexts/NotificationContext';
import { useTranslation } from 'react-i18next';
import { useUserRole } from '../../hooks/useUserRole';
import type { ViewId } from '../../types/navigation';
import LoadingFallback from '../LoadingFallback';

interface ShareableViewProps {
  onLoadLink: (link: ShareableLink) => void;
}

export default function ShareableView({ onLoadLink }: ShareableViewProps) {
  const { linkId } = useParams<{ linkId: string }>();
  const navigate = useNavigate();
  const { createNotification } = useNotifications();
  const { t } = useTranslation();
  const { canView } = useUserRole();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadLink = async () => {
      if (!linkId) {
        setError(t('shareableLinks.invalidLink', 'Invalid link'));
        setLoading(false);
        return;
      }

      try {
        setLoading(true);
        const link = await loadShareableLink(linkId);

        if (!link) {
          setError(t('shareableLinks.linkNotFound', 'Link not found or expired'));
          setLoading(false);
          return;
        }

        if (!canView(link.viewId as ViewId)) {
          setError(t('common.unauthorizedView', 'Du saknar behörighet till denna vy'));
          setLoading(false);
          navigate('/', { replace: true });
          return;
        }

        // Load the link data
        onLoadLink(link);

        // Navigate to the view
        navigate(`/${link.viewId}`, { replace: true });

        createNotification(
          'success',
          'Link Loaded',
          t('shareableLinks.linkLoaded', 'Shareable link loaded successfully'),
          { showDesktop: false }
        );
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : t('shareableLinks.loadError', 'Failed to load link');
        setError(errorMessage);
        createNotification(
          'error',
          'Error Loading Link',
          errorMessage,
          { showDesktop: true }
        );
      } finally {
        setLoading(false);
      }
    };

    loadLink();
  }, [linkId, navigate, onLoadLink, createNotification, t, canView]);

  if (loading) {
    return <LoadingFallback />;
  }

  if (error) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-100 dark:bg-gray-900">
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-8 max-w-md">
          <h2 className="text-xl font-bold text-red-600 dark:text-red-400 mb-4">
            {t('shareableLinks.error', 'Error')}
          </h2>
          <p className="text-gray-700 dark:text-gray-300 mb-6">{error}</p>
          <button
            onClick={() => navigate('/')}
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
          >
            {t('shareableLinks.goHome', 'Go to Home')}
          </button>
        </div>
      </div>
    );
  }

  return null;
}

```

## `src/components/views/ThresholdIndustryView.tsx`

```tsx
import { useTranslation } from 'react-i18next';
import { lazy, Suspense } from 'react';
import { useThresholdIndustryData } from '../../hooks/useThresholdIndustryData';
import { TableSkeleton } from '../SkeletonLoader';
import { ThresholdProvider } from '../../contexts/ThresholdContext';

// Lazy load table component
const ThresholdIndustryTable = lazy(() => import('../ThresholdIndustryTable'));

export default function ThresholdIndustryView() {
  const { t } = useTranslation();
  const { data, loading, error } = useThresholdIndustryData();

  return (
    <ThresholdProvider>
      <div className="h-full bg-gray-100 dark:bg-gray-900 py-4 sm:py-6 lg:py-8 px-3 sm:px-4 lg:px-6 flex flex-col transition-all duration-300 ease-in-out">
        <div className="w-full flex flex-col flex-1 min-h-0">
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6 sm:mb-8 flex-shrink-0 gap-4">
            <div>
              <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-black dark:text-white mb-1 tracking-tight">
                {t('navigation.thresholdIndustry')}
              </h1>
              <p className="text-xs sm:text-sm text-gray-500 dark:text-gray-400 font-medium">Tröskelvärden per bransch</p>
            </div>
          </div>
          <div className="flex-1 min-h-0 transition-all duration-300 ease-in-out">
            <Suspense fallback={<TableSkeleton rows={10} columns={8} hasStickyColumns={true} />}>
              <ThresholdIndustryTable data={data} loading={loading} error={error} />
            </Suspense>
          </div>
        </div>
      </div>
    </ThresholdProvider>
  );
}


```

## `src/components/VirtualScrollTable.tsx`

```tsx
import { ReactNode, useRef, useEffect, useState } from 'react';

interface VirtualScrollTableProps<T> {
  data: T[];
  renderRow: (item: T, index: number, globalIndex: number) => ReactNode;
  rowHeight?: number;
  containerHeight?: number;
  overscan?: number;
  headerHeight?: number;
  className?: string;
  onScroll?: (scrollTop: number) => void;
}

export default function VirtualScrollTable<T>({
  data,
  renderRow,
  rowHeight = 60,
  containerHeight,
  overscan = 5,
  headerHeight = 48,
  className = '',
  onScroll,
}: VirtualScrollTableProps<T>) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 0 });
  const [containerSize, setContainerSize] = useState({ height: containerHeight || 600, width: 0 });
  const scrollTopRef = useRef(0);

  // Measure container size
  useEffect(() => {
    const updateSize = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        setContainerSize({
          height: containerHeight || rect.height || 600,
          width: rect.width,
        });
      }
    };

    updateSize();
    window.addEventListener('resize', updateSize);
    return () => window.removeEventListener('resize', updateSize);
  }, [containerHeight]);

  // Calculate visible range
  useEffect(() => {
    if (!containerRef.current) return;

    const calculateVisibleRange = () => {
      const scrollTop = scrollTopRef.current;
      const visibleHeight = containerSize.height - headerHeight;
      const start = Math.max(0, Math.floor(scrollTop / rowHeight) - overscan);
      const end = Math.min(
        data.length,
        Math.ceil((scrollTop + visibleHeight) / rowHeight) + overscan
      );
      setVisibleRange({ start, end });
    };

    calculateVisibleRange();
  }, [data.length, rowHeight, containerSize.height, headerHeight, overscan]);

  // Handle scroll
  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    const scrollTop = e.currentTarget.scrollTop;
    scrollTopRef.current = scrollTop;
    
    const visibleHeight = containerSize.height - headerHeight;
    const start = Math.max(0, Math.floor(scrollTop / rowHeight) - overscan);
    const end = Math.min(
      data.length,
      Math.ceil((scrollTop + visibleHeight) / rowHeight) + overscan
    );
    setVisibleRange({ start, end });

    if (onScroll) {
      onScroll(scrollTop);
    }
  };

  const totalHeight = data.length * rowHeight;
  const offsetY = visibleRange.start * rowHeight;
  const visibleItems = data.slice(visibleRange.start, visibleRange.end);

  return (
    <div
      ref={containerRef}
      className={`relative overflow-auto ${className}`}
      style={{ height: containerSize.height }}
      onScroll={handleScroll}
    >
      {/* Spacer for items before visible range */}
      <div style={{ height: offsetY }} />

      {/* Visible items */}
      <div style={{ position: 'relative' }}>
        {visibleItems.map((item, index) => {
          const globalIndex = visibleRange.start + index;
          return (
            <div
              key={globalIndex}
              style={{
                height: rowHeight,
                position: 'relative',
              }}
            >
              {renderRow(item, index, globalIndex)}
            </div>
          );
        })}
      </div>

      {/* Spacer for items after visible range */}
      <div style={{ height: Math.max(0, totalHeight - (visibleRange.end * rowHeight)) }} />
    </div>
  );
}


```

## `src/components/VirtualTableBody.tsx`

```tsx
import React, { ReactNode, useRef, useEffect, useState, useMemo, useCallback } from 'react';

interface VirtualTableBodyProps<T> {
  data: T[];
  renderRow: (item: T, index: number, globalIndex: number) => ReactNode;
  rowHeight?: number;
  overscan?: number;
  className?: string;
}

export default function VirtualTableBody<T>({
  data,
  renderRow,
  rowHeight = 60,
  overscan = 5,
  className = '',
}: VirtualTableBodyProps<T>) {
  const tbodyRef = useRef<HTMLTableSectionElement>(null);
  const [scrollTop, setScrollTop] = useState(0);
  const [containerHeight, setContainerHeight] = useState(600);
  const scrollContainerRef = useRef<HTMLElement | null>(null);
  const rafRef = useRef<number | null>(null);
  const pendingScrollTopRef = useRef<number>(0);

  // Debounced scroll handler using requestAnimationFrame
  const handleScroll = useCallback(() => {
    if (scrollContainerRef.current) {
      pendingScrollTopRef.current = scrollContainerRef.current.scrollTop;
      
      if (rafRef.current === null) {
        rafRef.current = requestAnimationFrame(() => {
          setScrollTop(pendingScrollTopRef.current);
          rafRef.current = null;
        });
      }
    }
  }, []);

  // Find scroll container and measure dimensions
  useEffect(() => {
    if (!tbodyRef.current) return;

    // Find the scrollable container (usually a parent div with overflow-auto)
    let container = tbodyRef.current.parentElement;
    while (container) {
      const style = window.getComputedStyle(container);
      const overflow = style.overflow;
      const overflowY = style.overflowY;
      if (overflow === 'auto' || overflow === 'scroll' || overflowY === 'auto' || overflowY === 'scroll') {
        scrollContainerRef.current = container;
        break;
      }
      container = container.parentElement;
    }

    const updateDimensions = () => {
      if (scrollContainerRef.current) {
        const rect = scrollContainerRef.current.getBoundingClientRect();
        setContainerHeight(rect.height || 600);
      }
    };

    if (scrollContainerRef.current) {
      updateDimensions();
      scrollContainerRef.current.addEventListener('scroll', handleScroll, { passive: true });
      window.addEventListener('resize', updateDimensions);

      return () => {
        if (rafRef.current !== null) {
          cancelAnimationFrame(rafRef.current);
        }
        if (scrollContainerRef.current) {
          scrollContainerRef.current.removeEventListener('scroll', handleScroll);
        }
        window.removeEventListener('resize', updateDimensions);
      };
    }
  }, [handleScroll]);

  // Calculate visible range - memoized for performance
  const visibleRange = useMemo(() => {
    // Subtract approximate header height (48px)
    const availableHeight = Math.max(200, containerHeight - 48);
    const start = Math.max(0, Math.floor(scrollTop / rowHeight) - overscan);
    const end = Math.min(
      data.length,
      Math.ceil((scrollTop + availableHeight) / rowHeight) + overscan
    );

    return {
      startIndex: start,
      endIndex: end,
      offsetY: start * rowHeight,
      totalHeight: data.length * rowHeight,
    };
  }, [scrollTop, rowHeight, containerHeight, data.length, overscan]);

  const { startIndex, endIndex, offsetY, totalHeight } = visibleRange;

  // Memoize visible items slice for performance
  const visibleItems = useMemo(() => {
    return data.slice(startIndex, endIndex);
  }, [data, startIndex, endIndex]);

  // Memoize renderRow callback to prevent unnecessary re-renders
  const memoizedRenderRow = useCallback((item: T, index: number, globalIndex: number) => {
    return renderRow(item, index, globalIndex);
  }, [renderRow]);

  if (data.length === 0) {
    return (
      <tbody ref={tbodyRef} className={className}>
        <tr>
          <td colSpan={100} className="text-center py-8 text-gray-600 dark:text-gray-300">
            <div className="text-sm">Inga resultat hittades.</div>
            <div className="text-xs mt-1 text-gray-600 dark:text-gray-400">
              Försök ändra dina sökkriterier eller filter.
            </div>
          </td>
        </tr>
      </tbody>
    );
  }

  return (
    <tbody ref={tbodyRef} className={className} style={{ position: 'relative' }}>
      {/* Spacer for items before visible range */}
      {offsetY > 0 && (
        <tr aria-hidden="true">
          <td
            colSpan={100}
            style={{
              height: offsetY,
              padding: 0,
              border: 'none',
              lineHeight: 0,
            }}
          />
        </tr>
      )}

      {/* Visible rows */}
      {visibleItems.map((item, relativeIndex) => {
        const globalIndex = startIndex + relativeIndex;
        return (
          <React.Fragment key={globalIndex}>
            {memoizedRenderRow(item, relativeIndex, globalIndex)}
          </React.Fragment>
        );
      })}

      {/* Spacer for items after visible range */}
      {endIndex < data.length && (
        <tr aria-hidden="true">
          <td
            colSpan={100}
            style={{
              height: Math.max(0, totalHeight - endIndex * rowHeight),
              padding: 0,
              border: 'none',
              lineHeight: 0,
            }}
          />
        </tr>
      )}
    </tbody>
  );
}

```

## `src/config/__tests__/viewTableMap.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { getTableId } from '../viewTableMap';
import { getTableMetadata } from '../tableMetadata';
import type { ViewId } from '../../types/navigation';

describe('viewTableMap', () => {
  describe('getTableId', () => {
    it('maps score-board to score-board', () => {
      expect(getTableId('score-board' as ViewId)).toBe('score-board');
    });

    it('maps score to score', () => {
      expect(getTableId('score' as ViewId)).toBe('score');
    });

    it('maps entry-exit-benjamin-graham to benjamin-graham', () => {
      expect(getTableId('entry-exit-benjamin-graham' as ViewId)).toBe('benjamin-graham');
    });

    it('maps fundamental-pe-industry to pe-industry', () => {
      expect(getTableId('fundamental-pe-industry' as ViewId)).toBe('pe-industry');
    });

    it('maps threshold-industry to threshold-industry', () => {
      expect(getTableId('threshold-industry' as ViewId)).toBe('threshold-industry');
    });

    it('maps personal-portfolio to personal-portfolio', () => {
      expect(getTableId('personal-portfolio' as ViewId)).toBe('personal-portfolio');
    });

    it('personal-portfolio has metadata for ConditionsModal (no null)', () => {
      const tableId = getTableId('personal-portfolio' as ViewId);
      expect(tableId).toBe('personal-portfolio');
      const metadata = getTableMetadata(tableId!);
      expect(metadata).toBeDefined();
      expect(metadata?.tableId).toBe('personal-portfolio');
    });

    it('returns null for admin', () => {
      expect(getTableId('admin' as ViewId)).toBeNull();
    });

    it('returns null for other ViewIds without table mapping', () => {
      expect(getTableId('entry-exit-entry2' as ViewId)).toBeNull();
      expect(getTableId('fundamental-current-ratio' as ViewId)).toBeNull();
    });
  });
});

```

## `src/config/apiKeys.ts`

```typescript
/**
 * API Keys Configuration
 *
 * Reads API keys from environment variables and optional Firestore cache.
 * Cache (set from Firestore or admin UI save) overrides env for non-empty values.
 */

export interface ApiKeys {
  eodhd?: string;
  marketstack?: string;
  finnhub?: string;
  alphaVantage?: string;
}

let cachedApiKeys: ApiKeys | null = null;

function getEnvKeys(): ApiKeys {
  return {
    eodhd: import.meta.env.VITE_EODHD_API_KEY,
    marketstack: import.meta.env.VITE_MARKETSTACK_API_KEY,
    finnhub: import.meta.env.VITE_FINNHUB_API_KEY,
    alphaVantage: import.meta.env.VITE_ALPHA_VANTAGE_API_KEY,
  };
}

/**
 * Merge cache with env: for each key, use cached value if non-empty, else env.
 */
function mergeKeys(cache: ApiKeys, env: ApiKeys): ApiKeys {
  return {
    eodhd: (cache.eodhd && cache.eodhd.trim()) ? cache.eodhd : env.eodhd,
    marketstack: (cache.marketstack && cache.marketstack.trim()) ? cache.marketstack : env.marketstack,
    finnhub: (cache.finnhub && cache.finnhub.trim()) ? cache.finnhub : env.finnhub,
    alphaVantage: (cache.alphaVantage && cache.alphaVantage.trim()) ? cache.alphaVantage : env.alphaVantage,
  };
}

/**
 * Set API keys cache (e.g. after admin save from UI).
 */
export function setApiKeysCache(keys: ApiKeys): void {
  cachedApiKeys = { ...keys };
}

/**
 * Set API keys cache from Firestore result (merge with env so empty Firestore fields use env).
 */
export function setApiKeysCacheFromFirestore(keys: ApiKeys): void {
  cachedApiKeys = mergeKeys(keys, getEnvKeys());
}

/**
 * Get API keys: merged cache + env (cache overrides for non-empty values).
 */
export function getApiKeys(): ApiKeys {
  const env = getEnvKeys();
  if (!cachedApiKeys) return env;
  return mergeKeys(cachedApiKeys, env);
}

/**
 * Get API keys for display in admin UI (same as getApiKeys).
 */
export function getApiKeysForDisplay(): ApiKeys {
  return getApiKeys();
}

```

## `src/config/brokers.ts`

```typescript
/**
 * Default broker names for Personal Portfolio.
 * Users can select from these or enter a custom broker name (e.g. "Annan").
 */

export const DEFAULT_BROKERS = [
  'Avanza',
  'Nordnet',
  'eToro',
  'Interactive Brokers',
] as const;

/** Value used in UI to show a free-text input for custom broker name */
export const BROKER_OTHER = 'Annan';

```

## `src/config/constants.ts`

```typescript
/**
 * Application Constants
 * 
 * This file contains all magic numbers and hardcoded values used throughout
 * the application. These constants have descriptive names to improve code
 * readability and maintainability.
 */

// Price tolerance multipliers
export const PRICE_TOLERANCE_GREEN = 1.05; // 5% above entry/benjamin graham
export const PRICE_TOLERANCE_BLUE = 1.15; // 15% above benjamin graham

// Return rate thresholds (percentages)
export const RR1_GREEN_THRESHOLD_PERCENT = 60;
export const RR2_GREEN_THRESHOLD_PERCENT = 90;

// Munger Quality Score thresholds
export const MUNGER_QUALITY_SCORE_RED_THRESHOLD = 40;
export const MUNGER_QUALITY_SCORE_GREEN_THRESHOLD = 60;

// Date thresholds (days)
export const DATE_NEAR_OLD_THRESHOLD_DAYS = 30;

// Color factors
export const COLOR_FACTOR_GREEN = 1.00;
export const COLOR_FACTOR_ORANGE_BLUE = 0.70;

// TB/S Price threshold
export const TB_S_PRICE_GREEN_THRESHOLD = 1.00;


```

## `src/config/firebase.ts`

```typescript
import { initializeApp, FirebaseApp } from 'firebase/app';
import { getAuth, Auth } from 'firebase/auth';
import { getFirestore, Firestore } from 'firebase/firestore';
import { getFunctions, Functions } from 'firebase/functions';
import { logger } from '../utils/logger';

// Validate that all required environment variables are present
const requiredEnvVars = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID
};

// Debug: Log environment variables (masked for security)
logger.debug('Firebase Config Check', {
  component: 'firebase',
  apiKey: requiredEnvVars.apiKey ? `${requiredEnvVars.apiKey.substring(0, 10)}...` : 'MISSING',
  authDomain: requiredEnvVars.authDomain || 'MISSING',
  projectId: requiredEnvVars.projectId || 'MISSING',
  storageBucket: requiredEnvVars.storageBucket || 'MISSING',
  messagingSenderId: requiredEnvVars.messagingSenderId || 'MISSING',
  appId: requiredEnvVars.appId ? `${requiredEnvVars.appId.substring(0, 20)}...` : 'MISSING',
});

const missingVars = Object.entries(requiredEnvVars)
  .filter(([_, value]) => !value || value === 'undefined')
  .map(([key]) => {
    // Convert camelCase to UPPER_CASE
    const upperKey = key.replace(/([A-Z])/g, '_$1').toUpperCase();
    return `VITE_FIREBASE_${upperKey}`;
  });

if (missingVars.length > 0) {
  const errorMessage = `Missing required Firebase environment variables: ${missingVars.join(', ')}\n\n` +
    `Please add these to your .env.local file (for local development) or ` +
    `Vercel Environment Variables (for production).\n\n` +
    `Go to: Vercel Dashboard → Your Project → Settings → Environment Variables`;
  
  logger.error('Firebase Configuration Error', new Error(errorMessage), { component: 'firebase', missingVars });
  
  // In production, throw error to be caught by error boundaries
  if (import.meta.env.PROD) {
    throw new Error(errorMessage);
  }
}

const firebaseConfig = {
  apiKey: requiredEnvVars.apiKey || 'missing-api-key',
  authDomain: requiredEnvVars.authDomain || 'missing-auth-domain',
  projectId: requiredEnvVars.projectId || 'missing-project-id',
  storageBucket: requiredEnvVars.storageBucket || 'missing-storage-bucket',
  messagingSenderId: requiredEnvVars.messagingSenderId || 'missing-messaging-sender-id',
  appId: requiredEnvVars.appId || 'missing-app-id'
};

// Initialize Firebase
let app: FirebaseApp;
let auth: Auth;
let db: Firestore;
let functions: Functions;

try {
  // Validate API key format (Firebase API keys start with AIza)
  if (firebaseConfig.apiKey && !firebaseConfig.apiKey.startsWith('AIza') && firebaseConfig.apiKey !== 'missing-api-key') {
    if (import.meta.env.DEV) {
      logger.warn('Firebase API Key format looks incorrect. It should start with "AIza"', { component: 'firebase' });
    }
  }
  
  app = initializeApp(firebaseConfig);
  auth = getAuth(app);
  db = getFirestore(app);
  functions = getFunctions(app);
  logger.info('Firebase initialized successfully', { component: 'firebase', projectId: firebaseConfig.projectId });
} catch (error: unknown) {
  const errorMessage = error instanceof Error ? error.message : String(error);
  logger.error('Firebase initialization error', error instanceof Error ? error : new Error(errorMessage), { component: 'firebase', errorMessage });
  
  // Check if it's an API key error
  if (errorMessage.includes('api-key-not-valid') || errorMessage.includes('API key')) {
    const detailedError = 
      `Firebase API Key Error: ${errorMessage}\n\n` +
      `This means your Firebase API key is invalid or incorrect.\n\n` +
      `How to fix:\n` +
      `1. Go to Firebase Console: https://console.firebase.google.com\n` +
      `2. Select your project: stock-score-df698\n` +
      `3. Go to Project Settings (gear icon) → General tab\n` +
      `4. Scroll down to "Your apps" section\n` +
      `5. If you have a web app, click on it, otherwise:\n` +
      `   - Click the web icon (</>)\n` +
      `   - Register a new app with a name\n` +
      `6. Copy the ENTIRE apiKey from the config object (it should start with "AIza")\n` +
      `7. Go to Vercel → Your Project → Settings → Environment Variables\n` +
      `8. Update VITE_FIREBASE_API_KEY with the correct value\n` +
      `9. Make sure you select all environments (Production, Preview, Development)\n` +
      `10. Redeploy your application\n\n` +
      `Current API Key (first 10 chars): ${firebaseConfig.apiKey?.substring(0, 10) || 'MISSING'}...\n` +
      `Make sure it starts with "AIza" and is the FULL key from Firebase Console.`;
    
    throw new Error(detailedError);
  }
  
  // Re-throw with more context for other errors
  throw new Error(
    `Firebase initialization failed: ${errorMessage}\n\n` +
    `This usually means:\n` +
    `1. Environment variables are missing (check Vercel or .env.local)\n` +
    `2. Firebase configuration values are incorrect\n` +
    `3. Network connectivity issues\n\n` +
    `Current config values:\n` +
    `- API Key: ${firebaseConfig.apiKey ? firebaseConfig.apiKey.substring(0, 10) + '...' : 'MISSING'}\n` +
    `- Project ID: ${firebaseConfig.projectId || 'MISSING'}\n` +
    `- Auth Domain: ${firebaseConfig.authDomain || 'MISSING'}`
  );
}

export { auth, db, functions };
export default app;


```

## `src/config/industryThresholds.ts`

```typescript
/**
 * Industry Threshold Configuration
 * 
 * This file contains all industry-specific threshold mappings used for
 * calculating and evaluating stock scores. These thresholds define the
 * expected ranges and values for different industries.
 * 
 * To update these values, modify this file directly. The values are
 * automatically imported and used by the sheets services.
 */

/**
 * Industry to IRR (Internal Rate of Return) value mapping
 * Represents the expected IRR threshold for each industry
 */
export const INDUSTRY_IRR_MAP: Record<string, number> = {
  'Agricultural Inputs': 25,
  'Apparel Retail': 20,
  'Auto Parts': 25,
  'Airlines': 25,
  'Biotechnology': 30,
  'Beverages - Wineries & Distilleries': 0,
  'Building Products & Equipment': 20,
  'Capital Markets': 20,
  'Chemicals': 20,
  'Coking Coal': 25,
  'Communication Equipment': 20,
  'Computer Hardware': 20,
  'Copper': 25,
  'Conglomerates': 15,
  'Discount Stores': 20,
  'Drug Manufacturers - General': 20,
  'Drug Manufacturers - Specialty & Generic': 20,
  'Aluminum': 20,
  'Electrical Equipment & Parts': 20,
  'Electronic Components': 20,
  'Electronic Gaming & Multimedia': 25,
  'Engineering & Construction': 20,
  'Farm & Heavy Construction Machinery': 20,
  'Farm Products': 20,
  'Footwear & Accessories': 20,
  'Gambling': 25,
  'Healthcare Plans': 20,
  'Industrial Distribution': 20,
  'Information Technology Services': 20,
  'Internet Content & Information': 35,
  'Internet Retail': 25,
  'Leisure': 20,
  'Luxury Goods': 20,
  'Marine Shipping': 25,
  'Medical Care Facilities': 20,
  'Medical Instruments & Supplies': 20,
  'Oil & Gas Exploration & Production & Integrated & Equipment & Services & Drilling': 26,
  'Oil & Gas Integrated': 22,
  'Oil & Gas Midstream': 15,
  'Oil & Gas Refining & Marketing': 20,
  'Other Industrial Metals & Mining': 25,
  'Other Precious Metals & Mining': 25,
  'Packaged Foods': 15,
  'Packaging & Containers': 20,
  'Pollution & Treatment Controls': 20,
  'Railroads': 16,
  'Real Estate Services': 15,
  'Recreational Vehicles': 20,
  'REIT - Industrial': 15,
  'REIT - Specialty': 15,
  'Residential Construction': 20,
  'Scientific & Technical Instruments': 20,
  'Security & Protection Services': 20,
  'Semiconductor Equipment & Materials': 25,
  'Semiconductors': 25,
  'Software': 35,
  'Solar': 25,
  'Specialty Business Services': 20,
  'Specialty Chemicals': 20,
  'Specialty Industrial Machinery': 20,
  'Steel': 25,
  'Telecom Services': 20,
  'Thermal Coal': 25,
  'Utilities - Regulated Electric': 15,
  'Utilities - Regulated Water': 15,
  'Utilities - Renewable': 15,
  'Waste Management': 15,
};

/**
 * Industry to Leverage F2 mapping
 * Defines green (max) and red (min) thresholds for leverage ratios
 * Note: greenMax is the maximum value for green status, redMin is the minimum value for red status
 */
export const INDUSTRY_LEVERAGE_F2_MAP: Record<string, { greenMax: number; redMin: number }> = {
  'Agricultural Inputs': { greenMax: 2.0, redMin: 3.0 },
  'Apparel Retail': { greenMax: 2.0, redMin: 3.0 },
  'Auto Parts': { greenMax: 2.0, redMin: 3.0 },
  'Airlines': { greenMax: 2.5, redMin: 4.0 },
  'Biotechnology': { greenMax: 1.0, redMin: 2.0 },
  'Beverages - Wineries & Distilleries': { greenMax: 0, redMin: 0 },
  'Building Products & Equipment': { greenMax: 2.0, redMin: 3.0 },
  'Chemicals': { greenMax: 2.0, redMin: 3.0 },
  'Coking Coal': { greenMax: 1.5, redMin: 2.5 },
  'Communication Equipment': { greenMax: 1.5, redMin: 2.5 },
  'Computer Hardware': { greenMax: 1.5, redMin: 2.5 },
  'Conglomerates': { greenMax: 2.5, redMin: 3.5 },
  'Copper': { greenMax: 1.5, redMin: 2.5 },
  'Discount Stores': { greenMax: 2.0, redMin: 3.0 },
  'Drug Manufacturers - General': { greenMax: 2.0, redMin: 3.0 },
  'Drug Manufacturers - Specialty & Generic': { greenMax: 2.5, redMin: 3.5 },
  'Electrical Equipment & Parts': { greenMax: 2.0, redMin: 3.0 },
  'Electronic Components': { greenMax: 1.5, redMin: 2.5 },
  'Aluminum': { greenMax: 1.5, redMin: 2.5 },
  'Electronic Gaming & Multimedia': { greenMax: 2.0, redMin: 3.5 },
  'Engineering & Construction': { greenMax: 1.5, redMin: 2.5 },
  'Farm & Heavy Construction Machinery': { greenMax: 2.0, redMin: 3.0 },
  'Farm Products': { greenMax: 2.0, redMin: 3.0 },
  'Footwear & Accessories': { greenMax: 1.5, redMin: 3.0 },
  'Gambling': { greenMax: 3.0, redMin: 4.5 },
  'Industrial Distribution': { greenMax: 2.0, redMin: 3.0 },
  'Information Technology Services': { greenMax: 1.5, redMin: 2.5 },
  'Internet Content & Information': { greenMax: 1.5, redMin: 2.5 },
  'Internet Retail': { greenMax: 2.0, redMin: 3.0 },
  'Leisure': { greenMax: 2.0, redMin: 3.0 },
  'Luxury Goods': { greenMax: 2.0, redMin: 3.0 },
  'Marine Shipping': { greenMax: 2.0, redMin: 3.0 },
  'Medical Care Facilities': { greenMax: 3.0, redMin: 4.5 },
  'Medical Instruments & Supplies': { greenMax: 1.5, redMin: 2.5 },
  'Oil & Gas Exploration & Production & Integrated & Equipment & Services & Drilling': { greenMax: 1.5, redMin: 3.0 },
  'Oil & Gas Integrated': { greenMax: 2.0, redMin: 3.0 },
  'Oil & Gas Midstream (Pipelines)': { greenMax: 3.5, redMin: 4.5 },
  'Oil & Gas Refining & Marketing': { greenMax: 2.0, redMin: 3.0 },
  'Other Industrial Metals & Mining': { greenMax: 1.5, redMin: 2.5 },
  'Other Precious Metals & Mining': { greenMax: 1.5, redMin: 2.5 },
  'Packaged Foods': { greenMax: 2.5, redMin: 3.5 },
  'Packaging & Containers': { greenMax: 2.5, redMin: 3.5 },
  'Pollution & Treatment Controls': { greenMax: 2.5, redMin: 3.5 },
  'Railroads': { greenMax: 3.0, redMin: 3.5 },
  'Real Estate Services': { greenMax: 1.5, redMin: 2.5 },
  'Recreational Vehicles': { greenMax: 2.0, redMin: 3.0 },
  'REIT - Industrial': { greenMax: 5.0, redMin: 6.5 },
  'REIT - Specialty': { greenMax: 5.5, redMin: 7.0 },
  'Residential Construction': { greenMax: 2.0, redMin: 3.0 },
  'Scientific & Technical Instruments': { greenMax: 1.5, redMin: 2.5 },
  'Security & Protection Services': { greenMax: 2.0, redMin: 3.0 },
  'Semiconductor Equipment & Materials': { greenMax: 1.5, redMin: 2.5 },
  'Semiconductors': { greenMax: 1.5, redMin: 2.5 },
  'Software': { greenMax: 1.5, redMin: 2.5 },
  'Solar': { greenMax: 2.0, redMin: 3.0 },
  'Specialty Business Services': { greenMax: 2.0, redMin: 3.0 },
  'Specialty Chemicals': { greenMax: 2.0, redMin: 3.0 },
  'Specialty Industrial Machinery': { greenMax: 2.0, redMin: 3.0 },
  'Steel': { greenMax: 1.5, redMin: 2.5 },
  'Telecom Services': { greenMax: 3.0, redMin: 4.0 },
  'Thermal Coal': { greenMax: 1.5, redMin: 2.5 },
  'Utilities - Regulated Electric': { greenMax: 4.5, redMin: 6.0 },
  'Utilities - Regulated Water': { greenMax: 4.5, redMin: 6.0 },
  'Utilities - Renewable': { greenMax: 4.0, redMin: 5.0 },
  'Waste Management': { greenMax: 3.0, redMin: 4.0 },
  'Capital Markets': { greenMax: 2.0, redMin: 3.0 },
  'Healthcare Plans': { greenMax: 2.0, redMin: 3.0 },
  'Oil & Gas Midstream': { greenMax: 3.5, redMin: 4.5 },
};

/**
 * Industry to RO40 mapping (Return on Assets)
 * Defines the expected min and max range for RO40 values by industry
 */
export const INDUSTRY_RO40_MAP: Record<string, { min: number; max: number }> = {
  'Oil & Gas Exploration & Production & Integrated & Equipment & Services & Drilling': { min: 0.15, max: 0.25 },
  'Discount Stores': { min: 0.25, max: 0.40 },
  'Drug Manufacturers - General': { min: 0.30, max: 0.45 },
  'Semiconductor Equipment & Materials': { min: 0.30, max: 0.45 },
  'Auto Parts': { min: 0.25, max: 0.40 },
  'Communication Equipment': { min: 0.25, max: 0.40 },
  'Information Technology Services': { min: 0.30, max: 0.45 },
  'Specialty Chemicals': { min: 0.25, max: 0.40 },
  'Building Products & Equipment': { min: 0.25, max: 0.40 },
  'Capital Markets': { min: 0.25, max: 0.40 },
  'Electrical Equipment & Parts': { min: 0.25, max: 0.40 },
  'Footwear & Accessories': { min: 0.25, max: 0.40 },
  'Gambling': { min: 0.25, max: 0.40 },
  'Marine Shipping': { min: 0.15, max: 0.25 },
  'Medical Instruments & Supplies': { min: 0.30, max: 0.45 },
  'Oil & Gas Integrated': { min: 0.15, max: 0.25 },
  'Semiconductors': { min: 0.30, max: 0.45 },
  'Solar': { min: 0.25, max: 0.40 },
  'Specialty Industrial Machinery': { min: 0.25, max: 0.40 },
  'Utilities - Renewable': { min: 0.15, max: 0.25 },
  'Agricultural Inputs': { min: 0.15, max: 0.25 },
  'Apparel Retail': { min: 0.25, max: 0.40 },
  'Biotechnology': { min: 0.20, max: 0.30 },
  'Beverages - Wineries & Distilleries': { min: 0, max: 0 },
  'Chemicals': { min: 0.25, max: 0.40 },
  'Coking Coal': { min: 0.15, max: 0.25 },
  'Conglomerates': { min: 0.25, max: 0.40 },
  'Electronic Gaming & Multimedia': { min: 0.40, max: 0.55 },
  'Farm Products': { min: 0.15, max: 0.25 },
  'Healthcare Plans': { min: 0.25, max: 0.40 },
  'Industrial Distribution': { min: 0.20, max: 0.30 },
  'Internet Retail': { min: 0.20, max: 0.30 },
  'Oil & Gas Refining & Marketing': { min: 0.15, max: 0.25 },
  'Other Industrial Metals & Mining': { min: 0.15, max: 0.25 },
  'Pollution & Treatment Controls': { min: 0.25, max: 0.40 },
  'Railroads': { min: 0.25, max: 0.40 },
  'REIT - Specialty': { min: 0.15, max: 0.25 },
  'Residential Construction': { min: 0.20, max: 0.30 },
  'Security & Protection Services': { min: 0.25, max: 0.40 },
  'Software': { min: 0.40, max: 0.55 },
  'Specialty Business Services': { min: 0.25, max: 0.40 },
  'Steel': { min: 0.15, max: 0.25 },
  'Telecom Services': { min: 0.15, max: 0.25 },
  'Thermal Coal': { min: 0.15, max: 0.25 },
  'Utilities - Regulated Electric': { min: 0.15, max: 0.25 },
  'Utilities - Regulated Water': { min: 0.15, max: 0.25 },
  'Waste Management': { min: 0.20, max: 0.30 },
  'Computer Hardware': { min: 0.25, max: 0.40 },
  'Copper': { min: 0.15, max: 0.25 },
  'Drug Manufacturers - Specialty & Generic': { min: 0.25, max: 0.40 },
  'Electronic Components': { min: 0.25, max: 0.40 },
  'Engineering & Construction': { min: 0.20, max: 0.30 },
  'Farm & Heavy Construction Machinery': { min: 0.20, max: 0.30 },
  'Internet Content & Information': { min: 0.40, max: 0.55 },
  'Leisure': { min: 0.25, max: 0.40 },
  'Luxury Goods': { min: 0.30, max: 0.45 },
  'Medical Care Facilities': { min: 0.20, max: 0.30 },
  'Oil & Gas Midstream (Pipelines)': { min: 0.15, max: 0.25 },
  'Other Precious Metals & Mining': { min: 0.15, max: 0.25 },
  'Packaged Foods': { min: 0.20, max: 0.30 },
  'Packaging & Containers': { min: 0.20, max: 0.30 },
  'Real Estate Services': { min: 0.20, max: 0.30 },
  'Recreational Vehicles': { min: 0.20, max: 0.30 },
  'REIT - Industrial': { min: 0.15, max: 0.25 },
  'Scientific & Technical Instruments': { min: 0.30, max: 0.45 },
  'Aluminum': { min: 0.15, max: 0.25 },
  'Airlines': { min: 0.15, max: 0.25 },
  'Oil & Gas Midstream': { min: 0.15, max: 0.25 },
};

/**
 * Industry to Cash/SDebt mapping
 * Defines the expected min and max range for Cash/SDebt ratios by industry
 */
export const INDUSTRY_CASH_SDEBT_MAP: Record<string, { min: number; max: number }> = {
  'Oil & Gas Exploration & Production & Integrated & Equipment & Services & Drilling': { min: 0.7, max: 1.2 },
  'Discount Stores': { min: 0.6, max: 1.0 },
  'Airlines': { min: 0.8, max: 1.1 },
  'Drug Manufacturers - General': { min: 1.0, max: 1.5 },
  'Semiconductor Equipment & Materials': { min: 1.0, max: 1.5 },
  'Auto Parts': { min: 0.8, max: 1.1 },
  'Communication Equipment': { min: 0.8, max: 1.2 },
  'Information Technology Services': { min: 1.0, max: 1.5 },
  'Specialty Chemicals': { min: 0.7, max: 1.0 },
  'Building Products & Equipment': { min: 0.8, max: 1.2 },
  'Electrical Equipment & Parts': { min: 0.8, max: 1.1 },
  'Footwear & Accessories': { min: 0.6, max: 1.0 },
  'Gambling': { min: 0.8, max: 1.1 },
  'Marine Shipping': { min: 0.9, max: 1.3 },
  'Medical Instruments & Supplies': { min: 0.8, max: 1.2 },
  'Oil & Gas Integrated': { min: 0.7, max: 1.0 },
  'Semiconductors': { min: 1.2, max: 1.8 },
  'Solar': { min: 0.8, max: 1.2 },
  'Specialty Industrial Machinery': { min: 0.8, max: 1.1 },
  'Utilities - Renewable': { min: 0.7, max: 1.0 },
  'Agricultural Inputs': { min: 0.8, max: 1.1 },
  'Apparel Retail': { min: 0.6, max: 1.0 },
  'Biotechnology': { min: 1.2, max: 2.0 },
  'Beverages - Wineries & Distilleries': { min: 0, max: 0 },
  'Chemicals': { min: 0.7, max: 1.0 },
  'Coking Coal': { min: 0.8, max: 1.2 },
  'Conglomerates': { min: 0.8, max: 1.2 },
  'Electronic Gaming & Multimedia': { min: 1.0, max: 1.5 },
  'Farm Products': { min: 0.8, max: 1.1 },
  'Industrial Distribution': { min: 0.8, max: 1.1 },
  'Internet Retail': { min: 0.8, max: 1.2 },
  'Oil & Gas Refining & Marketing': { min: 0.8, max: 1.2 },
  'Other Industrial Metals & Mining': { min: 0.8, max: 1.2 },
  'Pollution & Treatment Controls': { min: 0.8, max: 1.1 },
  'Railroads': { min: 0.8, max: 1.1 },
  'REIT - Specialty': { min: 0.5, max: 0.8 },
  'Residential Construction': { min: 0.8, max: 1.2 },
  'Security & Protection Services': { min: 0.8, max: 1.2 },
  'Software': { min: 1.3, max: 2.0 },
  'Specialty Business Services': { min: 0.8, max: 1.2 },
  'Steel': { min: 0.8, max: 1.1 },
  'Telecom Services': { min: 0.6, max: 0.9 },
  'Thermal Coal': { min: 0.8, max: 1.2 },
  'Utilities - Regulated Electric': { min: 0.5, max: 0.8 },
  'Utilities - Regulated Water': { min: 0.5, max: 0.8 },
  'Waste Management': { min: 0.6, max: 0.9 },
  'Computer Hardware': { min: 0.9, max: 1.3 },
  'Copper': { min: 0.8, max: 1.2 },
  'Drug Manufacturers - Specialty & Generic': { min: 0.9, max: 1.3 },
  'Electronic Components': { min: 0.8, max: 1.2 },
  'Engineering & Construction': { min: 0.8, max: 1.2 },
  'Farm & Heavy Construction Machinery': { min: 0.8, max: 1.1 },
  'Internet Content & Information': { min: 1.0, max: 1.5 },
  'Leisure': { min: 0.8, max: 1.2 },
  'Luxury Goods': { min: 0.9, max: 1.3 },
  'Medical Care Facilities': { min: 0.7, max: 1.0 },
  'Oil & Gas Midstream (Pipelines)': { min: 0.6, max: 0.9 },
  'Other Precious Metals & Mining': { min: 0.8, max: 1.2 },
  'Packaged Foods': { min: 0.6, max: 0.9 },
  'Packaging & Containers': { min: 0.6, max: 0.9 },
  'Real Estate Services': { min: 0.8, max: 1.2 },
  'Recreational Vehicles': { min: 0.8, max: 1.2 },
  'REIT - Industrial': { min: 0.5, max: 0.8 },
  'Scientific & Technical Instruments': { min: 0.8, max: 1.2 },
  'Aluminum': { min: 0.8, max: 1.2 },
  'Capital Markets': { min: 0.8, max: 1.2 },
  'Healthcare Plans': { min: 0.8, max: 1.2 },
  'Oil & Gas Midstream': { min: 0.6, max: 0.9 },
};

/**
 * Industry to Current Ratio mapping
 * Defines the expected min and max range for Current Ratio values by industry
 */
export const INDUSTRY_CURRENT_RATIO_MAP: Record<string, { min: number; max: number }> = {
  'Agricultural Inputs': { min: 1.1, max: 2.0 },
  'Airlines': { min: 0.5, max: 1.2 },
  'Aluminum': { min: 1.1, max: 2.2 },
  'Apparel Retail': { min: 0.8, max: 1.5 },
  'Auto Parts': { min: 1.1, max: 1.8 },
  'Biotechnology': { min: 1.5, max: 4.0 },
  'Beverages - Wineries & Distilleries': { min: 0, max: 0 },
  'Building Products & Equipment': { min: 1.2, max: 2.0 },
  'Capital Markets': { min: 1.0, max: 1.4 },
  'Chemicals': { min: 1.2, max: 2.0 },
  'Coking Coal': { min: 1.1, max: 2.0 },
  'Communication Equipment': { min: 1.2, max: 2.0 },
  'Computer Hardware': { min: 1.2, max: 2.0 },
  'Conglomerates': { min: 1.2, max: 2.0 },
  'Copper': { min: 1.2, max: 2.5 },
  'Discount Stores': { min: 0.8, max: 1.4 },
  'Drug Manufacturers - General': { min: 1.3, max: 2.5 },
  'Drug Manufacturers - Specialty & Generic': { min: 1.2, max: 2.2 },
  'Electrical Equipment & Parts': { min: 1.2, max: 2.0 },
  'Electronic Components': { min: 1.2, max: 2.0 },
  'Electronic Gaming & Multimedia': { min: 1.0, max: 2.0 },
  'Engineering & Construction': { min: 1.1, max: 1.8 },
  'Farm & Heavy Construction Machinery': { min: 1.2, max: 2.0 },
  'Farm Products': { min: 1.1, max: 2.0 },
  'Footwear & Accessories': { min: 1.1, max: 2.0 },
  'Gambling': { min: 0.9, max: 1.5 },
  'Healthcare Plans': { min: 1.0, max: 1.6 },
  'Industrial Distribution': { min: 1.0, max: 1.8 },
  'Information Technology Services': { min: 1.0, max: 1.8 },
  'Internet Content & Information': { min: 1.0, max: 2.0 },
  'Internet Retail': { min: 0.8, max: 1.5 },
  'Leisure': { min: 1.0, max: 1.6 },
  'Luxury Goods': { min: 1.2, max: 2.2 },
  'Marine Shipping': { min: 1.0, max: 2.0 },
  'Medical Care Facilities': { min: 1.0, max: 1.7 },
  'Medical Instruments & Supplies': { min: 1.5, max: 3.0 },
  'Oil & Gas Exploration & Production & Integrated & Equipment & Services & Drilling': { min: 1.0, max: 1.8 },
  'Oil & Gas Integrated': { min: 0.9, max: 1.5 },
  'Oil & Gas Midstream (Pipelines)': { min: 0.9, max: 1.4 },
  'Oil & Gas Refining & Marketing': { min: 0.9, max: 1.5 },
  'Other Industrial Metals & Mining': { min: 1.2, max: 2.5 },
  'Other Precious Metals & Mining': { min: 1.5, max: 3.0 },
  'Packaged Foods': { min: 1.0, max: 1.8 },
  'Packaging & Containers': { min: 1.1, max: 1.9 },
  'Pollution & Treatment Controls': { min: 1.2, max: 2.0 },
  'Railroads': { min: 0.9, max: 1.5 },
  'Real Estate Services': { min: 1.0, max: 1.6 },
  'Recreational Vehicles': { min: 1.2, max: 2.2 },
  'REIT - Industrial': { min: 0.7, max: 1.3 },
  'REIT - Specialty': { min: 0.7, max: 1.3 },
  'Residential Construction': { min: 2.0, max: 4.0 },
  'Scientific & Technical Instruments': { min: 1.3, max: 2.2 },
  'Security & Protection Services': { min: 1.0, max: 1.6 },
  'Semiconductor Equipment & Materials': { min: 1.2, max: 2.5 },
  'Semiconductors': { min: 1.2, max: 2.0 },
  'Software': { min: 0.6, max: 1.5 },
  'Solar': { min: 1.1, max: 2.0 },
  'Specialty Business Services': { min: 1.0, max: 1.6 },
  'Specialty Chemicals': { min: 1.2, max: 2.0 },
  'Specialty Industrial Machinery': { min: 1.2, max: 2.0 },
  'Steel': { min: 1.1, max: 2.2 },
  'Telecom Services': { min: 0.8, max: 1.3 },
  'Thermal Coal': { min: 1.1, max: 2.0 },
  'Utilities - Regulated Electric': { min: 0.8, max: 1.2 },
  'Utilities - Regulated Water': { min: 0.8, max: 1.3 },
  'Utilities - Renewable': { min: 1.0, max: 1.8 },
  'Waste Management': { min: 0.9, max: 1.4 },
  'Oil & Gas Midstream': { min: 0.9, max: 1.4 },
};


```

## `src/config/tableMetadata.ts`

```typescript
import { TableMetadata } from '../types/columnMetadata';

export const tableMetadata: TableMetadata[] = [
  {
    tableId: 'benjamin-graham',
    columns: [
      {
        columnKey: 'companyName',
        dataSource: 'Dashboard sheet, kolumn "Company Name"',
        conditions: [
          'Filtrera bort rader där Company Name är N/A eller tomt',
          'Filtrera bort rader där Ticker är N/A (Dashboard regel)'
        ]
      },
      {
        columnKey: 'ticker',
        dataSource: 'Dashboard sheet, kolumn "Ticker"',
        conditions: [
          'Filtrera bort rader där Ticker är N/A (Dashboard regel)',
          'Filtrera bort rader där Company Name är N/A'
        ]
      },
      {
        columnKey: 'currency',
        dataSource: 'Manuell inmatning via dropdown',
        conditions: [
          'Användaren väljer valuta från dropdown-lista',
          'Standardvärde är USD',
          'Tillgängliga valutor: USD, EUR, SEK, DKK, NOK, GBP, AUD, CAD, NZD'
        ]
      },
      {
        columnKey: 'entry1',
        dataSource: 'Manuell inmatning',
        conditions: [
          'Användaren fyller i värdet manuellt',
          'Värdet är numeriskt',
          'Date of Update uppdateras automatiskt när värdet ändras',
          'Används för beräkning av RR1: (Exit1 - Entry1) / Entry1 * 100'
        ]
      },
      {
        columnKey: 'entry2',
        dataSource: 'Manuell inmatning',
        conditions: [
          'Användaren fyller i värdet manuellt',
          'Värdet är numeriskt',
          'Date of Update uppdateras automatiskt när värdet ändras',
          'Används för beräkning av RR2: (Exit2 - Entry2) / Entry2 * 100'
        ]
      },
      {
        columnKey: 'exit1',
        dataSource: 'Manuell inmatning',
        conditions: [
          'Användaren fyller i värdet manuellt',
          'Värdet är numeriskt',
          'Date of Update uppdateras automatiskt när värdet ändras',
          'Används för beräkning av RR1: (Exit1 - Entry1) / Entry1 * 100'
        ]
      },
      {
        columnKey: 'exit2',
        dataSource: 'Manuell inmatning',
        conditions: [
          'Användaren fyller i värdet manuellt',
          'Värdet är numeriskt',
          'Date of Update uppdateras automatiskt när värdet ändras',
          'Används för beräkning av RR2: (Exit2 - Entry2) / Entry2 * 100'
        ]
      },
      {
        columnKey: 'dateOfUpdate',
        dataSource: 'Automatiskt beräknat',
        conditions: [
          'Uppdateras automatiskt när ENTRY1, ENTRY2, EXIT1 eller EXIT2 ändras',
          'Raderas om alla manuella fält (ENTRY1, ENTRY2, EXIT1, EXIT2) är tomma',
          'Visas i rött om datumet är äldre än idag och det finns värden i fälten',
          'Format: YYYY-MM-DD (endast datum, ingen tid)'
        ]
      },
      {
        columnKey: 'price',
        dataSource: 'Dashboard sheet, kolumn "Price"',
        conditions: [
          'Visa N/A om värdet är null eller ogiltigt',
          'Visa faktiska 0-värden som "0"',
          'Filtrera bort rader där Company Name eller Ticker är N/A'
        ]
      },
      {
        columnKey: 'benjaminGraham',
        dataSource: 'Dashboard sheet, kolumn "Benjamin Graham"',
        conditions: [
          'Visa N/A om värdet är null eller ogiltigt',
          'Visa faktiska 0-värden som "0"',
          'Röd färg om värdet är negativt (< 0)',
          'Grön färg om Price är inom +5% av Benjamin Graham-värdet (price <= benjaminGraham * 1.05)',
          'Filtrera bort rader där Company Name eller Ticker är N/A'
        ]
      },
      {
        columnKey: 'ivFcf',
        dataSource: 'Dashboard sheet, kolumn "IV (FCF)"',
        conditions: [
          'Visa N/A om värdet är null eller ogiltigt',
          'Filtrera bort rader där Company Name eller Ticker är N/A'
        ]
      },
      {
        columnKey: 'irr1',
        dataSource: 'Beräknat från Entry/Exit-värden',
        formula: 'RR1 = (Exit1 - Entry1) / Entry1 * 100',
        conditions: [
          'Beräknas från Entry1 och Exit1 värden',
          'Visa N/A om Entry1 eller Exit1 saknas eller är 0',
          'Formateras som procent med %-tecken och noll decimaler',
          'Grön färg om RR1 >= 60% OCH Price <= Entry1 * 1.05',
          'Filtrera bort rader där Company Name eller Ticker är N/A'
        ]
      },
      {
        columnKey: 'rr2',
        dataSource: 'Beräknat från Entry/Exit-värden',
        formula: 'RR2 = (Exit2 - Entry2) / Entry2 * 100',
        conditions: [
          'Beräknas från Entry2 och Exit2 värden',
          'Visa N/A om Entry2 eller Exit2 saknas eller är 0',
          'Formateras som procent med %-tecken och noll decimaler',
          'Grön färg om RR2 >= 90% OCH Price <= Entry2 * 1.05',
          'Filtrera bort rader där Company Name eller Ticker är N/A'
        ]
      }
    ]
  },
  {
    tableId: 'pe-industry',
    columns: [
      {
        columnKey: 'industry',
        dataSource: 'Dashboard sheet, kolumn "INDUSTRY"',
        conditions: [
          'Filtrera bort rader där Industry är N/A eller tomt',
          'Filtrera bort rader där Company Name eller Ticker är N/A',
          'Gruppera rader per Industry'
        ]
      },
      {
        columnKey: 'pe',
        dataSource: 'Dashboard sheet, kolumn "P/E"',
        formula: 'Median(P/E per industry)',
        conditions: [
          'Filtrera bort N/A och ogiltiga värden',
          'Beräkna median för alla P/E-värden per industry',
          'Visa N/A om inga giltiga värden finns (0-värden visas som "0.00")',
          'Filtrera bort rader där Industry, Company Name eller Ticker är N/A'
        ]
      },
      {
        columnKey: 'pe1',
        dataSource: 'Dashboard sheet, kolumn "P/E1"',
        formula: 'Median(P/E1 per industry)',
        conditions: [
          'Filtrera bort N/A och ogiltiga värden',
          'Beräkna median för alla P/E1-värden per industry',
          'Visa N/A om inga giltiga värden finns (0-värden visas som "0.00")',
          'Filtrera bort rader där Industry, Company Name eller Ticker är N/A'
        ]
      },
      {
        columnKey: 'pe2',
        dataSource: 'Dashboard sheet, kolumn "P/E2"',
        formula: 'Median(P/E2 per industry)',
        conditions: [
          'Filtrera bort N/A och ogiltiga värden',
          'Beräkna median för alla P/E2-värden per industry',
          'Visa N/A om inga giltiga värden finns (0-värden visas som "0.00")',
          'Filtrera bort rader där Industry, Company Name eller Ticker är N/A'
        ]
      },
      {
        columnKey: 'companyCount',
        dataSource: 'Beräknat från Dashboard sheet',
        formula: 'Count(företag per industry)',
        conditions: [
          'Räkna antal företag per industry',
          'Endast räkna företag där Industry, Company Name och Ticker är giltiga (inte N/A)'
        ]
      }
    ]
  },
  {
    tableId: 'score',
    columns: [
      {
        columnKey: 'antal',
        dataSource: 'Beräknat (radnummer i tabellen)',
        conditions: [
          'Automatiskt genererat radnummer',
          'Visas endast för identifiering av position i listan'
        ]
      },
      {
        columnKey: 'companyName',
        dataSource: 'Dashboard sheet, kolumn "Company Name"',
        conditions: [
          'Filtrera bort rader där Company Name är N/A eller tomt',
          'Filtrera bort rader där Ticker är N/A (Dashboard regel)'
        ]
      },
      {
        columnKey: 'ticker',
        dataSource: 'Dashboard sheet, kolumn "Ticker"',
        conditions: [
          'Filtrera bort rader där Ticker är N/A (Dashboard regel)',
          'Filtrera bort rader där Company Name är N/A'
        ]
      },
      {
        columnKey: 'currency',
        dataSource: 'Speglat från Entry/Exit-tabellen',
        conditions: [
          'Skrivskyddad kolumn som endast visar värdet från Entry/Exit-tabellen',
          'Standardvärde är USD om currency saknas',
          'Tillgängliga valutor: USD, EUR, SEK, DKK, NOK, GBP, AUD, CAD, NZD',
          'Currency kan endast redigeras i Entry/Exit-tabellen'
        ]
      },
      {
        columnKey: 'price',
        dataSource: 'Speglat från Entry/Exit-tabellen',
        conditions: [
          'Skrivskyddad kolumn som endast visar värdet från Entry/Exit-tabellen',
          'Visa N/A om värdet är null eller ogiltigt',
          'Visa faktiska 0-värden som "0"',
          'Price kan endast redigeras i Entry/Exit-tabellen'
        ]
      },
      {
        columnKey: 'entry1',
        dataSource: 'Speglat från Entry/Exit-tabellen',
        conditions: [
          'Skrivskyddad kolumn som endast visar värdet från Entry/Exit-tabellen',
          'Visar numeriskt värde om det finns, annars "-"',
          'Entry1 kan endast redigeras i Entry/Exit-tabellen',
          'Används för beräkning av RR1: (Exit1 - Entry1) / Entry1 * 100'
        ]
      },
      {
        columnKey: 'entry2',
        dataSource: 'Speglat från Entry/Exit-tabellen',
        conditions: [
          'Skrivskyddad kolumn som endast visar värdet från Entry/Exit-tabellen',
          'Visar numeriskt värde om det finns, annars "-"',
          'Entry2 kan endast redigeras i Entry/Exit-tabellen',
          'Används för beräkning av RR2: (Exit2 - Entry2) / Entry2 * 100'
        ]
      },
      {
        columnKey: 'exit1',
        dataSource: 'Speglat från Entry/Exit-tabellen',
        conditions: [
          'Skrivskyddad kolumn som endast visar värdet från Entry/Exit-tabellen',
          'Visar numeriskt värde om det finns, annars "-"',
          'Exit1 kan endast redigeras i Entry/Exit-tabellen',
          'Används för beräkning av RR1: (Exit1 - Entry1) / Entry1 * 100'
        ]
      },
      {
        columnKey: 'exit2',
        dataSource: 'Speglat från Entry/Exit-tabellen',
        conditions: [
          'Skrivskyddad kolumn som endast visar värdet från Entry/Exit-tabellen',
          'Visar numeriskt värde om det finns, annars "-"',
          'Exit2 kan endast redigeras i Entry/Exit-tabellen',
          'Används för beräkning av RR2: (Exit2 - Entry2) / Entry2 * 100'
        ]
      },
      {
        columnKey: 'score',
        dataSource: 'Beräknat från Score Board data med viktat poängsystem',
        formula: 'Summa av (vikt × färgfaktor) för alla metrics, där färgfaktor = 1.0 (grön), 0.7 (blå), 0.0 (röd/tom/N/A)',
        conditions: [
          'Poängsystem från 0-100',
          'Beräknas baserat på färgkodning i SCORE BOARD',
          'Fundamental metrics (50p totalt):',
          '  - VALUE CREATION (vikt: 7)',
          '  - Munger Quality Score (vikt: 7)',
          '  - IRR (vikt: 6)',
          '  - Ro40 F1 (vikt: 3)',
          '  - Ro40 F2 (vikt: 3)',
          '  - LEVERAGE F2 (vikt: 4)',
          '  - Cash/SDebt (vikt: 5)',
          '  - Current Ratio (vikt: 3)',
          '  - P/E1 INDUSTRY (vikt: 5)',
          '  - P/E2 INDUSTRY (vikt: 5)',
          '  - (TB/S)/Price (vikt: 2)',
          'Technical metrics (50p totalt):',
          '  - THEOENTRY (vikt: 40)',
          '  - SMA(100) (vikt: 2.5)',
          '  - SMA(200) (vikt: 2.5)',
          '  - SMA CROSS (vikt: 5)',
          'Färgmarkering:',
          '  - GRÖN om score >= 70',
          '  - BLÅ om score >= 45',
          '  - GRÅ om score < 45',
          'Hovra över score-värde för detaljerad breakdown'
        ]
      }
    ]
  },
  {
    tableId: 'score-board',
    columns: [
      {
        columnKey: 'companyName',
        dataSource: 'Dashboard sheet, kolumn "Company Name"',
        conditions: [
          'Filtrera bort rader där Company Name är N/A eller tomt',
          'Filtrera bort rader där Ticker är N/A (Dashboard regel)'
        ]
      },
      {
        columnKey: 'ticker',
        dataSource: 'Dashboard sheet, kolumn "Ticker"',
        conditions: [
          'Filtrera bort rader där Ticker är N/A (Dashboard regel)',
          'Filtrera bort rader där Company Name är N/A'
        ]
      },
      {
        columnKey: 'irr',
        dataSource: 'Dashboard sheet, kolumn "IRR"',
        conditions: [
          'Visa N/A om värdet är null eller ogiltigt',
          'Visa faktiska 0-värden som "0%"',
          'Formateras som procent med %-tecken och noll decimaler',
          'Filtrera bort rader där Company Name eller Ticker är N/A',
          'Färgmarkering baserat på threshold-värden från Threshold Industry:',
          '  - GRÖN om IRR >= IRR threshold (från Threshold Industry baserat på industry)',
          '  - RÖD om IRR < IRR threshold (från Threshold Industry baserat på industry)',
          '  - Ingen färg om industry inte hittas eller värdet är null/N/A'
        ]
      },
      {
        columnKey: 'mungerQualityScore',
        dataSource: 'Dashboard sheet, kolumn "Munger Quality Score"',
        conditions: [
          'Visa N/A om värdet är null eller ogiltigt',
          'Visa faktiska 0-värden som "0"',
          'Röd färg om värdet är mindre än 40',
          'Blå färg om värdet är mellan 40 och 60',
          'Grön färg om värdet är över 60',
          'Filtrera bort rader där Company Name eller Ticker är N/A'
        ]
      },
      {
        columnKey: 'valueCreation',
        dataSource: 'Dashboard sheet, kolumn "VALUE CREATION"',
        formula: 'Value Creation är genomsnitt för senaste 5 årets ROC - WACC',
        conditions: [
          'Visa N/A om värdet är null eller ogiltigt',
          'Visa faktiska 0-värden som "0.00%"',
          'Formateras som procent med %-tecken och två decimaler',
          'Röd färg om värdet är mindre än 0',
          'Grön färg om värdet är >= 0',
          'Filtrera bort rader där Company Name eller Ticker är N/A'
        ]
      },
      {
        columnKey: 'tbSPrice',
        dataSource: 'Dashboard sheet, kolumn "(TB/S)/Price"',
        formula: 'Hämtas direkt från kolumnen (TB/S)/Price',
        conditions: [
          'Hämtas direkt från kolumnen "(TB/S)/Price" i Dashboard sheet',
          'Visa N/A om värdet är null',
          'Formateras med två decimaler',
          'Filtrera bort rader där Company Name eller Ticker är N/A',
          'Färgmarkering:',
          '  - RÖD om (TB/S)/Price < 1.00',
          '  - GRÖN om (TB/S)/Price ≥ 1.00',
          '  - Ingen färg om värdet är null eller ogiltigt'
        ]
      },
      {
        columnKey: 'ro40F1',
        dataSource: 'Dashboard sheet, kolumn "Ro40 F1"',
        conditions: [
          'Visa N/A om värdet är null eller ogiltigt',
          'Visa faktiska 0-värden som "0.0%"',
          'Formateras som procent med %-tecken och en decimal',
          'Filtrera bort rader där Company Name eller Ticker är N/A',
          'Färgmarkering baserat på threshold-värden från Threshold Industry:',
          '  - RÖD om Ro40-värdet ≤ RO40 MIN (från Threshold Industry baserat på industry)',
          '  - GRÖN om Ro40-värdet ≥ RO40 MAX (från Threshold Industry baserat på industry)',
          '  - BLÅ om RO40 MIN < Ro40-värdet < RO40 MAX (från Threshold Industry baserat på industry)',
          '  - Ingen färg om industry inte hittas eller värdet är null/N/A',
          'Konverterar procent till decimal för jämförelse (t.ex. 25.0% → 0.25)'
        ]
      },
      {
        columnKey: 'ro40F2',
        dataSource: 'Dashboard sheet, kolumn "Ro40 F2"',
        conditions: [
          'Visa N/A om värdet är null eller ogiltigt',
          'Visa faktiska 0-värden som "0.0%"',
          'Formateras som procent med %-tecken och en decimal',
          'Filtrera bort rader där Company Name eller Ticker är N/A',
          'Färgmarkering baserat på threshold-värden från Threshold Industry:',
          '  - RÖD om Ro40-värdet ≤ RO40 MIN (från Threshold Industry baserat på industry)',
          '  - GRÖN om Ro40-värdet ≥ RO40 MAX (från Threshold Industry baserat på industry)',
          '  - BLÅ om RO40 MIN < Ro40-värdet < RO40 MAX (från Threshold Industry baserat på industry)',
          '  - Ingen färg om industry inte hittas eller värdet är null/N/A',
          'Konverterar procent till decimal för jämförelse (t.ex. 25.0% → 0.25)'
        ]
      },
      {
        columnKey: 'currentRatio',
        dataSource: 'Dashboard sheet, kolumn "Current Ratio"',
        conditions: [
          'Visa N/A om värdet är null eller ogiltigt',
          'Visa faktiska 0-värden som "0.00"',
          'Formateras med två decimaler',
          'Filtrera bort rader där Company Name eller Ticker är N/A',
          'Färgmarkering baserat på threshold-värden från Threshold Industry:',
          '  - RÖD om Current Ratio < Current Ratio MIN (från Threshold Industry baserat på industry)',
          '  - GRÖN om Current Ratio MIN ≤ Current Ratio < Current Ratio MAX (från Threshold Industry baserat på industry)',
          '  - BLÅ om Current Ratio ≥ Current Ratio MAX (från Threshold Industry baserat på industry)',
          '  - Ingen färg om industry inte hittas eller värdet är null/N/A'
        ]
      },
      {
        columnKey: 'cashSdebt',
        dataSource: 'Dashboard sheet, kolumn "Cash/SDebt"',
        conditions: [
          'Visa N/A om värdet är null eller ogiltigt',
          'Visa faktiska 0-värden som "0.00"',
          'Formateras med två decimaler',
          'Filtrera bort rader där Company Name eller Ticker är N/A',
          'Färgmarkering baserat på threshold-värden från Threshold Industry:',
          '  - GRÖN om division-by-zero (#DIV/0!)',
          '  - RÖD om Cash/SDebt ≤ Cash/SDebt MIN (från Threshold Industry baserat på industry)',
          '  - GRÖN om Cash/SDebt ≥ Cash/SDebt MAX (från Threshold Industry baserat på industry)',
          '  - BLÅ om Cash/SDebt MIN < Cash/SDebt < Cash/SDebt MAX (från Threshold Industry baserat på industry)',
          '  - Ingen färg om industry inte hittas eller värdet är null/N/A'
        ]
      },
      {
        columnKey: 'leverageF2',
        dataSource: 'Dashboard sheet, kolumn "Leverage F2"',
        conditions: [
          'Visa N/A om värdet är null eller ogiltigt',
          'Visa faktiska 0-värden som "0"',
          'Filtrera bort rader där Company Name eller Ticker är N/A',
          'Färgmarkering baserat på threshold-värden från Threshold Industry:',
          '  - GRÖN om Leverage F2 ≤ Leverage F2 MIN (från Threshold Industry baserat på industry)',
          '  - BLÅ om Leverage F2 MIN < Leverage F2 ≤ Leverage F2 MAX (från Threshold Industry baserat på industry)',
          '  - RÖD om Leverage F2 > Leverage F2 MAX (från Threshold Industry baserat på industry)',
          '  - Ingen färg om industry inte hittas eller värdet är null/N/A'
        ]
      },
      {
        columnKey: 'pe1Industry',
        dataSource: 'Dashboard sheet, kolumn "P/E1" jämfört med P/E INDUSTRY tabell, kolumn "P/E1 INDUSTRY" (median)',
        conditions: [
          'Beräknar procentuell skillnad: (P/E1 från Dashboard - P/E1 INDUSTRY från P/E INDUSTRY) / P/E1 INDUSTRY från P/E INDUSTRY * 100',
          'Visa N/A om värdet är null eller om industry inte hittas i P/E INDUSTRY tabellen',
          'Visa faktiska 0-värden som "0.0%"',
          'Formateras som procent med %-tecken och en decimal',
          'Filtrera bort rader där Company Name eller Ticker är N/A',
          'Matchar industry från Dashboard med industry i P/E INDUSTRY tabellen (case-insensitive)',
          'Röd färg om procenttalet > 0, grön färg om procenttalet <= 0'
        ]
      },
      {
        columnKey: 'pe2Industry',
        dataSource: 'Dashboard sheet, kolumn "P/E2" jämfört med P/E INDUSTRY tabell, kolumn "P/E2 INDUSTRY" (median)',
        conditions: [
          'Beräknar procentuell skillnad: (P/E2 från Dashboard - P/E2 INDUSTRY från P/E INDUSTRY) / P/E2 INDUSTRY från P/E INDUSTRY * 100',
          'Visa N/A om värdet är null eller om industry inte hittas i P/E INDUSTRY tabellen',
          'Visa faktiska 0-värden som "0.0%"',
          'Formateras som procent med %-tecken och en decimal',
          'Filtrera bort rader där Company Name eller Ticker är N/A',
          'Matchar industry från Dashboard med industry i P/E INDUSTRY tabellen (case-insensitive)',
          'Röd färg om procenttalet > 0, grön färg om procenttalet <= 0'
        ]
      },
      {
        columnKey: 'sma100',
        dataSource: 'SMA tabell (Technical section), kolumn "SMA(100)"',
        conditions: [
          'Hämtas från SMA tabellen i Technical section',
          'Matchas med Score Board data baserat på Ticker (case-insensitive)',
          'Visa N/A om värdet är null eller om ticker inte hittas i SMA tabellen',
          'Visa faktiska 0-värden som "0.00"',
          'Formateras med två decimaler',
          'Färgmarkering baserat på jämförelse med Price från ENTRY/EXIT tabellen:',
          '  - GRÖN om Price > SMA(100)',
          '  - RÖD om Price < SMA(100)',
          '  - GUL om Price == SMA(100)',
          '  - Ingen färg om Price eller SMA(100) saknas'
        ]
      },
      {
        columnKey: 'sma200',
        dataSource: 'SMA tabell (Technical section), kolumn "SMA(200)"',
        conditions: [
          'Hämtas från SMA tabellen i Technical section',
          'Matchas med Score Board data baserat på Ticker (case-insensitive)',
          'Visa N/A om värdet är null eller om ticker inte hittas i SMA tabellen',
          'Visa faktiska 0-värden som "0.00"',
          'Formateras med två decimaler',
          'Färgmarkering baserat på jämförelse med Price från ENTRY/EXIT tabellen:',
          '  - GRÖN om Price > SMA(200)',
          '  - RÖD om Price < SMA(200)',
          '  - GUL om Price == SMA(200)',
          '  - Ingen färg om Price eller SMA(200) saknas'
        ]
      },
      {
        columnKey: 'smaCross',
        dataSource: 'SMA tabell (Technical section), kolumn "SMA Cross"',
        conditions: [
          'Hämtas från SMA tabellen i Technical section',
          'Matchas med Score Board data baserat på Ticker (case-insensitive)',
          'Visa N/A om ticker inte hittas i SMA tabellen',
          'Röd färg om texten innehåller "GOLDEN"',
          'Grön färg om texten innehåller "DEATH"'
        ]
      }
    ]
  },
  {
    tableId: 'threshold-industry',
    columns: [
      {
        columnKey: 'industry',
        dataSource: 'Dashboard sheet, kolumn "INDUSTRY"',
        conditions: [
          'Hämtar alla unika industries från Dashboard',
          'Filtrera bort rader där Industry är N/A, tomt eller ogiltigt',
          'Varje industry visas endast en gång (inga dubbletter)',
          'Sorteras alfabetiskt'
        ]
      },
      {
        columnKey: 'irr',
        dataSource: 'Dashboard sheet, kolumn "IRR"',
        conditions: [
          'Kan redigeras manuellt',
          'Används som threshold för färgmarkering av IRR-kolumnen i SCORE BOARD',
          'Matchning sker baserat på industry (case-insensitive)'
        ]
      },
      {
        columnKey: 'leverageF2Min',
        dataSource: 'Auto-fylld baserat på industry mapping (Green_Max värde)',
        conditions: [
          'Auto-fylld baserat på industry namn',
          'Kan redigeras manuellt',
          'Visa 0 om industry inte hittas i mappningen'
        ]
      },
      {
        columnKey: 'leverageF2Max',
        dataSource: 'Auto-fylld baserat på industry mapping (Red_Min värde)',
        conditions: [
          'Auto-fylld baserat på industry namn',
          'Kan redigeras manuellt',
          'Visa 0 om industry inte hittas i mappningen'
        ]
      },
      {
        columnKey: 'ro40Min',
        dataSource: 'Auto-fylld baserat på industry mapping (Min värde)',
        conditions: [
          'Auto-fylld baserat på industry namn',
          'Kan redigeras manuellt',
          'Visa 0 om industry inte hittas i mappningen'
        ]
      },
      {
        columnKey: 'ro40Max',
        dataSource: 'Auto-fylld baserat på industry mapping (Max värde)',
        conditions: [
          'Auto-fylld baserat på industry namn',
          'Kan redigeras manuellt',
          'Visa 0 om industry inte hittas i mappningen'
        ]
      },
      {
        columnKey: 'cashSdebtMin',
        dataSource: 'Auto-fylld baserat på industry mapping (Min värde)',
        conditions: [
          'Auto-fylld baserat på industry namn',
          'Kan redigeras manuellt',
          'Visa 0 om industry inte hittas i mappningen'
        ]
      },
      {
        columnKey: 'cashSdebtMax',
        dataSource: 'Auto-fylld baserat på industry mapping (Max värde)',
        conditions: [
          'Auto-fylld baserat på industry namn',
          'Kan redigeras manuellt',
          'Visa 0 om industry inte hittas i mappningen'
        ]
      },
      {
        columnKey: 'currentRatioMin',
        dataSource: 'Auto-fylld baserat på industry mapping (Min värde)',
        conditions: [
          'Auto-fylld baserat på industry namn',
          'Kan redigeras manuellt',
          'Visa 0 om industry inte hittas i mappningen'
        ]
      },
      {
        columnKey: 'currentRatioMax',
        dataSource: 'Auto-fylld baserat på industry mapping (Max värde)',
        conditions: [
          'Auto-fylld baserat på industry namn',
          'Kan redigeras manuellt',
          'Visa 0 om industry inte hittas i mappningen'
        ]
      }
    ]
  },
  {
    tableId: 'sma-100',
    columns: [
      {
        columnKey: 'companyName',
        dataSource: 'Dashboard sheet, kolumn "Company Name"',
        conditions: [
          'Filtrera bort rader där Company Name är N/A eller tomt',
          'Filtrera bort rader där Ticker är N/A (Dashboard regel)'
        ]
      },
      {
        columnKey: 'ticker',
        dataSource: 'Dashboard sheet, kolumn "Ticker"',
        conditions: [
          'Filtrera bort rader där Ticker är N/A (Dashboard regel)',
          'Filtrera bort rader där Company Name är N/A'
        ]
      },
      {
        columnKey: 'sma100',
        dataSource: 'SMA sheet (gid=1413104083), kolumn "SMA(100)"',
        conditions: [
          'Visa faktiska 0-värden som "0.00"',
          'Filtrera bort rader där Company Name eller Ticker är N/A'
        ]
      },
      {
        columnKey: 'sma200',
        dataSource: 'SMA sheet (gid=1413104083), kolumn "SMA(200)"',
        conditions: [
          'Visa faktiska 0-värden som "0.00"',
          'Filtrera bort rader där Company Name eller Ticker är N/A'
        ]
      },
      {
        columnKey: 'smaCross',
        dataSource: 'SMA sheet (gid=1413104083), kolumn "SMA Cross"',
        conditions: [
          'Kolumnen innehåller text, inte nummer',
          'Filtrera bort rader där Company Name eller Ticker är N/A',
          'Visa tom sträng om värdet är N/A eller tomt'
        ]
      }
    ]
  },
  {
    tableId: 'personal-portfolio',
    columns: [
      {
        columnKey: 'rowNumber',
        dataSource: 'Radnummer i tabellen',
        conditions: [
          'Visar radnummer (1, 2, 3, …) för identifiering',
          'Klicka på pilen för att expandera och se fördelning per broker'
        ]
      },
      {
        columnKey: 'currency',
        dataSource: 'Speglat från Entry/Exit-tabellen',
        conditions: [
          'Standardvärde är USD om currency saknas',
          'Currency kan endast redigeras i Entry/Exit-tabellen'
        ]
      }
    ]
  }
];

export function getTableMetadata(tableId: string): TableMetadata | undefined {
  return tableMetadata.find(meta => meta.tableId === tableId);
}

export function getColumnMetadata(tableId: string, columnKey: string) {
  const table = getTableMetadata(tableId);
  return table?.columns.find(col => col.columnKey === columnKey);
}


```

## `src/config/thresholdIndustryData.ts`

```typescript
/**
 * Static Threshold Industry Data
 * 
 * This file contains the static threshold industry data that was previously
 * fetched from Google Sheets. The data is generated from industry threshold
 * mappings in industryThresholds.ts.
 * 
 * Manual changes to threshold values are persisted in Firestore and localStorage
 * via ThresholdContext.
 */

import { ThresholdIndustryData } from '../types/stock';
import {
  INDUSTRY_IRR_MAP,
  INDUSTRY_LEVERAGE_F2_MAP,
  INDUSTRY_RO40_MAP,
  INDUSTRY_CASH_SDEBT_MAP,
  INDUSTRY_CURRENT_RATIO_MAP,
} from './industryThresholds';

/**
 * Generate threshold industry data from mappings
 * Uses all industries found across all mapping files
 */
function generateThresholdIndustryData(): ThresholdIndustryData[] {
  // Collect all unique industries from all mappings
  const industrySet = new Set<string>();
  
  // Add industries from all maps
  Object.keys(INDUSTRY_IRR_MAP).forEach(industry => industrySet.add(industry));
  Object.keys(INDUSTRY_LEVERAGE_F2_MAP).forEach(industry => industrySet.add(industry));
  Object.keys(INDUSTRY_RO40_MAP).forEach(industry => industrySet.add(industry));
  Object.keys(INDUSTRY_CASH_SDEBT_MAP).forEach(industry => industrySet.add(industry));
  Object.keys(INDUSTRY_CURRENT_RATIO_MAP).forEach(industry => industrySet.add(industry));
  
  // Convert to sorted array and map to ThresholdIndustryData
  const industries = Array.from(industrySet).sort();
  
  return industries.map((industry) => {
    // Get IRR value (default to 0 if not found)
    const irrValue = INDUSTRY_IRR_MAP[industry] ?? 0;
    
    // Get Leverage F2 values (default to { min: 0, max: 0 } if not found)
    const leverageF2Map = INDUSTRY_LEVERAGE_F2_MAP[industry];
    const leverageF2Values = leverageF2Map
      ? { min: leverageF2Map.greenMax, max: leverageF2Map.redMin }
      : { min: 0, max: 0 };
    
    // Get RO40 values (default to { min: 0, max: 0 } if not found)
    const ro40Values = INDUSTRY_RO40_MAP[industry] ?? { min: 0, max: 0 };
    
    // Get Cash/SDebt values (default to { min: 0, max: 0 } if not found)
    const cashSdebtValues = INDUSTRY_CASH_SDEBT_MAP[industry] ?? { min: 0, max: 0 };
    
    // Get Current Ratio values (default to { min: 0, max: 0 } if not found)
    const currentRatioValues = INDUSTRY_CURRENT_RATIO_MAP[industry] ?? { min: 0, max: 0 };
    
    return {
      industry: industry,
      irr: irrValue,
      leverageF2Min: leverageF2Values.min,
      leverageF2Max: leverageF2Values.max,
      ro40Min: ro40Values.min,
      ro40Max: ro40Values.max,
      cashSdebtMin: cashSdebtValues.min,
      cashSdebtMax: cashSdebtValues.max,
      currentRatioMin: currentRatioValues.min,
      currentRatioMax: currentRatioValues.max,
    };
  });
}

/**
 * Static threshold industry data
 * Generated from industry threshold mappings at build time
 */
export const STATIC_THRESHOLD_INDUSTRY_DATA: ThresholdIndustryData[] = generateThresholdIndustryData();

```

## `src/config/viewTableMap.ts`

```typescript
import type { ViewId } from '../types/navigation';

/**
 * Maps a view ID to its corresponding table metadata ID.
 * Single source of truth for viewId → tableId used by App, Header, and ConditionsSidebar.
 */
export function getTableId(viewId: ViewId): string | null {
  if (viewId === 'score-board') return 'score-board';
  if (viewId === 'score') return 'score';
  if (viewId === 'entry-exit-benjamin-graham') return 'benjamin-graham';
  if (viewId === 'fundamental-pe-industry') return 'pe-industry';
  if (viewId === 'threshold-industry') return 'threshold-industry';
  if (viewId === 'personal-portfolio') return 'personal-portfolio';
  return null;
}

/** Alias for getTableId; use when the view→table mapping intent should be explicit. */
export const getTableIdForView = getTableId;

```

## `src/contexts/__tests__/RefreshContext.integration.test.tsx`

```tsx
/**
 * Integration tests for RefreshContext registry pattern.
 * Proves that Refresh All calls adminRefreshCache (Cloud Function) and triggers
 * registered refetches with skipFetch. Does not call clearCache or fetch from Apps Script.
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import React from 'react';
import { RefreshProvider, useRefresh, useRefreshOptional } from '../RefreshContext';
import { LoadingProgressProvider } from '../LoadingProgressContext';

const mockAdminRefresh = vi.fn().mockResolvedValue({ data: { ok: true, refreshed: [], errors: [] } });
vi.mock('firebase/functions', () => ({
  httpsCallable: vi.fn(() => mockAdminRefresh),
}));

vi.mock('../../config/firebase', () => ({
  functions: {},
}));

vi.mock('../../utils/serviceWorkerRegistration', () => ({
  requestClearApiCache: vi.fn().mockResolvedValue(undefined),
}));

vi.mock('../ToastContext', () => ({
  useToast: () => ({
    showSuccess: vi.fn(),
    showError: vi.fn(),
    showWarning: vi.fn(),
  }),
}));

vi.mock('../NotificationContext', () => ({
  useNotifications: () => ({
    createNotification: vi.fn(),
  }),
}));

vi.mock('react-i18next', () => ({
  useTranslation: () => ({ t: (key: string, fallback?: string) => fallback ?? key, i18n: {} }),
}));

const wrapper = ({ children }: { children: React.ReactNode }) => (
  <LoadingProgressProvider>
    <RefreshProvider>{children}</RefreshProvider>
  </LoadingProgressProvider>
);

describe('RefreshContext integration', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockAdminRefresh.mockResolvedValue({ data: { ok: true, refreshed: [], errors: [] } });
  });

  it('registerRefetch returns unregister callback', () => {
    const refetchMock = vi.fn().mockResolvedValue(undefined);

    const { result } = renderHook(
      () => {
        const refresh = useRefresh();
        return refresh.registerRefetch('score-board', refetchMock);
      },
      { wrapper }
    );

    expect(typeof result.current).toBe('function');

    act(() => {
      result.current();
    });

    // After unregister, refreshAll should not call our refetch
    // (we'll verify in next test)
  });

  it('refreshAll calls adminRefreshCache (Cloud Function) and triggers refetches with skipFetch', async () => {
    const scoreBoardRefetch = vi.fn().mockResolvedValue(undefined);
    const benjaminGrahamRefetch = vi.fn().mockResolvedValue(undefined);

    const { result } = renderHook(
      () => {
        const refresh = useRefresh();
        React.useEffect(() => {
          const un1 = refresh.registerRefetch('score-board', scoreBoardRefetch);
          const un2 = refresh.registerRefetch('benjamin-graham', benjaminGrahamRefetch);
          return () => {
            un1();
            un2();
          };
        }, [refresh]);
        return refresh;
      },
      { wrapper }
    );

    await act(async () => {
      await result.current.refreshAll();
    });

    expect(mockAdminRefresh).toHaveBeenCalledWith({ force: true });
    expect(scoreBoardRefetch).toHaveBeenCalledTimes(1);
    expect(scoreBoardRefetch).toHaveBeenCalledWith({ skipFetch: true });
    expect(benjaminGrahamRefetch).toHaveBeenCalledTimes(1);
    expect(benjaminGrahamRefetch).toHaveBeenCalledWith({ skipFetch: true });
  });

  it('refreshAll does NOT call refetch when no data consumers are mounted', async () => {
    const refetchMock = vi.fn().mockResolvedValue(undefined);

    // Component that uses useRefresh but does NOT register any refetch
    const { result } = renderHook(
      () => {
        const refresh = useRefresh();
        return refresh;
      },
      { wrapper }
    );

    // No one has registered - call refreshAll
    await act(async () => {
      await result.current.refreshAll();
    });

    // Our refetch was never registered, so it should never be called
    expect(refetchMock).not.toHaveBeenCalled();
  });

  it('unregister removes refetch from registry - unmounted hook does not get refreshed', async () => {
    const refetchMock = vi.fn().mockResolvedValue(undefined);

    const refreshAllRef = { current: null as (() => Promise<void>) | null };

    const { unmount } = renderHook(
      () => {
        const refresh = useRefresh();
        refreshAllRef.current = refresh.refreshAll;
        React.useEffect(() => {
          const unregister = refresh.registerRefetch('score-board', refetchMock);
          return unregister;
        }, [refresh]);
        return refresh;
      },
      { wrapper }
    );

    // Unmount - cleanup runs, refetch is unregistered
    unmount();

    // Call refreshAll (via ref - provider still exists in wrapper)
    await act(async () => {
      await refreshAllRef.current!();
    });

    // Refetch should NOT have been called (we unregistered on unmount)
    expect(refetchMock).not.toHaveBeenCalled();
  });

  it('useRefreshOptional returns undefined when outside RefreshProvider', () => {
    const { result } = renderHook(() => useRefreshOptional(), {
      wrapper: ({ children }) => <>{children}</>,
    });

    expect(result.current).toBeUndefined();
  });
});

```

## `src/contexts/AuthContext.tsx`

```tsx
import { createContext, useContext, useEffect, useState, ReactNode, useCallback } from 'react';
import { 
  User, 
  UserCredential,
  signInWithEmailAndPassword, 
  createUserWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  getIdTokenResult
} from 'firebase/auth';
import { auth } from '../config/firebase';
import { logger } from '../utils/logger';

export type UserRole = 'viewer' | 'admin' | null;

export interface ViewerPermissions {
  allowedViews?: string[];
}

export interface AuthContextType {
  currentUser: User | null;
  userRole: UserRole;
  viewerPermissions: ViewerPermissions | null;
  login: (email: string, password: string) => Promise<void>;
  signup: (email: string, password: string) => Promise<UserCredential>;
  logout: () => Promise<void>;
  refreshUserRole: () => Promise<void>;
  loading: boolean;
}

export const AuthContext = createContext<AuthContextType | undefined>(undefined);

/**
 * Hook to access authentication context
 * 
 * Provides access to current user, user role, and authentication methods.
 * Must be used within an AuthProvider component.
 * 
 * @returns AuthContextType with currentUser, userRole, login, signup, logout, refreshUserRole, and loading
 * @throws {Error} If used outside of AuthProvider
 * 
 * @example
 * ```typescript
 * function MyComponent() {
 *   const { currentUser, userRole, logout } = useAuth();
 *   
 *   if (!currentUser) {
 *     return <Login />;
 *   }
 *   
 *   return <div>Welcome, {currentUser.email}</div>;
 * }
 * ```
 */
export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

/**
 * Authentication context provider
 * 
 * Provides authentication state and methods to all child components.
 * Manages user authentication, role retrieval, and auth state changes.
 * 
 * @param children - React children components that need access to auth context
 * 
 * @example
 * ```typescript
 * <AuthProvider>
 *   <App />
 * </AuthProvider>
 * ```
 */
export function AuthProvider({ children }: { children: ReactNode }) {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [userRole, setUserRole] = useState<UserRole>(null);
  const [viewerPermissions, setViewerPermissions] = useState<ViewerPermissions | null>(null);
  const [loading, setLoading] = useState(true);

  // Get user role from custom claims
  const getUserRole = useCallback(async (user: User | null): Promise<UserRole> => {
    if (!user) return null;
    
    try {
      const tokenResult = await getIdTokenResult(user, true); // Force refresh to get latest claims
      const role = tokenResult.claims.role as string;
      
      if (role === 'viewer' || role === 'admin') {
        return role;
      }
      
      return null;
    } catch (error) {
      logger.error('Error getting user role', error, { component: 'AuthContext', operation: 'getUserRole' });
      return null;
    }
  }, []);

  // Get viewer permissions (allowedViews) from custom claims
  // Backward compat: supports both ARRAY and MAP format (MAP recommended for Firestore rules)
  const getViewerPermissions = useCallback(async (user: User | null): Promise<ViewerPermissions | null> => {
    if (!user) return null;
    
    try {
      const tokenResult = await getIdTokenResult(user, true); // Force refresh to get latest claims
      const av = tokenResult.claims.allowedViews;
      let allowedViews: string[] = [];
      if (Array.isArray(av)) {
        allowedViews = av.filter((v): v is string => typeof v === 'string');
      } else if (av && typeof av === 'object' && !Array.isArray(av)) {
        allowedViews = Object.keys(av).filter((k) => (av as Record<string, unknown>)[k] === true);
      }
      if (allowedViews.length > 0) {
        return { allowedViews };
      }
      return null;
    } catch (error) {
      logger.error('Error getting viewer permissions', error, { component: 'AuthContext', operation: 'getViewerPermissions' });
      return null;
    }
  }, []);

  // Refresh user role and permissions (useful after admin changes permissions)
  const refreshUserRole = useCallback(async () => {
    if (currentUser) {
      const role = await getUserRole(currentUser);
      setUserRole(role);
      
      const permissions = await getViewerPermissions(currentUser);
      setViewerPermissions(permissions);
    }
  }, [currentUser, getUserRole, getViewerPermissions]);

  function signup(email: string, password: string): Promise<UserCredential> {
    return createUserWithEmailAndPassword(auth, email, password);
  }

  function login(email: string, password: string) {
    return signInWithEmailAndPassword(auth, email, password).then(() => {
      // User logged in successfully
    });
  }

  function logout() {
    return signOut(auth);
  }

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (user) => {
      setCurrentUser(user);
      
      if (user) {
        const role = await getUserRole(user);
        setUserRole(role);
        
        const permissions = await getViewerPermissions(user);
        setViewerPermissions(permissions);
      } else {
        setUserRole(null);
        setViewerPermissions(null);
      }
      
      setLoading(false);
    });

    return unsubscribe;
  }, [getUserRole, getViewerPermissions]);

  const value = {
    currentUser,
    userRole,
    viewerPermissions,
    login,
    signup,
    logout,
    refreshUserRole,
    loading
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}


```

## `src/contexts/AutoRefreshContext.tsx`

```tsx
import { createContext, useContext, ReactNode, useMemo } from 'react';

/**
 * AutoRefreshContext - Deprecated
 * 
 * Auto-refresh functionality has been removed. Cache now automatically refreshes
 * every 30 minutes via Firestore TTL. This context is kept for backward compatibility
 * but provides no functionality.
 * 
 * @deprecated This context is no longer used. Cache refreshes automatically via Firestore TTL.
 */
interface AutoRefreshContextType {
  enabled: boolean;
  interval: number;
  setEnabled: (enabled: boolean) => void;
  setIntervalValue: (interval: number) => void;
  lastRefreshTime: Date | null;
}

const AutoRefreshContext = createContext<AutoRefreshContextType | undefined>(undefined);

interface AutoRefreshProviderProps {
  children: ReactNode;
}

/**
 * AutoRefreshProvider - Deprecated
 * 
 * Provides a minimal context for backward compatibility.
 * Auto-refresh functionality has been removed - cache now refreshes automatically
 * every 30 minutes via Firestore TTL.
 * 
 * @deprecated This provider is kept for backward compatibility but provides no functionality.
 */
export function AutoRefreshProvider({ children }: AutoRefreshProviderProps) {
  // Minimal stub implementation - no auto-refresh logic
  // Cache now automatically refreshes via Firestore TTL (30 minutes)
  const value: AutoRefreshContextType = useMemo(() => ({
    enabled: false,
    interval: 0,
    setEnabled: () => {
      // No-op: auto-refresh is disabled
    },
    setIntervalValue: () => {
      // No-op: auto-refresh is disabled
    },
    lastRefreshTime: null,
  }), []);

  return (
    <AutoRefreshContext.Provider value={value}>
      {children}
    </AutoRefreshContext.Provider>
  );
}

/**
 * useAutoRefresh - Deprecated
 * 
 * Auto-refresh functionality has been removed. Cache now automatically refreshes
 * every 30 minutes via Firestore TTL.
 * 
 * @deprecated This hook is kept for backward compatibility but returns stub values.
 */
export function useAutoRefresh(): AutoRefreshContextType {
  const context = useContext(AutoRefreshContext);
  if (context === undefined) {
    throw new Error('useAutoRefresh must be used within an AutoRefreshProvider');
  }
  return context;
}

/**
 * AUTO_REFRESH_INTERVALS - Deprecated
 * 
 * Auto-refresh intervals are no longer used. Cache refreshes automatically
 * every 30 minutes via Firestore TTL.
 * 
 * @deprecated This export is kept for backward compatibility only.
 */
export const AUTO_REFRESH_INTERVALS = {
  OFF: 0,
  HOUR_1: 1 * 60 * 60 * 1000, // 1 hour
  HOUR_3: 3 * 60 * 60 * 1000, // 3 hours
} as const;


```

## `src/contexts/EntryExitContext.tsx`

```tsx
import { createContext, useContext, ReactNode, useState, useCallback, useEffect, useRef, useMemo } from 'react';
import { EntryExitData } from '../types/stock';
import { useAuth } from './AuthContext';
import { saveEntryExitValues, loadEntryExitValues } from '../services/userDataService';
import { onSnapshot, doc } from 'firebase/firestore';
import { db } from '../config/firebase';
import { isObject, isNumber, isString, isNullOrUndefined } from '../utils/typeGuards';
import { logger } from '../utils/logger';
import { validateEntryExitValue } from '../utils/inputValidator';
import type { EntryExitValuesForScore } from '../types/score';

export type EntryExitValues = EntryExitValuesForScore;

interface EntryExitContextType {
  getEntryExitValue: (ticker: string, companyName: string) => EntryExitValues | undefined;
  getFieldValue: (ticker: string, companyName: string, field: keyof EntryExitValues) => number | string | null;
  setFieldValue: (ticker: string, companyName: string, field: keyof EntryExitValues, value: number | string | null) => void;
  commitField: (ticker: string, companyName: string, field: keyof EntryExitValues) => Promise<void>;
  initializeFromData: (data: EntryExitData[]) => void;
  entryExitValues: Map<string, EntryExitValues>; // Computed for backward compatibility
}

export const EntryExitContext = createContext<EntryExitContextType | undefined>(undefined);

const STORAGE_KEY = 'entryExitValues';

// Type guard for EntryExitValues
function isEntryExitValues(value: unknown): value is EntryExitValues {
  if (!isObject(value)) {
    return false;
  }
  
  const obj = value as Record<string, unknown>;
  
  // Check required numeric fields
  if (!isNumber(obj.entry1) || !isNumber(obj.entry2) || 
      !isNumber(obj.exit1) || !isNumber(obj.exit2)) {
    return false;
  }
  
  // Check required string field
  if (!isString(obj.currency)) {
    return false;
  }
  
  // Check optional dateOfUpdate field (can be null or string)
  if (!isNullOrUndefined(obj.dateOfUpdate) && !isString(obj.dateOfUpdate)) {
    return false;
  }
  
  return true;
}

// Load from localStorage (fallback)
const loadFromStorage = (): Map<string, EntryExitValues> => {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored) {
      const parsed = JSON.parse(stored);
      return new Map(Object.entries(parsed));
    }
  } catch (error: unknown) {
    logger.error('Error loading EntryExit values from localStorage', error, { component: 'EntryExitContext', operation: 'loadFromLocalStorage' });
  }
  return new Map();
};

// Save to localStorage (fallback)
const saveToStorage = (values: Map<string, EntryExitValues>) => {
  try {
    const obj = Object.fromEntries(values);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
  } catch (error: unknown) {
    logger.error('Error saving EntryExit values to localStorage', error, { component: 'EntryExitContext', operation: 'saveToLocalStorage' });
  }
};

interface EntryExitProviderProps {
  children: ReactNode;
}

export function EntryExitProvider({ children }: EntryExitProviderProps) {
  const { currentUser } = useAuth();
  // serverRows: source of truth from Firestore
  const [serverRows, setServerRows] = useState<Map<string, EntryExitValues>>(() => loadFromStorage());
  // draft: only fields user is currently editing (e.g. "AAPL-Apple Inc..entry1": 123)
  const [draft, setDraft] = useState<Record<string, number | string | null>>({});
  const [isLoading, setIsLoading] = useState(true);
  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const dirtyKeysRef = useRef<Set<string>>(new Set()); // Set of "ticker-companyName.field" that are being edited
  const isInitialLoadRef = useRef(true); // Track initial load to prevent listener from processing during load

  // Load data from Firestore and set up real-time listener
  useEffect(() => {
    if (!currentUser) {
      // If no user, just load from localStorage
      const localData = loadFromStorage();
      if (localData.size > 0) {
        setServerRows(localData);
      }
      setIsLoading(false);
      isInitialLoadRef.current = false;
      return;
    }

    const loadData = async () => {
      setIsLoading(true);
      isInitialLoadRef.current = true;
      try {
        const loaded = await loadEntryExitValues(currentUser);
        if (loaded) {
          setServerRows((prev) => {
            const next = new Map(Object.entries(loaded));
            for (const [key, value] of prev) {
              if (!next.has(key)) {
                next.set(key, value);
              }
            }
            return next;
          });
        } else {
          // If no Firestore data, try localStorage
          const localData = loadFromStorage();
          if (localData.size > 0) {
            setServerRows(localData);
          }
        }
      } catch (error: unknown) {
        logger.error('Error loading EntryExit values', error, { component: 'EntryExitContext', operation: 'loadEntryExitValues' });
        // Fallback to localStorage
        const localData = loadFromStorage();
        if (localData.size > 0) {
          setServerRows(localData);
        }
      } finally {
        setIsLoading(false);
        // Mark initial load as complete after a short delay to ensure data is set
        setTimeout(() => {
          isInitialLoadRef.current = false;
        }, 100);
      }
    };

    loadData();

    // Set up real-time listener for changes from other users
    const docRef = doc(db, 'sharedData', 'entryExit');
    const unsubscribe = onSnapshot(
      docRef,
      (docSnapshot) => {
        // Skip during initial load
        if (isInitialLoadRef.current) {
          return;
        }
        
        // Ignore our own pending writes
        if (docSnapshot.metadata.hasPendingWrites) {
          return;
        }
        
        if (docSnapshot.exists()) {
          const data = docSnapshot.data();
          const remoteValues = data.values || {};
          
          // MERGE remote changes - never replace everything
          setServerRows((prev) => {
            const next = new Map(prev);
            let hasChanges = false;
            
            // Process each remote value
            for (const [key, remoteValue] of Object.entries(remoteValues)) {
              if (!isEntryExitValues(remoteValue)) {
                logger.warn(`Invalid EntryExitValues format for key ${key}`, { component: 'EntryExitContext', operation: 'loadEntryExitValues', key, remoteValue });
                continue;
              }
              const remoteEntry = remoteValue;
              const prevRow = next.get(key) || { entry1: 0, entry2: 0, exit1: 0, exit2: 0, currency: 'USD', dateOfUpdate: null };
              
              // Merge remote into existing
              const merged: EntryExitValues = { ...prevRow, ...remoteEntry };
              
              // Keep local edits while editing (dirty fields should not be overwritten)
              const fields: Array<keyof EntryExitValues> = ['entry1', 'entry2', 'exit1', 'exit2', 'currency', 'dateOfUpdate'];
              for (const field of fields) {
                const dk = `${key}.${field}`;
                if (dirtyKeysRef.current.has(dk)) {
                  // This field is being edited, keep the local value
                  // Type assertion is safe here because prevRow and merged have the same structure
                  (merged as Record<keyof EntryExitValues, number | string | null>)[field] = prevRow[field];
                }
              }
              
              next.set(key, merged);
              hasChanges = true;
            }
            
            if (hasChanges) {
              // Also update localStorage
              saveToStorage(next);
              return next;
            }
            return prev;
          });
        }
      },
      (error) => {
        logger.error('Error listening to EntryExit values', error, { component: 'EntryExitContext', operation: 'listenToEntryExitValues' });
      }
    );

    return () => {
      unsubscribe();
    };
  }, [currentUser?.uid]); // Removed isLoading from dependencies - listener should only recreate when user changes

  // Auto-save draft values to Firestore (debounced)
  useEffect(() => {
    if (isLoading || !currentUser || Object.keys(draft).length === 0) return;

    // Clear existing timeout
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }

    // Build current state from serverRows + draft for saving
    const currentState = new Map(serverRows);
    for (const [draftKey, draftValue] of Object.entries(draft)) {
      const [key, field] = draftKey.split('.');
      const entry = currentState.get(key) || { entry1: 0, entry2: 0, exit1: 0, exit2: 0, currency: 'USD', dateOfUpdate: null };
      // Type assertion is safe here because field comes from our own draft keys which are validated
      const updated: EntryExitValues = { ...entry, [field as keyof EntryExitValues]: draftValue as number | string | null };
      
      // Update dateOfUpdate if needed
      const allEmpty = updated.entry1 === 0 && updated.entry2 === 0 && updated.exit1 === 0 && updated.exit2 === 0;
      if (allEmpty) {
        updated.dateOfUpdate = null;
      } else if (!updated.dateOfUpdate) {
        const currentDate = new Date().toLocaleString('sv-SE', { year: 'numeric', month: '2-digit', day: '2-digit' });
        updated.dateOfUpdate = currentDate;
      }
      
      currentState.set(key, updated);
    }

    // Save to localStorage immediately (fast fallback)
    saveToStorage(currentState);

    // Debounce Firestore save to avoid too many writes
    saveTimeoutRef.current = setTimeout(async () => {
      try {
        const obj = Object.fromEntries(currentState);
        await saveEntryExitValues(currentUser, obj);
        // After successful save, release dirty locks + remove draft
        dirtyKeysRef.current.clear();
        setDraft({});
      } catch (error: unknown) {
        logger.error('Error saving EntryExit values to Firestore', error, { component: 'EntryExitContext', operation: 'saveEntryExitValues' });
        // On error, keep dirty keys and draft so user's edits aren't lost
      }
    }, 1000); // Wait 1 second after last change

    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [draft, serverRows, currentUser, isLoading]);

  // Display value: draft if exists, otherwise server value
  const getFieldValue = useCallback((ticker: string, companyName: string, field: keyof EntryExitValues): number | string | null => {
    const key = `${ticker}-${companyName}`;
    const dk = `${key}.${field}`;
    
    // If draft exists, return draft value
    if (dk in draft) {
      return draft[dk];
    }
    
    // Otherwise return server value
    const serverEntry = serverRows.get(key);
    if (field === 'dateOfUpdate') return serverEntry?.[field] ?? null;
    if (field === 'currency') return serverEntry?.[field] ?? 'USD';
    return serverEntry?.[field] ?? 0;
  }, [serverRows, draft]);

  // Backward compatibility: get full EntryExitValues object
  const getEntryExitValue = useCallback((ticker: string, companyName: string): EntryExitValues | undefined => {
    const key = `${ticker}-${companyName}`;
    const serverEntry = serverRows.get(key);
    
    if (!serverEntry) {
      return undefined;
    }
    
    // Build result from server entry, but replace with draft values if they exist
    const result: EntryExitValues = { ...serverEntry };
    const fields: Array<keyof EntryExitValues> = ['entry1', 'entry2', 'exit1', 'exit2', 'currency', 'dateOfUpdate'];
    
    for (const field of fields) {
      const dk = `${key}.${field}`;
      if (dk in draft) {
        const draftValue = draft[dk];
        // Type-safe assignment with runtime checks
        if (field === 'currency' && typeof draftValue === 'string') {
          result.currency = draftValue;
        } else if (field === 'dateOfUpdate' && (typeof draftValue === 'string' || draftValue === null)) {
          result.dateOfUpdate = draftValue;
        } else if ((field === 'entry1' || field === 'entry2' || field === 'exit1' || field === 'exit2') && typeof draftValue === 'number') {
          // Type assertion is safe here because we've verified the field type and value type match
          (result as Record<'entry1' | 'entry2' | 'exit1' | 'exit2', number>)[field] = draftValue;
        }
      }
    }
    
    return result;
  }, [serverRows, draft]);

  // While typing: mark dirty + update draft (and optionally optimistic update serverRows)
  const setFieldValue = useCallback((ticker: string, companyName: string, field: keyof EntryExitValues, value: number | string | null) => {
    // Validate the value before setting
    const validation = validateEntryExitValue(field, value);
    if (!validation.isValid) {
      logger.warn('Invalid EntryExit value rejected', {
        component: 'EntryExitContext',
        operation: 'setFieldValue',
        field,
        value,
        error: validation.error,
      });
      // Still allow the change for UI responsiveness, but log the warning
      // The UI component will show the validation error
    }

    const key = `${ticker}-${companyName}`;
    const dk = `${key}.${field}`;
    
    // Mark as dirty and update draft
    dirtyKeysRef.current.add(dk);
    setDraft((d) => ({ ...d, [dk]: value }));
    
    // Optional optimistic UI update (keeps tables consistent)
    setServerRows((rows) => {
      const newRows = new Map(rows);
      const current = newRows.get(key) || { entry1: 0, entry2: 0, exit1: 0, exit2: 0, currency: 'USD', dateOfUpdate: null };
      const updated: EntryExitValues = { ...current, [field]: value };
      
      // Update dateOfUpdate if needed
      const allEmpty = updated.entry1 === 0 && updated.entry2 === 0 && updated.exit1 === 0 && updated.exit2 === 0;
      if (allEmpty) {
        updated.dateOfUpdate = null;
      } else if (!updated.dateOfUpdate && field !== 'dateOfUpdate') {
        const currentDate = new Date().toLocaleString('sv-SE', { year: 'numeric', month: '2-digit', day: '2-digit' });
        updated.dateOfUpdate = currentDate;
      }
      
      newRows.set(key, updated);
      return newRows;
    });
  }, []);

  // Commit to Firestore on blur/enter, then release dirty lock
  const commitField = useCallback(async (ticker: string, companyName: string, field: keyof EntryExitValues) => {
    const key = `${ticker}-${companyName}`;
    const dk = `${key}.${field}`;
    const value = draft[dk];
    
    if (value === undefined) return;

    // Validate before committing to Firestore
    const validation = validateEntryExitValue(field, value);
    if (!validation.isValid) {
      logger.warn('Cannot commit invalid EntryExit value', {
        component: 'EntryExitContext',
        operation: 'commitField',
        field,
        value,
        error: validation.error,
      });
      // Don't commit invalid values
      return;
    }

    // Build the full entry to save
    const serverEntry = serverRows.get(key) || { entry1: 0, entry2: 0, exit1: 0, exit2: 0, currency: 'USD', dateOfUpdate: null };
    const updated: EntryExitValues = { ...serverEntry, [field]: value };
    
    // Validate the complete entry
    const entryValidation = Object.entries(updated).every(([f, v]) => {
      const fieldValidation = validateEntryExitValue(f as keyof EntryExitValues, v);
      return fieldValidation.isValid;
    });

    if (!entryValidation) {
      logger.warn('Cannot commit EntryExit entry with invalid values', {
        component: 'EntryExitContext',
        operation: 'commitField',
        key,
        updated,
      });
      return;
    }
    
    // Update dateOfUpdate if needed
    const allEmpty = updated.entry1 === 0 && updated.entry2 === 0 && updated.exit1 === 0 && updated.exit2 === 0;
    if (allEmpty) {
      updated.dateOfUpdate = null;
    } else if (!updated.dateOfUpdate && field !== 'dateOfUpdate') {
      const currentDate = new Date().toLocaleString('sv-SE', { year: 'numeric', month: '2-digit', day: '2-digit' });
      updated.dateOfUpdate = currentDate;
    }

    try {
      // Save this specific field immediately
      const allValues = Object.fromEntries(serverRows);
      allValues[key] = updated;
      await saveEntryExitValues(currentUser, allValues);
      
      // Release lock + remove draft
      dirtyKeysRef.current.delete(dk);
      setDraft((d) => {
        const { [dk]: _, ...rest } = d;
        return rest;
      });
      
      // Update serverRows with committed value
      setServerRows((rows) => {
        const newRows = new Map(rows);
        newRows.set(key, updated);
        return newRows;
      });
    } catch (error: unknown) {
      logger.error('Error committing field to Firestore', error, { component: 'EntryExitContext', operation: 'commitField' });
    }
  }, [draft, serverRows, currentUser]);

  const initializeFromData = useCallback((data: EntryExitData[]) => {
    setServerRows((prev) => {
      const newMap = new Map(prev);
      data.forEach((item) => {
        const key = `${item.ticker}-${item.companyName}`;
        // Only initialize if key doesn't exist (preserve manually entered values)
        if (!newMap.has(key)) {
          newMap.set(key, {
            entry1: item.entry1 || 0,
            entry2: item.entry2 || 0,
            exit1: item.exit1 || 0,
            exit2: item.exit2 || 0,
            currency: item.currency || 'USD',
            dateOfUpdate: item.dateOfUpdate || null,
          });
        }
      });
      return newMap;
    });
  }, []);

  // Compute entryExitValues from serverRows + draft for backward compatibility
  const entryExitValues = useMemo(() => {
    const result = new Map(serverRows);
    for (const [draftKey, draftValue] of Object.entries(draft)) {
      const [key, field] = draftKey.split('.');
      const entry = result.get(key) || { entry1: 0, entry2: 0, exit1: 0, exit2: 0, currency: 'USD', dateOfUpdate: null };
      result.set(key, { ...entry, [field]: draftValue });
    }
    return result;
  }, [serverRows, draft]);

  const value: EntryExitContextType = {
    getEntryExitValue,
    getFieldValue,
    setFieldValue,
    commitField,
    initializeFromData,
    entryExitValues,
  };

  return <EntryExitContext.Provider value={value}>{children}</EntryExitContext.Provider>;
}

export function useEntryExitValues(): EntryExitContextType {
  const context = useContext(EntryExitContext);
  if (context === undefined) {
    throw new Error('useEntryExitValues must be used within an EntryExitProvider');
  }
  return context;
}

```

## `src/contexts/LoadingProgressContext.tsx`

```tsx
import { createContext, useContext, ReactNode, useState, useCallback, useMemo, useEffect } from 'react';
import { logger } from '../utils/logger';

export interface DataSourceProgress {
  name: string;
  progress: number; // 0-100
  status: 'pending' | 'loading' | 'complete' | 'error';
  estimatedTimeRemaining?: number; // milliseconds
  rowsLoaded?: number;
  totalRows?: number;
  startTime?: number;
  message?: string;
}

interface LoadingProgressContextType {
  dataSources: Map<string, DataSourceProgress>;
  totalProgress: number;
  estimatedTimeRemaining: number;
  isAnyLoading: boolean;
  updateProgress: (source: string, progress: Partial<DataSourceProgress>) => void;
  reset: () => void;
  getDataSource: (source: string) => DataSourceProgress | undefined;
}

const LoadingProgressContext = createContext<LoadingProgressContextType | undefined>(undefined);

// Standard estimated times for different data sources (in milliseconds)
// Note: threshold-industry removed - data is now static and loads instantly
const DEFAULT_ESTIMATED_TIMES: Record<string, number> = {
  'score-board': 4000,
  'benjamin-graham': 2500,
  'sma': 2500,
  'pe-industry': 1500,
};

// Load historical data from localStorage
function getHistoricalTime(source: string): number | null {
  try {
    const key = `loadTime:${source}`;
    const stored = localStorage.getItem(key);
    if (stored) {
      return parseFloat(stored);
    }
  } catch (error) {
    logger.error(`Error loading historical time for ${source}`, error, { component: 'LoadingProgressContext', operation: 'loadHistoricalTime', source });
  }
  return null;
}

// Save historical data to localStorage
function saveHistoricalTime(source: string, time: number): void {
  try {
    const key = `loadTime:${source}`;
    localStorage.setItem(key, String(time));
  } catch (error) {
    logger.error(`Error saving historical time for ${source}`, error, { component: 'LoadingProgressContext', operation: 'saveHistoricalTime', source });
  }
}

interface LoadingProgressProviderProps {
  children: ReactNode;
}

export function LoadingProgressProvider({ children }: LoadingProgressProviderProps) {
  const [dataSources, setDataSources] = useState<Map<string, DataSourceProgress>>(new Map());

  const updateProgress = useCallback((source: string, progressUpdate: Partial<DataSourceProgress>) => {
    setDataSources((prev) => {
      const newMap = new Map(prev);
      const existing = newMap.get(source);
      
      // Initialize if doesn't exist
      if (!existing) {
        const historicalTime = getHistoricalTime(source);
        const estimatedTime = historicalTime || DEFAULT_ESTIMATED_TIMES[source] || 3000;
        
        newMap.set(source, {
          name: source,
          progress: 0,
          status: 'pending',
          estimatedTimeRemaining: estimatedTime,
          startTime: Date.now(),
          ...progressUpdate,
        });
      } else {
        // Update existing
        const updated: DataSourceProgress = {
          ...existing,
          ...progressUpdate,
        };
        
        // Calculate estimated time remaining based on progress
        if (updated.progress > 0 && updated.startTime) {
          const elapsed = Date.now() - updated.startTime;
          const estimatedTotal = (elapsed / updated.progress) * 100;
          updated.estimatedTimeRemaining = Math.max(0, estimatedTotal - elapsed);
        }
        
        // Save historical time when complete
        if (updated.status === 'complete' && updated.startTime) {
          const totalTime = Date.now() - updated.startTime;
          saveHistoricalTime(source, totalTime);
        }
        
        newMap.set(source, updated);
      }
      
      return newMap;
    });
  }, []);

  const reset = useCallback(() => {
    setDataSources(new Map());
  }, []);

  const getDataSource = useCallback((source: string) => {
    return dataSources.get(source);
  }, [dataSources]);

  // Calculate total progress
  const totalProgress = useMemo(() => {
    if (dataSources.size === 0) return 0;
    
    let total = 0;
    let count = 0;
    dataSources.forEach((source) => {
      total += source.progress;
      count++;
    });
    
    return count > 0 ? Math.round(total / count) : 0;
  }, [dataSources]);

  // Calculate total estimated time remaining
  const estimatedTimeRemaining = useMemo(() => {
    let maxTime = 0;
    dataSources.forEach((source) => {
      if (source.status === 'loading' && source.estimatedTimeRemaining) {
        maxTime = Math.max(maxTime, source.estimatedTimeRemaining);
      }
    });
    return maxTime;
  }, [dataSources]);

  // Check if any data source is loading
  const isAnyLoading = useMemo(() => {
    for (const source of dataSources.values()) {
      if (source.status === 'loading' || source.status === 'pending') {
        return true;
      }
    }
    return false;
  }, [dataSources]);

  const value: LoadingProgressContextType = {
    dataSources,
    totalProgress,
    estimatedTimeRemaining,
    isAnyLoading,
    updateProgress,
    reset,
    getDataSource,
  };

  return (
    <LoadingProgressContext.Provider value={value}>
      {children}
    </LoadingProgressContext.Provider>
  );
}

export function useLoadingProgress(): LoadingProgressContextType {
  const context = useContext(LoadingProgressContext);
  if (context === undefined) {
    throw new Error('useLoadingProgress must be used within a LoadingProgressProvider');
  }
  return context;
}


```

## `src/contexts/NotificationContext.tsx`

```tsx
import { createContext, useContext, ReactNode, useState, useCallback, useEffect } from 'react';
import { notificationService, Notification, NotificationType } from '../services/notificationService';
import { getUserPreferences, NotificationPreferences, DEFAULT_NOTIFICATION_PREFERENCES } from '../services/userPreferencesService';
import { useAuth } from './AuthContext';
import { logger } from '../utils/logger';

interface NotificationContextType {
  notifications: Notification[];
  unreadCount: number;
  permissionState: 'default' | 'granted' | 'denied';
  requestPermission: () => Promise<boolean>;
  createNotification: (
    type: NotificationType,
    title: string,
    message: string,
    options?: {
      persistent?: boolean;
      showDesktop?: boolean;
      data?: Record<string, unknown>;
    }
  ) => Notification;
  markAsRead: (notificationId: string) => void;
  markAllAsRead: () => void;
  removeNotification: (notificationId: string) => void;
  clearAll: () => void;
  refresh: () => void;
}

const NotificationContext = createContext<NotificationContextType | undefined>(undefined);

interface NotificationProviderProps {
  children: ReactNode;
}

export function NotificationProvider({ children }: NotificationProviderProps) {
  const { currentUser } = useAuth();
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [permissionState, setPermissionState] = useState<'default' | 'granted' | 'denied'>(
    notificationService.getPermissionState()
  );
  const [userPreferences, setUserPreferences] = useState<NotificationPreferences>(DEFAULT_NOTIFICATION_PREFERENCES);

  const refresh = useCallback(() => {
    setNotifications(notificationService.getNotifications());
    setPermissionState(notificationService.getPermissionState());
  }, []);

  const requestPermission = useCallback(async (): Promise<boolean> => {
    const granted = await notificationService.requestPermission();
    setPermissionState(notificationService.getPermissionState());
    return granted;
  }, []);

  const createNotification = useCallback(
    (
      type: NotificationType,
      title: string,
      message: string,
      options?: {
        persistent?: boolean;
        showDesktop?: boolean;
        data?: Record<string, unknown>;
      }
    ): Notification => {
      // Check if notifications are enabled
      if (!userPreferences.enabled) {
        logger.debug('Notifications disabled by user preferences', {
          component: 'NotificationContext',
          type,
        });
        // Still create the notification but don't show it
        const notification = notificationService.createNotification(type, title, message, {
          ...options,
          showDesktop: false,
        });
        refresh();
        return notification;
      }

      // Check if this notification type is enabled
      let typeEnabled = true;
      switch (type) {
        case 'data-update':
          typeEnabled = userPreferences.dataUpdates;
          break;
        case 'error':
          typeEnabled = userPreferences.errors;
          break;
        case 'success':
          typeEnabled = userPreferences.success;
          break;
        case 'info':
          typeEnabled = userPreferences.info;
          break;
        case 'warning':
          typeEnabled = userPreferences.warning;
          break;
      }

      if (!typeEnabled) {
        logger.debug(`Notification type ${type} disabled by user preferences`, {
          component: 'NotificationContext',
        });
        // Still create the notification but don't show it
        const notification = notificationService.createNotification(type, title, message, {
          ...options,
          showDesktop: false,
        });
        refresh();
        return notification;
      }

      // Check desktop notification preference
      const showDesktop = options?.showDesktop !== false && userPreferences.desktopNotifications;

      const notification = notificationService.createNotification(type, title, message, {
        ...options,
        showDesktop,
      });
      refresh();
      return notification;
    },
    [refresh, userPreferences]
  );

  const markAsRead = useCallback(
    (notificationId: string) => {
      notificationService.markAsRead(notificationId);
      refresh();
    },
    [refresh]
  );

  const markAllAsRead = useCallback(() => {
    notificationService.markAllAsRead();
    refresh();
  }, [refresh]);

  const removeNotification = useCallback(
    (notificationId: string) => {
      notificationService.removeNotification(notificationId);
      refresh();
    },
    [refresh]
  );

  const clearAll = useCallback(() => {
    notificationService.clearAll();
    refresh();
  }, [refresh]);

  // Load user preferences
  useEffect(() => {
    const loadPreferences = async () => {
      if (!currentUser) {
        setUserPreferences(DEFAULT_NOTIFICATION_PREFERENCES);
        return;
      }

      try {
        const prefs = await getUserPreferences(currentUser.uid);
        if (prefs) {
          setUserPreferences(prefs.notifications);
        }
      } catch (error) {
        logger.error('Error loading notification preferences', error, {
          component: 'NotificationContext',
        });
      }
    };

    loadPreferences();
  }, [currentUser]);

  // Initial load
  useEffect(() => {
    refresh();
  }, [refresh]);

  // Auto-refresh notifications periodically
  useEffect(() => {
    const interval = setInterval(() => {
      refresh();
    }, 1000); // Refresh every second

    return () => clearInterval(interval);
  }, [refresh]);

  // Clean up old notifications on mount
  useEffect(() => {
    notificationService.clearOldNotifications(7); // Keep last 7 days
    refresh();
  }, [refresh]);

  const unreadCount = notifications.filter((n) => !n.read).length;

  const value: NotificationContextType = {
    notifications,
    unreadCount,
    permissionState,
    requestPermission,
    createNotification,
    markAsRead,
    markAllAsRead,
    removeNotification,
    clearAll,
    refresh,
  };

  return <NotificationContext.Provider value={value}>{children}</NotificationContext.Provider>;
}

export function useNotifications(): NotificationContextType {
  const context = useContext(NotificationContext);
  if (context === undefined) {
    throw new Error('useNotifications must be used within a NotificationProvider');
  }
  return context;
}

```

## `src/contexts/RefreshContext.tsx`

```tsx
import { createContext, useContext, ReactNode, useCallback, useMemo, useRef, useState } from 'react';
import { httpsCallable } from 'firebase/functions';
import { functions } from '../config/firebase';
import { useToast } from './ToastContext';
import { useNotifications } from './NotificationContext';
import { useLoadingProgress } from './LoadingProgressContext';
import { useTranslation } from 'react-i18next';
import { requestClearApiCache } from '../utils/serviceWorkerRegistration';
import { logger } from '../utils/logger';

/** Data sources that can register refetch functions */
export type DataSourceId = 'score-board' | 'benjamin-graham' | 'pe-industry';

/** Options for refetch - skipFetch: only read from viewData (after adminRefreshCache) */
export interface RefetchOptions {
  skipFetch?: boolean;
}

interface RefreshContextType {
  refreshAll: () => Promise<void>;
  isRefreshing: boolean;
  /** Register a refetch function. Returns unregister callback for cleanup on unmount. */
  registerRefetch: (sourceId: DataSourceId, refetch: (options?: RefetchOptions) => Promise<void>) => () => void;
  // Individual refetch functions (trigger only registered refetches for that source)
  refreshBenjaminGraham: () => Promise<void>;
  refreshScoreBoard: () => Promise<void>;
  refreshPEIndustry: () => Promise<void>;
}

const RefreshContext = createContext<RefreshContextType | undefined>(undefined);

interface RefreshProviderProps {
  children: ReactNode;
}

/** Registry: sourceId -> Set of refetch functions. Each mounted hook instance registers. */
type RefetchRegistry = Map<DataSourceId, Set<(options?: RefetchOptions) => Promise<void>>>;

export function RefreshProvider({ children }: RefreshProviderProps) {
  const { t } = useTranslation();
  const { showSuccess, showError } = useToast();
  const { createNotification } = useNotifications();
  const { reset: resetProgress } = useLoadingProgress();
  const [isRefreshing, setIsRefreshing] = useState(false);

  const registryRef = useRef<RefetchRegistry>(new Map());

  const registerRefetch = useCallback((sourceId: DataSourceId, refetch: (options?: RefetchOptions) => Promise<void>) => {
    const registry = registryRef.current;
    if (!registry.has(sourceId)) {
      registry.set(sourceId, new Set());
    }
    registry.get(sourceId)!.add(refetch);
    return () => {
      registry.get(sourceId)?.delete(refetch);
      if (registry.get(sourceId)?.size === 0) registry.delete(sourceId);
    };
  }, []);

  const callRefetchesForSource = useCallback(
    async (sourceId: DataSourceId, options?: RefetchOptions): Promise<PromiseSettledResult<void>[]> => {
      const set = registryRef.current.get(sourceId);
      if (!set || set.size === 0) return [];
      const promises = Array.from(set).map((fn) => fn(options));
      return Promise.allSettled(promises);
    },
    []
  );

  const refreshAll = useCallback(async () => {
    try {
      setIsRefreshing(true);
      logger.info('Refresh Now: Calling adminRefreshCache (server-side)', { component: 'RefreshContext', operation: 'refreshAll' });

      const adminRefresh = httpsCallable<{ viewIds?: string[]; force?: boolean; dryRun?: boolean }, { ok: boolean; refreshed: unknown[]; errors: string[] }>(
        functions,
        'adminRefreshCache'
      );
      const result = await adminRefresh({ force: true });
      const data = result.data;

      if (!data?.ok) {
        throw new Error(data?.errors?.join('; ') || 'adminRefreshCache failed');
      }
      if ((data.errors ?? []).length > 0) {
        logger.warn('Refresh Now: adminRefreshCache completed with errors', {
          component: 'RefreshContext',
          operation: 'refreshAll',
          errors: data.errors,
        });
      }

      resetProgress();

      try {
        await requestClearApiCache();
      } catch (swError) {
        logger.warn('Refresh Now: Failed to clear SW cache, continuing', {
          component: 'RefreshContext',
          operation: 'refreshAll',
          error: swError,
        });
      }

      logger.debug('Refresh Now: Triggering refetches (viewData only)', { component: 'RefreshContext', operation: 'refreshAll' });
      const sourceIds: DataSourceId[] = ['score-board', 'benjamin-graham', 'pe-industry'];
      const allResults: PromiseSettledResult<void>[] = [];
      const dataTypeNames = ['ScoreBoard', 'BenjaminGraham', 'PEIndustry'];

      for (let i = 0; i < sourceIds.length; i++) {
        const results = await callRefetchesForSource(sourceIds[i], { skipFetch: true });
        results.forEach((r) => allResults.push(r));
        const dataType = dataTypeNames[i];
        results.forEach((result, idx) => {
          if (result.status === 'fulfilled') {
            logger.info(`Refresh Now: ${dataType} refetch ${idx + 1} completed`, { component: 'RefreshContext', operation: 'refreshAll', dataType });
          } else {
            logger.error(`Refresh Now: ${dataType} refetch ${idx + 1} failed`, {
              component: 'RefreshContext',
              operation: 'refreshAll',
              dataType,
              error: result.reason,
            });
          }
        });
      }

      const hasErrors = allResults.some((r) => r.status === 'rejected');
      if (hasErrors) {
        const errorMessage = t('toast.refreshError', 'Fel vid uppdatering av data');
        showError(errorMessage);
        createNotification('error', 'Data Refresh Failed', errorMessage, { showDesktop: true, persistent: false });
      } else {
        const successMessage = t('toast.refreshSuccess', 'All data har uppdaterats');
        showSuccess(successMessage);
        createNotification('success', 'Data Refresh Complete', successMessage, { showDesktop: false, persistent: false });
      }
    } catch (error: unknown) {
      logger.error('Refresh Now: Unexpected error', { component: 'RefreshContext', operation: 'refreshAll', error });
      const errorMessage = t('toast.refreshError', 'Fel vid uppdatering av data');
      showError(errorMessage);
      createNotification('error', 'Data Refresh Error', errorMessage, { showDesktop: true, persistent: false });
    } finally {
      setIsRefreshing(false);
    }
  }, [callRefetchesForSource, showSuccess, showError, createNotification, t, resetProgress]);

  const refreshBenjaminGraham = useCallback(async () => {
    setIsRefreshing(true);
    try {
      await callRefetchesForSource('benjamin-graham');
    } finally {
      setIsRefreshing(false);
    }
  }, [callRefetchesForSource]);

  const refreshScoreBoard = useCallback(async () => {
    setIsRefreshing(true);
    try {
      await callRefetchesForSource('score-board');
    } finally {
      setIsRefreshing(false);
    }
  }, [callRefetchesForSource]);

  const refreshPEIndustry = useCallback(async () => {
    setIsRefreshing(true);
    try {
      await callRefetchesForSource('pe-industry');
    } finally {
      setIsRefreshing(false);
    }
  }, [callRefetchesForSource]);

  const value: RefreshContextType = useMemo(
    () => ({
      refreshAll,
      isRefreshing,
      registerRefetch,
      refreshBenjaminGraham,
      refreshScoreBoard,
      refreshPEIndustry,
    }),
    [refreshAll, isRefreshing, registerRefetch, refreshBenjaminGraham, refreshScoreBoard, refreshPEIndustry]
  );

  if (import.meta.env.DEV) {
    logger.debug('RefreshProvider: Rendering RefreshContext.Provider', {
      hasRefreshAll: typeof value.refreshAll === 'function',
      isRefreshing: value.isRefreshing,
    });
  }

  return <RefreshContext.Provider value={value}>{children}</RefreshContext.Provider>;
}

export function useRefresh(): RefreshContextType {
  const context = useContext(RefreshContext);
  if (context === undefined) {
    throw new Error(
      'useRefresh must be used within a RefreshProvider.\n\n' +
        'SOLUTION:\n' +
        '1. Check App.tsx - RefreshProvider must wrap AutoRefreshProvider:\n' +
        '   <LoadingProgressProvider>\n' +
        '     <RefreshProvider>\n' +
        '       <AutoRefreshProvider>...</AutoRefreshProvider>\n' +
        '     </RefreshProvider>\n' +
        '   </LoadingProgressProvider>\n' +
        '2. Ensure RefreshProvider is rendered before AutoRefreshProvider in the component tree.\n' +
        '3. Check that RefreshProvider is not conditionally rendered or skipped.'
    );
  }
  return context;
}

/** Returns context or undefined if not within RefreshProvider. Use for optional registration (e.g. in data hooks). */
export function useRefreshOptional(): RefreshContextType | undefined {
  return useContext(RefreshContext);
}

```

## `src/contexts/ThemeContext.tsx`

```tsx
import { createContext, useContext, useEffect, useState, ReactNode } from 'react';

type Theme = 'light' | 'dark' | 'system';

interface ThemeContextType {
  theme: Theme;
  setTheme: (theme: Theme) => void;
  resolvedTheme: 'light' | 'dark';
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setThemeState] = useState<Theme>(() => {
    const saved = localStorage.getItem('stockScoreTheme');
    return (saved as Theme) || 'light';
  });

  const [resolvedTheme, setResolvedTheme] = useState<'light' | 'dark'>(() => {
    if (theme === 'system') {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }
    return theme;
  });

  useEffect(() => {
    const root = window.document.documentElement;
    
    const updateTheme = () => {
      let resolved: 'light' | 'dark';
      
      if (theme === 'system') {
        resolved = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      } else {
        resolved = theme;
      }
      
      setResolvedTheme(resolved);
      
      if (resolved === 'dark') {
        root.classList.add('dark');
      } else {
        root.classList.remove('dark');
      }
    };

    updateTheme();

    // Listen for system theme changes
    if (theme === 'system') {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      const handleChange = () => updateTheme();
      
      // Modern browsers
      if (mediaQuery.addEventListener) {
        mediaQuery.addEventListener('change', handleChange);
        return () => mediaQuery.removeEventListener('change', handleChange);
      } 
      // Fallback for older browsers
      else if (mediaQuery.addListener) {
        mediaQuery.addListener(handleChange);
        return () => mediaQuery.removeListener(handleChange);
      }
    }
  }, [theme]);

  const setTheme = (newTheme: Theme) => {
    setThemeState(newTheme);
    localStorage.setItem('stockScoreTheme', newTheme);
  };

  return (
    <ThemeContext.Provider value={{ theme, setTheme, resolvedTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}


```

## `src/contexts/ThresholdContext.tsx`

```tsx
import { createContext, useContext, ReactNode, useState, useCallback, useEffect, useRef, useMemo } from 'react';
import { ThresholdIndustryData } from '../types/stock';
import { useAuth } from './AuthContext';
import {
  loadSharedThresholdValues,
  saveSharedThresholdValues,
  loadFromLocalStorage,
  saveToLocalStorage,
  type ThresholdValues,
} from '../services/sharedThresholdService';
import { onSnapshot, doc } from 'firebase/firestore';
import { db } from '../config/firebase';
import { logger } from '../utils/logger';

export type { ThresholdValues } from '../services/sharedThresholdService';

interface ThresholdContextType {
  getThresholdValue: (industry: string) => ThresholdValues | undefined;
  getFieldValue: (industry: string, field: keyof ThresholdValues) => number;
  setFieldValue: (industry: string, field: keyof ThresholdValues, value: number) => void;
  commitField: (industry: string, field: keyof ThresholdValues) => Promise<void>;
  initializeFromData: (data: ThresholdIndustryData[]) => void;
  thresholdValues: Map<string, ThresholdValues>; // Computed for backward compatibility
}

export const ThresholdContext = createContext<ThresholdContextType | undefined>(undefined);

// Load from localStorage (fallback) - uses sharedThresholdService key
const loadFromStorage = (): Map<string, ThresholdValues> => {
  const loaded = loadFromLocalStorage();
  if (loaded) {
    return new Map(Object.entries(loaded));
  }
  return new Map();
};

// Save to localStorage (read-cache only)
const saveToStorage = (values: Map<string, ThresholdValues>) => {
  saveToLocalStorage(Object.fromEntries(values));
};

interface ThresholdProviderProps {
  children: ReactNode;
}

export function ThresholdProvider({ children }: ThresholdProviderProps) {
  const { currentUser, userRole } = useAuth();
  // serverRows: source of truth from Firestore
  const [serverRows, setServerRows] = useState<Map<string, ThresholdValues>>(() => loadFromStorage());
  // draft: only fields user is currently editing (e.g. "Technology.irr": 15)
  const [draft, setDraft] = useState<Record<string, number>>({});
  const [isLoading, setIsLoading] = useState(true);
  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const dirtyKeysRef = useRef<Set<string>>(new Set()); // Set of "industry.field" that are being edited
  const isInitialLoadRef = useRef(true); // Track initial load to prevent listener from processing during load

  // Load data from Firestore and set up real-time listener
  useEffect(() => {
    if (!currentUser) {
      // If no user, just load from localStorage
      const localData = loadFromStorage();
      if (localData.size > 0) {
        setServerRows(localData);
      }
      setIsLoading(false);
      isInitialLoadRef.current = false;
      return;
    }

    const loadData = async () => {
      setIsLoading(true);
      isInitialLoadRef.current = true;
      try {
        const loaded = await loadSharedThresholdValues(currentUser);
        if (loaded) {
          setServerRows(new Map(Object.entries(loaded)));
        } else {
          // If no Firestore data, try localStorage
          const localData = loadFromStorage();
          if (localData.size > 0) {
            setServerRows(localData);
          }
        }
      } catch (error: unknown) {
        logger.error('Error loading shared threshold', error, {
          component: 'ThresholdContext',
          operation: 'sharedThreshold.loadFailed',
        });
        const localData = loadFromStorage();
        if (localData.size > 0) {
          setServerRows(localData);
        }
      } finally {
        setIsLoading(false);
        // Mark initial load as complete after a short delay to ensure data is set
        setTimeout(() => {
          isInitialLoadRef.current = false;
        }, 100);
      }
    };

    loadData();

    // Set up real-time listener for changes from other users
    const docRef = doc(db, 'sharedData', 'threshold');
    const unsubscribe = onSnapshot(
      docRef,
      (docSnapshot) => {
        // Skip during initial load
        if (isInitialLoadRef.current) {
          return;
        }
        
        // Ignore our own pending writes
        if (docSnapshot.metadata.hasPendingWrites) {
          return;
        }
        
        if (docSnapshot.exists()) {
          const data = docSnapshot.data();
          const remoteValues = data.values || {};
          
          // MERGE remote changes - never replace everything
          setServerRows((prev) => {
            const next = new Map(prev);
            let hasChanges = false;
            
            // Process each remote value
            for (const [industry, remoteValue] of Object.entries(remoteValues)) {
              const remoteThreshold = remoteValue as ThresholdValues;
              const prevRow = next.get(industry) || {
                irr: 0,
                leverageF2Min: 0,
                leverageF2Max: 0,
                ro40Min: 0,
                ro40Max: 0,
                cashSdebtMin: 0,
                cashSdebtMax: 0,
                currentRatioMin: 0,
                currentRatioMax: 0,
              };
              
              // Merge remote into existing
              const merged: ThresholdValues = { ...prevRow, ...remoteThreshold };
              
              // Keep local edits while editing (dirty fields should not be overwritten)
              const fields: Array<keyof ThresholdValues> = [
                'irr', 'leverageF2Min', 'leverageF2Max', 'ro40Min', 'ro40Max',
                'cashSdebtMin', 'cashSdebtMax', 'currentRatioMin', 'currentRatioMax'
              ];
              
              for (const field of fields) {
                const dk = `${industry}.${field}`;
                if (dirtyKeysRef.current.has(dk)) {
                  // This field is being edited, keep the local value
                  merged[field] = prevRow[field];
                }
              }
              
              next.set(industry, merged);
              hasChanges = true;
            }
            
            if (hasChanges) {
              // Also update localStorage
              saveToStorage(next);
              return next;
            }
            return prev;
          });
        }
      },
      (error) => {
        logger.error('Error listening to Threshold values', error, { component: 'ThresholdContext', operation: 'listenToThresholdValues' });
      }
    );

    return () => {
      unsubscribe();
    };
  }, [currentUser?.uid]); // Removed isLoading from dependencies - listener should only recreate when user changes

  // Auto-save draft values to Firestore (debounced) - admin only
  useEffect(() => {
    if (isLoading || !currentUser || userRole !== 'admin' || Object.keys(draft).length === 0) {
      return;
    }

    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }

    const currentState = new Map(serverRows);
    for (const [draftKey, draftValue] of Object.entries(draft)) {
      const [industry, field] = draftKey.split('.');
      const entry = currentState.get(industry) || {
        irr: 0,
        leverageF2Min: 0,
        leverageF2Max: 0,
        ro40Min: 0,
        ro40Max: 0,
        cashSdebtMin: 0,
        cashSdebtMax: 0,
        currentRatioMin: 0,
        currentRatioMax: 0,
      };
      currentState.set(industry, { ...entry, [field]: draftValue });
    }

    saveToStorage(currentState);

    saveTimeoutRef.current = setTimeout(async () => {
      try {
        const obj = Object.fromEntries(currentState);
        await saveSharedThresholdValues(obj, { user: currentUser, userRole });
        dirtyKeysRef.current.clear();
        setDraft({});
      } catch (error: unknown) {
        if ((error as Error).message === 'sharedThreshold.saveDenied') {
          logger.warn('Threshold save denied (viewer)', {
            component: 'ThresholdContext',
            operation: 'sharedThreshold.saveDenied',
          });
        } else {
          logger.error('Error saving shared threshold to Firestore', error, {
            component: 'ThresholdContext',
            operation: 'sharedThreshold.saveFailed',
          });
        }
      }
    }, 1000);

    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [draft, serverRows, currentUser, userRole, isLoading]);

  // Display value: draft if exists, otherwise server value
  const getFieldValue = useCallback((industry: string, field: keyof ThresholdValues): number => {
    const dk = `${industry}.${field}`;
    
    // If draft exists, return draft value
    if (dk in draft) {
      return draft[dk];
    }
    
    // Otherwise return server value
    const serverEntry = serverRows.get(industry);
    return serverEntry?.[field] ?? 0;
  }, [serverRows, draft]);

  // Backward compatibility: get full ThresholdValues object
  const getThresholdValue = useCallback((industry: string): ThresholdValues | undefined => {
    const serverEntry = serverRows.get(industry);
    
    if (!serverEntry) {
      return undefined;
    }
    
    // Build result from server entry, but replace with draft values if they exist
    const result: ThresholdValues = { ...serverEntry };
    const fields: Array<keyof ThresholdValues> = [
      'irr', 'leverageF2Min', 'leverageF2Max', 'ro40Min', 'ro40Max',
      'cashSdebtMin', 'cashSdebtMax', 'currentRatioMin', 'currentRatioMax'
    ];
    
    for (const field of fields) {
      const dk = `${industry}.${field}`;
      if (dk in draft) {
        result[field] = draft[dk];
      }
    }
    
    return result;
  }, [serverRows, draft]);

  // While typing: mark dirty + update draft. Viewer: no-op.
  const setFieldValue = useCallback(
    (industry: string, field: keyof ThresholdValues, value: number) => {
      if (userRole !== 'admin') {
        logger.warn('setFieldValue denied: viewer cannot edit', {
          component: 'ThresholdContext',
          operation: 'sharedThreshold.setFieldValueDenied',
        });
        return;
      }

      const dk = `${industry}.${field}`;
      dirtyKeysRef.current.add(dk);
      setDraft((d) => ({ ...d, [dk]: value }));
      setServerRows((rows) => {
        const newRows = new Map(rows);
        const current = newRows.get(industry) || {
          irr: 0,
          leverageF2Min: 0,
          leverageF2Max: 0,
          ro40Min: 0,
          ro40Max: 0,
          cashSdebtMin: 0,
          cashSdebtMax: 0,
          currentRatioMin: 0,
          currentRatioMax: 0,
        };
        newRows.set(industry, { ...current, [field]: value });
        return newRows;
      });
    },
    [userRole]
  );

  // Commit to Firestore on blur/enter. Viewer: no-op, return early.
  const commitField = useCallback(
    async (industry: string, field: keyof ThresholdValues) => {
      if (userRole !== 'admin') return;

      const dk = `${industry}.${field}`;
      const value = draft[dk];
      if (value === undefined) return;

      const serverEntry = serverRows.get(industry) || {
        irr: 0,
        leverageF2Min: 0,
        leverageF2Max: 0,
        ro40Min: 0,
        ro40Max: 0,
        cashSdebtMin: 0,
        cashSdebtMax: 0,
        currentRatioMin: 0,
        currentRatioMax: 0,
      };
      const updated: ThresholdValues = { ...serverEntry, [field]: value };

      try {
        const allValues = Object.fromEntries(serverRows);
        allValues[industry] = updated;
        await saveSharedThresholdValues(allValues, { user: currentUser, userRole });
        dirtyKeysRef.current.delete(dk);
        setDraft((d) => {
          const { [dk]: _, ...rest } = d;
          return rest;
        });
        setServerRows((rows) => {
          const newRows = new Map(rows);
          newRows.set(industry, updated);
          return newRows;
        });
      } catch (error: unknown) {
        if ((error as Error).message !== 'sharedThreshold.saveDenied') {
          logger.error('Error committing field to Firestore', error, {
            component: 'ThresholdContext',
            operation: 'sharedThreshold.saveFailed',
          });
        }
      }
    },
    [draft, serverRows, currentUser, userRole]
  );

  const initializeFromData = useCallback((data: ThresholdIndustryData[]) => {
    setServerRows((prev) => {
      const newMap = new Map(prev);
      data.forEach((item) => {
        if (!newMap.has(item.industry)) {
          newMap.set(item.industry, {
            irr: item.irr || 0,
            leverageF2Min: item.leverageF2Min || 0,
            leverageF2Max: item.leverageF2Max || 0,
            ro40Min: item.ro40Min || 0,
            ro40Max: item.ro40Max || 0,
            cashSdebtMin: item.cashSdebtMin || 0,
            cashSdebtMax: item.cashSdebtMax || 0,
            currentRatioMin: item.currentRatioMin || 0,
            currentRatioMax: item.currentRatioMax || 0,
          });
        }
      });
      return newMap;
    });
  }, []);

  // Compute thresholdValues from serverRows + draft for backward compatibility
  const thresholdValues = useMemo(() => {
    const result = new Map(serverRows);
    for (const [draftKey, draftValue] of Object.entries(draft)) {
      const [industry, field] = draftKey.split('.');
      const entry = result.get(industry) || {
        irr: 0,
        leverageF2Min: 0,
        leverageF2Max: 0,
        ro40Min: 0,
        ro40Max: 0,
        cashSdebtMin: 0,
        cashSdebtMax: 0,
        currentRatioMin: 0,
        currentRatioMax: 0,
      };
      result.set(industry, { ...entry, [field]: draftValue });
    }
    return result;
  }, [serverRows, draft]);

  const value: ThresholdContextType = {
    getThresholdValue,
    getFieldValue,
    setFieldValue,
    commitField,
    initializeFromData,
    thresholdValues,
  };

  return <ThresholdContext.Provider value={value}>{children}</ThresholdContext.Provider>;
}

export function useThresholdValues(): ThresholdContextType {
  const context = useContext(ThresholdContext);
  if (context === undefined) {
    throw new Error('useThresholdValues must be used within a ThresholdProvider');
  }
  return context;
}

```

## `src/contexts/ToastContext.tsx`

```tsx
import { createContext, useContext, ReactNode, useState, useCallback } from 'react';
import { Toast, ToastType } from '../components/Toast';

interface ToastContextType {
  showToast: (message: string, type?: ToastType, duration?: number) => void;
  showSuccess: (message: string, duration?: number) => void;
  showError: (message: string, duration?: number) => void;
  showInfo: (message: string, duration?: number) => void;
  showWarning: (message: string, duration?: number) => void;
  removeToast: (id: string) => void;
  toasts: Toast[];
}

const ToastContext = createContext<ToastContextType | undefined>(undefined);

interface ToastProviderProps {
  children: ReactNode;
}

export function ToastProvider({ children }: ToastProviderProps) {
  const [toasts, setToasts] = useState<Toast[]>([]);

  const removeToast = useCallback((id: string) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  }, []);

  const showToast = useCallback(
    (message: string, type: ToastType = 'info', duration: number = 5000) => {
      const id = `toast-${Date.now()}-${Math.random()}`;
      const newToast: Toast = {
        id,
        message,
        type,
        duration,
      };

      setToasts((prev) => [...prev, newToast]);
    },
    []
  );

  const showSuccess = useCallback(
    (message: string, duration?: number) => {
      showToast(message, 'success', duration);
    },
    [showToast]
  );

  const showError = useCallback(
    (message: string, duration?: number) => {
      showToast(message, 'error', duration || 7000); // Errors stay longer
    },
    [showToast]
  );

  const showInfo = useCallback(
    (message: string, duration?: number) => {
      showToast(message, 'info', duration);
    },
    [showToast]
  );

  const showWarning = useCallback(
    (message: string, duration?: number) => {
      showToast(message, 'warning', duration || 6000);
    },
    [showToast]
  );

  const value: ToastContextType = {
    showToast,
    showSuccess,
    showError,
    showInfo,
    showWarning,
    removeToast,
    toasts,
  };

  return <ToastContext.Provider value={value}>{children}</ToastContext.Provider>;
}

export function useToast(): ToastContextType {
  const context = useContext(ToastContext);
  if (context === undefined) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  return context;
}


```

## `src/hooks/__tests__/useBenjaminGrahamData.test.ts`

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { useBenjaminGrahamData } from '../useBenjaminGrahamData';
import * as sheetsService from '../../services/sheets';
import * as deltaSyncService from '../../services/deltaSyncService';
import * as firestoreCacheService from '../../services/firestoreCacheService';

// Mock dependencies
vi.mock('../../services/sheets');
vi.mock('../../services/deltaSyncService');
vi.mock('../../services/firestoreCacheService');
vi.mock('../../contexts/LoadingProgressContext', () => ({
  useLoadingProgress: () => ({
    updateProgress: vi.fn(),
  }),
}));
vi.mock('../usePageVisibility', () => ({
  usePageVisibility: () => true,
}));

vi.mock('../../contexts/RefreshContext', () => ({
  useRefreshOptional: () => undefined,
}));

vi.mock('../../contexts/NotificationContext', () => ({
  useNotifications: () => ({ createNotification: vi.fn() }),
}));

describe('useBenjaminGrahamData Error Handling', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
    vi.spyOn(firestoreCacheService, 'getViewDataWithFallback').mockResolvedValue(null);
    vi.spyOn(firestoreCacheService, 'setViewData').mockResolvedValue(undefined);
  });

  it('should handle fetch errors', async () => {
    const mockError = new Error('Failed to fetch data');
    vi.spyOn(sheetsService, 'fetchBenjaminGrahamData').mockRejectedValue(mockError);
    vi.spyOn(firestoreCacheService, 'getCachedData').mockResolvedValue(null);
    vi.spyOn(firestoreCacheService, 'getDeltaCacheEntry').mockResolvedValue(null);

    const { result } = renderHook(() => useBenjaminGrahamData());

    await waitFor(() => {
      expect(result.current.error).toBeTruthy();
      expect(result.current.loading).toBe(false);
    });
  });

  it('should handle network errors', async () => {
    const networkError = new TypeError('Failed to fetch');
    vi.spyOn(sheetsService, 'fetchBenjaminGrahamData').mockRejectedValue(networkError);
    vi.spyOn(firestoreCacheService, 'getCachedData').mockResolvedValue(null);
    vi.spyOn(firestoreCacheService, 'getDeltaCacheEntry').mockResolvedValue(null);

    const { result } = renderHook(() => useBenjaminGrahamData());

    await waitFor(() => {
      expect(result.current.error).toBeTruthy();
      expect(result.current.error).toMatch(/Connection error|Network error|Unable to connect/i);
    });
  });

  it('should handle delta sync errors and fallback to regular fetch', async () => {
    const deltaError = new Error('Delta sync failed');
    vi.spyOn(deltaSyncService, 'initSync').mockRejectedValue(deltaError);
    vi.spyOn(sheetsService, 'fetchBenjaminGrahamData').mockResolvedValue([]);
    vi.spyOn(firestoreCacheService, 'getCachedData').mockResolvedValue(null);
    vi.spyOn(firestoreCacheService, 'getDeltaCacheEntry').mockResolvedValue(null);
    vi.spyOn(deltaSyncService, 'isDeltaSyncEnabled').mockReturnValue(true);

    const { result } = renderHook(() => useBenjaminGrahamData());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });
  });

  it('should handle invalid data transformation', async () => {
    const invalidData = { data: null, meta: { fields: null } };
    vi.spyOn(sheetsService, 'fetchBenjaminGrahamData').mockImplementation(() => {
      throw new Error('Invalid data format');
    });
    vi.spyOn(firestoreCacheService, 'getCachedData').mockResolvedValue(null);
    vi.spyOn(firestoreCacheService, 'getDeltaCacheEntry').mockResolvedValue(null);

    const { result } = renderHook(() => useBenjaminGrahamData());

    await waitFor(() => {
      expect(result.current.error).toBeTruthy();
    });
  });

  it('should handle empty data gracefully', async () => {
    vi.spyOn(sheetsService, 'fetchBenjaminGrahamData').mockResolvedValue([]);
    vi.spyOn(firestoreCacheService, 'getCachedData').mockResolvedValue(null);
    vi.spyOn(firestoreCacheService, 'getDeltaCacheEntry').mockResolvedValue(null);

    const { result } = renderHook(() => useBenjaminGrahamData());

    await waitFor(() => {
      expect(result.current.data).toEqual([]);
      expect(result.current.loading).toBe(false);
      expect(result.current.error).toBeNull();
    });
  });
});

```

## `src/hooks/__tests__/useColumnVisibility.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useColumnVisibility, ColumnConfig } from '../useColumnVisibility';

// Mock logger
vi.mock('../../utils/logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  },
}));

describe('useColumnVisibility', () => {
  const mockColumns: ColumnConfig[] = [
    { key: 'col1', label: 'Column 1', defaultVisible: true },
    { key: 'col2', label: 'Column 2', defaultVisible: true },
    { key: 'col3', label: 'Column 3', defaultVisible: false },
    { key: 'col4', label: 'Column 4', required: true },
  ];

  beforeEach(() => {
    localStorage.clear();
  });

  it('should initialize with default visibility', () => {
    const { result } = renderHook(() =>
      useColumnVisibility({ tableId: 'test', columns: mockColumns })
    );

    expect(result.current.isColumnVisible('col1')).toBe(true);
    expect(result.current.isColumnVisible('col2')).toBe(true);
    expect(result.current.isColumnVisible('col3')).toBe(false);
    expect(result.current.isColumnVisible('col4')).toBe(true);
  });

  it('should load saved visibility from localStorage', () => {
    const savedVisibility = {
      col1: false,
      col2: true,
      col3: true,
    };
    localStorage.setItem('columnVisibility_test', JSON.stringify(savedVisibility));

    const { result } = renderHook(() =>
      useColumnVisibility({ tableId: 'test', columns: mockColumns })
    );

    expect(result.current.isColumnVisible('col1')).toBe(false);
    expect(result.current.isColumnVisible('col2')).toBe(true);
    expect(result.current.isColumnVisible('col3')).toBe(true);
  });

  it('should toggle column visibility', () => {
    const { result } = renderHook(() =>
      useColumnVisibility({ tableId: 'test', columns: mockColumns })
    );

    act(() => {
      result.current.toggleColumn('col1');
    });

    expect(result.current.isColumnVisible('col1')).toBe(false);
  });

  it('should not allow hiding required columns', () => {
    const { result } = renderHook(() =>
      useColumnVisibility({ tableId: 'test', columns: mockColumns })
    );

    act(() => {
      result.current.toggleColumn('col4');
    });

    expect(result.current.isColumnVisible('col4')).toBe(true);
  });

  it('should save visibility to localStorage', () => {
    const { result } = renderHook(() =>
      useColumnVisibility({ tableId: 'test', columns: mockColumns })
    );

    act(() => {
      result.current.toggleColumn('col1');
    });

    const saved = JSON.parse(localStorage.getItem('columnVisibility_test') || '{}');
    expect(saved.col1).toBe(false);
  });

  it('should show all columns', () => {
    const { result } = renderHook(() =>
      useColumnVisibility({ tableId: 'test', columns: mockColumns })
    );

    act(() => {
      result.current.hideAllColumns();
      result.current.showAllColumns();
    });

    expect(result.current.isColumnVisible('col1')).toBe(true);
    expect(result.current.isColumnVisible('col2')).toBe(true);
    expect(result.current.isColumnVisible('col3')).toBe(true);
  });

  it('should hide all non-required columns', () => {
    const { result } = renderHook(() =>
      useColumnVisibility({ tableId: 'test', columns: mockColumns })
    );

    act(() => {
      result.current.hideAllColumns();
    });

    expect(result.current.isColumnVisible('col1')).toBe(false);
    expect(result.current.isColumnVisible('col2')).toBe(false);
    expect(result.current.isColumnVisible('col3')).toBe(false);
    expect(result.current.isColumnVisible('col4')).toBe(true); // Required
  });

  it('should reset to defaults', () => {
    const { result } = renderHook(() =>
      useColumnVisibility({ tableId: 'test', columns: mockColumns })
    );

    act(() => {
      result.current.toggleColumn('col1');
      result.current.toggleColumn('col2');
      result.current.resetToDefaults();
    });

    expect(result.current.isColumnVisible('col1')).toBe(true);
    expect(result.current.isColumnVisible('col2')).toBe(true);
    expect(result.current.isColumnVisible('col3')).toBe(false);
  });

  it('should handle corrupted localStorage data', () => {
    localStorage.setItem('columnVisibility_test', 'invalid json');

    const { result } = renderHook(() =>
      useColumnVisibility({ tableId: 'test', columns: mockColumns })
    );

    // Should fall back to defaults
    expect(result.current.isColumnVisible('col1')).toBe(true);
  });

  it('should merge saved state with new columns', () => {
    const savedVisibility = { col1: false };
    localStorage.setItem('columnVisibility_test', JSON.stringify(savedVisibility));

    const newColumns: ColumnConfig[] = [
      { key: 'col1', label: 'Column 1' },
      { key: 'col5', label: 'Column 5', defaultVisible: false },
    ];

    const { result } = renderHook(() =>
      useColumnVisibility({ tableId: 'test', columns: newColumns })
    );

    expect(result.current.isColumnVisible('col1')).toBe(false); // From saved
    expect(result.current.isColumnVisible('col5')).toBe(false); // From default
  });
});

```

## `src/hooks/__tests__/useDebounce.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { useDebounce } from '../useDebounce';

describe('useDebounce', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should return initial value immediately', () => {
    const { result } = renderHook(() => useDebounce('test', 300));
    expect(result.current).toBe('test');
  });

  it('should debounce value changes', async () => {
    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 300),
      { initialProps: { value: 'initial' } }
    );

    expect(result.current).toBe('initial');

    rerender({ value: 'updated' });
    expect(result.current).toBe('initial'); // Still initial

    await vi.advanceTimersByTimeAsync(300);
    await waitFor(() => {
      expect(result.current).toBe('updated');
    });
  });

  it('should cancel previous timeout when value changes quickly', async () => {
    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 300),
      { initialProps: { value: 'initial' } }
    );

    rerender({ value: 'first' });
    await vi.advanceTimersByTimeAsync(100);

    rerender({ value: 'second' });
    await vi.advanceTimersByTimeAsync(100);

    rerender({ value: 'third' });
    await vi.advanceTimersByTimeAsync(300);

    expect(result.current).toBe('third');
  });

  it('should use custom delay', async () => {
    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 500),
      { initialProps: { value: 'initial' } }
    );

    rerender({ value: 'updated' });
    await vi.advanceTimersByTimeAsync(300);
    expect(result.current).toBe('initial'); // Still initial after 300ms

    await vi.advanceTimersByTimeAsync(200);
    await waitFor(() => {
      expect(result.current).toBe('updated');
    });
  });

  it('should handle number values', async () => {
    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 300),
      { initialProps: { value: 0 } }
    );

    rerender({ value: 100 });
    await vi.advanceTimersByTimeAsync(300);

    await waitFor(() => {
      expect(result.current).toBe(100);
    });
  });

  it('should handle object values', async () => {
    const initial = { key: 'value' };
    const updated = { key: 'newValue' };

    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 300),
      { initialProps: { value: initial } }
    );

    rerender({ value: updated });
    await vi.advanceTimersByTimeAsync(300);

    await waitFor(() => {
      expect(result.current).toEqual(updated);
    });
  });
});

```

## `src/hooks/__tests__/useGlobalSearch.test.ts`

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook } from '@testing-library/react';
import { useGlobalSearch } from '../useGlobalSearch';
import { createMockScoreBoardData, createMockBenjaminGrahamData, createMockPEIndustryData, createMockThresholdData } from '../../test/helpers';

// Mock the data hooks
vi.mock('../useScoreBoardData', () => ({
  useScoreBoardData: () => ({
    data: [
      createMockScoreBoardData({ companyName: 'Apple Inc', ticker: 'AAPL', industry: 'Technology' }),
      createMockScoreBoardData({ companyName: 'Microsoft Corp', ticker: 'MSFT', industry: 'Technology' }),
    ],
  }),
}));

vi.mock('../useBenjaminGrahamData', () => ({
  useBenjaminGrahamData: () => ({
    data: [
      createMockBenjaminGrahamData({ companyName: 'Apple Inc', ticker: 'AAPL' }),
    ],
  }),
}));

vi.mock('../usePEIndustryData', () => ({
  usePEIndustryData: () => ({
    data: [
      createMockPEIndustryData({ industry: 'Technology' }),
    ],
  }),
}));

vi.mock('../useThresholdIndustryData', () => ({
  useThresholdIndustryData: () => ({
    data: [
      createMockThresholdData({ industry: 'Technology' }),
    ],
  }),
}));

describe('useGlobalSearch', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should return empty array for empty query', () => {
    const { result } = renderHook(() => useGlobalSearch());

    const results = result.current.search('');
    expect(results).toEqual([]);
  });

  it('should search by company name', () => {
    const { result } = renderHook(() => useGlobalSearch());

    const results = result.current.search('Apple');

    expect(results.length).toBeGreaterThan(0);
    expect(results.some(r => r.companyName === 'Apple Inc')).toBe(true);
  });

  it('should search by ticker', () => {
    const { result } = renderHook(() => useGlobalSearch());

    const results = result.current.search('AAPL');

    expect(results.length).toBeGreaterThan(0);
    expect(results.some(r => r.ticker === 'AAPL')).toBe(true);
  });

  it('should search by industry', () => {
    const { result } = renderHook(() => useGlobalSearch());

    const results = result.current.search('Technology');

    expect(results.length).toBeGreaterThan(0);
    expect(results.every(r => r.industry === 'Technology' || !r.industry)).toBe(true);
  });

  it('should search across all data types', () => {
    const { result } = renderHook(() => useGlobalSearch());

    const results = result.current.search('Technology');

    // Should find results from multiple data types
    const types = results.map(r => r.type);
    expect(types).toContain('score-board');
    expect(types).toContain('pe-industry');
    expect(types).toContain('threshold-industry');
  });

  it('should limit results to 50', () => {
    const { result } = renderHook(() => useGlobalSearch());

    // Create a query that would match many items
    const results = result.current.search('Tech');

    expect(results.length).toBeLessThanOrEqual(50);
  });

  it('should be case-insensitive', () => {
    const { result } = renderHook(() => useGlobalSearch());

    const results1 = result.current.search('apple');
    const results2 = result.current.search('APPLE');

    expect(results1.length).toBe(results2.length);
  });

  it('should remove duplicate results by id', () => {
    const { result } = renderHook(() => useGlobalSearch());

    const results = result.current.search('Apple');

    const ids = results.map(r => r.id);
    const uniqueIds = new Set(ids);
    expect(ids.length).toBe(uniqueIds.size);
  });
});

```

## `src/hooks/__tests__/usePEIndustryData.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { usePEIndustryData } from '../usePEIndustryData';
import { fetchPEIndustryData } from '../../services/sheets';
import { getCachedData, getDeltaCacheEntry } from '../../services/firestoreCacheService';
import { createMockPEIndustryData } from '../../test/helpers';

// Mock dependencies
vi.mock('../../services/sheets', () => ({
  fetchPEIndustryData: vi.fn(),
}));

vi.mock('../../services/firestoreCacheService', async () => {
  const actual = await vi.importActual('../../services/firestoreCacheService');
  return {
    ...actual,
    getCachedData: vi.fn(),
    getDeltaCacheEntry: vi.fn(),
    setCachedData: vi.fn(),
    setDeltaCacheEntry: vi.fn(),
  };
});

vi.mock('../../services/deltaSyncService', () => ({
  isDeltaSyncEnabled: vi.fn(() => false),
  initSync: vi.fn(),
  pollChanges: vi.fn(),
  loadSnapshot: vi.fn(),
  applyChangesToCache: vi.fn(),
  getPollIntervalMs: vi.fn(() => 900000),
  snapshotToTransformerFormat: vi.fn(),
}));

vi.mock('../../contexts/LoadingProgressContext', () => ({
  useLoadingProgress: () => ({
    updateProgress: vi.fn(),
  }),
}));

vi.mock('../usePageVisibility', () => ({
  usePageVisibility: () => true,
}));

vi.mock('../../utils/errorHandler', () => ({
  formatError: vi.fn((err) => ({ message: String(err), userMessage: String(err) })),
  logError: vi.fn(),
  createErrorHandler: vi.fn(() => (err: unknown) => ({ message: String(err), userMessage: String(err) })),
}));

vi.mock('../../contexts/RefreshContext', () => ({
  useRefreshOptional: () => undefined,
}));

vi.mock('../../contexts/NotificationContext', () => ({
  useNotifications: () => ({ createNotification: vi.fn() }),
}));

describe('usePEIndustryData', () => {
  const mockData = [
    createMockPEIndustryData({ industry: 'Technology', pe: 20 }),
    createMockPEIndustryData({ industry: 'Finance', pe: 15 }),
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should load data from cache initially', async () => {
    (getDeltaCacheEntry as any).mockResolvedValue(null);
    (getCachedData as any).mockResolvedValue(mockData);

    const { result } = renderHook(() => usePEIndustryData());

    await waitFor(() => {
      expect(result.current.data).toEqual(mockData);
      expect(result.current.loading).toBe(false);
    });
  });

  it('should fetch data when cache is empty', async () => {
    (getDeltaCacheEntry as any).mockResolvedValue(null);
    (getCachedData as any).mockResolvedValue(null);
    (fetchPEIndustryData as any).mockResolvedValue(mockData);

    const { result } = renderHook(() => usePEIndustryData());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.data).toEqual(mockData);
    expect(fetchPEIndustryData).toHaveBeenCalled();
  });

  it('should handle fetch errors', async () => {
    (getDeltaCacheEntry as any).mockResolvedValue(null);
    (getCachedData as any).mockResolvedValue(null);
    (fetchPEIndustryData as any).mockRejectedValue(new Error('Fetch error'));

    const { result } = renderHook(() => usePEIndustryData());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.error).toBeTruthy();
  });
});

```

## `src/hooks/__tests__/useScoreBoardData.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { renderHook, waitFor, act } from '@testing-library/react';
import { useScoreBoardData } from '../useScoreBoardData';
import { fetchScoreBoardData } from '../../services/sheets';
import { getCachedData, getDeltaCacheEntry } from '../../services/firestoreCacheService';
import { createMockScoreBoardData } from '../../test/helpers';

// Mock dependencies
vi.mock('../../services/sheets', () => ({
  fetchScoreBoardData: vi.fn(),
}));

vi.mock('../../services/firestoreCacheService', async () => {
  const actual = await vi.importActual('../../services/firestoreCacheService');
  return {
    ...actual,
    getCachedData: vi.fn(),
    getDeltaCacheEntry: vi.fn(),
    setCachedData: vi.fn(),
    setDeltaCacheEntry: vi.fn(),
  };
});

vi.mock('../../services/deltaSyncService', () => ({
  isDeltaSyncEnabled: vi.fn(() => false),
  initSync: vi.fn(),
  pollChanges: vi.fn(),
  loadSnapshot: vi.fn(),
  applyChangesToCache: vi.fn(),
  getPollIntervalMs: vi.fn(() => 900000),
  snapshotToTransformerFormat: vi.fn(),
}));

vi.mock('../../contexts/LoadingProgressContext', () => ({
  useLoadingProgress: () => ({
    updateProgress: vi.fn(),
  }),
}));

vi.mock('../usePageVisibility', () => ({
  usePageVisibility: () => true,
}));

vi.mock('../../utils/errorHandler', () => ({
  formatError: vi.fn((err) => ({ message: String(err), userMessage: String(err) })),
  logError: vi.fn(),
  createErrorHandler: vi.fn(() => (err: unknown) => ({ message: String(err), userMessage: String(err) })),
}));

vi.mock('../../contexts/RefreshContext', () => ({
  useRefreshOptional: () => undefined,
}));

vi.mock('../../contexts/NotificationContext', () => ({
  useNotifications: () => ({ createNotification: vi.fn() }),
}));

describe('useScoreBoardData', () => {
  const mockData = [
    createMockScoreBoardData({ companyName: 'Company A', ticker: 'A' }),
    createMockScoreBoardData({ companyName: 'Company B', ticker: 'B' }),
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should load data from cache initially', async () => {
    (getDeltaCacheEntry as any).mockResolvedValue(null);
    (getCachedData as any).mockResolvedValue(mockData);

    const { result } = renderHook(() => useScoreBoardData());

    await waitFor(() => {
      expect(result.current.data).toEqual(mockData);
      expect(result.current.loading).toBe(false);
    });
  });

  it('should fetch data when cache is empty', async () => {
    (getDeltaCacheEntry as any).mockResolvedValue(null);
    (getCachedData as any).mockResolvedValue(null);
    (fetchScoreBoardData as any).mockResolvedValue(mockData);

    const { result } = renderHook(() => useScoreBoardData());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.data).toEqual(mockData);
    expect(fetchScoreBoardData).toHaveBeenCalled();
  });

  it('should handle fetch errors', async () => {
    (getDeltaCacheEntry as any).mockResolvedValue(null);
    (getCachedData as any).mockResolvedValue(null);
    (fetchScoreBoardData as any).mockRejectedValue(new Error('Fetch error'));

    const { result } = renderHook(() => useScoreBoardData());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.error).toBeTruthy();
    expect(result.current.data).toEqual([]);
  });

  it('should support force refresh', async () => {
    (getDeltaCacheEntry as any).mockResolvedValue(null);
    (getCachedData as any).mockResolvedValue(mockData);
    (fetchScoreBoardData as any).mockResolvedValue(mockData);

    const { result } = renderHook(() => useScoreBoardData());

    await act(async () => {
      await result.current.refetch(true);
    });

    expect(fetchScoreBoardData).toHaveBeenCalledWith(true, expect.any(Function));
  });

  it('should update lastUpdated on successful fetch', async () => {
    (getDeltaCacheEntry as any).mockResolvedValue(null);
    (getCachedData as any).mockResolvedValue(null);
    (fetchScoreBoardData as any).mockResolvedValue(mockData);

    const { result } = renderHook(() => useScoreBoardData());

    await waitFor(() => {
      expect(result.current.lastUpdated).toBeTruthy();
    });
  });
});

```

## `src/hooks/__tests__/useTablePagination.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useTablePagination } from '../useTablePagination';

describe('useTablePagination', () => {
  const generateData = (count: number) => {
    return Array.from({ length: count }, (_, i) => ({ id: i, name: `Item ${i}` }));
  };

  it('should paginate data correctly', () => {
    const data = generateData(100);
    const { result } = renderHook(() =>
      useTablePagination({ data, itemsPerPage: 10 })
    );

    expect(result.current.paginatedData).toHaveLength(10);
    expect(result.current.totalPages).toBe(10);
    expect(result.current.currentPage).toBe(1);
  });

  it('should navigate to next page', () => {
    const data = generateData(100);
    const { result } = renderHook(() =>
      useTablePagination({ data, itemsPerPage: 10 })
    );

    act(() => {
      result.current.nextPage();
    });

    expect(result.current.currentPage).toBe(2);
    expect(result.current.paginatedData[0].id).toBe(10);
  });

  it('should navigate to previous page', () => {
    const data = generateData(100);
    const { result } = renderHook(() =>
      useTablePagination({ data, itemsPerPage: 10, initialPage: 2 })
    );

    act(() => {
      result.current.previousPage();
    });

    expect(result.current.currentPage).toBe(1);
  });

  it('should not go beyond first page', () => {
    const data = generateData(100);
    const { result } = renderHook(() =>
      useTablePagination({ data, itemsPerPage: 10, initialPage: 1 })
    );

    act(() => {
      result.current.previousPage();
    });

    expect(result.current.currentPage).toBe(1);
  });

  it('should not go beyond last page', () => {
    const data = generateData(100);
    const { result } = renderHook(() =>
      useTablePagination({ data, itemsPerPage: 10, initialPage: 10 })
    );

    act(() => {
      result.current.nextPage();
    });

    expect(result.current.currentPage).toBe(10);
  });

  it('should go to specific page', () => {
    const data = generateData(100);
    const { result } = renderHook(() =>
      useTablePagination({ data, itemsPerPage: 10 })
    );

    act(() => {
      result.current.goToPage(5);
    });

    expect(result.current.currentPage).toBe(5);
    expect(result.current.paginatedData[0].id).toBe(40);
  });

  it('should clamp page number to valid range', () => {
    const data = generateData(100);
    const { result } = renderHook(() =>
      useTablePagination({ data, itemsPerPage: 10 })
    );

    act(() => {
      result.current.goToPage(0);
    });
    expect(result.current.currentPage).toBe(1);

    act(() => {
      result.current.goToPage(100);
    });
    expect(result.current.currentPage).toBe(10);
  });

  it('should go to first page', () => {
    const data = generateData(100);
    const { result } = renderHook(() =>
      useTablePagination({ data, itemsPerPage: 10, initialPage: 5 })
    );

    act(() => {
      result.current.goToFirstPage();
    });

    expect(result.current.currentPage).toBe(1);
  });

  it('should go to last page', () => {
    const data = generateData(100);
    const { result } = renderHook(() =>
      useTablePagination({ data, itemsPerPage: 10 })
    );

    act(() => {
      result.current.goToLastPage();
    });

    expect(result.current.currentPage).toBe(10);
  });

  it('should reset to page 1 when data changes significantly', () => {
    const data1 = generateData(100);
    const { result, rerender } = renderHook(
      ({ data }) => useTablePagination({ data, itemsPerPage: 10 }),
      { initialProps: { data: data1 } }
    );

    act(() => {
      result.current.goToPage(5);
    });

    const data2 = generateData(20); // Much smaller dataset
    rerender({ data: data2 });

    expect(result.current.currentPage).toBe(1);
  });

  it('should calculate correct start and end indices', () => {
    const data = generateData(100);
    const { result } = renderHook(() =>
      useTablePagination({ data, itemsPerPage: 10, initialPage: 3 })
    );

    expect(result.current.startIndex).toBe(21);
    expect(result.current.endIndex).toBe(30);
  });

  it('should handle empty data', () => {
    const { result } = renderHook(() =>
      useTablePagination({ data: [], itemsPerPage: 10 })
    );

    expect(result.current.paginatedData).toHaveLength(0);
    expect(result.current.totalPages).toBe(0);
    expect(result.current.totalItems).toBe(0);
  });
});

```

## `src/hooks/__tests__/useTableSearch.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { renderHook, act, waitFor } from '@testing-library/react';
import { useTableSearch } from '../useTableSearch';
import { createMockScoreBoardData } from '../../test/helpers';

// Mock sanitizeSearchQuery
vi.mock('../../utils/inputValidator', async () => {
  const actual = await vi.importActual('../../utils/inputValidator');
  return {
    ...actual,
    sanitizeSearchQuery: (query: string) => query, // Simple passthrough for tests
  };
});

describe('useTableSearch', () => {
  const mockData = [
    createMockScoreBoardData({ companyName: 'Apple Inc', ticker: 'AAPL', industry: 'Technology' }),
    createMockScoreBoardData({ companyName: 'Microsoft Corp', ticker: 'MSFT', industry: 'Technology' }),
    createMockScoreBoardData({ companyName: 'Tesla Inc', ticker: 'TSLA', industry: 'Automotive' }),
  ];

  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should filter data by search query', async () => {
    const { result } = renderHook(() =>
      useTableSearch({
        data: mockData,
        searchFields: ['companyName', 'ticker'],
      })
    );

    act(() => {
      result.current.setSearchValue('Apple');
    });

    await vi.advanceTimersByTimeAsync(350);
    await waitFor(() => {
      expect(result.current.filteredData).toHaveLength(1);
      expect(result.current.filteredData[0].companyName).toBe('Apple Inc');
    });
  });

  it('should filter by multiple fields', async () => {
    const { result } = renderHook(() =>
      useTableSearch({
        data: mockData,
        searchFields: ['companyName', 'ticker', 'industry'],
      })
    );

    act(() => {
      result.current.setSearchValue('Tech');
    });

    await vi.advanceTimersByTimeAsync(350);
    await waitFor(() => {
      expect(result.current.filteredData.length).toBeGreaterThan(0);
    });
  });

  it('should apply advanced filters', () => {
    const { result } = renderHook(() =>
      useTableSearch({
        data: mockData,
        searchFields: ['companyName'],
        advancedFilters: {
          industry: 'Technology',
        },
      })
    );

    expect(result.current.filteredData.length).toBe(2);
    expect(result.current.filteredData.every(item => item.industry === 'Technology')).toBe(true);
  });

  it('should handle empty search query', async () => {
    const { result } = renderHook(() =>
      useTableSearch({
        data: mockData,
        searchFields: ['companyName'],
      })
    );

    act(() => {
      result.current.setSearchValue('');
    });

    await vi.advanceTimersByTimeAsync(350);
    await waitFor(() => {
      expect(result.current.filteredData).toHaveLength(mockData.length);
    });
  });

  it('should handle number range filters', () => {
    const dataWithScores = [
      createMockScoreBoardData({ companyName: 'Company A', score: 50 }),
      createMockScoreBoardData({ companyName: 'Company B', score: 75 }),
      createMockScoreBoardData({ companyName: 'Company C', score: 90 }),
    ];

    const { result } = renderHook(() =>
      useTableSearch({
        data: dataWithScores,
        searchFields: ['companyName'],
        advancedFilters: {
          score: { min: 70, max: 80 },
        },
      })
    );

    expect(result.current.filteredData).toHaveLength(1);
    expect(result.current.filteredData[0].score).toBe(75);
  });
});

```

## `src/hooks/__tests__/useTableSort.test.ts`

```typescript
import { describe, it, expect, vi } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useTableSort } from '../useTableSort';
import { createMockScoreBoardData } from '../../test/helpers';

// Mock logger
vi.mock('../../utils/logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  },
}));

describe('useTableSort', () => {
  const mockData = [
    createMockScoreBoardData({ companyName: 'Company A', ticker: 'A', score: 50 }),
    createMockScoreBoardData({ companyName: 'Company B', ticker: 'B', score: 80 }),
    createMockScoreBoardData({ companyName: 'Company C', ticker: 'C', score: 30 }),
  ];

  it('should sort data by default key', () => {
    const { result } = renderHook(() =>
      useTableSort(mockData, 'companyName', 'asc')
    );

    expect(result.current.sortedData[0].companyName).toBe('Company A');
    expect(result.current.sortedData[1].companyName).toBe('Company B');
    expect(result.current.sortedData[2].companyName).toBe('Company C');
  });

  it('should sort in descending order', () => {
    const { result } = renderHook(() =>
      useTableSort(mockData, 'companyName', 'desc')
    );

    expect(result.current.sortedData[0].companyName).toBe('Company C');
    expect(result.current.sortedData[1].companyName).toBe('Company B');
    expect(result.current.sortedData[2].companyName).toBe('Company A');
  });

  it('should handle sort direction toggle', () => {
    const { result } = renderHook(() =>
      useTableSort(mockData, 'companyName', 'asc')
    );

    act(() => {
      result.current.handleSort('score');
    });

    expect(result.current.sortConfig.key).toBe('score');
    expect(result.current.sortConfig.direction).toBe('asc');

    act(() => {
      result.current.handleSort('score');
    });

    expect(result.current.sortConfig.direction).toBe('desc');
  });

  it('should sort numeric values correctly', () => {
    const { result } = renderHook(() =>
      useTableSort(mockData, 'score', 'asc')
    );

    expect(result.current.sortedData[0].score).toBe(30);
    expect(result.current.sortedData[1].score).toBe(50);
    expect(result.current.sortedData[2].score).toBe(80);
  });

  it('should handle null values in sorting', () => {
    const dataWithNulls = [
      createMockScoreBoardData({ companyName: 'Company A', score: null }),
      createMockScoreBoardData({ companyName: 'Company B', score: 50 }),
      createMockScoreBoardData({ companyName: 'Company C', score: null }),
    ];

    const { result } = renderHook(() =>
      useTableSort(dataWithNulls, 'score', 'asc')
    );

    // Items with null should be at the end
    const sorted = result.current.sortedData;
    expect(sorted[sorted.length - 1].score).toBeNull();
  });

  it('should handle N/A string values', () => {
    const dataWithNA = [
      createMockScoreBoardData({ companyName: 'Company A', score: 'N/A' as any }),
      createMockScoreBoardData({ companyName: 'Company B', score: 50 }),
    ];

    const { result } = renderHook(() =>
      useTableSort(dataWithNA, 'score', 'asc')
    );

    // N/A values should be at the end
    const sorted = result.current.sortedData;
    expect(sorted[sorted.length - 1].score).toBe('N/A');
  });
});

```

## `src/hooks/__tests__/useThresholdIndustryData.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { useThresholdIndustryData } from '../useThresholdIndustryData';
import { createMockThresholdData } from '../../test/helpers';
import { ThresholdIndustryData } from '../../types/stock';

// Mock static data file
const mockStaticData: ThresholdIndustryData[] = [
  createMockThresholdData({ industry: 'Technology', irr: 20 }),
  createMockThresholdData({ industry: 'Finance', irr: 15 }),
];

vi.mock('../../config/thresholdIndustryData', () => ({
  STATIC_THRESHOLD_INDUSTRY_DATA: mockStaticData,
}));

// Mock ThresholdContext
const mockInitializeFromData = vi.fn();

vi.mock('../../contexts/ThresholdContext', () => ({
  useThresholdValues: () => ({
    initializeFromData: mockInitializeFromData,
  }),
}));

describe('useThresholdIndustryData', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should load data from static file on mount', async () => {
    const { result } = renderHook(() => useThresholdIndustryData());

    // Wait for loading to complete
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.data).toEqual(mockStaticData);
    expect(result.current.error).toBeNull();
    expect(result.current.lastUpdated).toBeInstanceOf(Date);
    expect(mockInitializeFromData).toHaveBeenCalledWith(mockStaticData);
  });

  it('should call initializeFromData when data loads', async () => {
    renderHook(() => useThresholdIndustryData());

    await waitFor(() => {
      expect(mockInitializeFromData).toHaveBeenCalled();
    });

    expect(mockInitializeFromData).toHaveBeenCalledWith(mockStaticData);
  });

  it('should refetch data from static file', async () => {
    const { result } = renderHook(() => useThresholdIndustryData());

    // Wait for initial load
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    // Clear previous call count
    mockInitializeFromData.mockClear();

    // Call refetch
    result.current.refetch();

    // Wait for refetch to complete
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.data).toEqual(mockStaticData);
    expect(mockInitializeFromData).toHaveBeenCalledWith(mockStaticData);
    expect(result.current.error).toBeNull();
  });

  it('should update lastUpdated when refetching', async () => {
    const { result } = renderHook(() => useThresholdIndustryData());

    // Wait for initial load
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    const firstLastUpdated = result.current.lastUpdated;

    // Wait a bit to ensure different timestamp
    await new Promise(resolve => setTimeout(resolve, 10));

    // Call refetch
    result.current.refetch();

    // Wait for refetch to complete
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.lastUpdated).toBeInstanceOf(Date);
    // lastUpdated should be updated (or at least set)
    expect(result.current.lastUpdated).not.toBeNull();
  });
});

```

## `src/hooks/useBenjaminGrahamData.ts`

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';
import { 
  fetchBenjaminGrahamData, 
  ProgressCallback,
  getValue,
  isValidValue,
  parseNumericValueNullable
} from '../services/sheets';
import type { DataRow } from '../services/sheets';
import { 
  initSync, 
  pollChanges, 
  loadSnapshot, 
  applyChangesToCache,
  isDeltaSyncEnabled,
  getPollIntervalMs,
  snapshotToTransformerFormat,
  type DeltaSyncConfig
} from '../services/deltaSyncService';
import {
  setDeltaCacheEntry,
  getDeltaCacheEntry,
  getCachedData,
  VIEWDATA_MIGRATION_MODE,
  setViewData,
  getViewDataWithFallback,
  CACHE_KEYS,
} from '../services/firestoreCacheService';
import { BenjaminGrahamData } from '../types/stock';
import { useLoadingProgress } from '../contexts/LoadingProgressContext';
import { useRefreshOptional } from '../contexts/RefreshContext';
import { usePageVisibility } from './usePageVisibility';
import { formatError, logError, createErrorHandler, isErrorType } from '../utils/errorHandler';
import { isDataRowArray } from '../utils/typeGuards';
import { logger } from '../utils/logger';
import { useNotifications } from '../contexts/NotificationContext';
import { detectDataChanges, formatChangeSummary } from '../utils/dataChangeDetector';

const APPS_SCRIPT_URL = import.meta.env.VITE_APPS_SCRIPT_URL || '';
const SHEET_NAME = 'DashBoard';
const CACHE_KEY = CACHE_KEYS.BENJAMIN_GRAHAM;

// Transformer function for Benjamin Graham data
function transformBenjaminGrahamData(results: { data: DataRow[]; meta: { fields: string[] | null } }): BenjaminGrahamData[] {
  if (!isDataRowArray(results.data)) {
    const errorHandler = createErrorHandler({
      operation: 'transform Benjamin Graham data',
      component: 'useBenjaminGrahamData',
    });
    throw new Error('Invalid data format: expected array of DataRow');
  }
  
  const benjaminGrahamData = results.data
    .map((row: DataRow) => {
      const companyName = getValue(['Company Name', 'Company', 'company'], row);
      const ticker = getValue(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
      const priceStr = getValue(['Price', 'price', 'PRICE'], row);
      const benjaminGrahamStr = getValue(['Benjamin Graham', 'benjamin graham', 'Benjamin', 'benjamin'], row);
      
      // Only process if company name is valid (not #N/A)
      if (!isValidValue(companyName)) {
        return null;
      }
      
      // Filter out rows where Ticker is N/A (DashBoard rule: if Ticker is N/A, don't fetch data)
      if (!isValidValue(ticker)) {
        return null;
      }
      
      // Parse Price value as number (handle #N/A)
      const price = parseNumericValueNullable(priceStr);
      
      // Parse Benjamin Graham value as number (handle #N/A)
      const benjaminGraham = parseNumericValueNullable(benjaminGrahamStr);
      
      // Parse IV (FCF) if it exists
      const ivFcfStr = getValue(['IV (FCF)', 'IV(FCF)', 'iv fcf', 'ivfcf'], row);
      const ivFcf = parseNumericValueNullable(ivFcfStr);
      
      // Parse IRR1 if it exists
      const irr1Str = getValue(['IRR1', 'irr1', 'IRR 1', 'irr 1'], row);
      const irr1 = parseNumericValueNullable(irr1Str);
      
      // Include row if both company name and ticker are valid (we already checked above)
      return {
        companyName: companyName,
        ticker: ticker,
        price: price,
        benjaminGraham: benjaminGraham,
        ivFcf: ivFcf, // Include if it exists
        irr1: irr1, // Include if it exists
      };
    })
    .filter((data) => data !== null) as BenjaminGrahamData[];
  
  return benjaminGrahamData;
}

/**
 * Custom hook for fetching and managing Benjamin Graham data with delta sync
 * 
 * Implements delta sync for efficient data updates:
 * - **Delta Sync (enabled)**: Uses version-based incremental updates
 *   - Initial load: Full snapshot
 *   - Subsequent updates: Only changed rows (polling every 15 minutes)
 *   - Automatic polling when page is visible
 * - **Fallback (disabled)**: Uses regular fetch with stale-while-revalidate
 * 
 * **Delta Sync Strategy:**
 * - Polls for changes every 15 minutes (configurable)
 * - Only polls when page is visible (saves resources)
 * - Falls back to regular fetch if delta sync fails
 * - Uses version numbers to track changes efficiently
 * 
 * **Cache Strategy:**
 * - Delta cache: Version-based with lastUpdated timestamp
 * - Regular cache: TTL-based (20 minutes)
 * - Shows cached data immediately, updates in background
 * 
 * **Edge Cases:**
 * - Missing threshold data: Returns BLANK for industry-dependent metrics
 * - Version mismatch: Triggers full snapshot reload
 * - Polling failures: Silent (doesn't show errors to user)
 * 
 * @returns Object with data, loading state, error, lastUpdated timestamp, and refetch function
 * 
 * @example
 * ```typescript
 * const { data, loading, error, refetch } = useBenjaminGrahamData();
 * 
 * // Data automatically updates via delta sync if enabled
 * // Or manually refresh:
 * refetch(true);
 * ```
 */
export function useBenjaminGrahamData() {
  const [data, setData] = useState<BenjaminGrahamData[]>([]);
  const [loading, setLoading] = useState(true); // Start with loading state
  const [error, setError] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
  const { updateProgress } = useLoadingProgress();
  const isPageVisible = usePageVisibility();
  const currentVersionRef = useRef<number>(0);
  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const { createNotification } = useNotifications();
  const previousDataRef = useRef<BenjaminGrahamData[]>([]);
  const cacheLoadedRef = useRef<boolean>(false);

  // Load data using delta-sync or fallback to regular fetch
  const loadData = useCallback(async (forceRefresh: boolean = false, isBackground: boolean = false) => {
    try {
      if (!isBackground) {
        setLoading(true);
      }
      setError(null);
      
      if (!isBackground) {
        updateProgress('benjamin-graham', {
          status: 'loading',
          progress: 0,
          message: 'Loading data...',
        });
      }

      // Try delta-sync if enabled
      if (isDeltaSyncEnabled() && APPS_SCRIPT_URL && !forceRefresh) {
        try {
          const config: DeltaSyncConfig = {
            sheetName: SHEET_NAME,
            apiBaseUrl: APPS_SCRIPT_URL,
            dataTypeName: 'Benjamin Graham',
          };

          // Load initial snapshot or use cached data
          const result = await initSync<BenjaminGrahamData>(
            config,
            CACHE_KEY,
            transformBenjaminGrahamData
          );

          // Detect data changes
          const changes = detectDataChanges(
            previousDataRef.current,
            result.data,
            (item) => `${item.ticker}-${item.companyName}`,
            0.05 // 5% threshold
          );
          
          setData(result.data);
          previousDataRef.current = result.data;
          currentVersionRef.current = result.version;
          setLastUpdated(new Date());
          setViewData('entry-exit-benjamin-graham', { benjaminGraham: result.data }, { source: 'client-refresh' }).catch((e) =>
            logger.warn('Failed to write viewData', { component: 'useBenjaminGrahamData', error: e })
          );
          // Show notification if significant changes detected
          if (changes.hasSignificantChanges && !isBackground) {
            const changeMessage = formatChangeSummary(changes);
            createNotification(
              'data-update',
              'Benjamin Graham Data Updated',
              `Total: ${changes.total} items. ${changeMessage}`,
              {
                showDesktop: true,
                data: { changes, dataType: 'benjamin-graham' },
              }
            );
          }
          
          if (!isBackground) {
            updateProgress('benjamin-graham', {
              status: 'complete',
              progress: 100,
              message: 'Data loaded',
            });
          }
          
          if (!isBackground) {
            setLoading(false);
          }
          return;
        } catch (deltaSyncError) {
          // Delta sync failed, fallback to regular fetch
          const errorMessage = deltaSyncError instanceof Error ? deltaSyncError.message : String(deltaSyncError);
          
          // Only log warning if it's not a timeout (timeouts are expected and will fallback)
          if (!errorMessage.includes('timeout') && !errorMessage.includes('Request timeout')) {
            logger.warn(
              `Delta sync failed for ${SHEET_NAME}, falling back to regular fetch: ${errorMessage}`,
              { component: 'useBenjaminGrahamData', operation: 'initialize delta sync', sheetName: SHEET_NAME, error: deltaSyncError }
            );
          } else {
            logger.debug(
              `Delta sync timed out for ${SHEET_NAME}, using regular fetch instead`,
              { component: 'useBenjaminGrahamData', operation: 'initialize delta sync', sheetName: SHEET_NAME }
            );
          }
          // Don't throw - fallback to regular fetch
        }
      }

      // Fallback to regular fetch
      const progressCallback: ProgressCallback = (progress) => {
        if (!isBackground) {
          updateProgress('benjamin-graham', {
            progress: progress.percentage,
            status: progress.stage === 'complete' ? 'complete' : 'loading',
            message: progress.message,
            rowsLoaded: progress.rowsProcessed,
            totalRows: progress.totalRows,
          });
        }
      };
      
      logger.debug('Fetching Benjamin Graham data', { 
        component: 'useBenjaminGrahamData', 
        operation: 'loadData',
        forceRefresh,
        isBackground 
      });
      
      const fetchedData = await fetchBenjaminGrahamData(forceRefresh, progressCallback);
      
      logger.info('Benjamin Graham data fetched successfully', { 
        component: 'useBenjaminGrahamData', 
        operation: 'loadData',
        entryCount: fetchedData.length,
        forceRefresh 
      });
      
      // Detect data changes
      const changes = detectDataChanges(
        previousDataRef.current,
        fetchedData,
        (item) => `${item.ticker}-${item.companyName}`,
        0.05 // 5% threshold
      );
      
      logger.debug('Updating Benjamin Graham state with new data', { 
        component: 'useBenjaminGrahamData', 
        operation: 'loadData',
        entryCount: fetchedData.length,
        hasChanges: changes.hasSignificantChanges 
      });
      
      setData(fetchedData);
      previousDataRef.current = fetchedData;
      setLastUpdated(new Date());
      setViewData('entry-exit-benjamin-graham', { benjaminGraham: fetchedData }, { source: 'client-refresh' }).catch((e) =>
        logger.warn('Failed to write viewData', { component: 'useBenjaminGrahamData', error: e })
      );
      logger.info('Benjamin Graham state updated successfully', { 
        component: 'useBenjaminGrahamData', 
        operation: 'loadData',
        entryCount: fetchedData.length 
      });
      
      // Show notification if significant changes detected
      if (changes.hasSignificantChanges && !isBackground) {
        const changeMessage = formatChangeSummary(changes);
        createNotification(
          'data-update',
          'Benjamin Graham Data Updated',
          `Total: ${changes.total} items. ${changeMessage}`,
          {
            showDesktop: true,
            data: { changes, dataType: 'benjamin-graham' },
          }
        );
      }
      
      if (!isBackground) {
        updateProgress('benjamin-graham', {
          status: 'complete',
          progress: 100,
        });
      }
    } catch (err: unknown) {
      const errorHandler = createErrorHandler({
        operation: 'fetch Benjamin Graham data',
        component: 'useBenjaminGrahamData',
        additionalInfo: { forceRefresh, isBackground },
      });
      const formatted = errorHandler(err);
      setError(formatted.userMessage);
      if (!isBackground) {
        updateProgress('benjamin-graham', {
          status: 'error',
          progress: 0,
          message: formatted.userMessage,
        });
      }
    } finally {
      if (!isBackground) {
        setLoading(false);
      }
    }
  }, [updateProgress, createNotification]);

  // Poll for changes using delta-sync
  const pollForChanges = useCallback(async () => {
    // Only poll if page is visible
    if (!isPageVisible) {
      return;
    }

    if (!isDeltaSyncEnabled() || !APPS_SCRIPT_URL || currentVersionRef.current === 0) {
      return;
    }

    try {
      const config: DeltaSyncConfig = {
        sheetName: SHEET_NAME,
        apiBaseUrl: APPS_SCRIPT_URL,
        dataTypeName: 'Benjamin Graham',
      };

      const changes = await pollChanges(config, currentVersionRef.current);
      const cacheResult = await applyChangesToCache<BenjaminGrahamData>(changes, CACHE_KEY);

      if (cacheResult.needsReload) {
        // Changes detected, reload snapshot
        const snapshot = await loadSnapshot(config);
        const transformerFormat = snapshotToTransformerFormat(snapshot);
        const transformedData = transformBenjaminGrahamData(transformerFormat);
        // cutover: no appCache writes for view-docs
        if (VIEWDATA_MIGRATION_MODE !== 'cutover') {
          setDeltaCacheEntry(CACHE_KEY, transformedData, snapshot.version, true);
        }
        setViewData('entry-exit-benjamin-graham', { benjaminGraham: transformedData }, { source: 'client-refresh' }).catch((e) =>
          logger.warn('Failed to write viewData', { component: 'useBenjaminGrahamData', error: e })
        );
        // Detect data changes
        const changes = detectDataChanges(
          previousDataRef.current,
          transformedData,
          (item) => `${item.ticker}-${item.companyName}`,
          0.05 // 5% threshold
        );
        
        setData(transformedData);
        previousDataRef.current = transformedData;
        currentVersionRef.current = snapshot.version;
        setLastUpdated(new Date());
        
        // Show notification if significant changes detected
        if (changes.hasSignificantChanges) {
          const changeMessage = formatChangeSummary(changes);
          createNotification(
            'data-update',
            'Benjamin Graham Data Updated',
            `Total: ${changes.total} items. ${changeMessage}`,
            {
              showDesktop: true,
              data: { changes, dataType: 'benjamin-graham' },
            }
          );
        }
      } else if (cacheResult.data) {
        // No changes, use cached data
        setData(cacheResult.data);
        currentVersionRef.current = cacheResult.version;
      }
    } catch (pollError) {
      // Silently fail polling - don't show errors to user
      const context = {
        operation: 'poll for changes',
        component: 'useBenjaminGrahamData',
        additionalInfo: { version: currentVersionRef.current },
      };
      const formatted = formatError(pollError, context);
      if (isErrorType(pollError, 'timeout')) {
        logger.warn(formatted.message, { component: context.component, operation: context.operation, ...formatted.context.additionalInfo });
      } else {
        logError(pollError, formatted.context);
      }
    }
  }, [isPageVisible]);

  // Load cache on mount - viewData first (dual-read/cutover), then appCache fallback
  useEffect(() => {
    const loadCache = async () => {
      if (cacheLoadedRef.current) return;
      cacheLoadedRef.current = true;
      
      try {
        const result = await getViewDataWithFallback<{ benjaminGraham: BenjaminGrahamData[] }>('entry-exit-benjamin-graham', {
          fallback: async () => {
            const delta = await getDeltaCacheEntry<BenjaminGrahamData[]>(CACHE_KEY);
            const regular = delta ? null : await getCachedData<BenjaminGrahamData[]>(CACHE_KEY);
            const arr = delta?.data ?? regular;
            return arr && arr.length > 0 ? { benjaminGraham: arr } : null;
          },
        });
        if (result && result.data.benjaminGraham.length > 0) {
          const cachedData = result.data.benjaminGraham;
          setData(cachedData);
          previousDataRef.current = cachedData;
          const delta = await getDeltaCacheEntry<BenjaminGrahamData[]>(CACHE_KEY);
          currentVersionRef.current = delta?.version ?? 0;
          setLoading(false);
          return;
        }
      } catch (err) {
        logger.warn('Failed to load cache, fetching fresh data', { component: 'useBenjaminGrahamData', error: err });
      }
      
      loadData(false, false);
    };
    
    loadCache();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Only run once on mount

  // Set up polling for changes (delta-sync only)
  useEffect(() => {
    if (isDeltaSyncEnabled() && APPS_SCRIPT_URL && isPageVisible) {
      const intervalMs = getPollIntervalMs();
      
      // Poll immediately after initial load (with delay)
      const initialPollTimeout = setTimeout(() => {
        pollForChanges();
      }, 5000); // Wait 5 seconds after initial load

      // Set up periodic polling (only when page is visible)
      pollIntervalRef.current = setInterval(() => {
        pollForChanges();
      }, intervalMs);

      return () => {
        clearTimeout(initialPollTimeout);
        if (pollIntervalRef.current) {
          clearInterval(pollIntervalRef.current);
        }
      };
    } else {
      // Clear interval if page becomes hidden or delta-sync is disabled
      if (pollIntervalRef.current) {
        clearInterval(pollIntervalRef.current);
        pollIntervalRef.current = null;
      }
    }
  }, [pollForChanges, isPageVisible]);

  const refetch = useCallback(
    async (forceRefresh?: boolean | { skipFetch?: boolean }) => {
      const opts = typeof forceRefresh === 'object' ? forceRefresh : { skipFetch: false };
      if (opts?.skipFetch) {
        setLoading(true);
        try {
          const result = await getViewDataWithFallback<{ benjaminGraham: BenjaminGrahamData[] }>('entry-exit-benjamin-graham', {
            fallback: async () => {
              const delta = await getDeltaCacheEntry<BenjaminGrahamData[]>(CACHE_KEY);
              const regular = delta ? null : await getCachedData<BenjaminGrahamData[]>(CACHE_KEY);
              const arr = delta?.data ?? regular;
              return arr && arr.length > 0 ? { benjaminGraham: arr } : null;
            },
          });
          if (result?.data?.benjaminGraham?.length) {
            setData(result.data.benjaminGraham);
            previousDataRef.current = result.data.benjaminGraham;
            setLastUpdated(new Date());
          }
        } finally {
          setLoading(false);
        }
        return;
      }
      loadData(typeof forceRefresh === 'boolean' ? forceRefresh : false);
    },
    [loadData]
  );

  const refreshContext = useRefreshOptional();
  useEffect(() => {
    if (!refreshContext) return;
    const unregister = refreshContext.registerRefetch('benjamin-graham', (options) =>
      refetch(options?.skipFetch ? { skipFetch: true } : true)
    );
    return unregister;
  }, [refreshContext, refetch]);

  return {
    data,
    loading,
    error,
    lastUpdated,
    refetch,
  };
}


```

## `src/hooks/useColumnFilters.ts`

```typescript
import { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import { UniqueValue } from './useColumnUniqueValues';

export type FilterOperator = 'equals' | 'notEquals' | 'greaterThan' | 'lessThan' | 'greaterThanOrEqual' | 'lessThanOrEqual' | 'contains';

export interface ColumnFilter {
  columnKey: string;
  type: 'values' | 'condition' | 'none';
  selectedValues?: (string | number | boolean | null)[];
  conditionOperator?: FilterOperator;
  conditionValue?: string | number;
}

export interface ColumnFilters {
  [columnKey: string]: ColumnFilter;
}

interface UseColumnFiltersOptions<T> {
  data: T[];
  tableId: string;
  onFiltersChange?: (filters: ColumnFilters) => void;
}

interface UseColumnFiltersReturn<T> {
  filters: ColumnFilters;
  setColumnFilter: (columnKey: string, filter: ColumnFilter | null) => void;
  clearColumnFilter: (columnKey: string) => void;
  clearAllFilters: () => void;
  hasActiveFilter: (columnKey: string) => boolean;
  hasAnyActiveFilter: () => boolean;
  getColumnUniqueValues: (columnKey: string) => UniqueValue[];
  filteredData: T[];
}

const STORAGE_KEY_PREFIX = 'columnFilters:';

/**
 * Custom hook for managing column-specific filters
 * 
 * Provides functionality to:
 * - Set and clear filters per column
 * - Filter data based on column filters
 * - Persist filters to localStorage
 * - Support value-based and condition-based filtering
 * 
 * @template T - Type of data items
 * @param options - Hook options
 * @returns Filter management functions and filtered data
 */
export function useColumnFilters<T extends Record<string, unknown>>({
  data,
  tableId,
  onFiltersChange,
}: UseColumnFiltersOptions<T>): UseColumnFiltersReturn<T> {
  const storageKey = `${STORAGE_KEY_PREFIX}${tableId}`;
  
  // Load filters from localStorage on mount
  const [filters, setFilters] = useState<ColumnFilters>(() => {
    try {
      const stored = localStorage.getItem(storageKey);
      if (stored) {
        return JSON.parse(stored);
      }
    } catch (error) {
      console.error('Error loading column filters from localStorage:', error);
    }
    return {};
  });

  // Save filters to localStorage whenever they change
  useEffect(() => {
    try {
      if (Object.keys(filters).length > 0) {
        localStorage.setItem(storageKey, JSON.stringify(filters));
      } else {
        localStorage.removeItem(storageKey);
      }
    } catch (error) {
      console.error('Error saving column filters to localStorage:', error);
    }
  }, [filters, storageKey]);

  // Notify parent of filter changes
  useEffect(() => {
    if (onFiltersChange) {
      onFiltersChange(filters);
    }
  }, [filters, onFiltersChange]);

  const setColumnFilter = useCallback((columnKey: string, filter: ColumnFilter | null) => {
    setFilters((prev) => {
      const newFilters = { ...prev };
      if (filter && filter.type !== 'none') {
        newFilters[columnKey] = filter;
      } else {
        delete newFilters[columnKey];
      }
      return newFilters;
    });
  }, []);

  const clearColumnFilter = useCallback((columnKey: string) => {
    setColumnFilter(columnKey, null);
  }, [setColumnFilter]);

  const clearAllFilters = useCallback(() => {
    setFilters({});
  }, []);

  const hasActiveFilter = useCallback((columnKey: string): boolean => {
    const filter = filters[columnKey];
    if (!filter || filter.type === 'none') return false;
    
    if (filter.type === 'values') {
      return filter.selectedValues !== undefined && filter.selectedValues.length > 0;
    }
    
    if (filter.type === 'condition') {
      return filter.conditionValue !== undefined && filter.conditionValue !== null && filter.conditionValue !== '';
    }
    
    return false;
  }, [filters]);

  const hasAnyActiveFilter = useCallback((): boolean => {
    return Object.keys(filters).some((key) => hasActiveFilter(key));
  }, [filters, hasActiveFilter]);

  // Get unique values for a column
  // Note: We can't call hooks conditionally, so we'll compute values on-demand
  // and cache them manually
  const uniqueValuesCacheRef = useRef<Map<string, UniqueValue[]>>(new Map());
  
  // Update cache when data changes
  useEffect(() => {
    uniqueValuesCacheRef.current.clear();
  }, [data]);

  const getColumnUniqueValues = useCallback((columnKey: string): UniqueValue[] => {
    // Compute unique values manually (can't use hook here)
    if (!data || data.length === 0 || !columnKey) {
      return [];
    }

    // Check cache first
    if (uniqueValuesCacheRef.current.has(columnKey)) {
      return uniqueValuesCacheRef.current.get(columnKey)!;
    }

    // Count occurrences of each value
    const valueCounts = new Map<string | number | boolean | null, number>();
    
    data.forEach((item) => {
      const value = item[columnKey];
      const normalizedValue = value === null || value === undefined ? null : value;
      const currentCount = valueCounts.get(normalizedValue) || 0;
      valueCounts.set(normalizedValue, currentCount + 1);
    });

    // Convert to array of UniqueValue objects
    const uniqueValues: UniqueValue[] = Array.from(valueCounts.entries()).map(([value, count]) => {
      let displayValue: string;
      
      if (value === null || value === undefined) {
        displayValue = '(Tomma)';
      } else if (typeof value === 'boolean') {
        displayValue = value ? 'Ja' : 'Nej';
      } else if (typeof value === 'number') {
        displayValue = value.toString();
      } else {
        displayValue = String(value).trim() || '(Tomma)';
      }

      return {
        value,
        count,
        displayValue,
      };
    });

    // Sort: null values last, then by type and value
    uniqueValues.sort((a, b) => {
      // Null values go to the end
      if (a.value === null && b.value !== null) return 1;
      if (a.value !== null && b.value === null) return -1;
      if (a.value === null && b.value === null) return 0;

      // Sort by type: numbers first, then strings, then booleans
      const aType = typeof a.value;
      const bType = typeof b.value;
      
      if (aType === 'number' && bType === 'string') return -1;
      if (aType === 'string' && bType === 'number') return 1;
      if (aType === 'boolean' && bType !== 'boolean') return 1;
      if (aType !== 'boolean' && bType === 'boolean') return -1;

      // Same type: sort by value
      if (aType === 'number' && bType === 'number') {
        return (a.value as number) - (b.value as number);
      }
      
      if (aType === 'string' && bType === 'string') {
        return a.displayValue.localeCompare(b.displayValue, 'sv', { sensitivity: 'base' });
      }
      
      if (aType === 'boolean' && bType === 'boolean') {
        return (a.value === b.value) ? 0 : (a.value ? 1 : -1);
      }

      return 0;
    });

    // Cache the result
    uniqueValuesCacheRef.current.set(columnKey, uniqueValues);
    return uniqueValues;
  }, [data]);

  // Filter data based on column filters
  const filteredData = useMemo(() => {
    if (Object.keys(filters).length === 0) {
      return data;
    }

    return data.filter((item) => {
      return Object.entries(filters).every(([columnKey, filter]) => {
        if (filter.type === 'none') return true;

        const itemValue = item[columnKey];

        // Value-based filtering
        if (filter.type === 'values' && filter.selectedValues !== undefined) {
          if (filter.selectedValues.length === 0) return true;
          
          // Handle null values
          if (itemValue === null || itemValue === undefined) {
            return filter.selectedValues.includes(null);
          }
          
          // Check if item value is in selected values
          return filter.selectedValues.some((selectedValue) => {
            if (selectedValue === null) return itemValue === null || itemValue === undefined;
            
            // Type-aware comparison
            if (typeof itemValue === 'number' && typeof selectedValue === 'number') {
              return itemValue === selectedValue;
            }
            if (typeof itemValue === 'boolean' && typeof selectedValue === 'boolean') {
              return itemValue === selectedValue;
            }
            // String comparison (case-insensitive)
            return String(itemValue).toLowerCase() === String(selectedValue).toLowerCase();
          });
        }

        // Condition-based filtering
        if (filter.type === 'condition' && filter.conditionOperator && filter.conditionValue !== undefined && filter.conditionValue !== null && filter.conditionValue !== '') {
          if (itemValue === null || itemValue === undefined) {
            // Null values don't match any condition except "not equals"
            return filter.conditionOperator === 'notEquals';
          }

          const itemValueStr = String(itemValue);
          const itemValueNum = typeof itemValue === 'number' ? itemValue : parseFloat(itemValueStr);
          const conditionValueStr = String(filter.conditionValue);
          const conditionValueNum = typeof filter.conditionValue === 'number' ? filter.conditionValue : parseFloat(conditionValueStr);

          switch (filter.conditionOperator) {
            case 'equals':
              return itemValueStr.toLowerCase() === conditionValueStr.toLowerCase();
            case 'notEquals':
              return itemValueStr.toLowerCase() !== conditionValueStr.toLowerCase();
            case 'greaterThan':
              return !isNaN(itemValueNum) && !isNaN(conditionValueNum) && itemValueNum > conditionValueNum;
            case 'lessThan':
              return !isNaN(itemValueNum) && !isNaN(conditionValueNum) && itemValueNum < conditionValueNum;
            case 'greaterThanOrEqual':
              return !isNaN(itemValueNum) && !isNaN(conditionValueNum) && itemValueNum >= conditionValueNum;
            case 'lessThanOrEqual':
              return !isNaN(itemValueNum) && !isNaN(conditionValueNum) && itemValueNum <= conditionValueNum;
            case 'contains':
              return itemValueStr.toLowerCase().includes(conditionValueStr.toLowerCase());
            default:
              return true;
          }
        }

        return true;
      });
    });
  }, [data, filters]);

  return {
    filters,
    setColumnFilter,
    clearColumnFilter,
    clearAllFilters,
    hasActiveFilter,
    hasAnyActiveFilter,
    getColumnUniqueValues,
    filteredData,
  };
}

```

## `src/hooks/useColumnReorder.ts`

```typescript
import { useState, useCallback, useEffect } from 'react';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  horizontalListSortingStrategy,
} from '@dnd-kit/sortable';

export interface UseColumnReorderOptions {
  tableId: string;
  columns: Array<{ key: string }>;
  onReorder?: (newOrder: string[]) => void;
}

const STORAGE_PREFIX = 'table_column_order_';

/**
 * Hook for managing column reordering in tables using drag & drop
 * 
 * Features:
 * - Drag & drop column headers to reorder
 * - Keyboard accessibility for reordering
 * - Persist column order to localStorage per table
 * - Visual feedback during drag
 * 
 * @param options Configuration options
 * @returns Column order state and reorder handlers
 */
export function useColumnReorder({
  tableId,
  columns,
  onReorder,
}: UseColumnReorderOptions) {
  const storageKey = `${STORAGE_PREFIX}${tableId}`;
  
  // Load saved order from localStorage
  const loadSavedOrder = useCallback((): string[] => {
    try {
      const saved = localStorage.getItem(storageKey);
      if (saved) {
        const parsed = JSON.parse(saved) as string[];
        // Validate that all saved keys exist in current columns
        const columnKeys = columns.map((col) => col.key);
        return parsed.filter((key) => columnKeys.includes(key));
      }
    } catch (error) {
      console.warn('Failed to load column order from localStorage:', error);
    }
    return columns.map((col) => col.key);
  }, [storageKey, columns]);

  const [columnOrder, setColumnOrder] = useState<string[]>(loadSavedOrder);

  // Update order when columns change
  useEffect(() => {
    const currentKeys = columns.map((col) => col.key);
    const savedOrder = loadSavedOrder();
    
    // Merge saved order with new columns (add new columns at the end)
    const newOrder = [
      ...savedOrder.filter((key) => currentKeys.includes(key)),
      ...currentKeys.filter((key) => !savedOrder.includes(key)),
    ];
    
    setColumnOrder(newOrder);
  }, [columns, loadSavedOrder]);

  // Save order to localStorage whenever it changes
  useEffect(() => {
    try {
      if (columnOrder.length > 0) {
        localStorage.setItem(storageKey, JSON.stringify(columnOrder));
      }
    } catch (error) {
      console.warn('Failed to save column order to localStorage:', error);
    }
  }, [columnOrder, storageKey]);

  // Configure sensors for drag & drop
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // Require 8px movement before drag starts
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  // Handle drag end
  const handleDragEnd = useCallback(
    (event: DragEndEvent) => {
      const { active, over } = event;

      if (over && active.id !== over.id) {
        setColumnOrder((items) => {
          const oldIndex = items.indexOf(active.id as string);
          const newIndex = items.indexOf(over.id as string);
          const newOrder = arrayMove(items, oldIndex, newIndex);
          
          // Call optional callback
          if (onReorder) {
            onReorder(newOrder);
          }
          
          return newOrder;
        });
      }
    },
    [onReorder]
  );

  // Get ordered columns
  const getOrderedColumns = useCallback(
    <T extends { key: string }>(cols: T[]): T[] => {
      return columnOrder
        .map((key) => cols.find((col) => col.key === key))
        .filter((col): col is T => col !== undefined)
        .concat(cols.filter((col) => !columnOrder.includes(col.key)));
    },
    [columnOrder]
  );

  // Reset to default order
  const resetOrder = useCallback(() => {
    const defaultOrder = columns.map((col) => col.key);
    setColumnOrder(defaultOrder);
    try {
      localStorage.removeItem(storageKey);
    } catch (error) {
      console.warn('Failed to remove column order from localStorage:', error);
    }
    if (onReorder) {
      onReorder(defaultOrder);
    }
  }, [columns, storageKey, onReorder]);

  return {
    columnOrder,
    sensors,
    handleDragEnd,
    getOrderedColumns,
    resetOrder,
    DndContext,
    SortableContext,
    horizontalListSortingStrategy,
    closestCenter,
  };
}

```

## `src/hooks/useColumnResize.ts`

```typescript
import { useState, useCallback, useEffect, useRef } from 'react';

export interface ColumnWidths {
  [columnKey: string]: number;
}

export interface UseColumnResizeOptions {
  tableId: string;
  columns: Array<{ key: string }>;
  defaultWidth?: number;
  minWidth?: number;
  maxWidth?: number;
}

const STORAGE_PREFIX = 'table_column_widths_';

/**
 * Hook for managing column resizing in tables
 * 
 * Features:
 * - Drag to resize column headers
 * - Persist widths to localStorage per table
 * - Min/max width constraints
 * - Visual feedback during resize
 * 
 * @param options Configuration options
 * @returns Column widths state and resize handlers
 */
export function useColumnResize({
  tableId,
  columns,
  defaultWidth = 150,
  minWidth = 80,
  maxWidth = 500,
}: UseColumnResizeOptions) {
  const storageKey = `${STORAGE_PREFIX}${tableId}`;
  
  // Load saved widths from localStorage
  const loadSavedWidths = useCallback((): ColumnWidths => {
    try {
      const saved = localStorage.getItem(storageKey);
      if (saved) {
        const parsed = JSON.parse(saved) as ColumnWidths;
        // Validate that all saved widths are within constraints
        const validated: ColumnWidths = {};
        Object.keys(parsed).forEach((key) => {
          const width = parsed[key];
          if (typeof width === 'number' && width >= minWidth && width <= maxWidth) {
            validated[key] = width;
          }
        });
        return validated;
      }
    } catch (error) {
      console.warn('Failed to load column widths from localStorage:', error);
    }
    return {};
  }, [storageKey, minWidth, maxWidth]);

  const [columnWidths, setColumnWidths] = useState<ColumnWidths>(loadSavedWidths);
  const [resizingColumn, setResizingColumn] = useState<string | null>(null);
  const [resizeStartX, setResizeStartX] = useState(0);
  const [resizeStartWidth, setResizeStartWidth] = useState(0);
  const resizeRef = useRef<{ columnKey: string; startX: number; startWidth: number } | null>(null);

  // Save widths to localStorage whenever they change
  useEffect(() => {
    try {
      if (Object.keys(columnWidths).length > 0) {
        localStorage.setItem(storageKey, JSON.stringify(columnWidths));
      }
    } catch (error) {
      console.warn('Failed to save column widths to localStorage:', error);
    }
  }, [columnWidths, storageKey]);

  // Get width for a specific column
  const getColumnWidth = useCallback(
    (columnKey: string): number => {
      return columnWidths[columnKey] || defaultWidth;
    },
    [columnWidths, defaultWidth]
  );

  // Handle mouse down on resize handle
  const handleResizeStart = useCallback(
    (columnKey: string, e: React.MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();
      
      const currentWidth = getColumnWidth(columnKey);
      setResizingColumn(columnKey);
      setResizeStartX(e.clientX);
      setResizeStartWidth(currentWidth);
      
      resizeRef.current = {
        columnKey,
        startX: e.clientX,
        startWidth: currentWidth,
      };

      // Add global mouse event listeners
      document.addEventListener('mousemove', handleResizeMove);
      document.addEventListener('mouseup', handleResizeEnd);
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
    },
    [getColumnWidth]
  );

  // Handle mouse move during resize
  const handleResizeMove = useCallback(
    (e: MouseEvent) => {
      if (!resizeRef.current) return;

      const { columnKey, startX, startWidth } = resizeRef.current;
      const deltaX = e.clientX - startX;
      const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + deltaX));

      setColumnWidths((prev) => ({
        ...prev,
        [columnKey]: newWidth,
      }));
    },
    [minWidth, maxWidth]
  );

  // Handle mouse up to end resize
  const handleResizeEnd = useCallback(() => {
    setResizingColumn(null);
    resizeRef.current = null;
    
      // Remove global event listeners
      document.removeEventListener('mousemove', handleResizeMove);
      document.removeEventListener('mouseup', handleResizeEnd);
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
  }, [handleResizeMove]);

  // Reset all column widths to default
  const resetWidths = useCallback(() => {
    setColumnWidths({});
    try {
      localStorage.removeItem(storageKey);
    } catch (error) {
      console.warn('Failed to remove column widths from localStorage:', error);
    }
  }, [storageKey]);

  // Set width for a specific column programmatically
  const setColumnWidth = useCallback(
    (columnKey: string, width: number) => {
      const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, width));
      setColumnWidths((prev) => ({
        ...prev,
        [columnKey]: constrainedWidth,
      }));
    },
    [minWidth, maxWidth]
  );

  return {
    columnWidths,
    resizingColumn,
    getColumnWidth,
    handleResizeStart,
    resetWidths,
    setColumnWidth,
  };
}

```

## `src/hooks/useColumnUniqueValues.ts`

```typescript
import { useMemo } from 'react';

export interface UniqueValue {
  value: string | number | boolean | null;
  count: number;
  displayValue: string;
}

/**
 * Custom hook to extract unique values from a specific column in a dataset
 * 
 * Extracts unique values from a column, counts occurrences, and returns them
 * sorted with display-friendly formatting.
 * 
 * @template T - Type of data items
 * @param data - Array of data items
 * @param columnKey - Key of the column to extract values from
 * @returns Array of unique values with counts, sorted alphabetically/numerically
 */
export function useColumnUniqueValues<T extends Record<string, unknown>>(
  data: T[],
  columnKey: string
): UniqueValue[] {
  return useMemo(() => {
    if (!data || data.length === 0 || !columnKey) {
      return [];
    }

    // Count occurrences of each value
    const valueCounts = new Map<string | number | boolean | null, number>();
    
    data.forEach((item) => {
      const value = item[columnKey];
      const normalizedValue = value === null || value === undefined ? null : value;
      const currentCount = valueCounts.get(normalizedValue) || 0;
      valueCounts.set(normalizedValue, currentCount + 1);
    });

    // Convert to array of UniqueValue objects
    const uniqueValues: UniqueValue[] = Array.from(valueCounts.entries()).map(([value, count]) => {
      let displayValue: string;
      
      if (value === null || value === undefined) {
        displayValue = '(Tomma)';
      } else if (typeof value === 'boolean') {
        displayValue = value ? 'Ja' : 'Nej';
      } else if (typeof value === 'number') {
        displayValue = value.toString();
      } else {
        displayValue = String(value).trim() || '(Tomma)';
      }

      return {
        value,
        count,
        displayValue,
      };
    });

    // Sort: null values last, then by type and value
    uniqueValues.sort((a, b) => {
      // Null values go to the end
      if (a.value === null && b.value !== null) return 1;
      if (a.value !== null && b.value === null) return -1;
      if (a.value === null && b.value === null) return 0;

      // Sort by type: numbers first, then strings, then booleans
      const aType = typeof a.value;
      const bType = typeof b.value;
      
      if (aType === 'number' && bType === 'string') return -1;
      if (aType === 'string' && bType === 'number') return 1;
      if (aType === 'boolean' && bType !== 'boolean') return 1;
      if (aType !== 'boolean' && bType === 'boolean') return -1;

      // Same type: sort by value
      if (aType === 'number' && bType === 'number') {
        return (a.value as number) - (b.value as number);
      }
      
      if (aType === 'string' && bType === 'string') {
        return a.displayValue.localeCompare(b.displayValue, 'sv', { sensitivity: 'base' });
      }
      
      if (aType === 'boolean' && bType === 'boolean') {
        return (a.value === b.value) ? 0 : (a.value ? 1 : -1);
      }

      return 0;
    });

    return uniqueValues;
  }, [data, columnKey]);
}

```

## `src/hooks/useColumnVisibility.ts`

```typescript
import { useState, useEffect, useCallback } from 'react';
import { logger } from '../utils/logger';

export interface ColumnConfig {
  key: string;
  label: string;
  defaultVisible?: boolean;
  required?: boolean; // Required columns cannot be hidden
}

interface UseColumnVisibilityProps {
  tableId: string;
  columns: ColumnConfig[];
}

export function useColumnVisibility({ tableId, columns }: UseColumnVisibilityProps) {
  const storageKey = `columnVisibility_${tableId}`;

  // Initialize visibility state from localStorage or defaults
  const getInitialVisibility = useCallback(() => {
    try {
      const saved = localStorage.getItem(storageKey);
      if (saved) {
        const parsed = JSON.parse(saved);
        // Merge saved state with current columns (in case columns changed)
        const visibility: Record<string, boolean> = {};
        columns.forEach(col => {
          visibility[col.key] = parsed[col.key] !== undefined 
            ? parsed[col.key] 
            : (col.defaultVisible !== false);
        });
        if (tableId === 'personal-portfolio') {
          visibility['currency'] = false;
          visibility['currentPrice'] = false;
        }
        return visibility;
      }
    } catch (error) {
      logger.error('Error loading column visibility', error, { component: 'useColumnVisibility', operation: 'loadVisibility' });
    }
    
    // Default: all columns visible except those explicitly set to defaultVisible: false
    const visibility: Record<string, boolean> = {};
    columns.forEach(col => {
      visibility[col.key] = col.defaultVisible !== false;
    });
    if (tableId === 'personal-portfolio') {
      visibility['currency'] = false;
      visibility['currentPrice'] = false;
    }
    return visibility;
  }, [storageKey, tableId, columns]);

  const [columnVisibility, setColumnVisibility] = useState<Record<string, boolean>>(getInitialVisibility);

  // Save to localStorage whenever visibility changes
  useEffect(() => {
    try {
      localStorage.setItem(storageKey, JSON.stringify(columnVisibility));
    } catch (error) {
      logger.error('Error saving column visibility', error, { component: 'useColumnVisibility', operation: 'saveVisibility' });
    }
  }, [storageKey, columnVisibility]);

  const toggleColumn = useCallback((columnKey: string) => {
    setColumnVisibility(prev => {
      const column = columns.find(col => col.key === columnKey);
      // Don't allow hiding required columns
      if (column?.required) {
        return prev;
      }
      return {
        ...prev,
        [columnKey]: !prev[columnKey],
      };
    });
  }, [columns]);

  const showAllColumns = useCallback(() => {
    const visibility: Record<string, boolean> = {};
    columns.forEach(col => {
      visibility[col.key] = true;
    });
    setColumnVisibility(visibility);
  }, [columns]);

  const hideAllColumns = useCallback(() => {
    const visibility: Record<string, boolean> = {};
    columns.forEach(col => {
      visibility[col.key] = col.required ? true : false;
    });
    setColumnVisibility(visibility);
  }, [columns]);

  const resetToDefaults = useCallback(() => {
    setColumnVisibility(getInitialVisibility());
  }, [getInitialVisibility]);

  const isColumnVisible = useCallback((columnKey: string) => {
    return columnVisibility[columnKey] !== false;
  }, [columnVisibility]);

  return {
    columnVisibility,
    toggleColumn,
    showAllColumns,
    hideAllColumns,
    resetToDefaults,
    isColumnVisible,
  };
}


```

## `src/hooks/useDebounce.ts`

```typescript
import { useState, useEffect } from 'react';

/**
 * Custom hook for debouncing a value
 * 
 * Delays updating the value until the user stops making changes for the
 * specified delay period. Useful for reducing API calls during search input
 * or other frequent updates.
 * 
 * **Debounce Strategy:**
 * - Waits for delay period of inactivity before updating
 * - Cancels previous timer if value changes before delay completes
 * - Default delay: 300ms (good balance between responsiveness and efficiency)
 * 
 * **Use Cases:**
 * - Search input: Reduces API calls while user is typing
 * - Filter changes: Prevents excessive filtering operations
 * - Resize handlers: Reduces calculations during window resize
 * 
 * @template T - Type of value being debounced
 * @param value - The value to debounce
 * @param delay - The delay in milliseconds (default: 300ms)
 * @returns The debounced value (updates after delay period)
 * 
 * @example
 * ```typescript
 * const [searchValue, setSearchValue] = useState('');
 * const debouncedSearch = useDebounce(searchValue, 500);
 * 
 * // debouncedSearch only updates 500ms after user stops typing
 * useEffect(() => {
 *   performSearch(debouncedSearch);
 * }, [debouncedSearch]);
 * ```
 */
export function useDebounce<T>(value: T, delay: number = 300): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Set up a timer to update the debounced value after the delay
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Clean up the timer if value changes before delay completes
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}


```

## `src/hooks/useGlobalSearch.ts`

```typescript
import { useMemo } from 'react';
import { useScoreBoardData } from './useScoreBoardData';
import { useBenjaminGrahamData } from './useBenjaminGrahamData';
import { usePEIndustryData } from './usePEIndustryData';
import { useThresholdIndustryData } from './useThresholdIndustryData';
import { ViewId } from '../types/navigation';

export interface SearchResult {
  id: string;
  type: 'score-board' | 'benjamin-graham' | 'pe-industry' | 'entry-exit' | 'threshold-industry';
  viewId: ViewId;
  label: string;
  companyName?: string;
  ticker?: string;
  industry?: string;
  matchField: string; // Which field matched the search
}

export function useGlobalSearch() {
  const { data: scoreBoardData } = useScoreBoardData();
  const { data: benjaminGrahamData } = useBenjaminGrahamData();
  const { data: peIndustryData } = usePEIndustryData();
  const { data: thresholdIndustryData } = useThresholdIndustryData();

  const search = useMemo(() => {
    return (query: string): SearchResult[] => {
      if (!query || query.trim().length === 0) {
        return [];
      }

      const normalizedQuery = query.toLowerCase().trim();
      const results: SearchResult[] = [];

      // Search in ScoreBoardData
      scoreBoardData.forEach((item, index) => {
        const companyName = item.companyName?.toLowerCase() || '';
        const ticker = item.ticker?.toLowerCase() || '';
        const industry = item.industry?.toLowerCase() || '';

        if (companyName.includes(normalizedQuery)) {
          results.push({
            id: `score-board-${index}`,
            type: 'score-board',
            viewId: 'score-board',
            label: item.companyName,
            companyName: item.companyName,
            ticker: item.ticker,
            industry: item.industry,
            matchField: 'companyName',
          });
        } else if (ticker.includes(normalizedQuery)) {
          results.push({
            id: `score-board-${index}`,
            type: 'score-board',
            viewId: 'score-board',
            label: `${item.companyName} (${item.ticker})`,
            companyName: item.companyName,
            ticker: item.ticker,
            industry: item.industry,
            matchField: 'ticker',
          });
        } else if (industry.includes(normalizedQuery)) {
          results.push({
            id: `score-board-${index}`,
            type: 'score-board',
            viewId: 'score-board',
            label: `${item.industry} - ${item.companyName}`,
            companyName: item.companyName,
            ticker: item.ticker,
            industry: item.industry,
            matchField: 'industry',
          });
        }
      });

      // Search in BenjaminGrahamData
      benjaminGrahamData.forEach((item, index) => {
        const companyName = item.companyName?.toLowerCase() || '';
        const ticker = item.ticker?.toLowerCase() || '';

        if (companyName.includes(normalizedQuery) || ticker.includes(normalizedQuery)) {
          results.push({
            id: `benjamin-graham-${index}`,
            type: 'benjamin-graham',
            viewId: 'entry-exit-benjamin-graham',
            label: companyName.includes(normalizedQuery) ? item.companyName : `${item.companyName} (${item.ticker})`,
            companyName: item.companyName,
            ticker: item.ticker,
            matchField: companyName.includes(normalizedQuery) ? 'companyName' : 'ticker',
          });
        }
      });

      // Search in PEIndustryData
      peIndustryData.forEach((item, index) => {
        const industry = item.industry?.toLowerCase() || '';
        if (industry.includes(normalizedQuery)) {
          results.push({
            id: `pe-industry-${index}`,
            type: 'pe-industry',
            viewId: 'fundamental-pe-industry',
            label: item.industry,
            industry: item.industry,
            matchField: 'industry',
          });
        }
      });

      // Search in ThresholdIndustryData
      thresholdIndustryData.forEach((item, index) => {
        const industry = item.industry?.toLowerCase() || '';
        if (industry.includes(normalizedQuery)) {
          results.push({
            id: `threshold-industry-${index}`,
            type: 'threshold-industry',
            viewId: 'threshold-industry',
            label: item.industry,
            industry: item.industry,
            matchField: 'industry',
          });
        }
      });

      // Remove only exact duplicates (same id) to allow same company in different tables
      const uniqueResults = results.filter((result, index, self) =>
        index === self.findIndex((r) => r.id === result.id)
      );

      // Limit to 50 results for performance (increased from 20 since we show all tables)
      return uniqueResults.slice(0, 50);
    };
  }, [scoreBoardData, benjaminGrahamData, peIndustryData, thresholdIndustryData]);

  return { search };
}


```

## `src/hooks/useOnlineStatus.ts`

```typescript
import { useState, useEffect } from 'react';

/**
 * Hook to track online/offline status
 */
export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(() => {
    // Check if we're in a browser environment
    if (typeof navigator !== 'undefined' && 'onLine' in navigator) {
      return navigator.onLine;
    }
    // Default to online if we can't determine
    return true;
  });

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return isOnline;
}

```

## `src/hooks/usePageVisibility.ts`

```typescript
import { useState, useEffect } from 'react';

/**
 * Hook to track page visibility
 * Returns true if page is visible, false if hidden
 */
export function usePageVisibility(): boolean {
  const [isVisible, setIsVisible] = useState(() => !document.hidden);

  useEffect(() => {
    const handleVisibilityChange = () => {
      setIsVisible(!document.hidden);
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, []);

  return isVisible;
}

```

## `src/hooks/usePEIndustryData.ts`

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';
import { fetchPEIndustryData, ProgressCallback } from '../services/sheets';
import { transformPEIndustryData } from '../services/sheets/peIndustryService';
import type { DataRow } from '../services/sheets';
import { PEIndustryData } from '../types/stock';
import { useLoadingProgress } from '../contexts/LoadingProgressContext';
import { useRefreshOptional } from '../contexts/RefreshContext';
import {
  getCachedData,
  getDeltaCacheEntry,
  setDeltaCacheEntry,
  setViewData,
  getViewDataWithFallback,
  CACHE_KEYS,
  VIEWDATA_MIGRATION_MODE,
} from '../services/firestoreCacheService';
import { createErrorHandler, logError, formatError, isErrorType } from '../utils/errorHandler';
import { logger } from '../utils/logger';
import { useNotifications } from '../contexts/NotificationContext';
import { detectDataChanges, formatChangeSummary } from '../utils/dataChangeDetector';
import { 
  initSync, 
  pollChanges, 
  loadSnapshot, 
  applyChangesToCache,
  isDeltaSyncEnabled,
  getPollIntervalMs,
  snapshotToTransformerFormat,
  type DeltaSyncConfig
} from '../services/deltaSyncService';
import { usePageVisibility } from './usePageVisibility';

const APPS_SCRIPT_URL = import.meta.env.VITE_APPS_SCRIPT_URL || '';
const SHEET_NAME = 'DashBoard';
const CACHE_KEY = CACHE_KEYS.PE_INDUSTRY;

/**
 * Custom hook for fetching and managing P/E Industry data with delta sync
 * 
 * Implements delta sync for efficient data updates:
 * - **Delta Sync (enabled)**: Uses version-based incremental updates
 *   - Initial load: Full snapshot
 *   - Subsequent updates: Only changed rows (polling every 15 minutes)
 *   - Automatic polling when page is visible
 * - **Fallback (disabled)**: Uses regular fetch with stale-while-revalidate
 * 
 * **Delta Sync Strategy:**
 * - Polls for changes every 15 minutes (configurable)
 * - Only polls when page is visible (saves resources)
 * - Falls back to regular fetch if delta sync fails
 * - Uses version numbers to track changes efficiently
 * 
 * **Cache Strategy:**
 * - Delta cache: Version-based with lastUpdated timestamp
 * - Regular cache: TTL-based (20 minutes)
 * - Shows cached data immediately, updates in background
 * 
 * @returns Object with data, loading state, error, lastUpdated timestamp, and refetch function
 */
export function usePEIndustryData() {
  const [data, setData] = useState<PEIndustryData[]>([]);
  const [loading, setLoading] = useState(true); // Start with loading state
  const [error, setError] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
  const { updateProgress } = useLoadingProgress();
  const isPageVisible = usePageVisibility();
  const currentVersionRef = useRef<number>(0);
  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const { createNotification } = useNotifications();
  const previousDataRef = useRef<PEIndustryData[]>([]);
  const cacheLoadedRef = useRef<boolean>(false);

  // Load data using delta-sync or fallback to regular fetch
  const loadData = useCallback(async (forceRefresh: boolean = false, isBackground: boolean = false) => {
    try {
      if (!isBackground) {
        setLoading(true);
      }
      setError(null);
      
      if (!isBackground) {
        updateProgress('pe-industry', {
          status: 'loading',
          progress: 0,
          message: 'Loading data...',
        });
      }

      // Try delta-sync if enabled
      if (isDeltaSyncEnabled() && APPS_SCRIPT_URL && !forceRefresh) {
        try {
          const config: DeltaSyncConfig = {
            sheetName: SHEET_NAME,
            apiBaseUrl: APPS_SCRIPT_URL,
            dataTypeName: 'PE Industry',
          };

          // Load initial snapshot or use cached data
          const result = await initSync<PEIndustryData>(
            config,
            CACHE_KEY,
            transformPEIndustryData
          );

          // Detect data changes
          const changes = detectDataChanges(
            previousDataRef.current,
            result.data,
            (item) => item.industry,
            0.05 // 5% threshold
          );
          
          setData(result.data);
          previousDataRef.current = result.data;
          currentVersionRef.current = result.version;
          setLastUpdated(new Date());
          setViewData('fundamental-pe-industry', { peIndustry: result.data }, { source: 'client-refresh' }).catch((e) =>
            logger.warn('Failed to write viewData', { component: 'usePEIndustryData', error: e })
          );
          // Show notification if significant changes detected
          if (changes.hasSignificantChanges && !isBackground) {
            const changeMessage = formatChangeSummary(changes);
            createNotification(
              'data-update',
              'P/E Industry Data Updated',
              `Total: ${changes.total} items. ${changeMessage}`,
              {
                showDesktop: true,
                data: { changes, dataType: 'pe-industry' },
              }
            );
          }
          
          if (!isBackground) {
            updateProgress('pe-industry', {
              status: 'complete',
              progress: 100,
              message: 'Data loaded',
            });
          }
          
          if (!isBackground) {
            setLoading(false);
          }
          return;
        } catch (deltaSyncError) {
          // Delta sync failed, fallback to regular fetch
          const errorMessage = deltaSyncError instanceof Error ? deltaSyncError.message : String(deltaSyncError);
          
          // Only log warning if it's not a timeout (timeouts are expected and will fallback)
          if (!errorMessage.includes('timeout') && !errorMessage.includes('Request timeout')) {
            logger.warn(
              `Delta sync failed for ${SHEET_NAME}, falling back to regular fetch: ${errorMessage}`,
              { component: 'usePEIndustryData', operation: 'initialize delta sync', sheetName: SHEET_NAME, error: deltaSyncError }
            );
          } else {
            logger.debug(
              `Delta sync timed out for ${SHEET_NAME}, using regular fetch instead`,
              { component: 'usePEIndustryData', operation: 'initialize delta sync', sheetName: SHEET_NAME }
            );
          }
          // Don't throw - fallback to regular fetch
        }
      }

      // Fallback to regular fetch
      const progressCallback: ProgressCallback = (progress) => {
        if (!isBackground) {
          updateProgress('pe-industry', {
            progress: progress.percentage,
            status: progress.stage === 'complete' ? 'complete' : 'loading',
            message: progress.message,
            rowsLoaded: progress.rowsProcessed,
            totalRows: progress.totalRows,
          });
        }
      };
      
      logger.debug('Fetching PE Industry data', { 
        component: 'usePEIndustryData', 
        operation: 'loadData',
        forceRefresh,
        isBackground 
      });
      
      const fetchedData = await fetchPEIndustryData(forceRefresh, progressCallback);
      
      logger.info('PE Industry data fetched successfully', { 
        component: 'usePEIndustryData', 
        operation: 'loadData',
        entryCount: fetchedData.length,
        forceRefresh 
      });
      
      // Detect data changes
      const changes = detectDataChanges(
        previousDataRef.current,
        fetchedData,
        (item) => item.industry,
        0.05 // 5% threshold
      );
      
      logger.debug('Updating PE Industry state with new data', { 
        component: 'usePEIndustryData', 
        operation: 'loadData',
        entryCount: fetchedData.length,
        hasChanges: changes.hasSignificantChanges 
      });
      
      setData(fetchedData);
      previousDataRef.current = fetchedData;
      setLastUpdated(new Date());
      setViewData('fundamental-pe-industry', { peIndustry: fetchedData }, { source: 'client-refresh' }).catch((e) =>
        logger.warn('Failed to write viewData', { component: 'usePEIndustryData', error: e })
      );
      logger.info('PE Industry state updated successfully', { 
        component: 'usePEIndustryData', 
        operation: 'loadData',
        entryCount: fetchedData.length 
      });
      
      // Show notification if significant changes detected
      if (changes.hasSignificantChanges && !isBackground) {
        const changeMessage = formatChangeSummary(changes);
        createNotification(
          'data-update',
          'P/E Industry Data Updated',
          `Total: ${changes.total} items. ${changeMessage}`,
          {
            showDesktop: true,
            data: { changes, dataType: 'pe-industry' },
          }
        );
      }
      
      if (!isBackground) {
        updateProgress('pe-industry', {
          status: 'complete',
          progress: 100,
        });
      }
    } catch (err: unknown) {
      const errorHandler = createErrorHandler({
        operation: 'fetch P/E Industry data',
        component: 'usePEIndustryData',
        additionalInfo: { forceRefresh, isBackground },
      });
      const formatted = errorHandler(err);
      setError(formatted.userMessage);
      if (!isBackground) {
        updateProgress('pe-industry', {
          status: 'error',
          progress: 0,
          message: formatted.userMessage,
        });
      }
    } finally {
      if (!isBackground) {
        setLoading(false);
      }
    }
  }, [updateProgress, createNotification]);

  // Poll for changes using delta-sync
  const pollForChanges = useCallback(async () => {
    // Only poll if page is visible
    if (!isPageVisible) {
      return;
    }

    if (!isDeltaSyncEnabled() || !APPS_SCRIPT_URL || currentVersionRef.current === 0) {
      return;
    }

    try {
      const config: DeltaSyncConfig = {
        sheetName: SHEET_NAME,
        apiBaseUrl: APPS_SCRIPT_URL,
        dataTypeName: 'PE Industry',
      };

      const changesResponse = await pollChanges(config, currentVersionRef.current);
      const cacheResult = await applyChangesToCache<PEIndustryData>(changesResponse, CACHE_KEY);

      if (cacheResult.needsReload) {
        // Changes detected, reload snapshot
        const snapshot = await loadSnapshot(config);
        const transformerFormat = snapshotToTransformerFormat(snapshot);
        const transformedData = transformPEIndustryData(transformerFormat);
        // cutover: no appCache writes for view-docs
        if (VIEWDATA_MIGRATION_MODE !== 'cutover') {
          setDeltaCacheEntry(CACHE_KEY, transformedData, snapshot.version, true);
        }
        setViewData('fundamental-pe-industry', { peIndustry: transformedData }, { source: 'client-refresh' }).catch((e) =>
          logger.warn('Failed to write viewData', { component: 'usePEIndustryData', error: e })
        );
        // Detect data changes
        const dataChanges = detectDataChanges(
          previousDataRef.current,
          transformedData,
          (item) => item.industry,
          0.05 // 5% threshold
        );
        
        setData(transformedData);
        previousDataRef.current = transformedData;
        currentVersionRef.current = snapshot.version;
        setLastUpdated(new Date());
        
        // Show notification if significant changes detected
        if (dataChanges.hasSignificantChanges) {
          const changeMessage = formatChangeSummary(dataChanges);
          createNotification(
            'data-update',
            'P/E Industry Data Updated',
            `Total: ${dataChanges.total} items. ${changeMessage}`,
            {
              showDesktop: true,
              data: { changes: dataChanges, dataType: 'pe-industry' },
            }
          );
        }
      } else if (cacheResult.data) {
        // No changes, use cached data
        setData(cacheResult.data);
        currentVersionRef.current = cacheResult.version;
      }
    } catch (pollError) {
      // Silently fail polling - don't show errors to user
      const context = {
        operation: 'poll for changes',
        component: 'usePEIndustryData',
        additionalInfo: { version: currentVersionRef.current },
      };
      const formatted = formatError(pollError, context);
      if (isErrorType(pollError, 'timeout')) {
        logger.warn(formatted.message, { component: context.component, operation: context.operation, ...formatted.context.additionalInfo });
      } else {
        logError(pollError, formatted.context);
      }
    }
  }, [isPageVisible, createNotification]);

  // Load cache on mount - viewData first (dual-read/cutover), then appCache fallback
  useEffect(() => {
    const loadCache = async () => {
      if (cacheLoadedRef.current) return;
      cacheLoadedRef.current = true;
      
      try {
        const result = await getViewDataWithFallback<{ peIndustry: PEIndustryData[] }>('fundamental-pe-industry', {
          fallback: async () => {
            const delta = await getDeltaCacheEntry<PEIndustryData[]>(CACHE_KEY);
            const regular = delta ? null : await getCachedData<PEIndustryData[]>(CACHE_KEY);
            const arr = delta?.data ?? regular;
            return arr && arr.length > 0 ? { peIndustry: arr } : null;
          },
        });
        if (result && result.data.peIndustry.length > 0) {
          const cachedData = result.data.peIndustry;
          setData(cachedData);
          previousDataRef.current = cachedData;
          const delta = await getDeltaCacheEntry<PEIndustryData[]>(CACHE_KEY);
          currentVersionRef.current = delta?.version ?? 0;
          setLoading(false);
          return;
        }
      } catch (err) {
        logger.warn('Failed to load cache, fetching fresh data', { component: 'usePEIndustryData', error: err });
      }
      
      loadData(false, false);
    };
    
    loadCache();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Only run once on mount

  // Set up polling for changes (delta-sync only)
  useEffect(() => {
    if (isDeltaSyncEnabled() && APPS_SCRIPT_URL && isPageVisible) {
      const intervalMs = getPollIntervalMs();
      
      // Poll immediately after initial load (with delay)
      const initialPollTimeout = setTimeout(() => {
        pollForChanges();
      }, 5000); // Wait 5 seconds after initial load

      // Set up periodic polling (only when page is visible)
      pollIntervalRef.current = setInterval(() => {
        pollForChanges();
      }, intervalMs);

      return () => {
        clearTimeout(initialPollTimeout);
        if (pollIntervalRef.current) {
          clearInterval(pollIntervalRef.current);
        }
      };
    } else {
      // Clear interval if page becomes hidden or delta-sync is disabled
      if (pollIntervalRef.current) {
        clearInterval(pollIntervalRef.current);
        pollIntervalRef.current = null;
      }
    }
  }, [pollForChanges, isPageVisible]);

  const refetch = useCallback(
    async (forceRefresh?: boolean | { skipFetch?: boolean }) => {
      const opts = typeof forceRefresh === 'object' ? forceRefresh : { skipFetch: false };
      if (opts?.skipFetch) {
        setLoading(true);
        try {
          const result = await getViewDataWithFallback<{ peIndustry: PEIndustryData[] }>('fundamental-pe-industry', {
            fallback: async () => {
              const delta = await getDeltaCacheEntry<PEIndustryData[]>(CACHE_KEY);
              const regular = delta ? null : await getCachedData<PEIndustryData[]>(CACHE_KEY);
              const arr = delta?.data ?? regular;
              return arr && arr.length > 0 ? { peIndustry: arr } : null;
            },
          });
          if (result?.data?.peIndustry?.length) {
            setData(result.data.peIndustry);
            previousDataRef.current = result.data.peIndustry;
            setLastUpdated(new Date());
          }
        } finally {
          setLoading(false);
        }
        return;
      }
      loadData(typeof forceRefresh === 'boolean' ? forceRefresh : false);
    },
    [loadData]
  );

  const refreshContext = useRefreshOptional();
  useEffect(() => {
    if (!refreshContext) return;
    const unregister = refreshContext.registerRefetch('pe-industry', (options) =>
      refetch(options?.skipFetch ? { skipFetch: true } : true)
    );
    return unregister;
  }, [refreshContext, refetch]);

  return {
    data,
    loading,
    error,
    lastUpdated,
    refetch,
  };
}


```

## `src/hooks/usePortfolioSearch.ts`

```typescript
import { useMemo } from 'react';
import { BenjaminGrahamData } from '../types/stock';
import { sanitizeSearchQuery } from '../utils/inputValidator';

export interface StockSearchResult {
  companyName: string;
  ticker: string;
  price: number | null;
  benjaminGraham: number | null;
}

/**
 * Custom hook for searching stocks in benjaminGrahamData
 * 
 * Searches for stocks by ticker or company name (case-insensitive).
 * Returns matching stocks with relevant data for portfolio addition.
 * 
 * @param benjaminGrahamData - Array of Benjamin Graham data to search in
 * @param query - Search query (ticker or company name)
 * @returns Array of matching stock search results
 * 
 * @example
 * ```typescript
 * const { data: benjaminGrahamData } = useBenjaminGrahamData();
 * const results = usePortfolioSearch(benjaminGrahamData, 'AAPL');
 * ```
 */
export function usePortfolioSearch(
  benjaminGrahamData: BenjaminGrahamData[],
  query: string
): StockSearchResult[] {
  return useMemo(() => {
    if (!query || query.trim().length < 2) {
      return [];
    }

    // Sanitize search query to prevent XSS and regex injection
    const sanitizedQuery = sanitizeSearchQuery(query);
    const normalizedQuery = sanitizedQuery.toLowerCase().trim();

    if (normalizedQuery.length === 0) {
      return [];
    }

    const results: StockSearchResult[] = [];

    for (const item of benjaminGrahamData) {
      const companyName = (item.companyName || '').toLowerCase();
      const ticker = (item.ticker || '').toLowerCase();

      // Check if query matches company name or ticker
      if (companyName.includes(normalizedQuery) || ticker.includes(normalizedQuery)) {
        results.push({
          companyName: item.companyName,
          ticker: item.ticker,
          price: item.price ?? null,
          benjaminGraham: item.benjaminGraham ?? null,
        });
      }
    }

    // Limit results to 50 for performance
    return results.slice(0, 50);
  }, [benjaminGrahamData, query]);
}

```

## `src/hooks/usePullToRefresh.ts`

```typescript
import { useEffect, useRef, useState } from 'react';

interface PullToRefreshOptions {
  onRefresh: () => void | Promise<void>;
  threshold?: number; // Distance in pixels to trigger refresh
  disabled?: boolean;
  enabled?: boolean; // Only enable on mobile
}

export function usePullToRefresh({
  onRefresh,
  threshold = 80,
  disabled = false,
  enabled = true,
}: PullToRefreshOptions) {
  const [pullDistance, setPullDistance] = useState(0);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const startY = useRef<number | null>(null);
  const containerRef = useRef<HTMLElement | null>(null);
  const isDragging = useRef(false);

  useEffect(() => {
    // Only enable on mobile devices
    const isMobile = window.innerWidth < 1024;
    if (!enabled || disabled || !isMobile) {
      return;
    }

    const container = containerRef.current;
    if (!container) return;

    const handleTouchStart = (e: TouchEvent) => {
      // Only start if at top of scrollable area
      if (container.scrollTop === 0 && !isRefreshing) {
        startY.current = e.touches[0].clientY;
        isDragging.current = true;
      }
    };

    const handleTouchMove = (e: TouchEvent) => {
      if (!isDragging.current || startY.current === null) return;

      const currentY = e.touches[0].clientY;
      const deltaY = currentY - startY.current;

      // Only allow pull down, not up
      if (deltaY > 0 && container.scrollTop === 0) {
        e.preventDefault(); // Prevent default scrolling
        const distance = Math.min(deltaY, threshold * 1.5); // Allow over-pull with resistance
        setPullDistance(distance);
      } else if (deltaY < 0) {
        // Reset if user scrolls back up
        startY.current = null;
        isDragging.current = false;
        setPullDistance(0);
      }
    };

    const handleTouchEnd = async () => {
      if (!isDragging.current || startY.current === null) return;

      if (pullDistance >= threshold && !isRefreshing) {
        setIsRefreshing(true);
        setPullDistance(0);
        try {
          await onRefresh();
        } finally {
          setIsRefreshing(false);
        }
      } else {
        setPullDistance(0);
      }

      startY.current = null;
      isDragging.current = false;
    };

    container.addEventListener('touchstart', handleTouchStart, { passive: false });
    container.addEventListener('touchmove', handleTouchMove, { passive: false });
    container.addEventListener('touchend', handleTouchEnd, { passive: true });
    container.addEventListener('touchcancel', handleTouchEnd, { passive: true });

    return () => {
      container.removeEventListener('touchstart', handleTouchStart);
      container.removeEventListener('touchmove', handleTouchMove);
      container.removeEventListener('touchend', handleTouchEnd);
      container.removeEventListener('touchcancel', handleTouchEnd);
    };
  }, [onRefresh, threshold, disabled, enabled, pullDistance, isRefreshing]);

  const pullProgress = Math.min(pullDistance / threshold, 1);
  const shouldTrigger = pullDistance >= threshold;

  return {
    containerRef,
    pullDistance,
    pullProgress,
    isRefreshing,
    shouldTrigger,
  };
}

```

## `src/hooks/useScoreBoardData.ts`

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';
import { fetchScoreBoardData, ProgressCallback } from '../services/sheets';
import { createScoreBoardTransformer } from '../services/sheets/scoreBoardService';
import { fetchPEIndustryData } from '../services/sheets/peIndustryService';
import { fetchSMAData } from '../services/sheets/smaService';
import type { DataRow } from '../services/sheets';
import { ScoreBoardData, PEIndustryData } from '../types/stock';
import { useLoadingProgress } from '../contexts/LoadingProgressContext';
import { useRefreshOptional } from '../contexts/RefreshContext';
import {
  getCachedData,
  getDeltaCacheEntry,
  setDeltaCacheEntry,
  setViewData,
  getViewDataWithFallback,
  CACHE_KEYS,
  VIEWDATA_MIGRATION_MODE,
} from '../services/firestoreCacheService';
import { createErrorHandler, logError, formatError, isErrorType } from '../utils/errorHandler';
import { useNotifications } from '../contexts/NotificationContext';
import { detectDataChanges, formatChangeSummary } from '../utils/dataChangeDetector';
import { logger } from '../utils/logger';
import { 
  initSync, 
  pollChanges, 
  loadSnapshot, 
  applyChangesToCache,
  isDeltaSyncEnabled,
  getPollIntervalMs,
  snapshotToTransformerFormat,
  type DeltaSyncConfig
} from '../services/deltaSyncService';
import { usePageVisibility } from './usePageVisibility';

const APPS_SCRIPT_URL = import.meta.env.VITE_APPS_SCRIPT_URL || '';
const SHEET_NAME = 'DashBoard';
const CACHE_KEY = CACHE_KEYS.SCORE_BOARD;

/**
 * Custom hook for fetching and managing Score Board data with delta sync
 * 
 * Implements delta sync for efficient data updates:
 * - **Delta Sync (enabled)**: Uses version-based incremental updates
 *   - Initial load: Full snapshot
 *   - Subsequent updates: Only changed rows (polling every 15 minutes)
 *   - Automatic polling when page is visible
 * - **Fallback (disabled)**: Uses regular fetch with stale-while-revalidate
 * 
 * **Delta Sync Strategy:**
 * - Polls for changes every 15 minutes (configurable)
 * - Only polls when page is visible (saves resources)
 * - Falls back to regular fetch if delta sync fails
 * - Uses version numbers to track changes efficiently
 * - Fetches PE Industry and SMA data separately for calculations
 * 
 * **Cache Strategy:**
 * - Delta cache: Version-based with lastUpdated timestamp
 * - Regular cache: TTL-based (20 minutes)
 * - Shows cached data immediately, updates in background
 * 
 * @returns Object with data, loading state, error, lastUpdated timestamp, and refetch function
 * 
 * @example
 * ```typescript
 * const { data, loading, error, refetch } = useScoreBoardData();
 * 
 * // Data automatically updates via delta sync if enabled
 * // Or manually refresh:
 * refetch(true);
 * ```
 */
export function useScoreBoardData() {
  const [data, setData] = useState<ScoreBoardData[]>([]);
  const [loading, setLoading] = useState(true); // Start with loading state
  const [error, setError] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
  const { updateProgress } = useLoadingProgress();
  const isPageVisible = usePageVisibility();
  const currentVersionRef = useRef<number>(0);
  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const { createNotification } = useNotifications();
  const previousDataRef = useRef<ScoreBoardData[]>([]);
  const cacheLoadedRef = useRef<boolean>(false);

  // Helper function to fetch PE Industry and SMA data and create maps
  const fetchDependenciesAndCreateTransformer = useCallback(async (forceRefresh: boolean = false) => {
    // Fetch PEIndustryData and SMAData in parallel (they are independent)
    const [peIndustryResult, smaResult] = await Promise.allSettled([
      fetchPEIndustryData(forceRefresh),
      fetchSMAData(forceRefresh),
    ]);

    // Process PEIndustryData results
    let peIndustryData: PEIndustryData[] = [];
    if (peIndustryResult.status === 'fulfilled') {
      peIndustryData = peIndustryResult.value;
    } else {
      logger.warn(
        'Failed to fetch PE Industry data for P/E1 INDUSTRY calculation',
        { component: 'useScoreBoardData', operation: 'fetchDependenciesAndCreateTransformer', error: peIndustryResult.reason }
      );
    }

    // Create maps for quick lookup: industry -> pe1 and pe2 (median)
    const industryPe1Map = new Map<string, number>();
    const industryPe2Map = new Map<string, number>();
    peIndustryData.forEach((peIndustry) => {
      if (peIndustry.pe1 !== null) {
        industryPe1Map.set(peIndustry.industry.toLowerCase(), peIndustry.pe1);
      }
      if (peIndustry.pe2 !== null) {
        industryPe2Map.set(peIndustry.industry.toLowerCase(), peIndustry.pe2);
      }
    });

    // Process SMAData results
    let smaDataMap = new Map<string, { sma100: number | null; sma200: number | null; smaCross: string | null }>();
    if (smaResult.status === 'fulfilled') {
      const smaData = smaResult.value;
      smaData.forEach((sma) => {
        const tickerKey = sma.ticker.toLowerCase().trim();
        smaDataMap.set(tickerKey, {
          sma100: sma.sma100,
          sma200: sma.sma200,
          smaCross: sma.smaCross,
        });
      });
    } else {
      logger.warn(
        'Failed to fetch SMA data for Score Board',
        { component: 'useScoreBoardData', operation: 'fetchDependenciesAndCreateTransformer', error: smaResult.reason }
      );
    }

    // Create transformer with the maps
    const transformer = createScoreBoardTransformer(industryPe1Map, industryPe2Map, smaDataMap);

    // Convert Maps to plain objects for worker serialization (delta sync / initSync)
    const industryPe1MapObj: Record<string, number> = {};
    industryPe1Map.forEach((value, key) => {
      industryPe1MapObj[key] = value;
    });
    const industryPe2MapObj: Record<string, number> = {};
    industryPe2Map.forEach((value, key) => {
      industryPe2MapObj[key] = value;
    });
    const smaDataMapObj: Record<string, { sma100: number | null; sma200: number | null; smaCross: string | null }> = {};
    smaDataMap.forEach((value, key) => {
      smaDataMapObj[key] = value;
    });

    return {
      transformer,
      additionalData: {
        industryPe1Map: industryPe1MapObj,
        industryPe2Map: industryPe2MapObj,
        smaDataMap: smaDataMapObj,
      },
    };
  }, []);

  // Load data using delta-sync or fallback to regular fetch
  const loadData = useCallback(async (forceRefresh: boolean = false, isBackground: boolean = false) => {
    try {
      if (!isBackground) {
        setLoading(true);
      }
      setError(null);
      
      if (!isBackground) {
        updateProgress('score-board', {
          status: 'loading',
          progress: 0,
          message: 'Loading data...',
        });
      }

      // Try delta-sync if enabled
      if (isDeltaSyncEnabled() && APPS_SCRIPT_URL && !forceRefresh) {
        try {
          // Fetch dependencies first (PE Industry, SMA) for transformer and worker additionalData
          const { transformer, additionalData } = await fetchDependenciesAndCreateTransformer(forceRefresh);

          const config: DeltaSyncConfig = {
            sheetName: SHEET_NAME,
            apiBaseUrl: APPS_SCRIPT_URL,
            dataTypeName: 'Score Board',
            additionalData,
          };

          // Load initial snapshot or use cached data
          const result = await initSync<ScoreBoardData>(
            config,
            CACHE_KEY,
            transformer
          );

          // Detect data changes
          const changes = detectDataChanges(
            previousDataRef.current,
            result.data,
            (item) => `${item.ticker}-${item.companyName}`,
            0.05 // 5% threshold
          );
          
          setData(result.data);
          previousDataRef.current = result.data;
          currentVersionRef.current = result.version;
          setLastUpdated(new Date());
          setViewData('score-board', { scoreBoard: result.data }, { source: 'client-refresh' }).catch((e) =>
            logger.warn('Failed to write viewData', { component: 'useScoreBoardData', error: e })
          );
          setViewData('score', { scoreBoard: result.data }, { source: 'client-refresh' }).catch((e) =>
            logger.warn('Failed to write viewData', { component: 'useScoreBoardData', error: e })
          );
          // Show notification if significant changes detected
          if (changes.hasSignificantChanges && !isBackground) {
            const changeMessage = formatChangeSummary(changes);
            createNotification(
              'data-update',
              'Score Board Data Updated',
              `Total: ${changes.total} items. ${changeMessage}`,
              {
                showDesktop: true,
                data: { changes, dataType: 'score-board' },
              }
            );
          }
          
          if (!isBackground) {
            updateProgress('score-board', {
              status: 'complete',
              progress: 100,
              message: 'Data loaded',
            });
          }
          
          if (!isBackground) {
            setLoading(false);
          }
          return;
        } catch (deltaSyncError) {
          // Delta sync failed, fallback to regular fetch
          const errorMessage = deltaSyncError instanceof Error ? deltaSyncError.message : String(deltaSyncError);
          
          // Only log warning if it's not a timeout (timeouts are expected and will fallback)
          if (!errorMessage.includes('timeout') && !errorMessage.includes('Request timeout')) {
            logger.warn(
              `Delta sync failed for ${SHEET_NAME}, falling back to regular fetch: ${errorMessage}`,
              { component: 'useScoreBoardData', operation: 'initialize delta sync', sheetName: SHEET_NAME, error: deltaSyncError }
            );
          } else {
            logger.debug(
              `Delta sync timed out for ${SHEET_NAME}, using regular fetch instead`,
              { component: 'useScoreBoardData', operation: 'initialize delta sync', sheetName: SHEET_NAME }
            );
          }
          // Don't throw - fallback to regular fetch
        }
      }

      // Fallback to regular fetch
      const progressCallback: ProgressCallback = (progress) => {
        if (!isBackground) {
          updateProgress('score-board', {
            progress: progress.percentage,
            status: progress.stage === 'complete' ? 'complete' : 'loading',
            message: progress.message,
            rowsLoaded: progress.rowsProcessed,
            totalRows: progress.totalRows,
          });
        }
      };
      
      logger.debug('Fetching Score Board data', { 
        component: 'useScoreBoardData', 
        operation: 'loadData',
        forceRefresh,
        isBackground 
      });
      
      const fetchedData = await fetchScoreBoardData(forceRefresh, progressCallback);
      
      logger.info('Score Board data fetched successfully', { 
        component: 'useScoreBoardData', 
        operation: 'loadData',
        entryCount: fetchedData.length,
        forceRefresh 
      });
      
      // Detect data changes
      const changes = detectDataChanges(
        previousDataRef.current,
        fetchedData,
        (item) => `${item.ticker}-${item.companyName}`,
        0.05 // 5% threshold
      );
      
      // Update data
      logger.debug('Updating Score Board state with new data', { 
        component: 'useScoreBoardData', 
        operation: 'loadData',
        entryCount: fetchedData.length,
        hasChanges: changes.hasSignificantChanges 
      });
      
      setData(fetchedData);
      previousDataRef.current = fetchedData;
      setLastUpdated(new Date());
      setViewData('score-board', { scoreBoard: fetchedData }, { source: 'client-refresh' }).catch((e) =>
        logger.warn('Failed to write viewData', { component: 'useScoreBoardData', error: e })
      );
      setViewData('score', { scoreBoard: fetchedData }, { source: 'client-refresh' }).catch((e) =>
        logger.warn('Failed to write viewData', { component: 'useScoreBoardData', error: e })
      );
      logger.info('Score Board state updated successfully', { 
        component: 'useScoreBoardData', 
        operation: 'loadData',
        entryCount: fetchedData.length 
      });
      
      // Show notification if significant changes detected
      if (changes.hasSignificantChanges && !isBackground) {
        const changeMessage = formatChangeSummary(changes);
        createNotification(
          'data-update',
          'Score Board Data Updated',
          `Total: ${changes.total} items. ${changeMessage}`,
          {
            showDesktop: true,
            data: { changes, dataType: 'score-board' },
          }
        );
      }
      
      if (!isBackground) {
        updateProgress('score-board', {
          status: 'complete',
          progress: 100,
        });
      }
    } catch (err: unknown) {
      const errorHandler = createErrorHandler({
        operation: 'fetch Score Board data',
        component: 'useScoreBoardData',
        additionalInfo: { forceRefresh, isBackground },
      });
      const formatted = errorHandler(err);
      setError(formatted.userMessage);
      if (!isBackground) {
        updateProgress('score-board', {
          status: 'error',
          progress: 0,
          message: formatted.userMessage,
        });
      }
    } finally {
      if (!isBackground) {
        setLoading(false);
      }
    }
  }, [updateProgress, createNotification, fetchDependenciesAndCreateTransformer]);

  // Poll for changes using delta-sync
  const pollForChanges = useCallback(async () => {
    // Only poll if page is visible
    if (!isPageVisible) {
      return;
    }

    if (!isDeltaSyncEnabled() || !APPS_SCRIPT_URL || currentVersionRef.current === 0) {
      return;
    }

    try {
      const config: DeltaSyncConfig = {
        sheetName: SHEET_NAME,
        apiBaseUrl: APPS_SCRIPT_URL,
        dataTypeName: 'Score Board',
      };

      const changesResponse = await pollChanges(config, currentVersionRef.current);
      const cacheResult = await applyChangesToCache<ScoreBoardData>(changesResponse, CACHE_KEY);

      if (cacheResult.needsReload) {
        // Changes detected, reload snapshot
        // First fetch dependencies (transformer has maps closed over)
        const { transformer } = await fetchDependenciesAndCreateTransformer(false);

        // Load snapshot
        const snapshot = await loadSnapshot(config);
        const transformerFormat = snapshotToTransformerFormat(snapshot);
        const transformedData = transformer(transformerFormat);
        // cutover: no appCache writes for view-docs
        if (VIEWDATA_MIGRATION_MODE !== 'cutover') {
          setDeltaCacheEntry(CACHE_KEY, transformedData, snapshot.version, true);
        }
        setViewData('score-board', { scoreBoard: transformedData }, { source: 'client-refresh' }).catch((e) =>
          logger.warn('Failed to write viewData', { component: 'useScoreBoardData', error: e })
        );
        setViewData('score', { scoreBoard: transformedData }, { source: 'client-refresh' }).catch((e) =>
          logger.warn('Failed to write viewData', { component: 'useScoreBoardData', error: e })
        );
        // Detect data changes
        const dataChanges = detectDataChanges(
          previousDataRef.current,
          transformedData,
          (item) => `${item.ticker}-${item.companyName}`,
          0.05 // 5% threshold
        );
        
        setData(transformedData);
        previousDataRef.current = transformedData;
        currentVersionRef.current = snapshot.version;
        setLastUpdated(new Date());
        
        // Show notification if significant changes detected
        if (dataChanges.hasSignificantChanges) {
          const changeMessage = formatChangeSummary(dataChanges);
          createNotification(
            'data-update',
            'Score Board Data Updated',
            `Total: ${dataChanges.total} items. ${changeMessage}`,
            {
              showDesktop: true,
              data: { changes: dataChanges, dataType: 'score-board' },
            }
          );
        }
      } else if (cacheResult.data) {
        // No changes, use cached data
        setData(cacheResult.data);
        currentVersionRef.current = cacheResult.version;
      }
    } catch (pollError) {
      // Silently fail polling - don't show errors to user
      const context = {
        operation: 'poll for changes',
        component: 'useScoreBoardData',
        additionalInfo: { version: currentVersionRef.current },
      };
      const formatted = formatError(pollError, context);
      // Timeouts during poll are expected (e.g. cold start); log as warning to avoid noisy [ERROR]
      if (isErrorType(pollError, 'timeout')) {
        logger.warn(formatted.message, { component: context.component, operation: context.operation, ...formatted.context.additionalInfo });
      } else {
        logError(pollError, formatted.context);
      }
    }
  }, [isPageVisible, createNotification, fetchDependenciesAndCreateTransformer]);

  // Load cache on mount - viewData first (dual-read/cutover), then appCache fallback
  useEffect(() => {
    const loadCache = async () => {
      if (cacheLoadedRef.current) return;
      cacheLoadedRef.current = true;
      
      try {
        const fallbackFn = async () => {
          const delta = await getDeltaCacheEntry<ScoreBoardData[]>(CACHE_KEY);
          const regular = delta ? null : await getCachedData<ScoreBoardData[]>(CACHE_KEY);
          const arr = delta?.data ?? regular;
          return arr && arr.length > 0 ? { scoreBoard: arr } : null;
        };
        let result = await getViewDataWithFallback<{ scoreBoard: ScoreBoardData[] }>('score-board', { fallback: fallbackFn });
        if (!result) {
          result = await getViewDataWithFallback<{ scoreBoard: ScoreBoardData[] }>('score', { fallback: fallbackFn });
        }
        if (result && result.data.scoreBoard.length > 0) {
          const cachedData = result.data.scoreBoard;
          setData(cachedData);
          previousDataRef.current = cachedData;
          const delta = await getDeltaCacheEntry<ScoreBoardData[]>(CACHE_KEY);
          currentVersionRef.current = delta?.version ?? 0;
          setLoading(false);
          return;
        }
      } catch (err) {
        logger.warn('Failed to load cache, fetching fresh data', { component: 'useScoreBoardData', error: err });
      }
      
      loadData(false, false);
    };
    
    loadCache();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Only run once on mount

  // Set up polling for changes (delta-sync only)
  useEffect(() => {
    if (isDeltaSyncEnabled() && APPS_SCRIPT_URL && isPageVisible) {
      const intervalMs = getPollIntervalMs();
      
      // Poll immediately after initial load (with delay)
      const initialPollTimeout = setTimeout(() => {
        pollForChanges();
      }, 5000); // Wait 5 seconds after initial load

      // Set up periodic polling (only when page is visible)
      pollIntervalRef.current = setInterval(() => {
        pollForChanges();
      }, intervalMs);

      return () => {
        clearTimeout(initialPollTimeout);
        if (pollIntervalRef.current) {
          clearInterval(pollIntervalRef.current);
        }
      };
    } else {
      // Clear interval if page becomes hidden or delta-sync is disabled
      if (pollIntervalRef.current) {
        clearInterval(pollIntervalRef.current);
        pollIntervalRef.current = null;
      }
    }
  }, [pollForChanges, isPageVisible]);

  const refetch = useCallback(
    async (forceRefresh?: boolean | { skipFetch?: boolean }) => {
      const opts = typeof forceRefresh === 'object' ? forceRefresh : { skipFetch: false };
      if (opts?.skipFetch) {
        setLoading(true);
        try {
          const fallbackFn = async () => {
            const delta = await getDeltaCacheEntry<ScoreBoardData[]>(CACHE_KEY);
            const regular = delta ? null : await getCachedData<ScoreBoardData[]>(CACHE_KEY);
            const arr = delta?.data ?? regular;
            return arr && arr.length > 0 ? { scoreBoard: arr } : null;
          };
          let result = await getViewDataWithFallback<{ scoreBoard: ScoreBoardData[] }>('score-board', { fallback: fallbackFn });
          if (!result) result = await getViewDataWithFallback<{ scoreBoard: ScoreBoardData[] }>('score', { fallback: fallbackFn });
          if (result?.data?.scoreBoard?.length) {
            setData(result.data.scoreBoard);
            previousDataRef.current = result.data.scoreBoard;
            setLastUpdated(new Date());
          }
        } finally {
          setLoading(false);
        }
        return;
      }
      loadData(typeof forceRefresh === 'boolean' ? forceRefresh : false);
    },
    [loadData]
  );

  const refreshContext = useRefreshOptional();
  useEffect(() => {
    if (!refreshContext) return;
    const unregister = refreshContext.registerRefetch('score-board', (options) =>
      refetch(options?.skipFetch ? { skipFetch: true } : true)
    );
    return unregister;
  }, [refreshContext, refetch]);

  return {
    data,
    loading,
    error,
    lastUpdated,
    refetch,
  };
}


```

## `src/hooks/useSwipeGesture.ts`

```typescript
import { useRef, useEffect, useState } from 'react';

interface SwipeGestureOptions {
  onSwipeLeft?: () => void;
  onSwipeRight?: () => void;
  threshold?: number; // Minimum distance in pixels to trigger swipe
  velocityThreshold?: number; // Minimum velocity to trigger swipe
}

/**
 * Hook for detecting swipe gestures (left/right)
 * Primarily used for closing sidebar on mobile
 */
export function useSwipeGesture({
  onSwipeLeft,
  onSwipeRight,
  threshold = 50,
  velocityThreshold = 0.3,
}: SwipeGestureOptions) {
  const elementRef = useRef<HTMLElement | null>(null);
  const touchStartRef = useRef<{ x: number; y: number; time: number } | null>(null);
  const [isTracking, setIsTracking] = useState(false);

  useEffect(() => {
    const element = elementRef.current;
    if (!element || (!onSwipeLeft && !onSwipeRight)) return;

    const handleTouchStart = (e: TouchEvent) => {
      const touch = e.touches[0];
      touchStartRef.current = {
        x: touch.clientX,
        y: touch.clientY,
        time: Date.now(),
      };
      setIsTracking(true);
    };

    const handleTouchMove = (e: TouchEvent) => {
      if (!touchStartRef.current || !isTracking) return;
      
      // Prevent default scrolling if we're tracking a horizontal swipe
      const touch = e.touches[0];
      const deltaX = touch.clientX - touchStartRef.current.x;
      const deltaY = touch.clientY - touchStartRef.current.y;
      
      // If horizontal movement is greater than vertical, prevent default
      if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
        e.preventDefault();
      }
    };

    const handleTouchEnd = (e: TouchEvent) => {
      if (!touchStartRef.current || !isTracking) {
        setIsTracking(false);
        return;
      }

      const touch = e.changedTouches[0];
      const deltaX = touch.clientX - touchStartRef.current.x;
      const deltaY = touch.clientY - touchStartRef.current.y;
      const deltaTime = Date.now() - touchStartRef.current.time;
      const velocity = Math.abs(deltaX) / deltaTime;

      // Check if it's a valid swipe (horizontal movement greater than vertical)
      if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > threshold && velocity > velocityThreshold) {
        if (deltaX > 0 && onSwipeRight) {
          onSwipeRight();
        } else if (deltaX < 0 && onSwipeLeft) {
          onSwipeLeft();
        }
      }

      touchStartRef.current = null;
      setIsTracking(false);
    };

    element.addEventListener('touchstart', handleTouchStart, { passive: false });
    element.addEventListener('touchmove', handleTouchMove, { passive: false });
    element.addEventListener('touchend', handleTouchEnd, { passive: true });

    return () => {
      element.removeEventListener('touchstart', handleTouchStart);
      element.removeEventListener('touchmove', handleTouchMove);
      element.removeEventListener('touchend', handleTouchEnd);
    };
  }, [onSwipeLeft, onSwipeRight, threshold, velocityThreshold, isTracking]);

  return elementRef;
}

```

## `src/hooks/useTablePagination.ts`

```typescript
import { useMemo, useState, useEffect } from 'react';

interface UseTablePaginationOptions<T> {
  data: T[];
  itemsPerPage?: number;
  initialPage?: number;
}

/**
 * Custom hook for table pagination
 * 
 * Provides pagination functionality with:
 * - Automatic page reset when data changes significantly
 * - Page navigation (next, previous, first, last, go to page)
 * - Calculated indices for display (e.g., "Showing 1-50 of 150")
 * 
 * **Pagination Strategy:**
 * - Default: 50 items per page (configurable)
 * - Automatically resets to page 1 if current page exceeds total pages
 * - Provides 1-based page numbers for user-friendly display
 * 
 * @template T - Type of data items being paginated
 * @param options - Pagination options
 * @param options.data - Array of data items to paginate
 * @param options.itemsPerPage - Number of items per page (default: 50)
 * @param options.initialPage - Initial page number (default: 1)
 * @returns Object with pagination state and navigation functions
 * 
 * @example
 * ```typescript
 * const {
 *   currentPage,
 *   totalPages,
 *   paginatedData,
 *   goToPage,
 *   nextPage
 * } = useTablePagination({
 *   data: stockData,
 *   itemsPerPage: 25,
 *   initialPage: 1
 * });
 * ```
 */
export function useTablePagination<T>({
  data,
  itemsPerPage = 50,
  initialPage = 1,
}: UseTablePaginationOptions<T>) {
  const [currentPage, setCurrentPage] = useState(initialPage);

  const totalPages = Math.ceil(data.length / itemsPerPage);
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;

  const paginatedData = useMemo(() => {
    return data.slice(startIndex, endIndex);
  }, [data, startIndex, endIndex]);

  // Reset to page 1 when data changes significantly (e.g., after filtering)
  useEffect(() => {
    if (currentPage > totalPages && totalPages > 0) {
      setCurrentPage(1);
    }
  }, [totalPages, currentPage]);

  const goToPage = (page: number) => {
    const validPage = Math.max(1, Math.min(page, totalPages));
    setCurrentPage(validPage);
  };

  const nextPage = () => {
    if (currentPage < totalPages) {
      setCurrentPage(currentPage + 1);
    }
  };

  const previousPage = () => {
    if (currentPage > 1) {
      setCurrentPage(currentPage - 1);
    }
  };

  const goToFirstPage = () => {
    setCurrentPage(1);
  };

  const goToLastPage = () => {
    setCurrentPage(totalPages);
  };

  return {
    currentPage,
    totalPages,
    itemsPerPage,
    paginatedData,
    totalItems: data.length,
    goToPage,
    nextPage,
    previousPage,
    goToFirstPage,
    goToLastPage,
    startIndex: startIndex + 1,
    endIndex: Math.min(endIndex, data.length),
  };
}


```

## `src/hooks/useTableSearch.ts`

```typescript
import { useMemo, useState } from 'react';
import { FilterValues } from '../components/AdvancedFilters';
import { useDebounce } from './useDebounce';
import { sanitizeSearchQuery } from '../utils/inputValidator';

interface UseTableSearchOptions<T> {
  data: T[];
  searchFields?: (keyof T)[];
  initialSearch?: string;
  advancedFilters?: FilterValues;
  debounceDelay?: number;
}

/**
 * Custom hook for table search and filtering
 * 
 * Provides search functionality with:
 * - Text search across multiple fields (with debouncing)
 * - Advanced filters (number ranges, boolean, text)
 * - XSS and regex injection protection via sanitization
 * - Case-insensitive matching
 * 
 * **Search Algorithm:**
 * - Debounced text search (300ms default) to reduce API calls
 * - Searches across all specified fields or all fields if none specified
 * - Uses includes() for substring matching (safe after sanitization)
 * - Advanced filters support: number ranges, exact matches, boolean filters
 * 
 * **Security:**
 * - All search queries are sanitized to prevent XSS and regex injection
 * - Special characters are escaped before use in string matching
 * 
 * @template T - Type of data items being searched
 * @param options - Search options
 * @param options.data - Array of data items to search
 * @param options.searchFields - Optional array of field names to search (defaults to all fields)
 * @param options.initialSearch - Initial search value (default: '')
 * @param options.advancedFilters - Advanced filter values (number ranges, etc.)
 * @param options.debounceDelay - Debounce delay in milliseconds (default: 300)
 * @returns Object with search value, setter, and filtered data
 * 
 * @example
 * ```typescript
 * const { searchValue, setSearchValue, filteredData } = useTableSearch({
 *   data: stockData,
 *   searchFields: ['companyName', 'ticker'],
 *   advancedFilters: { score: { min: 50, max: 100 } }
 * });
 * ```
 */
export function useTableSearch<T extends Record<string, any>>({
  data,
  searchFields,
  initialSearch = '',
  advancedFilters = {},
  debounceDelay = 300,
}: UseTableSearchOptions<T>) {
  const [searchValue, setSearchValue] = useState(initialSearch);
  const debouncedSearchValue = useDebounce(searchValue, debounceDelay);

  const filteredData = useMemo(() => {
    let result = data;

    // Apply text search (using debounced value)
    if (debouncedSearchValue.trim()) {
      // Sanitize search query to prevent XSS and regex injection
      const sanitizedQuery = sanitizeSearchQuery(debouncedSearchValue);
      const searchLower = sanitizedQuery.toLowerCase().trim();
      const fieldsToSearch = searchFields || (Object.keys(data[0] || {}) as (keyof T)[]);

      result = result.filter((item) => {
        return fieldsToSearch.some((field) => {
          const value = item[field];
          if (value === null || value === undefined) {
            return false;
          }
          // Use indexOf for safe string matching (sanitized query is safe)
          return String(value).toLowerCase().includes(searchLower);
        });
      });
    }

    // Apply advanced filters
    if (advancedFilters && Object.keys(advancedFilters).length > 0) {
      result = result.filter((item) => {
        return Object.entries(advancedFilters).every(([key, filterValue]) => {
          if (filterValue === null || filterValue === '' || filterValue === undefined) {
            return true; // No filter applied
          }

          const itemValue = item[key];

          // Handle null/undefined values
          if (itemValue === null || itemValue === undefined) {
            return false;
          }

          // Handle number range filter
          if (typeof filterValue === 'object' && filterValue !== null && ('min' in filterValue || 'max' in filterValue)) {
            const numValue = typeof itemValue === 'number' ? itemValue : parseFloat(String(itemValue));
            if (isNaN(numValue)) return false;
            
            const { min, max } = filterValue as { min?: number; max?: number };
            if (min !== undefined && numValue < min) return false;
            if (max !== undefined && numValue > max) return false;
            return true;
          }

          // Handle boolean filter
          if (typeof filterValue === 'boolean') {
            return Boolean(itemValue) === filterValue;
          }

          // Handle number filter
          if (typeof filterValue === 'number') {
            const numValue = typeof itemValue === 'number' ? itemValue : parseFloat(String(itemValue));
            return !isNaN(numValue) && numValue === filterValue;
          }

          // Handle text/string filter
          if (typeof filterValue === 'string') {
            return String(itemValue).toLowerCase().includes(filterValue.toLowerCase());
          }

          return true;
        });
      });
    }

    return result;
  }, [data, debouncedSearchValue, searchFields, advancedFilters]);

  return {
    searchValue,
    setSearchValue,
    filteredData,
  };
}


```

## `src/hooks/useTableSort.ts`

```typescript
import { useState, useMemo } from 'react';

export type SortDirection = 'asc' | 'desc';
export type SortConfig<T> = {
  key: keyof T | null;
  direction: SortDirection;
};

/**
 * Helper function to check if a value represents N/A
 * 
 * **Why this logic?**
 * - Business requirement: N/A values should be sorted to the end
 * - String 'N/A' explicitly means missing data
 * - Null/undefined values mean missing data
 * - Numeric 0 is a valid value and should be displayed as "0", not N/A
 */
function isNAValue(value: unknown, key: string | number | symbol): boolean {
  if (value == null) return true;
  
  // String values: 'N/A' means N/A
  if (typeof value === 'string' && value.trim().toUpperCase() === 'N/A') return true;
  
  return false;
}

/**
 * Custom hook for table sorting with N/A value handling
 * 
 * Provides sorting functionality that:
 * - Separates N/A values and places them at the end
 * - Handles different data types (numbers, strings)
 * - Supports ascending/descending sort with toggle
 * - Uses different N/A detection logic for ThresholdIndustryData vs other types
 * 
 * **N/A Handling Strategy:**
 * - **ThresholdIndustryData**: Only checks the sorted column for N/A
 * - **Other types**: Checks all numeric columns (except score and industry)
 * - N/A items are always sorted to the end, then sorted by company name
 * 
 * **Why N/A values go last?**
 * - Business requirement: Missing data should not interfere with meaningful comparisons
 * - Ensures data quality by highlighting incomplete records
 * - Provides consistent user experience across all table views
 * 
 * @template T - Type of data items being sorted
 * @param data - Array of data items to sort
 * @param defaultSortKey - Default column to sort by
 * @param defaultDirection - Default sort direction ('asc' or 'desc')
 * @returns Object with sorted data, sort configuration, and sort handler
 * 
 * @example
 * ```typescript
 * const { sortedData, sortConfig, handleSort } = useTableSort(
 *   stockData,
 *   'score',
 *   'desc'
 * );
 * 
 * // In component:
 * <button onClick={() => handleSort('price')}>
 *   Sort by Price {sortConfig.key === 'price' && sortConfig.direction}
 * </button>
 * ```
 */
export function useTableSort<T>(
  data: T[],
  defaultSortKey: keyof T,
  defaultDirection: SortDirection = 'asc'
) {
  const [sortConfig, setSortConfig] = useState<SortConfig<T>>({
    key: defaultSortKey,
    direction: defaultDirection,
  });

  const sortedData = useMemo(() => {
    if (!sortConfig.key) {
      return data;
    }

    // Helper function to check if a row has N/A in the column being sorted
    // For ThresholdIndustryData: only check the sorted column, not all columns
    // For other types: check all numeric columns except score and industry
    const hasNAInSortedColumn = (item: T): boolean => {
      if (!sortConfig.key) return false;
      
      const value = item[sortConfig.key];
      const keyStr = String(sortConfig.key);
      
      // For ThresholdIndustryData, only check the sorted column itself
      // Skip industry column as it's always a valid string
      if (keyStr === 'industry') {
        return false;
      }
      
      return isNAValue(value, sortConfig.key);
    };
    
    // Helper function to check if a row has N/A in ANY column (for backward compatibility)
    // For BenjaminGrahamData: check price and benjaminGraham (0 = N/A)
    // For other types: check all numeric columns except score and industry
    const hasNAInAnyColumn = (item: T): boolean => {
      // Get all keys from the item
      // Use type guard: T must be object for Object.keys
      const keys = Object.keys(item as object) as Array<keyof T>;
      
      for (const key of keys) {
        // Skip companyName, ticker, company, ticket, and industry as they can't be N/A (filtered out already or always valid)
        if (String(key) === 'companyName' || String(key) === 'ticker' || 
            String(key) === 'company' || String(key) === 'ticket' ||
            String(key) === 'industry') {
          continue;
        }
        
        const value = item[key];
        if (isNAValue(value, key)) {
          return true;
        }
      }
      return false;
    };

    // Separate items with N/A in the sorted column from items without N/A
    // For ThresholdIndustryData, only check the sorted column
    // For other types, check all columns
    const regularItems: T[] = [];
    const naItems: T[] = [];

    // Check if this is ThresholdIndustryData by checking if 'industry' key exists
    // Type guard: ensure data[0] is an object before checking for 'industry'
    const isThresholdIndustryData = data.length > 0 && typeof data[0] === 'object' && data[0] !== null && 'industry' in data[0];
    
    data.forEach((item) => {
      // For ThresholdIndustryData, only check the sorted column
      // For other types, check all columns
      const hasNA = isThresholdIndustryData 
        ? hasNAInSortedColumn(item)
        : hasNAInAnyColumn(item);
      
      if (hasNA) {
        naItems.push(item);
      } else {
        regularItems.push(item);
      }
    });

    // Sort regular items
    // At this point, sortConfig.key is guaranteed to be non-null (checked at line 38)
    const sortKey = sortConfig.key;
    const sortedRegular = [...regularItems].sort((a, b) => {
      const aValue = a[sortKey];
      const bValue = b[sortKey];

      // Handle null/undefined (should not happen after N/A check, but safety)
      if (aValue == null && bValue == null) return 0;
      if (aValue == null) return 1;
      if (bValue == null) return -1;

      // Numeric comparison
      if (typeof aValue === 'number' && typeof bValue === 'number') {
        return aValue - bValue;
      }

      // String comparison (case-insensitive)
      const aStr = String(aValue).toLowerCase();
      const bStr = String(bValue).toLowerCase();
      
      if (aStr < bStr) return -1;
      if (aStr > bStr) return 1;
      return 0;
    });

    // Apply sort direction to regular items
    const finalSorted = sortConfig.direction === 'asc' ? sortedRegular : sortedRegular.reverse();

    // Sort N/A items by Company Name (or defaultSortKey if companyName doesn't exist)
    // Try to find 'companyName' key, otherwise use defaultSortKey
    const fallbackSortKey = ('companyName' in (data[0] || {}) ? 'companyName' : defaultSortKey) as keyof T;
    
    const sortedNAItems = [...naItems].sort((a, b) => {
      const aValue = a[fallbackSortKey];
      const bValue = b[fallbackSortKey];

      // Handle null/undefined
      if (aValue == null && bValue == null) return 0;
      if (aValue == null) return 1;
      if (bValue == null) return -1;

      // Numeric comparison
      if (typeof aValue === 'number' && typeof bValue === 'number') {
        return aValue - bValue;
      }

      // String comparison (case-insensitive)
      const aStr = String(aValue).toLowerCase();
      const bStr = String(bValue).toLowerCase();
      
      if (aStr < bStr) return -1;
      if (aStr > bStr) return 1;
      return 0;
    });

    // Edge case: All values are N/A
    // If all items have N/A values, they're all sorted by company name
    // This ensures consistent sorting even when no valid data exists
    // N/A items always go at the end, sorted by Company Name
    return [...finalSorted, ...sortedNAItems];
  }, [data, sortConfig, defaultSortKey]);

  const handleSort = (key: keyof T) => {
    setSortConfig((prevConfig) => {
      if (prevConfig.key === key) {
        // Toggle direction if clicking the same column
        return {
          key,
          direction: prevConfig.direction === 'asc' ? 'desc' : 'asc',
        };
      }
      // New column, start with ascending
      return {
        key,
        direction: 'asc',
      };
    });
  };

  return {
    sortedData,
    sortConfig,
    handleSort,
  };
}

```

## `src/hooks/useThresholdIndustryData.ts`

```typescript
import { useState, useEffect, useCallback, useContext } from 'react';
import { ThresholdIndustryData } from '../types/stock';
import { STATIC_THRESHOLD_INDUSTRY_DATA } from '../config/thresholdIndustryData';
import { ThresholdContext } from '../contexts/ThresholdContext';

/**
 * Hook to load threshold industry data from static file
 * 
 * Previously fetched from Google Sheets, now loads from static configuration file.
 * Manual changes to threshold values are persisted in Firestore and localStorage
 * via ThresholdContext.
 * 
 * Note: initializeFromData will only be called if ThresholdProvider is available.
 * If the hook is used outside ThresholdProvider, data will still load but won't
 * initialize the context (ThresholdIndustryTable will handle initialization when
 * rendered inside ThresholdProvider).
 * 
 * @returns Object with data, loading state, error, lastUpdated timestamp, and refetch function
 */
export function useThresholdIndustryData() {
  const [data, setData] = useState<ThresholdIndustryData[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
  
  // Safely get initializeFromData - will be undefined if ThresholdProvider is not available
  // Using useContext directly allows us to check if provider exists without throwing
  const thresholdContext = useContext(ThresholdContext);
  const initializeFromData = thresholdContext?.initializeFromData;

  // Load static data on mount
  useEffect(() => {
    try {
      // Load data from static file (synchronous)
      const staticData = STATIC_THRESHOLD_INDUSTRY_DATA;
      
      setData(staticData);
      setLastUpdated(new Date());
      setError(null);
      
      // Initialize ThresholdContext with static data if available
      if (initializeFromData) {
        initializeFromData(staticData);
      }
      
      // Set loading to false after a brief delay to maintain consistent loading behavior
      // This ensures components that check loading state see a consistent pattern
      setTimeout(() => {
        setLoading(false);
      }, 0);
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load threshold industry data';
      setError(errorMessage);
      setLoading(false);
    }
  }, [initializeFromData]);

  // Refetch function - reloads from static file (no network call)
  const refetch = useCallback((_forceRefresh?: boolean) => {
    setLoading(true);
    setError(null);
    
    try {
      const staticData = STATIC_THRESHOLD_INDUSTRY_DATA;
      setData(staticData);
      setLastUpdated(new Date());
      // Initialize ThresholdContext with static data if available
      if (initializeFromData) {
        initializeFromData(staticData);
      }
      
      setTimeout(() => {
        setLoading(false);
      }, 0);
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to reload threshold industry data';
      setError(errorMessage);
      setLoading(false);
    }
  }, [initializeFromData]);

  return {
    data,
    loading,
    error,
    lastUpdated,
    refetch,
  };
}

```

## `src/hooks/useUserRole.ts`

```typescript
import { useAuth } from '../contexts/AuthContext';
import { ViewId } from '../types/navigation';

/**
 * Custom hook for user role management and access control
 *
 * Provides convenient access to the current user's role and role-related
 * utilities. Two roles: viewer and admin. All users must be authenticated.
 *
 * **Roles:**
 * - viewer: Can view Score table and Personal Portfolio. May have additional allowedViews if granted by admin.
 * - admin: Full access to all tables and admin functions
 *
 * **Viewer Permissions:**
 * - Viewer without allowedViews: Score + Personal Portfolio only
 * - Viewer with allowedViews: Score + Personal Portfolio + views specified in allowedViews
 *
 * @returns Object with role information and permission flags
 * @returns userRole - Current user role ('viewer' | 'admin' | null)
 * @returns isAdmin - True if user is admin
 * @returns hasRole - True if user has any role (not null)
 * @returns getAllowedViews - Function that returns allowed views for viewer, or all views for admin
 * @returns canView - Function to check if user can view a specific view
 * @returns refreshUserRole - Function to refresh user role and permissions from server
 */
export function useUserRole() {
  const { userRole, viewerPermissions, refreshUserRole } = useAuth();

  const isAdmin = userRole === 'admin';
  const hasRole = userRole !== null;

  /**
   * Get all allowed views for the current user
   * - Admin: Returns null (has access to all views)
   * - Viewer with allowedViews: Score + allowedViews
   * - Viewer without allowedViews: ['score'] only
   */
  const getAllowedViews = (): string[] | null => {
    if (isAdmin) {
      return null; // Admin has access to all views
    }
    
    if (userRole === 'viewer' && viewerPermissions?.allowedViews) {
      // Viewer with permissions - always include 'score' even if not in allowedViews
      const views = new Set(['score', ...viewerPermissions.allowedViews]);
      return Array.from(views);
    }
    
    // Viewer without extra permissions - only Score
    return ['score'];
  };

  /**
   * Check if user can view a specific view
   */
  const canView = (viewId: ViewId): boolean => {
    // Admin view only for admin
    if (viewId === 'admin') {
      return isAdmin;
    }
    // Personal Portfolio is available to all authenticated users
    if (viewId === 'personal-portfolio') {
      return hasRole; // Any authenticated user (admin or viewer)
    }
    if (isAdmin) {
      return true; // Admin can view everything
    }
    
    const allowedViews = getAllowedViews();
    if (allowedViews === null) {
      return true; // Admin
    }
    
    return allowedViews.includes(viewId);
  };

  return {
    userRole,
    isAdmin,
    hasRole,
    getAllowedViews,
    canView,
    refreshUserRole,
  };
}

```

## `src/hooks/useVirtualScroll.ts`

```typescript
import { useState, useEffect, useRef, useMemo } from 'react';

interface UseVirtualScrollOptions {
  itemHeight: number;
  containerHeight: number;
  totalItems: number;
  overscan?: number;
}

/**
 * Custom hook for virtual scrolling optimization
 * 
 * Implements virtual scrolling to efficiently render large lists by only
 * rendering visible items plus an overscan buffer. This dramatically improves
 * performance for tables with hundreds or thousands of rows.
 * 
 * **Virtual Scrolling Algorithm:**
 * - Calculates which items are visible based on scroll position
 * - Only renders visible items + overscan buffer (default: 5 items above/below)
 * - Uses fixed item height for efficient calculations
 * - Provides offset for positioning rendered items
 * 
 * **Why overscan?**
 * - Prevents flickering when scrolling quickly
 * - Ensures smooth scrolling experience
 * - Default: 5 items above and below viewport
 * 
 * @param options - Virtual scroll options
 * @param options.itemHeight - Height of each item in pixels (must be fixed)
 * @param options.containerHeight - Height of scrollable container in pixels
 * @param options.totalItems - Total number of items in the list
 * @param options.overscan - Number of items to render outside viewport (default: 5)
 * @returns Object with container ref, virtual items info, and scroll position
 * 
 * @example
 * ```typescript
 * const { containerRef, virtualItems, scrollTop } = useVirtualScroll({
 *   itemHeight: 50,
 *   containerHeight: 600,
 *   totalItems: 1000,
 *   overscan: 5
 * });
 * 
 * // Render only visible items:
 * const visibleItems = data.slice(
 *   virtualItems.startIndex,
 *   virtualItems.endIndex
 * );
 * ```
 */
export function useVirtualScroll({
  itemHeight,
  containerHeight,
  totalItems,
  overscan = 5,
}: UseVirtualScrollOptions) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleScroll = () => {
      setScrollTop(container.scrollTop);
    };

    container.addEventListener('scroll', handleScroll, { passive: true });
    return () => container.removeEventListener('scroll', handleScroll);
  }, []);

  const virtualItems = useMemo(() => {
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / itemHeight) + overscan * 2,
      totalItems
    );
    const visibleStartIndex = Math.max(0, startIndex - overscan);

    return {
      startIndex: visibleStartIndex,
      endIndex,
      totalHeight: totalItems * itemHeight,
      offsetY: visibleStartIndex * itemHeight,
    };
  }, [scrollTop, itemHeight, containerHeight, totalItems, overscan]);

  return {
    containerRef,
    virtualItems,
    scrollTop,
  };
}


```

## `src/i18n/config.ts`

```typescript
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import enTranslations from '../locales/en/translation.json';
import svTranslations from '../locales/sv/translation.json';

// Load language from localStorage, default to 'en'
const savedLanguage = localStorage.getItem('stockScoreLanguage') || 'en';

i18n
  .use(initReactI18next)
  .init({
    resources: {
      en: {
        translation: enTranslations,
      },
      sv: {
        translation: svTranslations,
      },
    },
    lng: savedLanguage,
    fallbackLng: 'en',
    interpolation: {
      escapeValue: false, // React already escapes values
    },
  });

export default i18n;


```

## `src/index.css`

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

html {
  scroll-behavior: smooth;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f5f5f5;
  font-size: 16px;
  line-height: 1.5;
  color: #000000; /* Svart som standard färg */
}

/* Dark mode support */
.dark body {
  color: #ffffff; /* Vit i dark mode */
}

/* Typography Hierarchy */
h1 {
  font-size: 2.25rem; /* 36px */
  font-weight: 700;
  line-height: 1.2;
  letter-spacing: -0.025em;
  color: inherit;
}

h2 {
  font-size: 1.875rem; /* 30px */
  font-weight: 600;
  line-height: 1.3;
  letter-spacing: -0.025em;
  color: inherit;
}

h3 {
  font-size: 1.5rem; /* 24px */
  font-weight: 600;
  line-height: 1.4;
  color: inherit;
}

h4 {
  font-size: 1.25rem; /* 20px */
  font-weight: 600;
  line-height: 1.4;
  color: inherit;
}

h5 {
  font-size: 1.125rem; /* 18px */
  font-weight: 600;
  line-height: 1.5;
  color: inherit;
}

h6 {
  font-size: 1rem; /* 16px */
  font-weight: 600;
  line-height: 1.5;
  color: inherit;
}

/* Table typography */
table th {
  font-weight: 700;
  font-size: 0.75rem; /* 12px */
  letter-spacing: 0.05em;
  text-transform: uppercase;
}

table td {
  font-size: 0.875rem; /* 14px */
  font-weight: 400;
  line-height: 1.5;
}

/* Button typography */
button {
  font-weight: 500;
  letter-spacing: 0.01em;
}

/* Input typography */
input, select, textarea {
  font-size: 0.875rem; /* 14px */
  font-weight: 400;
  line-height: 1.5;
}

@keyframes shimmer {
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* Smooth transitions for common interactions - using Tailwind tokens */
.transition-smooth {
  transition: all theme('transitionDuration.normal') theme('transitionTimingFunction.ease-in-out');
}

.transition-fast {
  transition: all theme('transitionDuration.fast') theme('transitionTimingFunction.ease-in-out');
}

.transition-slow {
  transition: all theme('transitionDuration.slow') theme('transitionTimingFunction.ease-in-out');
}

/* Animation utilities */
.animate-fade-in {
  animation: fadeIn 0.3s ease-out;
}

.animate-fade-in-up {
  animation: fadeInUp 0.4s ease-out;
}

.animate-slide-in-right {
  animation: slideInRight 0.3s ease-out;
}

.animate-scale-in {
  animation: scaleIn 0.2s ease-out;
}

/* Touch-friendly button styles */
/* Minimum touch target size: 44x44px (Apple) or 48x48px (Material Design) */
@media (hover: none) and (pointer: coarse) {
  /* Touch device styles */
  button {
    min-height: 44px;
    min-width: 44px;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
    touch-action: manipulation;
  }

  /* Ensure interactive elements have adequate spacing */
  button + button {
    margin-left: 8px;
  }
}

/* Better touch feedback */
button {
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

/* Ensure buttons have adequate padding on mobile */
@media (max-width: 640px) {
  button:not(.min-touch-target) {
    padding: 10px 16px;
    min-height: 44px;
  }

  /* Smaller buttons should still be touch-friendly */
  button[class*="w-"], button[class*="h-"] {
    min-height: 44px;
    min-width: 44px;
  }

  /* Icon buttons */
  button[class*="p-2"] {
    padding: 12px;
    min-height: 44px;
    min-width: 44px;
  }

  button[class*="p-1"] {
    padding: 12px;
    min-height: 44px;
    min-width: 44px;
  }
}

/* Enhanced active state for touch devices */
@media (hover: none) and (pointer: coarse) {
  button:active {
    transform: scale(0.96);
    opacity: 0.8;
  }

  button:disabled:active {
    transform: none;
  }

  /* Touch-friendly clickable table headers */
  th[role="button"],
  th.cursor-pointer {
    min-height: 44px;
    touch-action: manipulation;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
  }

  th[role="button"]:active,
  th.cursor-pointer:active {
    opacity: 0.8;
    transform: scale(0.98);
  }
}

/* Print Styles */
@media print {
  @page {
    margin: 1cm;
    size: A4 landscape;
  }
  
  body {
    margin: 0;
    padding: 0;
    background: #fff !important;
    color: #000 !important;
  }
  
  /* Hide non-essential elements */
  button,
  .no-print,
  nav,
  header,
  aside,
  .sidebar,
  .header-actions,
  .pagination,
  .search-bar,
  .filters {
    display: none !important;
  }
  
  /* Table styles for print */
  table {
    width: 100% !important;
    border-collapse: collapse !important;
    page-break-inside: auto;
    font-size: 9pt;
  }
  
  thead {
    display: table-header-group;
  }
  
  tbody {
    display: table-row-group;
  }
  
  tr {
    page-break-inside: avoid;
    page-break-after: auto;
  }
  
  th, td {
    padding: 6px 8px !important;
    text-align: left;
    border: 1px solid #000 !important;
    font-size: 9pt !important;
    background: #fff !important;
    color: #000 !important;
  }
  
  th {
    background-color: #f5f5f5 !important;
    font-weight: bold !important;
    color: #000 !important;
  }
  
  /* Remove shadows and backgrounds */
  * {
    box-shadow: none !important;
    background-image: none !important;
  }
  
  /* Ensure full width tables */
  .table-container,
  table {
    min-width: 100% !important;
    max-width: 100% !important;
  }
  
  /* Print header */
  .print-header {
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 2px solid #000;
  }
  
  .print-header h1 {
    margin: 0 0 5px 0;
    font-size: 18pt;
    font-weight: bold;
  }
  
  .print-header .date {
    font-size: 10pt;
    color: #666;
  }
}


```

## `src/locales/en/translation.json`

```json
{
  "navigation": {
    "title": "Navigation",
    "scoreBoard": "SCORE BOARD",
    "score": "SCORE",
    "entryExit": "ENTRY/EXIT",
    "fundamental": "Fundamental",
    "teknikal": "Technical",
    "benjaminGraham": "ENTRY/EXIT",
    "entry1": "Manuell ENTRY/EXIT",
    "entry2": "Entry2",
    "exit1": "Exit1",
    "exit2": "Exit2",
    "irr1": "RR1",
    "ivFcf": "IV (FCF)",
    "peIndustry": "P/E INDUSTRY",
    "pe1Industry": "P/E1 INDUSTRY",
    "pe2Industry": "P/E2 INDUSTRY",
    "currentRatio": "Current Ratio",
    "cashSdebt": "Cash/SDebt",
    "ro40Cy": "Ro40 CY",
    "ro40F1": "Ro40 F1",
    "ro40F2": "Ro40 F2",
    "tachart": "TAChart",
    "sma100": "SMA",
    "sma200": "SMA(200)",
    "smaCross": "SMA Cross",
    "pe": "PE:",
    "sma": "SMA:",
    "conditions": "Conditions",
    "condition": "Condition",
    "thresholdIndustry": "Threshold INDUSTRY",
    "personalPortfolio": "Personal Portfolio",
    "userManagement": "User Management"
  },
  "admin": {
    "title": "User Management",
    "description": "Grant selected users access to additional tables. All users have SCORE and Personal Portfolio by default.",
    "users": "Users",
    "email": "Email",
    "role": "Role",
    "extraTables": "Extra tables",
    "save": "Save",
    "saved": "Saved.",
    "error": "Failed to save",
    "loading": "Loading users..."
  },
  "conditions": {
    "dataSource": "Data Source",
    "formula": "Formula",
    "conditions": "Conditions",
    "close": "Close"
  },
  "lastUpdated": {
    "lastUpdated": "Last updated",
    "never": "Never",
    "updating": "Updating...",
    "auto": "Auto"
  },
  "common": {
    "underConstruction": "This view is under construction",
    "viewId": "View ID:",
    "close": "Close",
    "loading": "Loading...",
    "cancel": "Cancel",
    "save": "Save",
    "checking": "Checking status...",
    "unauthorizedView": "You do not have access to this view",
    "pleaseLogin": "Please log in to view your personal portfolio"
  },
  "header": {
    "apiKeys": "API Keys"
  },
  "apiKeys": {
    "title": "API Keys",
    "description": "Only admin can see and change keys. Changes are saved and used for currency exchange rates.",
    "save": "Save",
    "saving": "Saving…",
    "saved": "API keys saved."
  },
  "refresh": {
    "refreshAll": "Refresh All",
    "refreshNow": "Refresh Now",
    "refreshing": "Refreshing...",
    "refreshAllTooltip": "Refresh all data from all sources",
    "autoRefresh": "Auto Refresh",
    "autoRefreshOff": "Off",
    "autoRefresh15Min": "Every 15 minutes",
    "autoRefresh30Min": "Every 30 minutes",
    "autoRefresh60Min": "Every 60 minutes",
    "autoRefreshActive": "Auto refresh active"
  },
  "globalSearch": {
    "placeholder": "Search all tables...",
    "noResults": "No results found"
  },
  "toast": {
    "close": "Close",
    "refreshSuccess": "All data has been updated",
    "refreshError": "Error updating data",
    "refreshCacheClearWarning": "Cache could not be cleared; you may need editor rights. Data will still refresh where possible.",
    "dataUpdated": "Data updated",
    "updateFailed": "Update failed"
  },
  "aria": {
    "table": "Table",
    "tableDescription": "Table with sortable columns",
    "sortColumn": "Sort column",
    "sortAscending": "Sorted ascending",
    "sortDescending": "Sorted descending",
    "sortNone": "Not sorted",
    "row": "Row",
    "cell": "Cell",
    "loading": "Loading",
    "error": "Error",
    "noData": "No data available",
    "searchTable": "Search table",
    "clearSearch": "Clear search",
    "columnVisibility": "Select columns to display",
    "showAllColumns": "Show all columns",
    "hideAllColumns": "Hide all columns",
    "resetColumns": "Reset columns",
    "toggleColumn": "Toggle column visibility",
    "requiredColumn": "Required column",
    "pagination": "Pagination",
    "firstPage": "First page",
    "previousPage": "Previous page",
    "nextPage": "Next page",
    "lastPage": "Last page",
    "page": "Page",
    "currentPage": "Current page",
    "of": "of",
    "results": "results",
    "showing": "Showing",
    "to": "to",
    "skipToContent": "Skip to main content",
    "skipToNavigation": "Skip to navigation",
    "mainContent": "Main content",
    "navigation": "Navigation",
    "breadcrumb": "Breadcrumb",
    "currentPageBreadcrumb": "Current page",
    "navigateTo": "Navigate to",
    "menu": "Menu",
    "closeMenu": "Close menu",
    "openMenu": "Open menu",
    "refreshData": "Refresh data",
    "refreshing": "Refreshing",
    "selectTheme": "Select theme",
    "selectLanguage": "Select language",
    "globalSearch": "Global search",
    "searchResults": "Search results",
    "noResults": "No results",
    "selectResult": "Select result",
    "valueGood": "Good value",
    "valueWarning": "Warning",
    "valueNeutral": "Neutral value",
    "valueBad": "Bad value",
    "refreshMenu": "Refresh menu",
    "refreshNowButton": "Refresh data now",
    "autoRefreshOff": "Turn off auto refresh",
    "autoRefresh30Min": "Set auto refresh to 30 minutes",
    "autoRefresh60Min": "Set auto refresh to 60 minutes",
    "themeMenu": "Theme menu",
    "lightTheme": "Switch to light theme",
    "darkTheme": "Switch to dark theme",
    "systemTheme": "Use system theme",
    "languageMenu": "Language menu",
    "englishLanguage": "Switch to English",
    "swedishLanguage": "Switch to Swedish",
    "logoutButton": "Logout",
    "userProfileButton": "Open user profile",
    "expandRow": "Expand row details",
    "collapseRow": "Collapse row details",
    "filterButton": "Open filters",
    "closeFilters": "Close filters",
    "applyFilters": "Apply filters",
    "clearFilters": "Clear all filters",
    "saveFilter": "Save current filter",
    "loadFilter": "Load saved filter",
    "deleteFilter": "Delete saved filter",
    "closeModal": "Close modal",
    "refreshButton": "Refresh data",
    "showColumnInfo": "Show column information",
    "expandSidebar": "Expand sidebar",
    "collapseSidebar": "Collapse sidebar"
  },
  "loading": {
    "loadingData": "Loading data...",
    "estimatedTime": "Estimated time",
    "complete": "Complete",
    "error": "Error"
  },
  "auth": {
    "login": "Login",
    "signup": "Sign up",
    "logout": "Logout",
    "email": "Email",
    "password": "Password",
    "confirmPassword": "Confirm Password",
    "emailPlaceholder": "your@email.com",
    "passwordPlaceholder": "Your password",
    "confirmPasswordPlaceholder": "Confirm your password",
    "loginSuccess": "Login successful",
    "loginFailed": "Login failed",
    "signupSuccess": "Account created.",
    "signupFailed": "Sign up failed",
    "logoutSuccess": "Logout successful",
    "logoutFailed": "Logout failed",
    "loggingIn": "Logging in...",
    "creatingAccount": "Creating account...",
    "passwordMismatch": "Passwords do not match",
    "passwordTooShort": "Password must be at least 6 characters",
    "passwordMinLength": "At least 6 characters",
    "noAccount": "Don't have an account? ",
    "alreadyHaveAccount": "Already have an account? ",
    "createAccount": "Create account",
    "forgotPassword": "Forgot password?",
    "enterEmailForReset": "Enter your email address to receive a password reset link in your inbox.",
    "sendResetEmail": "Send",
    "resetEmailSent": "Password reset email sent! Check your inbox.",
    "resetFailed": "Failed to send reset email",
    "emailRequired": "Email address required",
    "sending": "Sending...",
    "cancel": "Cancel"
  },
  "roles": {
    "viewer": "Viewer",
    "admin": "Administrator",
    "noRole": "No role assigned"
  },
  "profile": {
    "title": "My Profile",
    "currentRole": "Your Role",
    "deregister": "Deregister Account",
    "deregisterTitle": "Deregister Account",
    "deregisterWarning": "If you deregister your account, it will be permanently deleted. This action cannot be undone.",
    "confirmDeregister": "Confirm Deregistration",
    "confirmDeregisterMessage": "Are you sure you want to deregister your account? Your account and all data will be permanently deleted. This action cannot be undone.",
    "confirmDeregisterButton": "Yes, deregister",
    "deregisterSuccess": "Your account has been deleted",
    "deregisterError": "Could not delete account",
    "deregistering": "Deleting..."
  },
  "errorBoundary": {
    "configurationError": "Configuration Error",
    "unknownError": "An unknown error occurred",
    "reloadPage": "Reload Page",
    "firebaseError": {
      "howToFix": "How to fix:",
      "step1": "Go to Vercel Dashboard → Your Project → Settings → Environment Variables",
      "step2": "Add all 6 Firebase environment variables:",
      "step3": "Make sure to select all environments: Production, Preview, and Development",
      "step4": "After adding variables, click \"Redeploy\" on your latest deployment",
      "varApiKey": "VITE_FIREBASE_API_KEY",
      "varAuthDomain": "VITE_FIREBASE_AUTH_DOMAIN",
      "varProjectId": "VITE_FIREBASE_PROJECT_ID",
      "varStorageBucket": "VITE_FIREBASE_STORAGE_BUCKET",
      "varMessagingSenderId": "VITE_FIREBASE_MESSAGING_SENDER_ID",
      "varAppId": "VITE_FIREBASE_APP_ID"
    },
    "providerError": {
      "howToFix": "Provider Context Error - How to fix:",
      "description": "This error indicates that RefreshProvider is not properly wrapping AutoRefreshProvider.",
      "step1": "Check src/App.tsx",
      "step2": "Verify the provider order is:",
      "step3": "Ensure RefreshProvider is a direct parent of AutoRefreshProvider",
      "step4": "Check that RefreshProvider is not conditionally rendered"
    }
  },
  "offline": {
    "indicator": "Offline - Showing cached data"
  },
  "pullToRefresh": {
    "pull": "Pull to refresh",
    "release": "Release to refresh",
    "refreshing": "Refreshing..."
  },
  "notifications": {
    "title": "Notifications",
    "justNow": "Just now",
    "minutesAgo": "{{count}} min ago",
    "hoursAgo": "{{count}} h ago",
    "daysAgo": "{{count}} d ago",
    "enableDesktop": "Enable Desktop",
    "markAllRead": "Mark all read",
    "clearAll": "Clear all",
    "noNotifications": "No notifications",
    "noNotificationsDesc": "You're all caught up!",
    "remove": "Remove notification",
    "all": "All",
    "dataUpdates": "Data Updates",
    "errors": "Errors",
    "success": "Success"
  },
  "quickFilters": {
    "title": "Quick Filters",
    "highScore": "High Score (>80)",
    "mediumScore": "Medium Score (50-80)",
    "lowScore": "Low Score (<50)",
    "lowPE": "Low P/E (<10)",
    "mediumPE": "Medium P/E (10-20)",
    "highPE": "High P/E (>20)",
    "lowPrice": "Low Price (<50)"
  },
  "filters": {
    "templates": "Filter Templates",
    "saveFilter": "Save Filter",
    "save": "Save",
    "saveAsTemplate": "Save as Template",
    "loadTemplate": "Load Template",
    "filterSaved": "Filter saved!"
  },
  "shareableLinks": {
    "title": "Create Shareable Link",
    "linkName": "Link Name (optional)",
    "linkNamePlaceholder": "e.g., High Score Stocks",
    "description": "Description (optional)",
    "descriptionPlaceholder": "Add a description...",
    "expiresIn": "Expires In (days)",
    "create": "Create Link",
    "saving": "Saving...",
    "linkCreated": "Link created!",
    "copy": "Copy",
    "share": "Share",
    "myLinks": "My Shareable Links",
    "noLinks": "No shareable links yet",
    "invalidLink": "Invalid link",
    "linkNotFound": "Link not found or expired",
    "loadError": "Failed to load link",
    "error": "Error",
    "goHome": "Go to Home",
    "linkLoaded": "Shareable link loaded successfully",
    "confirmDelete": "Are you sure you want to delete this link?",
    "delete": "Delete"
  },
  "export": {
    "csv": "Export to CSV",
    "excel": "Export to Excel"
  },
  "print": {
    "print": "Print"
  },
  "profile": {
    "notificationPreferences": "Notification Preferences",
    "notificationsEnabled": "Enable Notifications",
    "notificationsEnabledDesc": "Enable all notifications",
    "desktopNotifications": "Desktop Notifications",
    "desktopNotificationsDesc": "Show browser notifications",
    "enableDesktop": "Enable",
    "dataUpdates": "Data Updates",
    "errors": "Errors",
    "success": "Success Messages",
    "warnings": "Warnings",
    "soundEnabled": "Sound Notifications",
    "doNotDisturb": "Do Not Disturb",
    "doNotDisturbDesc": "Silence notifications during specified hours",
    "preferencesSaveError": "Failed to save preferences"
  },
  "portfolio": {
    "description": "Manage your personal stock portfolio",
    "addItem": "Add stock",
    "ticker": "Ticker",
    "companyName": "Company name",
    "companyNamePlaceholder": "Apple Inc.",
    "add": "Add",
    "remove": "Remove",
    "actions": "Actions",
    "empty": "Your portfolio is empty",
    "emptyDescription": "Add stocks above to start building your portfolio",
    "searchPlaceholder": "Search by ticker or company name...",
    "searchResults": "Search results",
    "noResults": "No results found",
    "selectStock": "Selected stock",
    "quantity": "Quantity",
    "quantityPlaceholder": "Enter quantity",
    "quantityRequired": "Quantity required",
    "quantityInvalid": "Invalid quantity",
    "addToPortfolio": "Add to portfolio",
    "investedAmount": "Invested amount",
    "investedAmountPlaceholder": "E.g. 10000",
    "investmentCurrency": "Investment currency",
    "investedAmountHelp": "Total invested amount. If empty, current price is used.",
    "optional": "Optional",
    "edit": "Edit",
    "editInvestment": "Edit investment",
    "calculatedAverage": "Calculated average:",
    "exchangeRateUnavailable": "Exchange rate could not be fetched. Using current price.",
    "updateInvestment": "Update investment",
    "totalInvested": "Total Invested ($)",
    "totalMarketValue": "Market Value ($)",
    "showCurrencyAndPrice": "Show currency and current price",
    "hideCurrencyAndPrice": "Hide currency and current price",
    "broker": "Broker",
    "brokerOther": "Other",
    "brokerCustomPlaceholder": "Enter broker name",
    "brokerRequired": "Enter broker or select from list",
    "addPosition": "Add position",
    "removePosition": "Remove",
    "atLeastOnePosition": "At least one position is required",
    "columns": {
      "rowNumber": "Number",
      "quantity": "Quantity",
      "companyName": "Company name",
      "ticker": "Ticker",
      "currency": "Currency",
      "price": "Price",
      "currentPrice": "Current Price",
      "currentPriceUSD": "Current Price($)",
      "average": "Average",
      "invested": "Invested",
      "marketValue": "Market Value",
      "profitLoss": "P/L",
      "profitLossPercent": "P/L%",
      "marketWeight": "Market Weight"
    }
  }
}


```

## `src/locales/sv/translation.json`

```json
{
  "navigation": {
    "title": "Navigation",
    "scoreBoard": "SCORE BOARD",
    "score": "SCORE",
    "entryExit": "ENTRY/EXIT",
    "fundamental": "Fundamental",
    "teknikal": "Teknikal",
    "benjaminGraham": "ENTRY/EXIT",
    "entry1": "Manuell ENTRY/EXIT",
    "entry2": "Entry2",
    "exit1": "Exit1",
    "exit2": "Exit2",
    "irr1": "RR1",
    "ivFcf": "IV (FCF)",
    "peIndustry": "P/E INDUSTRY",
    "pe1Industry": "P/E1 INDUSTRY",
    "pe2Industry": "P/E2 INDUSTRY",
    "currentRatio": "Current Ratio",
    "cashSdebt": "Cash/SDebt",
    "ro40Cy": "Ro40 CY",
    "ro40F1": "Ro40 F1",
    "ro40F2": "Ro40 F2",
    "tachart": "TAChart",
    "sma100": "SMA",
    "sma200": "SMA(200)",
    "smaCross": "SMA Cross",
    "pe": "PE:",
    "sma": "SMA:",
    "conditions": "Villkor",
    "condition": "Villkor",
    "thresholdIndustry": "Threshold INDUSTRY",
    "personalPortfolio": "Personlig portfölj",
    "userManagement": "Användarhantering"
  },
  "admin": {
    "title": "Användarhantering",
    "description": "Ge utvalda användare tillgång till fler tabeller. Alla användare har SCORE och Personlig portfölj som standard.",
    "users": "Användare",
    "email": "E-post",
    "role": "Roll",
    "extraTables": "Extra tabeller",
    "save": "Spara",
    "saved": "Sparat.",
    "error": "Kunde inte spara",
    "loading": "Laddar användare..."
  },
  "conditions": {
    "dataSource": "Datakälla",
    "formula": "Formel",
    "conditions": "Villkor",
    "close": "Stäng"
  },
  "lastUpdated": {
    "lastUpdated": "Senast uppdaterad",
    "never": "Aldrig",
    "updating": "Uppdaterar...",
    "auto": "Auto"
  },
  "common": {
    "underConstruction": "Denna vy är under konstruktion",
    "viewId": "View ID:",
    "close": "Stäng",
    "loading": "Laddar...",
    "cancel": "Avbryt",
    "save": "Spara",
    "checking": "Kontrollerar status...",
    "unauthorizedView": "Du har inte tillgång till denna vy",
    "pleaseLogin": "Logga in för att visa din personliga portfölj"
  },
  "header": {
    "apiKeys": "API-nycklar"
  },
  "apiKeys": {
    "title": "API-nycklar",
    "description": "Endast admin kan se och ändra. Ändringar sparas och används för valutakurser.",
    "save": "Spara",
    "saving": "Sparar…",
    "saved": "API-nycklar sparade."
  },
  "refresh": {
    "refreshAll": "Uppdatera allt",
    "refreshNow": "Uppdatera nu",
    "refreshing": "Uppdaterar...",
    "refreshAllTooltip": "Uppdatera all data från alla källor",
    "autoRefresh": "Automatisk uppdatering",
    "autoRefreshOff": "Av",
    "autoRefresh15Min": "Var 15:e minut",
    "autoRefresh30Min": "Var 30:e minut",
    "autoRefresh60Min": "Var 60:e minut",
    "autoRefreshActive": "Automatisk uppdatering aktiv"
  },
  "globalSearch": {
    "placeholder": "Sök i alla tabeller...",
    "noResults": "Inga resultat hittades"
  },
  "toast": {
    "close": "Stäng",
    "refreshSuccess": "All data har uppdaterats",
    "refreshError": "Fel vid uppdatering av data",
    "refreshCacheClearWarning": "Cache kunde inte rensas; du kan behöva redaktörsrättigheter. Data uppdateras ändå där det går.",
    "dataUpdated": "Data uppdaterad",
    "updateFailed": "Uppdatering misslyckades"
  },
  "aria": {
    "table": "Tabell",
    "tableDescription": "Tabell med sorterbara kolumner",
    "sortColumn": "Sortera kolumn",
    "sortAscending": "Sorterad stigande",
    "sortDescending": "Sorterad fallande",
    "sortNone": "Ej sorterad",
    "row": "Rad",
    "cell": "Cell",
    "loading": "Laddar",
    "error": "Fel",
    "noData": "Ingen data tillgänglig",
    "searchTable": "Sök i tabell",
    "clearSearch": "Rensa sökning",
    "columnVisibility": "Välj kolumner att visa",
    "showAllColumns": "Visa alla kolumner",
    "hideAllColumns": "Dölj alla kolumner",
    "resetColumns": "Återställ kolumner",
    "toggleColumn": "Växla synlighet för kolumn",
    "requiredColumn": "Obligatorisk kolumn",
    "pagination": "Sidnavigering",
    "firstPage": "Första sidan",
    "previousPage": "Föregående sida",
    "nextPage": "Nästa sida",
    "lastPage": "Sista sidan",
    "page": "Sida",
    "currentPage": "Aktuell sida",
    "of": "av",
    "results": "resultat",
    "showing": "Visar",
    "to": "till",
    "skipToContent": "Hoppa till huvudinnehåll",
    "skipToNavigation": "Hoppa till navigation",
    "mainContent": "Huvudinnehåll",
    "navigation": "Navigation",
    "breadcrumb": "Brödsmulor",
    "currentPageBreadcrumb": "Nuvarande sida",
    "navigateTo": "Navigera till",
    "menu": "Meny",
    "closeMenu": "Stäng meny",
    "openMenu": "Öppna meny",
    "refreshData": "Uppdatera data",
    "refreshing": "Uppdaterar",
    "selectTheme": "Välj tema",
    "selectLanguage": "Välj språk",
    "globalSearch": "Global sökning",
    "searchResults": "Sökresultat",
    "noResults": "Inga resultat",
    "selectResult": "Välj resultat",
    "valueGood": "Bra värde",
    "valueWarning": "Varning",
    "valueNeutral": "Neutralt värde",
    "valueBad": "Dåligt värde",
    "refreshMenu": "Uppdateringsmeny",
    "refreshNowButton": "Uppdatera data nu",
    "autoRefreshOff": "Stäng av automatisk uppdatering",
    "autoRefresh30Min": "Sätt automatisk uppdatering till 30 minuter",
    "autoRefresh60Min": "Sätt automatisk uppdatering till 60 minuter",
    "themeMenu": "Temameny",
    "lightTheme": "Växla till ljust tema",
    "darkTheme": "Växla till mörkt tema",
    "systemTheme": "Använd systemtema",
    "languageMenu": "Språkmeny",
    "englishLanguage": "Växla till engelska",
    "swedishLanguage": "Växla till svenska",
    "logoutButton": "Logga ut",
    "userProfileButton": "Öppna användarprofil",
    "expandRow": "Expandera raddetaljer",
    "collapseRow": "Dölj raddetaljer",
    "filterButton": "Öppna filter",
    "closeFilters": "Stäng filter",
    "applyFilters": "Tillämpa filter",
    "clearFilters": "Rensa alla filter",
    "saveFilter": "Spara aktuellt filter",
    "loadFilter": "Ladda sparat filter",
    "deleteFilter": "Ta bort sparat filter",
    "closeModal": "Stäng modal",
    "refreshButton": "Uppdatera data",
    "showColumnInfo": "Visa kolumninformation",
    "expandSidebar": "Expandera sidebar",
    "collapseSidebar": "Minimera sidebar"
  },
  "loading": {
    "loadingData": "Laddar data...",
    "estimatedTime": "Uppskattad tid",
    "complete": "Klar",
    "error": "Fel"
  },
  "auth": {
    "login": "Logga in",
    "signup": "Skapa konto",
    "logout": "Logga ut",
    "email": "E-post",
    "password": "Lösenord",
    "confirmPassword": "Bekräfta lösenord",
    "emailPlaceholder": "din@epost.se",
    "passwordPlaceholder": "Ditt lösenord",
    "confirmPasswordPlaceholder": "Bekräfta ditt lösenord",
    "loginSuccess": "Inloggning lyckades",
    "loginFailed": "Inloggning misslyckades",
    "signupSuccess": "Kontot skapades.",
    "signupFailed": "Kontoskapande misslyckades",
    "logoutSuccess": "Utloggning lyckades",
    "logoutFailed": "Utloggning misslyckades",
    "loggingIn": "Loggar in...",
    "creatingAccount": "Skapar konto...",
    "passwordMismatch": "Lösenorden matchar inte",
    "passwordTooShort": "Lösenordet måste vara minst 6 tecken",
    "passwordMinLength": "Minst 6 tecken",
    "noAccount": "Har du inget konto? ",
    "alreadyHaveAccount": "Har redan konto? ",
    "createAccount": "Skapa konto",
    "forgotPassword": "Glömt lösenord?",
    "enterEmailForReset": "Ange din e-postadress för att få en återställningslänk skickad till din inkorg.",
    "sendResetEmail": "Skicka",
    "resetEmailSent": "Återställningslänk skickad! Kontrollera din inkorg.",
    "resetFailed": "Kunde inte skicka återställningslänk",
    "emailRequired": "E-postadress krävs",
    "sending": "Skickar...",
    "cancel": "Avbryt"
  },
  "roles": {
    "viewer": "Visare",
    "admin": "Administratör",
    "noRole": "Ingen roll tilldelad"
  },
  "profile": {
    "title": "Min profil",
    "currentRole": "Din roll",
    "deregister": "Avregistrera konto",
    "deregisterTitle": "Avregistrera konto",
    "deregisterWarning": "Om du avregistrerar ditt konto kommer det att tas bort permanent. Denna åtgärd kan inte ångras.",
    "confirmDeregister": "Bekräfta avregistrering",
    "confirmDeregisterMessage": "Är du säker på att du vill avregistrera ditt konto? Ditt konto och all data kommer att tas bort permanent. Denna åtgärd kan inte ångras.",
    "confirmDeregisterButton": "Ja, avregistrera",
    "deregisterSuccess": "Ditt konto har tagits bort",
    "deregisterError": "Kunde inte ta bort kontot",
    "deregistering": "Tar bort..."
  },
  "errorBoundary": {
    "configurationError": "Konfigurationsfel",
    "unknownError": "Ett okänt fel uppstod",
    "reloadPage": "Ladda om sidan",
    "firebaseError": {
      "howToFix": "Så här fixar du:",
      "step1": "Gå till Vercel Dashboard → Ditt Projekt → Inställningar → Miljövariabler",
      "step2": "Lägg till alla 6 Firebase-miljövariabler:",
      "step3": "Se till att välja alla miljöer: Production, Preview och Development",
      "step4": "Efter att ha lagt till variabler, klicka på \"Redeploy\" på din senaste deployment",
      "varApiKey": "VITE_FIREBASE_API_KEY",
      "varAuthDomain": "VITE_FIREBASE_AUTH_DOMAIN",
      "varProjectId": "VITE_FIREBASE_PROJECT_ID",
      "varStorageBucket": "VITE_FIREBASE_STORAGE_BUCKET",
      "varMessagingSenderId": "VITE_FIREBASE_MESSAGING_SENDER_ID",
      "varAppId": "VITE_FIREBASE_APP_ID"
    },
    "providerError": {
      "howToFix": "Provider-kontextfel - Så här fixar du:",
      "description": "Detta fel indikerar att RefreshProvider inte korrekt omsluter AutoRefreshProvider.",
      "step1": "Kontrollera src/App.tsx",
      "step2": "Verifiera att provider-ordningen är:",
      "step3": "Se till att RefreshProvider är direkt förälder till AutoRefreshProvider",
      "step4": "Kontrollera att RefreshProvider inte renderas villkorligt"
    }
  },
  "offline": {
    "indicator": "Offline - Visar cachad data"
  },
  "pullToRefresh": {
    "pull": "Dra för att uppdatera",
    "release": "Släpp för att uppdatera",
    "refreshing": "Uppdaterar..."
  },
  "notifications": {
    "title": "Notifikationer",
    "justNow": "Just nu",
    "minutesAgo": "{{count}} min sedan",
    "hoursAgo": "{{count}} tim sedan",
    "daysAgo": "{{count}} dagar sedan",
    "enableDesktop": "Aktivera desktop",
    "markAllRead": "Markera alla som lästa",
    "clearAll": "Rensa alla",
    "noNotifications": "Inga notifikationer",
    "noNotificationsDesc": "Du är alltid uppdaterad!",
    "remove": "Ta bort notifikation",
    "all": "Alla",
    "dataUpdates": "Datauppdateringar",
    "errors": "Fel",
    "success": "Framgång"
  },
  "quickFilters": {
    "title": "Snabbfilter",
    "highScore": "Hög score (>80)",
    "mediumScore": "Medel score (50-80)",
    "lowScore": "Låg score (<50)",
    "lowPE": "Låg P/E (<10)",
    "mediumPE": "Medel P/E (10-20)",
    "highPE": "Hög P/E (>20)",
    "lowPrice": "Lågt pris (<50)"
  },
  "filters": {
    "templates": "Filter Templates",
    "saveFilter": "Spara filter",
    "save": "Spara",
    "saveAsTemplate": "Spara som Template",
    "loadTemplate": "Ladda template",
    "filterSaved": "Filter sparades!"
  },
  "shareableLinks": {
    "title": "Skapa Delbar Länk",
    "linkName": "Länknamn (valfritt)",
    "linkNamePlaceholder": "t.ex. Hög Score Aktier",
    "description": "Beskrivning (valfritt)",
    "descriptionPlaceholder": "Lägg till en beskrivning...",
    "expiresIn": "Går ut om (dagar)",
    "create": "Skapa Länk",
    "saving": "Sparar...",
    "linkCreated": "Länk skapad!",
    "copy": "Kopiera",
    "share": "Dela",
    "myLinks": "Mina Delbara Länkar",
    "noLinks": "Inga delbara länkar ännu",
    "invalidLink": "Ogiltig länk",
    "linkNotFound": "Länk hittades inte eller har gått ut",
    "loadError": "Kunde inte ladda länk",
    "error": "Fel",
    "goHome": "Gå till Hem",
    "linkLoaded": "Delbar länk laddad",
    "confirmDelete": "Är du säker på att du vill ta bort denna länk?",
    "delete": "Ta bort"
  },
  "export": {
    "csv": "Exportera till CSV",
    "excel": "Exportera till Excel"
  },
  "print": {
    "print": "Skriv ut"
  },
  "profile": {
    "notificationPreferences": "Notifikationsinställningar",
    "notificationsEnabled": "Aktivera Notifikationer",
    "notificationsEnabledDesc": "Aktivera alla notifikationer",
    "desktopNotifications": "Desktop Notifikationer",
    "desktopNotificationsDesc": "Visa webbläsarnotifikationer",
    "enableDesktop": "Aktivera",
    "dataUpdates": "Datauppdateringar",
    "errors": "Fel",
    "success": "Framgångsmeddelanden",
    "warnings": "Varningar",
    "soundEnabled": "Ljudnotifikationer",
    "doNotDisturb": "Stör Ej",
    "doNotDisturbDesc": "Tysta notifikationer under angivna timmar",
    "preferencesSaveError": "Kunde inte spara inställningar"
  },
  "portfolio": {
    "description": "Hantera din personliga aktieportfölj",
    "addItem": "Lägg till aktie",
    "ticker": "Ticker",
    "companyName": "Företagsnamn",
    "companyNamePlaceholder": "Apple Inc.",
    "add": "Lägg till",
    "remove": "Ta bort",
    "actions": "Åtgärder",
    "empty": "Din portfölj är tom",
    "emptyDescription": "Lägg till aktier ovan för att börja bygga din portfölj",
    "searchPlaceholder": "Sök på ticker eller företagsnamn...",
    "searchResults": "Sökresultat",
    "noResults": "Inga resultat hittades",
    "selectStock": "Vald aktie",
    "quantity": "Antal",
    "quantityPlaceholder": "Ange antal",
    "quantityRequired": "Antal krävs",
    "quantityInvalid": "Ogiltigt antal",
    "addToPortfolio": "Lägg till i portfölj",
    "investedAmount": "Investerat belopp",
    "investedAmountPlaceholder": "T.ex. 10000",
    "investmentCurrency": "Valuta för investering",
    "investedAmountHelp": "Totalt investerat belopp. Om tomt används nuvarande pris.",
    "optional": "Valfritt",
    "edit": "Redigera",
    "editInvestment": "Redigera investering",
    "calculatedAverage": "Beräknat genomsnitt:",
    "exchangeRateUnavailable": "Valutakurs kunde inte hämtas. Använder nuvarande pris.",
    "updateInvestment": "Uppdatera investering",
    "totalInvested": "Totalt investerat ($)",
    "totalMarketValue": "Marknadsvärde ($)",
    "showCurrencyAndPrice": "Visa valuta och nuvarande pris",
    "hideCurrencyAndPrice": "Dölj valuta och nuvarande pris",
    "broker": "Broker",
    "brokerOther": "Annan",
    "brokerCustomPlaceholder": "Skriv brokernamn",
    "brokerRequired": "Ange broker eller välj från listan",
    "addPosition": "Lägg till position",
    "removePosition": "Ta bort",
    "atLeastOnePosition": "Minst en position krävs",
    "columns": {
      "rowNumber": "Antal",
      "quantity": "Antal",
      "companyName": "Företagsnamn",
      "ticker": "Ticker",
      "currency": "Valuta",
      "price": "Pris",
      "currentPrice": "Nuvarande Pris",
      "currentPriceUSD": "Nuvarande Pris($)",
      "average": "Genomsnitt",
      "invested": "Investerat",
      "marketValue": "Marknadsvärde",
      "profitLoss": "Vinst/Förlust",
      "profitLossPercent": "P/L%",
      "marketWeight": "Marknadsvikt"
    }
  }
}


```

## `src/main.tsx`

```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import App from './App.tsx'
import './index.css'
import './i18n/config'
import { ThemeProvider } from './contexts/ThemeContext'
import { AuthProvider } from './contexts/AuthContext'
import { ToastProvider } from './contexts/ToastContext'
import { NotificationProvider } from './contexts/NotificationContext'
import { ErrorBoundary } from './components/ErrorBoundary'
import { logger } from './utils/logger'
import { validateEnvironmentVariables } from './utils/envValidator'
import { registerServiceWorker } from './utils/serviceWorkerRegistration'
import { initializeBackgroundSync } from './services/backgroundSyncService'
import { runPreAuthMigrations } from './services/migrations'

/**
 * Filter out browser extension errors that don't affect the application
 * These errors come from content scripts injected by browser extensions
 * (password managers, form fillers, accessibility tools, etc.)
 */
function isBrowserExtensionError(error: ErrorEvent | PromiseRejectionEvent | Error): boolean {
  let errorMessage = '';
  let errorSource = '';
  let errorStack = '';
  
  if (error instanceof ErrorEvent) {
    errorMessage = error.message || '';
    errorSource = error.filename || '';
    errorStack = error.error?.stack || '';
  } else if (error instanceof PromiseRejectionEvent) {
    const reason = error.reason;
    if (reason instanceof Error) {
      errorMessage = reason.message || '';
      errorStack = reason.stack || '';
      // Also check if the error object itself has extension patterns
      const errorString = String(reason);
      if (errorString) {
        errorMessage += ' ' + errorString;
      }
    } else if (reason && typeof reason === 'object') {
      // Handle fetch errors or other error-like objects
      errorMessage = (reason as any).message || String(reason);
      errorStack = (reason as any).stack || '';
      // Check for network error codes
      if ((reason as any).code) {
        errorMessage += ' ' + String((reason as any).code);
      }
      if ((reason as any).name) {
        errorMessage += ' ' + String((reason as any).name);
      }
    } else {
      errorMessage = String(reason);
    }
  } else if (error instanceof Error) {
    errorMessage = error.message || '';
    errorStack = error.stack || '';
  } else {
    errorMessage = String(error);
  }
  
  // Combine all error information for pattern matching
  const combinedText = `${errorMessage} ${errorSource} ${errorStack}`.toLowerCase();
  
  // Common patterns for browser extension errors
  const extensionPatterns = [
    'content-script',
    'web-client-content-script',
    'chrome-extension',
    'moz-extension',
    'safari-extension',
    'edge-extension',
    'could not find identifiable element',
    'could not find',
    'identifiable element',
    'extension context invalidated',
    'message handler closed',
    'receiving end does not exist',
    'webclient',
    'web-client',
  ];
  
  // Vite HMR connection errors (when dev server isn't running or viewing built version)
  // Only suppress these in production mode or when they're clearly HMR-related
  const viteHmrPatterns = [
    'net::err_connection_refused',
    'err_connection_refused',
    'failed to fetch',
    'localhost:5173',
    'vite client',
    'waitforsuccessfulping',
    'ping @ client',
    '@ client:',
  ];
  
  const isExtensionError = extensionPatterns.some(pattern => combinedText.includes(pattern));
  
  // Check for Vite HMR errors - these occur when:
  // 1. Dev server is not running but HMR client code is still present
  // 2. Viewing a built/preview version with HMR client code
  const isViteHmrError = viteHmrPatterns.some(pattern => combinedText.includes(pattern)) &&
                         (combinedText.includes('client:') || combinedText.includes('vite'));
  
  return isExtensionError || isViteHmrError;
}

// Set up global error handlers to filter out browser extension errors
// IMPORTANT: Set these up as early as possible, before any other code runs
if (typeof window !== 'undefined') {
  // Handle unhandled promise rejections
  window.addEventListener('unhandledrejection', (event) => {
    if (isBrowserExtensionError(event)) {
      // Suppress browser extension errors
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    // Log legitimate errors
    logger.error(
      'Unhandled promise rejection',
      event.reason instanceof Error ? event.reason : new Error(String(event.reason)),
      { component: 'main', type: 'unhandledrejection' }
    );
  }, true); // Use capture phase to catch early

  // Handle general errors
  window.addEventListener('error', (event) => {
    if (isBrowserExtensionError(event)) {
      // Suppress browser extension errors
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    // Log legitimate errors (ErrorBoundary will also catch React errors)
    if (event.error) {
      logger.error(
        'Unhandled error',
        event.error,
        { 
          component: 'main', 
          type: 'error',
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno
        }
      );
    }
  }, true); // Use capture phase to catch early
}

// Validate environment variables before app initialization
try {
  const validationResult = validateEnvironmentVariables();
  if (!validationResult.isValid) {
    logger.error(
      'Environment validation failed',
      new Error(validationResult.errors.join('; ')),
      { component: 'main', validationResult }
    );
  }
} catch (error) {
  logger.error(
    'Critical environment validation error',
    error instanceof Error ? error : new Error(String(error)),
    { component: 'main' }
  );
  // Re-throw in production to prevent app from starting
  if (import.meta.env.PROD) {
    throw error;
  }
}

// Safely get root element
const rootElement = document.getElementById('root');

if (!rootElement) {
  logger.error(
    'Root element not found. Make sure index.html contains <div id="root"></div>',
    new Error('Root element missing'),
    { component: 'main', operation: 'initialize' }
  );
  throw new Error('Root element not found. Please check index.html');
}

// Run pre-auth migrations (localStorage) before app renders
runPreAuthMigrations();

// Register Service Worker and enable background sync (production only)
if (import.meta.env.PROD) {
  registerServiceWorker().catch((error) => {
    logger.warn('Service Worker registration failed', {
      component: 'main',
      error,
    });
  });
  initializeBackgroundSync();
}

ReactDOM.createRoot(rootElement).render(
  <React.StrictMode>
    <ErrorBoundary>
      <BrowserRouter>
        <ThemeProvider>
          <ToastProvider>
            <AuthProvider>
              <NotificationProvider>
                <App />
              </NotificationProvider>
            </AuthProvider>
          </ToastProvider>
        </ThemeProvider>
      </BrowserRouter>
    </ErrorBoundary>
  </React.StrictMode>,
)


```

## `src/services/__tests__/cacheService.test.ts`

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import {
  setCachedData,
  getCachedData,
  clearCache,
  isCacheValid,
  isCacheFresh,
  isCacheStale,
  setDeltaCacheEntry,
  getDeltaCacheEntry,
  getCacheStats,
  getCacheAge,
  getLastVersion,
  getCacheStatsForKey,
  getTotalCacheSize,
  clearExpiredCache,
  CACHE_KEYS,
  DEFAULT_TTL,
} from '../cacheService';

/**
 * cacheService is neutralized: no localStorage data cache.
 * All data cache is in Firestore (firestoreCacheService).
 * These tests verify no-op / empty behavior.
 */
describe('cacheService (neutralized — no localStorage data cache)', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  describe('getCachedData', () => {
    it('should always return null', () => {
      expect(getCachedData('any-key')).toBeNull();
      expect(getCachedData(CACHE_KEYS.SCORE_BOARD)).toBeNull();
      expect(getCachedData('')).toBeNull();
    });

    it('should not throw for null or undefined key', () => {
      expect(() => getCachedData(null as unknown as string)).not.toThrow();
      expect(() => getCachedData(undefined as unknown as string)).not.toThrow();
    });
  });

  describe('getDeltaCacheEntry', () => {
    it('should always return null', () => {
      expect(getDeltaCacheEntry('any-key')).toBeNull();
      expect(getDeltaCacheEntry(CACHE_KEYS.BENJAMIN_GRAHAM)).toBeNull();
    });
  });

  describe('getLastVersion', () => {
    it('should always return 0', () => {
      expect(getLastVersion('any-key')).toBe(0);
    });
  });

  describe('setCachedData / setDeltaCacheEntry', () => {
    it('should not throw when setting cache (no-op)', () => {
      expect(() => setCachedData('test-key', { test: 'data' })).not.toThrow();
      expect(() => setDeltaCacheEntry('test-key', [], 1, true)).not.toThrow();
    });

    it('should not persist data — getCachedData still returns null', () => {
      setCachedData('test-key', { test: 'data' });
      expect(getCachedData('test-key')).toBeNull();
      setDeltaCacheEntry('delta-key', [{}], 1, true);
      expect(getDeltaCacheEntry('delta-key')).toBeNull();
    });
  });

  describe('getCacheStats / getCacheStatsForKey / getTotalCacheSize', () => {
    it('getCacheStats should return empty structure', () => {
      const stats = getCacheStats();
      expect(stats).toEqual({ hits: {}, misses: {}, sizes: {}, lastAccessed: {} });
    });

    it('getCacheStatsForKey should return zeros and null', () => {
      const stats = getCacheStatsForKey('any-key');
      expect(stats.hits).toBe(0);
      expect(stats.misses).toBe(0);
      expect(stats.hitRate).toBe(0);
      expect(stats.size).toBe(0);
      expect(stats.lastAccessed).toBeNull();
    });

    it('getTotalCacheSize should return 0', () => {
      expect(getTotalCacheSize()).toBe(0);
    });
  });

  describe('getCacheAge', () => {
    it('should always return null', () => {
      expect(getCacheAge('any-key')).toBeNull();
    });
  });

  describe('isCacheValid / isCacheFresh / isCacheStale', () => {
    it('isCacheValid should always return false', () => {
      expect(isCacheValid('any-key')).toBe(false);
      expect(isCacheValid(CACHE_KEYS.PE_INDUSTRY)).toBe(false);
    });

    it('isCacheFresh should always return false', () => {
      expect(isCacheFresh('any-key')).toBe(false);
    });

    it('isCacheStale should return false when no cache (getCachedData returns null)', () => {
      expect(isCacheStale('any-key')).toBe(false);
    });
  });

  describe('clearCache / clearExpiredCache', () => {
    it('should not throw (no-op)', () => {
      expect(() => clearCache()).not.toThrow();
      expect(() => clearCache('some-key')).not.toThrow();
      expect(() => clearExpiredCache()).not.toThrow();
    });
  });

  describe('exports', () => {
    it('should export CACHE_KEYS and DEFAULT_TTL', () => {
      expect(CACHE_KEYS).toBeDefined();
      expect(CACHE_KEYS.SCORE_BOARD).toBe('cache:scoreBoard');
      expect(DEFAULT_TTL).toBeGreaterThan(0);
    });
  });
});

```

## `src/services/__tests__/cacheWarmingService.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { warmCache, isCacheWarmingEnabled } from '../cacheWarmingService';
import { getCachedData, getCacheAge, setCachedData, CACHE_KEYS } from '../firestoreCacheService';
import { 
  fetchScoreBoardData, 
  fetchPEIndustryData, 
  // Note: fetchThresholdIndustryData removed - threshold data is now static
  fetchBenjaminGrahamData 
} from '../sheets';

// Mock the sheets services
vi.mock('../sheets', () => ({
  fetchScoreBoardData: vi.fn(),
  fetchPEIndustryData: vi.fn(),
  // Note: fetchThresholdIndustryData removed - threshold data is now static
  fetchBenjaminGrahamData: vi.fn(),
}));

// Mock logger
vi.mock('../../utils/logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  },
}));

// Mock firestoreCacheService
vi.mock('../firestoreCacheService', async () => {
  const actual = await vi.importActual('../firestoreCacheService');
  return {
    ...actual,
    getCachedData: vi.fn(),
    getCacheAge: vi.fn(),
    setCachedData: vi.fn(),
  };
});

describe('cacheWarmingService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
    // Reset environment variable
    vi.stubEnv('VITE_CACHE_WARMING_ENABLED', 'true');
  });

  afterEach(() => {
    vi.unstubAllEnvs();
  });

  describe('isCacheWarmingEnabled', () => {
    it('should return true when VITE_CACHE_WARMING_ENABLED is not "false"', () => {
      vi.stubEnv('VITE_CACHE_WARMING_ENABLED', 'true');
      expect(isCacheWarmingEnabled()).toBe(true);
    });

    it('should return false when VITE_CACHE_WARMING_ENABLED is "false"', () => {
      vi.stubEnv('VITE_CACHE_WARMING_ENABLED', 'false');
      expect(isCacheWarmingEnabled()).toBe(false);
    });

    it('should return true when VITE_CACHE_WARMING_ENABLED is undefined', () => {
      vi.unstubEnv('VITE_CACHE_WARMING_ENABLED');
      expect(isCacheWarmingEnabled()).toBe(true);
    });
  });

  describe('warmCache', () => {
    it('should skip warming when disabled via env var', async () => {
      vi.stubEnv('VITE_CACHE_WARMING_ENABLED', 'false');
      
      await warmCache();
      
      expect(fetchScoreBoardData).not.toHaveBeenCalled();
      expect(fetchPEIndustryData).not.toHaveBeenCalled();
      // Note: fetchThresholdIndustryData removed - threshold data is now static
      expect(fetchBenjaminGrahamData).not.toHaveBeenCalled();
    });

    it('should warm cache when cache is empty', async () => {
      vi.useFakeTimers();
      
      // Mock no cache
      (getCachedData as any).mockResolvedValue(null);
      (getCacheAge as any).mockResolvedValue(null);
      
      const mockData = [{ companyName: 'Test', ticker: 'TEST' }];
      (fetchScoreBoardData as any).mockResolvedValue(mockData);
      (fetchPEIndustryData as any).mockResolvedValue(mockData);
      // Note: fetchThresholdIndustryData removed - threshold data is now static
      (fetchBenjaminGrahamData as any).mockResolvedValue(mockData);

      const warmPromise = warmCache();
      
      // Fast-forward past the delay
      await vi.advanceTimersByTimeAsync(2000);
      await warmPromise;

      expect(fetchScoreBoardData).toHaveBeenCalledWith(false);
      expect(fetchPEIndustryData).toHaveBeenCalledWith(false);
      // Note: fetchThresholdIndustryData removed - threshold data is now static
      expect(fetchBenjaminGrahamData).toHaveBeenCalledWith(false);

      vi.useRealTimers();
    });

    it('should skip warming when cache is fresh (< 15 minutes)', async () => {
      vi.useFakeTimers();
      
      // Set fresh cache data (mocked)
      const mockData = [{ companyName: 'Test', ticker: 'TEST' }];
      (getCachedData as any).mockResolvedValue(mockData);
      (getCacheAge as any).mockResolvedValue(5 * 60 * 1000); // 5 minutes old

      const warmPromise = warmCache();
      await vi.advanceTimersByTimeAsync(2000);
      await warmPromise;

      // Should not fetch since cache is fresh
      expect(fetchScoreBoardData).not.toHaveBeenCalled();
      expect(fetchPEIndustryData).not.toHaveBeenCalled();
      // Note: fetchThresholdIndustryData removed - threshold data is now static
      expect(fetchBenjaminGrahamData).not.toHaveBeenCalled();

      vi.useRealTimers();
    });

    it('should warm cache when cache is stale (> 15 minutes)', async () => {
      vi.useFakeTimers();
      
      // Set stale cache data (mocked)
      const mockData = [{ companyName: 'Test', ticker: 'TEST' }];
      (getCachedData as any).mockResolvedValue(mockData);
      (getCacheAge as any).mockResolvedValue(20 * 60 * 1000); // 20 minutes old (stale)

      (fetchScoreBoardData as any).mockResolvedValue(mockData);
      (fetchPEIndustryData as any).mockResolvedValue(mockData);
      // Note: fetchThresholdIndustryData removed - threshold data is now static
      (fetchBenjaminGrahamData as any).mockResolvedValue(mockData);

      const warmPromise = warmCache();
      await vi.advanceTimersByTimeAsync(2000);
      await warmPromise;

      // Should fetch since cache is stale
      expect(fetchScoreBoardData).toHaveBeenCalledWith(false);
      expect(fetchPEIndustryData).toHaveBeenCalledWith(false);
      // Note: fetchThresholdIndustryData removed - threshold data is now static
      expect(fetchBenjaminGrahamData).toHaveBeenCalledWith(false);

      vi.useRealTimers();
    });

    it('should handle fetch failures gracefully', async () => {
      vi.useFakeTimers();
      
      (getCachedData as any).mockResolvedValue(null); // No cache
      (getCacheAge as any).mockResolvedValue(null);
      
      (fetchScoreBoardData as any).mockRejectedValue(new Error('Network error'));
      (fetchPEIndustryData as any).mockResolvedValue([]);
      // Note: fetchThresholdIndustryData removed - threshold data is now static
      (fetchBenjaminGrahamData as any).mockResolvedValue([]);

      const warmPromise = warmCache();
      await vi.advanceTimersByTimeAsync(2000);
      
      // Should not throw, even if one fetch fails
      await expect(warmPromise).resolves.not.toThrow();

      // Other fetches should still be called
      expect(fetchPEIndustryData).toHaveBeenCalled();
      // Note: fetchThresholdIndustryData removed - threshold data is now static
      expect(fetchBenjaminGrahamData).toHaveBeenCalled();

      vi.useRealTimers();
    });

    it('should warm all data types in parallel', async () => {
      vi.useFakeTimers();
      
      // Mock no cache
      (getCachedData as any).mockResolvedValue(null);
      (getCacheAge as any).mockResolvedValue(null);
      
      const mockData = [{ companyName: 'Test', ticker: 'TEST' }];
      (fetchScoreBoardData as any).mockResolvedValue(mockData);
      (fetchPEIndustryData as any).mockResolvedValue(mockData);
      // Note: fetchThresholdIndustryData removed - threshold data is now static
      (fetchBenjaminGrahamData as any).mockResolvedValue(mockData);

      const warmPromise = warmCache();
      await vi.advanceTimersByTimeAsync(2000);
      await warmPromise;

      // All should be called
      expect(fetchScoreBoardData).toHaveBeenCalled();
      expect(fetchPEIndustryData).toHaveBeenCalled();
      // Note: fetchThresholdIndustryData removed - threshold data is now static
      expect(fetchBenjaminGrahamData).toHaveBeenCalled();

      vi.useRealTimers();
    });

    it('should wait 2 seconds before warming', async () => {
      vi.useFakeTimers();
      
      // Mock no cache
      (getCachedData as any).mockResolvedValue(null);
      (getCacheAge as any).mockResolvedValue(null);
      
      const mockData = [{ companyName: 'Test', ticker: 'TEST' }];
      (fetchScoreBoardData as any).mockResolvedValue(mockData);

      const warmPromise = warmCache();
      
      // Before delay
      expect(fetchScoreBoardData).not.toHaveBeenCalled();
      
      // After delay
      await vi.advanceTimersByTimeAsync(2000);
      await warmPromise;
      
      expect(fetchScoreBoardData).toHaveBeenCalled();

      vi.useRealTimers();
    });
  });
});

```

## `src/services/__tests__/deltaSyncService.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import {
  initSync,
  pollChanges,
  loadSnapshot,
  applyChangesToCache,
  isDeltaSyncEnabled,
  getPollIntervalMs,
} from '../deltaSyncService';
import type { DeltaSyncConfig, SnapshotResponse, ChangesResponse } from '../deltaSyncService';

describe('deltaSyncService Error Handling', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    global.fetch = vi.fn();
    localStorage.clear();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('initSync error cases', () => {
    it('should handle network errors', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      global.fetch = vi.fn().mockRejectedValue(new Error('Network error'));

      const transformer = vi.fn((results) => results.data);

      await expect(
        initSync(config, 'test-key', transformer)
      ).rejects.toThrow();
    });

    it('should handle 404 errors', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: false,
        status: 404,
        statusText: 'Not Found',
        json: vi.fn().mockResolvedValue({ ok: false, error: 'Not found' }),
      } as unknown as Response);

      const transformer = vi.fn((results) => results.data);

      await expect(
        initSync(config, 'test-key', transformer)
      ).rejects.toThrow();
    });

    it('should handle invalid JSON response', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: vi.fn().mockRejectedValue(new Error('Invalid JSON')),
      } as unknown as Response);

      const transformer = vi.fn((results) => results.data);

      await expect(
        initSync(config, 'test-key', transformer)
      ).rejects.toThrow();
    });

    it('should handle snapshot with error flag', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      const errorResponse: SnapshotResponse = {
        ok: false,
        version: 0,
        headers: [],
        rows: [],
        generatedAt: new Date().toISOString(),
        error: 'Sheet not found',
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: vi.fn().mockResolvedValue(errorResponse),
      } as unknown as Response);

      const transformer = vi.fn((results) => results.data);

      await expect(
        initSync(config, 'test-key', transformer)
      ).rejects.toThrow(/error|Sheet not found/);
    });
  });

  describe('pollChanges error cases', () => {
    it('should handle AbortError (timeout)', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      const abortError = new Error('AbortError');
      abortError.name = 'AbortError';
      global.fetch = vi.fn().mockRejectedValue(abortError);

      await expect(
        pollChanges(config, 1)
      ).rejects.toThrow();
    });

    it('should handle HTTP 5xx errors with retry', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
      } as Response);

      // Should retry and eventually fail
      await expect(
        pollChanges(config, 1)
      ).rejects.toThrow();
    });

    it('should handle changes response with error flag', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      const errorResponse: ChangesResponse = {
        ok: false,
        fromVersion: 1,
        toVersion: 1,
        changes: [],
        error: 'Invalid version',
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: vi.fn().mockResolvedValue(errorResponse),
      } as unknown as Response);

      await expect(
        pollChanges(config, 1)
      ).rejects.toThrow(/error|Invalid version/);
    });

    it('should handle needsFullResync flag', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      const resyncResponse: ChangesResponse = {
        ok: true,
        fromVersion: 1,
        toVersion: 5,
        changes: [],
        needsFullResync: true,
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: vi.fn().mockResolvedValue(resyncResponse),
      } as unknown as Response);

      const result = await pollChanges(config, 1);
      expect(result.needsFullResync).toBe(true);
    });
  });

  describe('loadSnapshot token handling', () => {
    it('should NOT put token in URL when token is set (use POST with token in body)', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
        token: 'secret-token',
      };

      const snapshot: SnapshotResponse = {
        ok: true,
        version: 1,
        headers: ['col1', 'col2'],
        rows: [],
        generatedAt: new Date().toISOString(),
      };

      const fetchSpy = vi.fn().mockResolvedValue({
        ok: true,
        json: vi.fn().mockResolvedValue(snapshot),
      } as unknown as Response);
      global.fetch = fetchSpy;

      await loadSnapshot(config);

      expect(fetchSpy).toHaveBeenCalled();
      const [url, init] = fetchSpy.mock.calls[0] as [string, RequestInit];
      expect(url).not.toContain('token=');
      expect(url).toBe('https://script.google.com/macros/s/test/exec');
      expect(init?.method).toBe('POST');
      const body = JSON.parse((init?.body as string) || '{}');
      expect(body.token).toBe('secret-token');
      expect(body.action).toBe('snapshot');
      expect(body.sheet).toBe('TestSheet');
    });

    it('should use GET without token in URL when no token', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      const snapshot: SnapshotResponse = {
        ok: true,
        version: 1,
        headers: ['col1', 'col2'],
        rows: [],
        generatedAt: new Date().toISOString(),
      };

      const fetchSpy = vi.fn().mockResolvedValue({
        ok: true,
        json: vi.fn().mockResolvedValue(snapshot),
      } as unknown as Response);
      global.fetch = fetchSpy;

      await loadSnapshot(config);

      const [url, init] = fetchSpy.mock.calls[0] as [string, RequestInit];
      expect(url).not.toContain('token=');
      expect(init?.method).toBe('GET');
    });
  });

  describe('loadSnapshot error cases', () => {
    it('should handle network errors', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      global.fetch = vi.fn().mockRejectedValue(new TypeError('Network error'));

      await expect(
        loadSnapshot(config)
      ).rejects.toThrow();
    });

    it('should handle invalid snapshot structure', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: vi.fn().mockResolvedValue({
          // Missing required fields
          ok: true,
        }),
      } as unknown as Response);

      await expect(
        loadSnapshot(config)
      ).rejects.toThrow();
    });
  });

  describe('applyChangesToCache error cases', () => {
    it('should handle invalid changes array', async () => {
      const changes: ChangesResponse = {
        ok: true,
        fromVersion: 1,
        toVersion: 2,
        changes: null as unknown as [],
      };

      await expect(applyChangesToCache(changes, 'test-key')).resolves.toBeDefined();
    });

    it('should handle changes with invalid row data', async () => {
      const changes: ChangesResponse = {
        ok: true,
        fromVersion: 1,
        toVersion: 2,
        changes: [
          {
            id: 1,
            tsISO: new Date().toISOString(),
            key: 'test-key',
            rowIndex: 0,
            changedColumns: ['col1'],
            values: null as unknown as [],
          },
        ],
      };

      await expect(applyChangesToCache(changes, 'test-key')).resolves.toBeDefined();
    });
  });

  describe('Edge cases', () => {
    it('should handle empty sheet name', async () => {
      const config: DeltaSyncConfig = {
        sheetName: '',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      const transformer = vi.fn((results) => results.data);

      await expect(
        initSync(config, 'test-key', transformer)
      ).rejects.toThrow();
    });

    it('should handle invalid API base URL', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'invalid-url',
      };

      const transformer = vi.fn((results) => results.data);

      await expect(
        initSync(config, 'test-key', transformer)
      ).rejects.toThrow();
    });

    it('should handle version 0', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      const snapshot: SnapshotResponse = {
        ok: true,
        version: 0,
        headers: ['col1', 'col2'],
        rows: [],
        generatedAt: new Date().toISOString(),
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: vi.fn().mockResolvedValue(snapshot),
      } as unknown as Response);

      const transformer = vi.fn((results) => results.data);

      const result = await initSync(config, 'test-key', transformer);
      expect(result.version).toBe(0);
    });

    it('should handle negative version numbers', async () => {
      const config: DeltaSyncConfig = {
        sheetName: 'TestSheet',
        apiBaseUrl: 'https://script.google.com/macros/s/test/exec',
      };

      const snapshot: SnapshotResponse = {
        ok: true,
        version: -1,
        headers: ['col1'],
        rows: [],
        generatedAt: new Date().toISOString(),
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: vi.fn().mockResolvedValue(snapshot),
      } as unknown as Response);

      const transformer = vi.fn((results) => results.data);

      const result = await initSync(config, 'test-key', transformer);
      expect(result.version).toBe(-1);
    });
  });
});

```

## `src/services/__tests__/fetchService.test.ts`

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { fetchJSONData, fetchCSVData, convert2DArrayToObjects, validateCSVText } from '../sheets/fetchService';

// Mock environment variables
const originalEnv = import.meta.env;

describe('fetchService Error Handling', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Reset fetch mock
    global.fetch = vi.fn();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('fetchJSONData error cases', () => {
    it('should handle CORS errors', async () => {
      const mockTransformer = vi.fn((results) => results.data);
      
      global.fetch = vi.fn().mockRejectedValue(
        new TypeError('Failed to fetch')
      );

      await expect(
        fetchJSONData(
          'TestSheet',
          'Test Data',
          mockTransformer,
          undefined,
          undefined,
          true
        )
      ).rejects.toThrow(/CORS|Connection error/);
    });

    it('should handle 404 errors', async () => {
      const mockTransformer = vi.fn((results) => results.data);
      
      global.fetch = vi.fn().mockResolvedValue({
        ok: false,
        status: 404,
        statusText: 'Not Found',
      } as Response);

      await expect(
        fetchJSONData(
          'TestSheet',
          'Test Data',
          mockTransformer,
          undefined,
          undefined,
          true
        )
      ).rejects.toThrow(/404|not found/);
    });

    it('should handle 401/403 errors', async () => {
      const mockTransformer = vi.fn((results) => results.data);
      
      global.fetch = vi.fn().mockResolvedValue({
        ok: false,
        status: 403,
        statusText: 'Forbidden',
      } as Response);

      await expect(
        fetchJSONData(
          'TestSheet',
          'Test Data',
          mockTransformer,
          undefined,
          undefined,
          true
        )
      ).rejects.toThrow(/403|access denied/);
    });

    it('should handle invalid JSON response', async () => {
      const mockTransformer = vi.fn((results) => results.data);
      
      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: vi.fn().mockRejectedValue(new Error('Invalid JSON')),
      } as unknown as Response);

      await expect(
        fetchJSONData(
          'TestSheet',
          'Test Data',
          mockTransformer,
          undefined,
          undefined,
          true
        )
      ).rejects.toThrow(/parse JSON|Invalid JSON/);
    });

    it('should handle empty array response', async () => {
      const mockTransformer = vi.fn((results) => results.data);
      
      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: vi.fn().mockResolvedValue([]),
      } as unknown as Response);

      await expect(
        fetchJSONData(
          'TestSheet',
          'Test Data',
          mockTransformer,
          undefined,
          undefined,
          true
        )
      ).rejects.toThrow(/Invalid JSON response|expected non-empty array/);
    });

    it('should handle network timeout', async () => {
      const mockTransformer = vi.fn((results) => results.data);
      
      global.fetch = vi.fn().mockImplementation(() => {
        return new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Request timeout')), 100);
        });
      });

      await expect(
        fetchJSONData(
          'TestSheet',
          'Test Data',
          mockTransformer,
          undefined,
          undefined,
          true
        )
      ).rejects.toThrow();
    });
  });

  describe('fetchCSVData error cases', () => {
    it('should handle all proxy failures', async () => {
      const mockTransformer = vi.fn((results) => results.data);
      
      global.fetch = vi.fn().mockRejectedValue(new Error('Network error'));

      await expect(
        fetchCSVData(
          'https://example.com/sheet.csv',
          'Test Data',
          mockTransformer,
          undefined,
          undefined,
          true
        )
      ).rejects.toThrow(/Failed to fetch.*all proxies/);
    });

    it('should handle timeout errors', async () => {
      const mockTransformer = vi.fn((results) => results.data);
      
      const controller = new AbortController();
      controller.abort();
      
      global.fetch = vi.fn().mockRejectedValue(
        new Error('AbortError')
      );

      await expect(
        fetchCSVData(
          'https://example.com/sheet.csv',
          'Test Data',
          mockTransformer,
          undefined,
          undefined,
          true
        )
      ).rejects.toThrow();
    });

    it('should handle HTML response instead of CSV', async () => {
      const mockTransformer = vi.fn((results) => results.data);
      
      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        text: vi.fn().mockResolvedValue('<!DOCTYPE html><html>...</html>'),
      } as unknown as Response);

      await expect(
        fetchCSVData(
          'https://example.com/sheet.csv',
          'Test Data',
          mockTransformer,
          undefined,
          undefined,
          true
        )
      ).rejects.toThrow(/HTML login page|not publicly accessible/);
    });

    it('should handle empty CSV response', async () => {
      const mockTransformer = vi.fn((results) => results.data);
      
      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        text: vi.fn().mockResolvedValue(''),
      } as unknown as Response);

      await expect(
        fetchCSVData(
          'https://example.com/sheet.csv',
          'Test Data',
          mockTransformer,
          undefined,
          undefined,
          true
        )
      ).rejects.toThrow(/Empty response/);
    });
  });

  describe('convert2DArrayToObjects edge cases', () => {
    it('should handle empty array', () => {
      const result = convert2DArrayToObjects([]);
      expect(result).toEqual([]);
    });

    it('should handle array with only headers', () => {
      const result = convert2DArrayToObjects([['Header1', 'Header2']]);
      expect(result).toEqual([]);
    });

    it('should handle null/undefined values', () => {
      const result = convert2DArrayToObjects([
        ['Header1', 'Header2'],
        [null, undefined],
        ['Value1', 'Value2'],
      ]);
      expect(result).toEqual([
        { Header1: '', Header2: '' },
        { Header1: 'Value1', Header2: 'Value2' },
      ]);
    });
  });

  describe('validateCSVText edge cases', () => {
    it('should throw on empty string', () => {
      expect(() => validateCSVText('')).toThrow(/Empty response/);
    });

    it('should throw on HTML content', () => {
      expect(() => validateCSVText('<!DOCTYPE html><html></html>')).toThrow(/HTML/);
    });

    it('should throw on Google sign-in page', () => {
      expect(() => validateCSVText('Sign in to your Google Account')).toThrow(/HTML login page/);
    });

    it('should throw on invalid CSV format', () => {
      const longInvalidText = 'a'.repeat(200);
      expect(() => validateCSVText(longInvalidText)).toThrow(/valid CSV/);
    });
  });
});

```

## `src/services/__tests__/filterStorageService.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  saveFilter,
  loadFilter,
  getSavedFilters,
  deleteFilter,
  clearAllFilters,
  SavedFilter,
} from '../filterStorageService';
import { FilterValues } from '../../components/AdvancedFilters';

// Mock logger
vi.mock('../../utils/logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  },
}));

describe('filterStorageService', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  describe('saveFilter', () => {
    it('should save a filter successfully', () => {
      const tableId = 'testTable';
      const filterName = 'High Score Stocks';
      const filterValues: FilterValues = {
        score: { min: 80, max: 100 },
        companyName: 'Test',
      };

      expect(() => saveFilter(tableId, filterName, filterValues)).not.toThrow();

      const saved = loadFilter(tableId, filterName);
      expect(saved).toEqual(filterValues);
    });

    it('should throw error if tableId is missing', () => {
      const filterValues: FilterValues = { score: { min: 80 } };

      expect(() => saveFilter('', 'Test Filter', filterValues)).toThrow('Table ID and filter name are required');
    });

    it('should throw error if filter name is missing', () => {
      const filterValues: FilterValues = { score: { min: 80 } };

      expect(() => saveFilter('testTable', '', filterValues)).toThrow('Table ID and filter name are required');
    });

    it('should throw error if filter name is only whitespace', () => {
      const filterValues: FilterValues = { score: { min: 80 } };

      expect(() => saveFilter('testTable', '   ', filterValues)).toThrow('Table ID and filter name are required');
    });

    it('should trim filter name whitespace', () => {
      const tableId = 'testTable';
      const filterName = '  High Score Stocks  ';
      const filterValues: FilterValues = { score: { min: 80 } };

      saveFilter(tableId, filterName, filterValues);

      const saved = loadFilter(tableId, 'High Score Stocks');
      expect(saved).toEqual(filterValues);
    });

    it('should update existing filter with same name', () => {
      const tableId = 'testTable';
      const filterName = 'High Score Stocks';
      const filterValues1: FilterValues = { score: { min: 80 } };
      const filterValues2: FilterValues = { score: { min: 90 } };

      saveFilter(tableId, filterName, filterValues1);
      saveFilter(tableId, filterName, filterValues2);

      const saved = loadFilter(tableId, filterName);
      expect(saved).toEqual(filterValues2);
    });

    it('should handle localStorage quota exceeded error', () => {
      const originalSetItem = localStorage.setItem;
      localStorage.setItem = vi.fn(() => {
        const error = new DOMException('QuotaExceededError');
        error.name = 'QuotaExceededError';
        throw error;
      });

      const filterValues: FilterValues = { score: { min: 80 } };

      expect(() => saveFilter('testTable', 'Test Filter', filterValues)).toThrow('LocalStorage quota exceeded');

      localStorage.setItem = originalSetItem;
    });

    it('should handle special characters in filter name', () => {
      const tableId = 'testTable';
      const filterName = 'Filter & Co. <Special>';
      const filterValues: FilterValues = { score: { min: 80 } };

      saveFilter(tableId, filterName, filterValues);

      const saved = loadFilter(tableId, filterName);
      expect(saved).toEqual(filterValues);
    });
  });

  describe('loadFilter', () => {
    it('should load a saved filter', () => {
      const tableId = 'testTable';
      const filterName = 'High Score Stocks';
      const filterValues: FilterValues = {
        score: { min: 80, max: 100 },
        companyName: 'Test',
      };

      saveFilter(tableId, filterName, filterValues);
      const loaded = loadFilter(tableId, filterName);

      expect(loaded).toEqual(filterValues);
    });

    it('should return null if filter does not exist', () => {
      const loaded = loadFilter('testTable', 'NonExistent');
      expect(loaded).toBeNull();
    });

    it('should return null if tableId is missing', () => {
      const loaded = loadFilter('', 'Test Filter');
      expect(loaded).toBeNull();
    });

    it('should return null if filter name is missing', () => {
      const loaded = loadFilter('testTable', '');
      expect(loaded).toBeNull();
    });

    it('should return null if filter belongs to different table', () => {
      const tableId1 = 'table1';
      const tableId2 = 'table2';
      const filterName = 'Test Filter';
      const filterValues: FilterValues = { score: { min: 80 } };

      saveFilter(tableId1, filterName, filterValues);
      const loaded = loadFilter(tableId2, filterName);

      expect(loaded).toBeNull();
    });

    it('should handle corrupted localStorage data gracefully', () => {
      const tableId = 'testTable';
      const filterName = 'Test Filter';
      
      // Manually set corrupted data
      localStorage.setItem(`filters:${tableId}:${filterName}`, 'invalid json');

      const loaded = loadFilter(tableId, filterName);
      expect(loaded).toBeNull();
    });
  });

  describe('getSavedFilters', () => {
    it('should return all saved filters for a table', () => {
      const tableId = 'testTable';
      const filter1: FilterValues = { score: { min: 80 } };
      const filter2: FilterValues = { score: { min: 90 } };

      saveFilter(tableId, 'Filter 1', filter1);
      // Wait a bit to ensure different timestamps
      vi.useFakeTimers();
      vi.advanceTimersByTime(100);
      saveFilter(tableId, 'Filter 2', filter2);
      vi.useRealTimers();

      const filters = getSavedFilters(tableId);

      expect(filters).toHaveLength(2);
      expect(filters.map(f => f.name)).toContain('Filter 1');
      expect(filters.map(f => f.name)).toContain('Filter 2');
    });

    it('should return empty array if no filters exist', () => {
      const filters = getSavedFilters('testTable');
      expect(filters).toEqual([]);
    });

    it('should return empty array if tableId is missing', () => {
      const filters = getSavedFilters('');
      expect(filters).toEqual([]);
    });

    it('should sort filters by creation date (newest first)', () => {
      const tableId = 'testTable';
      
      vi.useFakeTimers();
      saveFilter(tableId, 'Filter 1', { score: { min: 80 } });
      vi.advanceTimersByTime(100);
      saveFilter(tableId, 'Filter 2', { score: { min: 90 } });
      vi.advanceTimersByTime(100);
      saveFilter(tableId, 'Filter 3', { score: { min: 100 } });
      vi.useRealTimers();

      const filters = getSavedFilters(tableId);

      expect(filters).toHaveLength(3);
      expect(filters[0].name).toBe('Filter 3');
      expect(filters[1].name).toBe('Filter 2');
      expect(filters[2].name).toBe('Filter 1');
    });

    it('should only return filters for specified table', () => {
      const tableId1 = 'table1';
      const tableId2 = 'table2';

      saveFilter(tableId1, 'Filter 1', { score: { min: 80 } });
      saveFilter(tableId2, 'Filter 2', { score: { min: 90 } });

      const filters1 = getSavedFilters(tableId1);
      const filters2 = getSavedFilters(tableId2);

      expect(filters1).toHaveLength(1);
      expect(filters1[0].name).toBe('Filter 1');
      expect(filters2).toHaveLength(1);
      expect(filters2[0].name).toBe('Filter 2');
    });

    it('should handle corrupted filter entries gracefully', () => {
      const tableId = 'testTable';
      
      // Save a valid filter
      saveFilter(tableId, 'Valid Filter', { score: { min: 80 } });
      
      // Manually add corrupted entry to the list
      const listKey = `filters:${tableId}:list`;
      localStorage.setItem(listKey, JSON.stringify(['Valid Filter', 'Corrupted Filter']));
      localStorage.setItem(`filters:${tableId}:Corrupted Filter`, 'invalid json');

      const filters = getSavedFilters(tableId);

      // Should only return valid filter and remove corrupted one
      expect(filters).toHaveLength(1);
      expect(filters[0].name).toBe('Valid Filter');
    });
  });

  describe('deleteFilter', () => {
    it('should delete a saved filter', () => {
      const tableId = 'testTable';
      const filterName = 'Test Filter';
      const filterValues: FilterValues = { score: { min: 80 } };

      saveFilter(tableId, filterName, filterValues);
      expect(loadFilter(tableId, filterName)).toEqual(filterValues);

      deleteFilter(tableId, filterName);

      expect(loadFilter(tableId, filterName)).toBeNull();
    });

    it('should not throw if filter does not exist', () => {
      expect(() => deleteFilter('testTable', 'NonExistent')).not.toThrow();
    });

    it('should not throw if tableId is missing', () => {
      expect(() => deleteFilter('', 'Test Filter')).not.toThrow();
    });

    it('should not throw if filter name is missing', () => {
      expect(() => deleteFilter('testTable', '')).not.toThrow();
    });

    it('should remove filter from list when deleted', () => {
      const tableId = 'testTable';

      saveFilter(tableId, 'Filter 1', { score: { min: 80 } });
      saveFilter(tableId, 'Filter 2', { score: { min: 90 } });

      expect(getSavedFilters(tableId)).toHaveLength(2);

      deleteFilter(tableId, 'Filter 1');

      const filters = getSavedFilters(tableId);
      expect(filters).toHaveLength(1);
      expect(filters[0].name).toBe('Filter 2');
    });

    it('should remove list key when last filter is deleted', () => {
      const tableId = 'testTable';
      const filterName = 'Test Filter';

      saveFilter(tableId, filterName, { score: { min: 80 } });
      expect(localStorage.getItem(`filters:${tableId}:list`)).toBeTruthy();

      deleteFilter(tableId, filterName);
      expect(localStorage.getItem(`filters:${tableId}:list`)).toBeNull();
    });
  });

  describe('clearAllFilters', () => {
    it('should clear all filters for a table', () => {
      const tableId = 'testTable';

      saveFilter(tableId, 'Filter 1', { score: { min: 80 } });
      saveFilter(tableId, 'Filter 2', { score: { min: 90 } });

      expect(getSavedFilters(tableId)).toHaveLength(2);

      clearAllFilters(tableId);

      expect(getSavedFilters(tableId)).toHaveLength(0);
      expect(loadFilter(tableId, 'Filter 1')).toBeNull();
      expect(loadFilter(tableId, 'Filter 2')).toBeNull();
    });

    it('should not affect filters from other tables', () => {
      const tableId1 = 'table1';
      const tableId2 = 'table2';

      saveFilter(tableId1, 'Filter 1', { score: { min: 80 } });
      saveFilter(tableId2, 'Filter 2', { score: { min: 90 } });

      clearAllFilters(tableId1);

      expect(getSavedFilters(tableId1)).toHaveLength(0);
      expect(getSavedFilters(tableId2)).toHaveLength(1);
    });

    it('should not throw if tableId is missing', () => {
      expect(() => clearAllFilters('')).not.toThrow();
    });

    it('should not throw if no filters exist', () => {
      expect(() => clearAllFilters('testTable')).not.toThrow();
    });
  });

  describe('edge cases', () => {
    it('should handle multiple filters per table', () => {
      const tableId = 'testTable';
      const filters = [
        { name: 'Filter 1', values: { score: { min: 80 } } },
        { name: 'Filter 2', values: { score: { min: 90 } } },
        { name: 'Filter 3', values: { companyName: 'Test' } },
      ];

      filters.forEach(({ name, values }) => {
        saveFilter(tableId, name, values);
      });

      const saved = getSavedFilters(tableId);
      expect(saved).toHaveLength(3);
    });

    it('should handle complex filter values', () => {
      const tableId = 'testTable';
      const filterName = 'Complex Filter';
      const filterValues: FilterValues = {
        score: { min: 80, max: 100 },
        companyName: 'Test Company',
        industry: 'Technology',
        irr: { min: 20 },
        mungerQualityScore: { max: 75 },
      };

      saveFilter(tableId, filterName, filterValues);
      const loaded = loadFilter(tableId, filterName);

      expect(loaded).toEqual(filterValues);
    });
  });
});

```

## `src/services/__tests__/firestoreCacheService.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { shouldBlockAppCacheWriteInCutover, CACHE_KEYS } from '../firestoreCacheService';

describe('firestoreCacheService - cutover guard', () => {
  describe('shouldBlockAppCacheWriteInCutover', () => {
    it('returns true for view-doc keys in cutover mode', () => {
      expect(shouldBlockAppCacheWriteInCutover(CACHE_KEYS.SCORE_BOARD, 'cutover')).toBe(true);
      expect(shouldBlockAppCacheWriteInCutover(CACHE_KEYS.BENJAMIN_GRAHAM, 'cutover')).toBe(true);
      expect(shouldBlockAppCacheWriteInCutover(CACHE_KEYS.PE_INDUSTRY, 'cutover')).toBe(true);
      expect(shouldBlockAppCacheWriteInCutover(CACHE_KEYS.SMA, 'cutover')).toBe(true);
    });

    it('returns false for currency_rates_usd in cutover mode', () => {
      expect(shouldBlockAppCacheWriteInCutover(CACHE_KEYS.CURRENCY_RATES_USD, 'cutover')).toBe(false);
    });

    it('returns false for view-doc keys in dual-read or dual-write mode', () => {
      expect(shouldBlockAppCacheWriteInCutover(CACHE_KEYS.SCORE_BOARD, 'dual-read')).toBe(false);
      expect(shouldBlockAppCacheWriteInCutover(CACHE_KEYS.SCORE_BOARD, 'dual-write')).toBe(false);
    });
  });
});

```

## `src/services/__tests__/sharedThresholdService.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  loadSharedThresholdValues,
  saveSharedThresholdValues,
  loadFromLocalStorage,
  saveToLocalStorage,
} from '../sharedThresholdService';
import { User } from 'firebase/auth';

const mockSetDoc = vi.fn();
const mockGetDoc = vi.fn();
const mockServerTimestamp = vi.fn(() => ({ _methodName: 'serverTimestamp' }));

vi.mock('firebase/firestore', () => ({
  doc: vi.fn((_db: unknown, col: string, id: string) => ({ _path: { segments: [col, id] } })),
  setDoc: vi.fn((...args: unknown[]) => mockSetDoc(...args)),
  getDoc: vi.fn((...args: unknown[]) => mockGetDoc(...args)),
  serverTimestamp: vi.fn(() => mockServerTimestamp()),
}));

vi.mock('../../config/firebase', () => ({
  db: {},
}));

vi.mock('../../utils/logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  },
}));

describe('sharedThresholdService', () => {
  const mockUser: User = {
    uid: 'test-admin-id',
    email: 'admin@example.com',
  } as User;

  const testValues = {
    Technology: {
      irr: 15,
      leverageF2Min: 0.5,
      leverageF2Max: 2.0,
      ro40Min: 10,
      ro40Max: 20,
      cashSdebtMin: 0.5,
      cashSdebtMax: 1.5,
      currentRatioMin: 1.0,
      currentRatioMax: 2.0,
    },
  };

  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
  });

  describe('saveSharedThresholdValues', () => {
    it('throws when userRole is not admin', async () => {
      await expect(
        saveSharedThresholdValues(testValues, { user: mockUser, userRole: 'viewer' })
      ).rejects.toThrow('sharedThreshold.saveDenied');

      await expect(
        saveSharedThresholdValues(testValues, { user: mockUser, userRole: null })
      ).rejects.toThrow('sharedThreshold.saveDenied');

      expect(mockSetDoc).not.toHaveBeenCalled();
    });

    it('throws when user is null', async () => {
      await expect(
        saveSharedThresholdValues(testValues, { user: null, userRole: 'admin' })
      ).rejects.toThrow('sharedThreshold.saveDenied');

      expect(mockSetDoc).not.toHaveBeenCalled();
    });

    it('writes to Firestore when userRole is admin', async () => {
      mockSetDoc.mockResolvedValue(undefined);

      await saveSharedThresholdValues(testValues, { user: mockUser, userRole: 'admin' });

      expect(mockSetDoc).toHaveBeenCalledWith(
        expect.any(Object),
        {
          values: testValues,
          updatedAt: expect.any(Object),
          updatedBy: mockUser.uid,
        },
        { merge: true }
      );
    });

    it('saves to localStorage after successful Firestore write', async () => {
      mockSetDoc.mockResolvedValue(undefined);

      await saveSharedThresholdValues(testValues, { user: mockUser, userRole: 'admin' });

      const stored = localStorage.getItem('sharedThresholdValues');
      expect(stored).toBeTruthy();
      expect(JSON.parse(stored!)).toEqual(testValues);
    });
  });

  describe('loadSharedThresholdValues', () => {
    it('returns data from Firestore when user is authenticated', async () => {
      mockGetDoc.mockResolvedValue({
        exists: () => true,
        data: () => ({ values: testValues }),
      });

      const result = await loadSharedThresholdValues(mockUser);

      expect(result).toEqual(testValues);
      expect(mockGetDoc).toHaveBeenCalled();
    });

    it('returns localStorage data when user is null', async () => {
      localStorage.setItem('sharedThresholdValues', JSON.stringify(testValues));

      const result = await loadSharedThresholdValues(null);

      expect(result).toEqual(testValues);
      expect(mockGetDoc).not.toHaveBeenCalled();
    });

    it('returns null when no data exists', async () => {
      mockGetDoc.mockResolvedValue({
        exists: () => false,
        data: () => null,
      });

      const result = await loadSharedThresholdValues(mockUser);

      expect(result).toBeNull();
    });

    it('falls back to localStorage when Firestore fails', async () => {
      mockGetDoc.mockRejectedValue(new Error('Firestore error'));
      localStorage.setItem('sharedThresholdValues', JSON.stringify(testValues));

      const result = await loadSharedThresholdValues(mockUser);

      expect(result).toEqual(testValues);
    });
  });

  describe('loadFromLocalStorage', () => {
    it('migrates from legacy thresholdValues key', () => {
      localStorage.setItem('thresholdValues', JSON.stringify(testValues));

      const result = loadFromLocalStorage();

      expect(result).toEqual(testValues);
      expect(localStorage.getItem('sharedThresholdValues')).toBeTruthy();
    });

    it('returns null when no data exists', () => {
      expect(loadFromLocalStorage()).toBeNull();
    });
  });

  describe('saveToLocalStorage', () => {
    it('saves values to localStorage', () => {
      saveToLocalStorage(testValues);

      const stored = localStorage.getItem('sharedThresholdValues');
      expect(JSON.parse(stored!)).toEqual(testValues);
    });
  });
});

```

## `src/services/__tests__/userDataService.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  saveEntryExitValues,
  loadEntryExitValues,
  saveCurrencyValues,
  loadCurrencyValues,
} from '../userDataService';
import { User } from 'firebase/auth';
import { doc, setDoc, getDoc, serverTimestamp } from 'firebase/firestore';

// Mock Firebase
const mockSetDoc = vi.fn();
const mockGetDoc = vi.fn();
const mockServerTimestamp = vi.fn(() => ({ _methodName: 'serverTimestamp' }));

vi.mock('firebase/firestore', () => ({
  doc: vi.fn((db, collection, id) => ({ _path: { segments: [collection, id] } })),
  setDoc: vi.fn((...args) => mockSetDoc(...args)),
  getDoc: vi.fn((...args) => mockGetDoc(...args)),
  serverTimestamp: vi.fn(() => mockServerTimestamp()),
}));

vi.mock('../../config/firebase', () => ({
  db: {},
}));

// Mock logger
vi.mock('../../utils/logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  },
}));

describe('userDataService', () => {
  const mockUser: User = {
    uid: 'test-user-id',
    email: 'test@example.com',
  } as User;

  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
  });

  describe('saveEntryExitValues', () => {
    const testValues = {
      'AAPL': {
        entry1: 150,
        entry2: 155,
        exit1: 160,
        exit2: 165,
        currency: 'USD',
        dateOfUpdate: '2024-01-01',
      },
      'MSFT': {
        entry1: 300,
        entry2: 305,
        exit1: 320,
        exit2: 325,
        currency: 'USD',
        dateOfUpdate: '2024-01-02',
      },
    };

    it('should save to Firestore when user is authenticated', async () => {
      mockSetDoc.mockResolvedValue(undefined);

      await saveEntryExitValues(mockUser, testValues);

      expect(mockSetDoc).toHaveBeenCalledWith(
        expect.any(Object),
        {
          values: testValues,
          updatedAt: expect.any(Object),
        },
        { merge: true }
      );
    });

    it('should save to localStorage as backup when using Firestore', async () => {
      mockSetDoc.mockResolvedValue(undefined);

      await saveEntryExitValues(mockUser, testValues);

      const stored = localStorage.getItem('entryExitValues');
      expect(stored).toBeTruthy();
      expect(JSON.parse(stored!)).toEqual(testValues);
    });

    it('should fallback to localStorage when user is not authenticated', async () => {
      await saveEntryExitValues(null, testValues);

      expect(mockSetDoc).not.toHaveBeenCalled();
      const stored = localStorage.getItem('entryExitValues');
      expect(JSON.parse(stored!)).toEqual(testValues);
    });

    it('should fallback to localStorage when Firestore save fails', async () => {
      mockSetDoc.mockRejectedValue(new Error('Firestore error'));

      await saveEntryExitValues(mockUser, testValues);

      const stored = localStorage.getItem('entryExitValues');
      expect(JSON.parse(stored!)).toEqual(testValues);
    });

    it('should handle localStorage quota exceeded error', async () => {
      const originalSetItem = localStorage.setItem;
      localStorage.setItem = vi.fn(() => {
        const error = new DOMException('QuotaExceededError');
        error.name = 'QuotaExceededError';
        throw error;
      });

      mockSetDoc.mockResolvedValue(undefined);

      // Should not throw, but log error
      await expect(saveEntryExitValues(mockUser, testValues)).resolves.not.toThrow();

      localStorage.setItem = originalSetItem;
    });
  });

  describe('loadEntryExitValues', () => {
    it('should load from Firestore when user is authenticated', async () => {
      const testValues = {
        'AAPL': {
          entry1: 150,
          entry2: 155,
          exit1: 160,
          exit2: 165,
          currency: 'USD',
          dateOfUpdate: '2024-01-01',
        },
      };

      mockGetDoc.mockResolvedValue({
        exists: () => true,
        data: () => ({ values: testValues }),
      });

      const result = await loadEntryExitValues(mockUser);

      expect(result).toEqual(testValues);
      expect(mockGetDoc).toHaveBeenCalled();
    });

    it('should fallback to localStorage when user is not authenticated', async () => {
      const testValues = {
        'AAPL': {
          entry1: 150,
          entry2: 155,
          exit1: 160,
          exit2: 165,
          currency: 'USD',
          dateOfUpdate: '2024-01-01',
        },
      };

      localStorage.setItem('entryExitValues', JSON.stringify(testValues));

      const result = await loadEntryExitValues(null);

      expect(result).toEqual(testValues);
      expect(mockGetDoc).not.toHaveBeenCalled();
    });

    it('should fallback to localStorage when Firestore load fails', async () => {
      const testValues = {
        'AAPL': {
          entry1: 150,
          entry2: 155,
          exit1: 160,
          exit2: 165,
          currency: 'USD',
          dateOfUpdate: '2024-01-01',
        },
      };

      mockGetDoc.mockRejectedValue(new Error('Firestore error'));
      localStorage.setItem('entryExitValues', JSON.stringify(testValues));

      const result = await loadEntryExitValues(mockUser);

      expect(result).toEqual(testValues);
    });

    it('should return null when no data exists', async () => {
      mockGetDoc.mockResolvedValue({
        exists: () => false,
        data: () => null,
      });

      const result = await loadEntryExitValues(mockUser);

      expect(result).toBeNull();
    });

    it('should ensure all values have currency field', async () => {
      const testValues = {
        'AAPL': {
          entry1: 150,
          entry2: 155,
          exit1: 160,
          exit2: 165,
          currency: 'USD',
          dateOfUpdate: '2024-01-01',
        },
        'MSFT': {
          entry1: 300,
          entry2: 305,
          exit1: 320,
          exit2: 325,
          dateOfUpdate: '2024-01-02',
        } as any,
      };

      mockGetDoc.mockResolvedValue({
        exists: () => true,
        data: () => ({ values: testValues }),
      });

      const result = await loadEntryExitValues(mockUser);

      expect(result!['AAPL'].currency).toBe('USD');
      expect(result!['MSFT'].currency).toBe('USD');
    });

    it('should migrate currency from old collection', async () => {
      const entryExitValues = {
        'AAPL': {
          entry1: 150,
          entry2: 155,
          exit1: 160,
          exit2: 165,
          currency: 'USD',
          dateOfUpdate: '2024-01-01',
        },
      };

      const currencyValues = {
        'MSFT': 'EUR',
      };

      mockGetDoc
        .mockResolvedValueOnce({
          exists: () => true,
          data: () => ({ values: entryExitValues }),
        })
        .mockResolvedValueOnce({
          exists: () => true,
          data: () => ({ values: currencyValues }),
        });

      const result = await loadEntryExitValues(mockUser);

      expect(result!['AAPL'].currency).toBe('USD');
      expect(result!['MSFT']).toBeDefined();
      expect(result!['MSFT'].currency).toBe('EUR');
    });
  });

  describe('saveCurrencyValues', () => {
    const testValues = {
      'AAPL': 'USD',
      'VOLV-B': 'SEK',
    };

    it('should save to Firestore when user is authenticated', async () => {
      mockSetDoc.mockResolvedValue(undefined);

      await saveCurrencyValues(mockUser, testValues);

      expect(mockSetDoc).toHaveBeenCalledWith(
        expect.any(Object),
        {
          values: testValues,
          updatedAt: expect.any(Object),
        },
        { merge: true }
      );
    });

    it('should fallback to localStorage when user is not authenticated', async () => {
      await saveCurrencyValues(null, testValues);

      expect(mockSetDoc).not.toHaveBeenCalled();
      const stored = localStorage.getItem('tachart-currency-map');
      expect(JSON.parse(stored!)).toEqual(testValues);
    });

    it('should fallback to localStorage when Firestore save fails', async () => {
      mockSetDoc.mockRejectedValue(new Error('Firestore error'));

      await saveCurrencyValues(mockUser, testValues);

      const stored = localStorage.getItem('tachart-currency-map');
      expect(JSON.parse(stored!)).toEqual(testValues);
    });
  });

  describe('loadCurrencyValues', () => {
    it('should load from Firestore when user is authenticated', async () => {
      const testValues = {
        'AAPL': 'USD',
        'VOLV-B': 'SEK',
      };

      mockGetDoc.mockResolvedValue({
        exists: () => true,
        data: () => ({ values: testValues }),
      });

      const result = await loadCurrencyValues(mockUser);

      expect(result).toEqual(testValues);
    });

    it('should fallback to localStorage when user is not authenticated', async () => {
      const testValues = {
        'AAPL': 'USD',
      };

      localStorage.setItem('tachart-currency-map', JSON.stringify(testValues));

      const result = await loadCurrencyValues(null);

      expect(result).toEqual(testValues);
    });

    it('should return null when no data exists', async () => {
      mockGetDoc.mockResolvedValue({
        exists: () => false,
        data: () => null,
      });

      const result = await loadCurrencyValues(mockUser);

      expect(result).toBeNull();
    });
  });

});

```

## `src/services/appConfigService.ts`

```typescript
import { doc, getDoc, setDoc } from 'firebase/firestore';
import { db } from '../config/firebase';
import type { ApiKeys } from '../config/apiKeys';

const APP_CONFIG_API_KEYS_PATH = 'appConfig/apiKeys';

/**
 * Get API keys from Firestore (admin-only document).
 * Returns null if document does not exist or on error.
 */
export async function getApiKeysFromFirestore(): Promise<ApiKeys | null> {
  try {
    const ref = doc(db, 'appConfig', 'apiKeys');
    const snapshot = await getDoc(ref);
    if (!snapshot.exists()) return null;
    const data = snapshot.data();
    return {
      eodhd: typeof data.eodhd === 'string' ? data.eodhd : undefined,
      marketstack: typeof data.marketstack === 'string' ? data.marketstack : undefined,
      finnhub: typeof data.finnhub === 'string' ? data.finnhub : undefined,
      alphaVantage: typeof data.alphaVantage === 'string' ? data.alphaVantage : undefined,
    };
  } catch {
    return null;
  }
}

/**
 * Save API keys to Firestore (admin-only).
 * Call only from admin UI.
 */
export async function setApiKeysInFirestore(keys: ApiKeys): Promise<void> {
  const ref = doc(db, 'appConfig', 'apiKeys');
  await setDoc(ref, {
    eodhd: keys.eodhd ?? '',
    marketstack: keys.marketstack ?? '',
    finnhub: keys.finnhub ?? '',
    alphaVantage: keys.alphaVantage ?? '',
  });
}

```

## `src/services/backgroundSyncService.ts`

```typescript
/**
 * Background Sync Service
 *
 * Coordinates background data synchronization when the user is inactive.
 * Works with Service Worker to sync data in the background without blocking the UI.
 */

import { logger } from '../utils/logger';
import { requestBackgroundSync } from '../utils/serviceWorkerRegistration';
import { isDeltaSyncEnabled } from './deltaSyncService';
import { snapshotToTransformerFormat } from './deltaSyncService';
import type { SnapshotResponse } from './deltaSyncService';
import { CACHE_KEYS } from './cacheKeys';
import { getCachedData, setDeltaCacheEntry, VIEWDATA_MIGRATION_MODE } from './firestoreCacheService';
import { transformBenjaminGrahamData } from './sheets/benjaminGrahamService';
import { transformPEIndustryData } from './sheets/peIndustryService';
import { transformSMAData } from './sheets/smaService';
import { createScoreBoardTransformer } from './sheets/scoreBoardService';
import type { PEIndustryData } from '../types/stock';
import type { SMAData } from '../types/stock';

const APPS_SCRIPT_URL = import.meta.env.VITE_APPS_SCRIPT_URL || '';
const APPS_SCRIPT_TOKEN = import.meta.env.VITE_APPS_SCRIPT_TOKEN || '';

// Sync coordination flag (stored in sessionStorage to coordinate between main app and SW)
const SYNC_COORDINATION_KEY = 'bg:sync:coordinating';
const SYNC_COORDINATION_TIMEOUT = 5 * 60 * 1000; // 5 minutes

// Unique sheets to sync (one fetch per sheet). Each sheet maps to one or more cache keys.
const SHEETS_TO_SYNC: { sheetName: string; cacheKeys: string[] }[] = [
  {
    sheetName: 'DashBoard',
    cacheKeys: [
      CACHE_KEYS.BENJAMIN_GRAHAM,
      CACHE_KEYS.PE_INDUSTRY,
      CACHE_KEYS.SCORE_BOARD,
    ],
  },
  { sheetName: 'SMA', cacheKeys: [CACHE_KEYS.SMA] },
];

/**
 * Check if sync is already in progress (coordination)
 */
function isSyncInProgress(): boolean {
  try {
    const syncData = sessionStorage.getItem(SYNC_COORDINATION_KEY);
    if (!syncData) return false;
    
    const { timestamp } = JSON.parse(syncData);
    const age = Date.now() - timestamp;
    
    // If sync flag is older than timeout, consider it stale
    if (age > SYNC_COORDINATION_TIMEOUT) {
      sessionStorage.removeItem(SYNC_COORDINATION_KEY);
      return false;
    }
    
    return true;
  } catch (error) {
    logger.warn('Failed to check sync status', {
      component: 'backgroundSyncService',
      operation: 'isSyncInProgress',
      error,
    });
    return false;
  }
}

/**
 * Set sync coordination flag
 */
function setSyncInProgress(sheetName: string): void {
  try {
    sessionStorage.setItem(
      SYNC_COORDINATION_KEY,
      JSON.stringify({
        sheetName,
        timestamp: Date.now(),
      })
    );
  } catch (error) {
    logger.warn('Failed to set sync status', {
      component: 'backgroundSyncService',
      operation: 'setSyncInProgress',
      error,
    });
  }
}

/**
 * Clear sync coordination flag
 */
function clearSyncInProgress(): void {
  try {
    sessionStorage.removeItem(SYNC_COORDINATION_KEY);
  } catch (error) {
    // Ignore errors
  }
}

/**
 * Persist snapshot to cache keys for a sheet (transform + setDeltaCacheEntry)
 */
async function persistSnapshotToCache(
  sheetName: string,
  cacheKeys: string[],
  snapshot: SnapshotResponse
): Promise<void> {
  let transformerFormat: ReturnType<typeof snapshotToTransformerFormat>;
  try {
    transformerFormat = snapshotToTransformerFormat(snapshot);
  } catch (err) {
    logger.warn('Failed to transform snapshot for background sync', {
      component: 'backgroundSyncService',
      sheetName,
      error: err,
    });
    return;
  }

  const version = snapshot.version ?? 0;

  // cutover: no appCache writes for view-docs
  const skipAppCacheWrite = VIEWDATA_MIGRATION_MODE === 'cutover';

  for (const cacheKey of cacheKeys) {
    try {
      if (cacheKey === CACHE_KEYS.BENJAMIN_GRAHAM) {
        const data = transformBenjaminGrahamData(transformerFormat);
        if (!skipAppCacheWrite) await setDeltaCacheEntry(cacheKey, data, version, true);
      } else if (cacheKey === CACHE_KEYS.PE_INDUSTRY) {
        const data = transformPEIndustryData(transformerFormat);
        if (!skipAppCacheWrite) await setDeltaCacheEntry(cacheKey, data, version, true);
      } else if (cacheKey === CACHE_KEYS.SMA) {
        const data = transformSMAData(transformerFormat);
        if (!skipAppCacheWrite) await setDeltaCacheEntry(cacheKey, data, version, true);
      } else if (cacheKey === CACHE_KEYS.SCORE_BOARD) {
        const peData = await getCachedData<PEIndustryData[]>(CACHE_KEYS.PE_INDUSTRY);
        const smaData = await getCachedData<SMAData[]>(CACHE_KEYS.SMA);
        if (!peData?.length || !smaData?.length) {
          logger.debug('Skipping Score Board persist: PE or SMA cache missing', {
            component: 'backgroundSyncService',
            sheetName,
          });
          continue;
        }
        const industryPe1Map = new Map<string, number>();
        const industryPe2Map = new Map<string, number>();
        peData.forEach((pe) => {
          if (pe.pe1 != null) industryPe1Map.set(pe.industry.toLowerCase(), pe.pe1);
          if (pe.pe2 != null) industryPe2Map.set(pe.industry.toLowerCase(), pe.pe2);
        });
        const smaDataMap = new Map<string, { sma100: number | null; sma200: number | null; smaCross: string | null }>();
        smaData.forEach((s) => {
          smaDataMap.set(s.ticker.toLowerCase().trim(), {
            sma100: s.sma100,
            sma200: s.sma200,
            smaCross: s.smaCross,
          });
        });
        const transformer = createScoreBoardTransformer(industryPe1Map, industryPe2Map, smaDataMap);
        const data = transformer(transformerFormat);
        if (!skipAppCacheWrite) await setDeltaCacheEntry(cacheKey, data, version, true);
      }
    } catch (err) {
      logger.warn('Failed to persist cache key in background sync', {
        component: 'backgroundSyncService',
        cacheKey,
        sheetName,
        error: err,
      });
    }
  }
}

/**
 * Sync a single sheet in the background (one fetch per sheet, persist to all its cache keys)
 */
async function syncSheet(sheetName: string, cacheKeys: string[]): Promise<void> {
  if (!APPS_SCRIPT_URL) {
    logger.debug('Apps Script URL not configured, skipping background sync', {
      component: 'backgroundSyncService',
      sheetName,
    });
    return;
  }

  if (!isDeltaSyncEnabled()) {
    logger.debug('Delta sync not enabled, skipping background sync', {
      component: 'backgroundSyncService',
      sheetName,
    });
    return;
  }

  if (isSyncInProgress()) {
    logger.debug('Sync already in progress, skipping', {
      component: 'backgroundSyncService',
      sheetName,
    });
    return;
  }

  try {
    setSyncInProgress(sheetName);
    logger.debug('Starting background sync for sheet', {
      component: 'backgroundSyncService',
      sheetName,
    });

    const result = await requestBackgroundSync(
      sheetName,
      APPS_SCRIPT_URL,
      APPS_SCRIPT_TOKEN || undefined
    ) as { type: string; sheetName?: string; snapshot?: SnapshotResponse };

    if (result?.type === 'SYNC_COMPLETE' && result.snapshot && result.sheetName) {
      await persistSnapshotToCache(result.sheetName, cacheKeys, result.snapshot);
    }

    logger.info('Background sync completed for sheet', {
      component: 'backgroundSyncService',
      sheetName,
    });
  } catch (error) {
    logger.warn('Background sync failed for sheet', {
      component: 'backgroundSyncService',
      sheetName,
      error,
    });
  } finally {
    setTimeout(() => clearSyncInProgress(), 30000);
  }
}

/**
 * Sync all sheets in the background (one fetch per unique sheet, then persist to all cache keys)
 */
export async function syncAllSheets(): Promise<void> {
  if (!('serviceWorker' in navigator)) {
    logger.debug('Service Worker not available, skipping background sync', {
      component: 'backgroundSyncService',
      operation: 'syncAllSheets',
    });
    return;
  }

  for (const { sheetName, cacheKeys } of SHEETS_TO_SYNC) {
    await syncSheet(sheetName, cacheKeys);
    await new Promise((r) => setTimeout(r, 1000));
  }
}

/**
 * Initialize background sync based on page visibility
 */
export function initializeBackgroundSync(): void {
  if (!('serviceWorker' in navigator)) {
    return;
  }

  // Sync when page becomes hidden (user switches tabs or minimizes)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // Page is hidden, trigger background sync
      logger.debug('Page hidden, triggering background sync', {
        component: 'backgroundSyncService',
        operation: 'visibilitychange',
      });
      
      // Sync in background (fire and forget)
      syncAllSheets().catch((error) => {
        logger.warn('Background sync failed', {
          component: 'backgroundSyncService',
          operation: 'visibilitychange',
          error,
        });
      });
    }
  });

  // Sync on page unload is not implemented. visibilitychange (tab switch) handles
  // background sync when the user leaves the tab; that is sufficient.
}

/**
 * Manual trigger for background sync (for testing or user-initiated)
 */
export async function triggerBackgroundSync(sheetName?: string): Promise<void> {
  if (sheetName) {
    const entry = SHEETS_TO_SYNC.find((s) => s.sheetName === sheetName);
    if (entry) await syncSheet(entry.sheetName, entry.cacheKeys);
    else logger.warn('Unknown sheet for background sync', { component: 'backgroundSyncService', sheetName });
  } else {
    await syncAllSheets();
  }
}

```

## `src/services/cacheKeys.ts`

```typescript
/**
 * Cache Keys
 * 
 * Centralized cache key definitions for all data types.
 * Used by both localStorage cache (deprecated) and Firestore cache.
 */

// Cache keys for different data types
export const CACHE_KEYS = {
  BENJAMIN_GRAHAM: 'cache:benjaminGraham',
  SMA: 'cache:sma',
  PE_INDUSTRY: 'cache:peIndustry',
  SCORE_BOARD: 'cache:scoreBoard',
  THRESHOLD_INDUSTRY: 'cache:thresholdIndustry',
  CURRENCY_RATES_USD: 'cache:currency_rates_usd',
} as const;

```

## `src/services/cacheService.ts`

```typescript
/**
 * Cache Service (neutralized — no localStorage data cache)
 *
 * Data cache has been removed. This module only exports types and no-op/empty
 * implementations so existing imports do not break. All shared data comes from
 * Firestore appCache (see firestoreCacheService).
 */

/**
 * Legacy cache interface (TTL-based). Kept for type compatibility.
 * @template T - The type of data being cached
 */
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

/**
 * Delta sync cache interface (version-based).
 * Used by firestoreCacheService and delta sync. Data is stored in Firestore, not localStorage.
 * @template T - The type of data being cached
 */
export interface DeltaCacheEntry<T> {
  data: T;
  version: number;
  lastSnapshotAt: number;
  lastUpdated: number;
  timestamp?: number;
  ttl?: number;
}

// Re-export CACHE_KEYS from centralized location for backward compatibility
// @deprecated Import CACHE_KEYS from './cacheKeys' instead
export { CACHE_KEYS } from './cacheKeys';

const DEFAULT_TTL_MINUTES = parseInt(import.meta.env.VITE_CACHE_DEFAULT_TTL_MINUTES || '180', 10);
export const DEFAULT_TTL = DEFAULT_TTL_MINUTES * 60 * 1000;

const FRESH_THRESHOLD_MINUTES = parseInt(import.meta.env.VITE_CACHE_FRESH_THRESHOLD_MINUTES || '5', 10);
export const FRESH_THRESHOLD_MS = FRESH_THRESHOLD_MINUTES * 60 * 1000;

const EMPTY_STATS = {
  hits: {} as Record<string, number>,
  misses: {} as Record<string, number>,
  sizes: {} as Record<string, number>,
  lastAccessed: {} as Record<string, number>,
};

export interface CacheStats {
  hits: Record<string, number>;
  misses: Record<string, number>;
  sizes: Record<string, number>;
  lastAccessed: Record<string, number>;
}

export function getCacheStats(): CacheStats {
  return { ...EMPTY_STATS };
}

export function checkQuotaUsage(): number | null {
  return null;
}

export function getCacheStatsForKey(_key: string): {
  hits: number;
  misses: number;
  hitRate: number;
  size: number;
  lastAccessed: number | null;
} {
  return {
    hits: 0,
    misses: 0,
    hitRate: 0,
    size: 0,
    lastAccessed: null,
  };
}

export function getTotalCacheSize(): number {
  return 0;
}

export function resetCacheStats(_key?: string): void {
  // No-op
}

export function getCachedData<T>(_key: string): T | null {
  return null;
}

export function getDeltaCacheEntry<T>(_key: string): DeltaCacheEntry<T> | null {
  return null;
}

export function getLastVersion(_key: string): number {
  return 0;
}

export function setCachedData<T>(_key: string, _data: T, _ttl: number = DEFAULT_TTL): void {
  // No-op
}

export function setDeltaCacheEntry<T>(
  _key: string,
  _data: T,
  _version: number,
  _isSnapshot: boolean = false,
  _ttl?: number
): void {
  // No-op
}

export function isCacheValid(_key: string): boolean {
  return false;
}

export function clearCache(_key?: string): void {
  // No-op
}

export function getCacheAge(_key: string): number | null {
  return null;
}

export function isCacheFresh(_key: string, _freshThresholdMs: number = FRESH_THRESHOLD_MS): boolean {
  return false;
}

export function isCacheStale(key: string, _freshThresholdMs: number = FRESH_THRESHOLD_MS): boolean {
  return getCachedData(key) !== null && getCacheAge(key) !== null;
}

export function clearExpiredCache(): void {
  // No-op
}

```

## `src/services/cacheWarmingService.ts`

```typescript
/**
 * Cache Warming Service
 * 
 * Preloads cache data in the background when the app starts
 * to improve performance and reduce loading times
 */

import { CACHE_KEYS, getCachedData, getCacheAge } from './firestoreCacheService';
import { logger } from '../utils/logger';
import { 
  fetchScoreBoardData, 
  fetchPEIndustryData, 
  // Note: fetchThresholdIndustryData removed - threshold data is now static
  fetchBenjaminGrahamData 
} from './sheets';

// Cache warming configuration
const WARMING_DELAY_MS = 2000; // Wait 2 seconds after app starts before warming
const WARMING_ENABLED = import.meta.env.VITE_CACHE_WARMING_ENABLED !== 'false'; // Default: true

/**
 * Warm cache for all data types
 * 
 * Preloads cache for all data types in the background to improve performance.
 * This is a fire-and-forget operation that runs after a short delay to avoid
 * blocking initial app render. Only warms cache if it doesn't exist or is very old.
 * 
 * @example
 * ```typescript
 * // Call on app startup
 * warmCache(); // Runs in background, doesn't block
 * ```
 */
export async function warmCache(): Promise<void> {
  if (!WARMING_ENABLED) {
    return;
  }

  // Wait a bit after app starts to avoid blocking initial render
  await new Promise(resolve => setTimeout(resolve, WARMING_DELAY_MS));

  // Warm cache for all data types in parallel
  // Use Promise.allSettled to avoid failures in one affecting others
  // Note: Threshold industry data is now static and not cached/warmed
  const warmingPromises = [
    warmCacheForKey(CACHE_KEYS.SCORE_BOARD, () => fetchScoreBoardData(false)),
    warmCacheForKey(CACHE_KEYS.PE_INDUSTRY, () => fetchPEIndustryData(false)),
    warmCacheForKey(CACHE_KEYS.BENJAMIN_GRAHAM, () => fetchBenjaminGrahamData(false)),
  ];

  await Promise.allSettled(warmingPromises);
}

/**
 * Warm cache for a specific key
 * Only fetches data if cache doesn't exist or is stale
 */
async function warmCacheForKey(
  cacheKey: string,
  fetchFn: () => Promise<unknown>
): Promise<void> {
  try {
    // Check if cache exists and is fresh
    // If cache exists, skip warming (data hooks will handle revalidation)
    const cachedData = await getCachedData(cacheKey);
    
    // Only warm if cache doesn't exist or is very old (> 15 minutes)
    const cacheAge = await getCacheAge(cacheKey);
    const FIFTEEN_MINUTES_MS = 15 * 60 * 1000;
    
    if (cachedData && cacheAge !== null && cacheAge < FIFTEEN_MINUTES_MS) {
      // Cache exists and is relatively fresh, skip warming
      return;
    }

    // Fetch data in background (silently fail on errors)
    await fetchFn();
  } catch (error) {
    // Silently fail - cache warming is not critical
    logger.debug(`Cache warming failed for ${cacheKey}`, { component: 'cacheWarmingService', operation: 'warmCacheForKey', cacheKey, error });
  }
}

/**
 * Check if cache warming is enabled
 * 
 * Determines if cache warming is enabled based on environment variable.
 * 
 * @returns true if cache warming is enabled, false otherwise
 * 
 * @example
 * ```typescript
 * if (isCacheWarmingEnabled()) {
 *   await warmCache();
 * }
 * ```
 */
export function isCacheWarmingEnabled(): boolean {
  return WARMING_ENABLED;
}

```

## `src/services/currencyService.ts`

```typescript
/**
 * Currency Service with Multi-API Fallback
 *
 * Tries multiple APIs in priority order:
 * 1. EODHD
 * 2. MarketStack
 * 3. FINNHUB
 * 4. Alpha Vantage
 * 5. ExchangeRate-API (fallback, no key)
 * Rates are cached in Firestore (15 hours TTL) to minimize requests.
 */

import { getApiKeys } from '../config/apiKeys';
import { getCachedData, setCachedData } from './firestoreCacheService';
import { CACHE_KEYS } from './cacheKeys';

const EXCHANGE_RATE_API_URL = 'https://open.er-api.com/v6/latest/USD';
const CACHE_TTL_MS = 15 * 60 * 60 * 1000; // 15 hours

interface CurrencyRatesData {
  rates: Record<string, number>;
  source: string;
}

/**
 * Get exchange rate from one currency to USD.
 * E.g. getExchangeRate('SEK', 'USD') returns how many USD per 1 SEK.
 *
 * @param fromCurrency - ISO 4217 code (e.g. 'SEK', 'EUR')
 * @param toCurrency - Target currency, default 'USD'
 * @returns Rate to multiply with amount in fromCurrency to get USD, or null if unavailable
 */
export async function getExchangeRate(
  fromCurrency: string,
  toCurrency: string = 'USD'
): Promise<number | null> {
  const from = fromCurrency.toUpperCase();
  const to = toCurrency.toUpperCase();

  if (from === to) {
    return 1;
  }

  try {
    const rates = await getRatesWithFallback();
    if (!rates) return null;

    // API returns rates FROM USD to other currencies (e.g. rates.SEK = SEK per 1 USD)
    // So USD per 1 SEK = 1 / rates.SEK
    if (to === 'USD' && from in rates) {
      const usdPerUnit = 1 / rates[from];
      return isFinite(usdPerUnit) ? usdPerUnit : null;
    }
    if (from === 'USD' && to in rates) {
      return isFinite(rates[to]) ? rates[to] : null;
    }
    if (from in rates) {
      const usdPerUnit = 1 / rates[from];
      return isFinite(usdPerUnit) ? usdPerUnit : null;
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Force refresh the currency rates cache by fetching from APIs and writing to Firestore.
 * Call before getExchangeRate when fresh rates are needed (e.g. every 15 minutes in Personal Portfolio).
 */
export async function refreshCurrencyRatesCache(): Promise<void> {
  await getRatesWithFallback(true);
}

/**
 * Try APIs in priority order until one succeeds
 */
async function getRatesWithFallback(forceRefresh?: boolean): Promise<Record<string, number> | null> {
  if (!forceRefresh) {
    const cached = await getCachedRates();
    if (cached) return cached.rates;
  }

  const apiKeys = getApiKeys();

  if (apiKeys.eodhd) {
    const rates = await fetchEODHDRates(apiKeys.eodhd);
    if (rates) {
      const merged = await mergeMissingMajorCurrencies(rates);
      await setCachedRates(merged, 'eodhd');
      return merged;
    }
  }

  if (apiKeys.marketstack) {
    const rates = await fetchMarketStackRates(apiKeys.marketstack);
    if (rates) {
      const merged = await mergeMissingMajorCurrencies(rates);
      await setCachedRates(merged, 'marketstack');
      return merged;
    }
  }

  if (apiKeys.finnhub) {
    const rates = await fetchFinnhubRates(apiKeys.finnhub);
    if (rates) {
      const merged = await mergeMissingMajorCurrencies(rates);
      await setCachedRates(merged, 'finnhub');
      return merged;
    }
  }

  if (apiKeys.alphaVantage) {
    const rates = await fetchAlphaVantageRates(apiKeys.alphaVantage);
    if (rates) {
      const merged = await mergeMissingMajorCurrencies(rates);
      await setCachedRates(merged, 'alphavantage');
      return merged;
    }
  }

  const rates = await fetchExchangeRateAPIRates();
  if (rates) {
    await setCachedRates(rates, 'exchangerate-api');
    return rates;
  }

  return null;
}

/** Major currencies to fetch from USD for APIs that only support single-pair */
const MAJOR_CURRENCIES = ['EUR', 'SEK', 'GBP', 'CHF', 'NOK', 'DKK', 'AUD', 'CAD', 'JPY'];

/**
 * Merge missing major currencies from the free API into rates.
 * Ensures we always have SEK and other major currencies even if the primary API omits them.
 */
async function mergeMissingMajorCurrencies(
  rates: Record<string, number>
): Promise<Record<string, number>> {
  const missing = MAJOR_CURRENCIES.filter((ccy) => !(ccy in rates));
  if (missing.length === 0) return rates;
  const fallback = await fetchExchangeRateAPIRates();
  if (!fallback) return rates;
  const merged = { ...rates };
  for (const ccy of missing) {
    if (ccy in fallback && typeof fallback[ccy] === 'number') {
      merged[ccy] = fallback[ccy];
    }
  }
  return merged;
}

async function getCachedRates(): Promise<CurrencyRatesData | null> {
  return getCachedData<CurrencyRatesData>(CACHE_KEYS.CURRENCY_RATES_USD);
}

async function setCachedRates(rates: Record<string, number>, source: string): Promise<void> {
  try {
    const data: CurrencyRatesData = { rates, source };
    await setCachedData(CACHE_KEYS.CURRENCY_RATES_USD, data, CACHE_TTL_MS);
  } catch {
    // Cache write failed (e.g. permission); API response still used for current call
  }
}

async function fetchEODHDRates(apiKey: string): Promise<Record<string, number> | null> {
  try {
    // EODHD real-time: one symbol per request, e.g. USDEUR.FOREX
    const symbols = MAJOR_CURRENCIES.map((c) => `USD${c}.FOREX`);
    const results = await Promise.all(
      symbols.map(async (symbol) => {
        const url = `https://eodhistoricaldata.com/api/real-time/${symbol}?api_token=${apiKey}&fmt=json`;
        const res = await fetch(url);
        if (!res.ok) return null;
        const data = (await res.json()) as { close?: number; code?: string };
        const close = data?.close;
        const code = data?.code?.replace('USD', '') || symbol.replace('USD', '').replace('.FOREX', '');
        if (typeof close === 'number' && code) return { code, rate: close };
        return null;
      })
    );
    const rates: Record<string, number> = { USD: 1 };
    for (const r of results) {
      if (r) rates[r.code] = r.rate;
    }
    if (Object.keys(rates).length <= 1) return null;
    return rates;
  } catch {
    return null;
  }
}

async function fetchMarketStackRates(_apiKey: string): Promise<Record<string, number> | null> {
  // MarketStack Currencies endpoint is metadata, not exchange rates. Use ExchangeRate-API.
  return null;
}

async function fetchFinnhubRates(apiKey: string): Promise<Record<string, number> | null> {
  try {
    // Finnhub forex rates: https://finnhub.io/api/v1/forex/rates?base=USD
    const res = await fetch(`https://finnhub.io/api/v1/forex/rates?base=USD&token=${apiKey}`);
    if (!res.ok) return null;
    const data = (await res.json()) as { quote?: Record<string, number> };
    const quote = data?.quote;
    if (!quote || typeof quote !== 'object') return null;
    const rates: Record<string, number> = { USD: 1 };
    for (const [ccy, value] of Object.entries(quote)) {
      if (typeof value === 'number') rates[ccy] = value;
    }
    if (Object.keys(rates).length <= 1) return null;
    return rates;
  } catch {
    return null;
  }
}

async function fetchAlphaVantageRates(apiKey: string): Promise<Record<string, number> | null> {
  try {
    const rates: Record<string, number> = { USD: 1 };
    await Promise.all(
      MAJOR_CURRENCIES.map(async (toCcy) => {
        const url = `https://www.alphavantage.co/query?function=CURRENCY_EXCHANGE_RATE&from_currency=USD&to_currency=${toCcy}&apikey=${apiKey}`;
        const res = await fetch(url);
        if (!res.ok) return;
        const data = (await res.json()) as { 'Realtime Currency Exchange Rate'?: { '5. Exchange Rate'?: string } };
        const rateStr = data?.['Realtime Currency Exchange Rate']?.['5. Exchange Rate'];
        if (rateStr) {
          const rate = parseFloat(rateStr);
          if (Number.isFinite(rate)) rates[toCcy] = rate;
        }
      })
    );
    if (Object.keys(rates).length <= 1) return null;
    return rates;
  } catch {
    return null;
  }
}

async function fetchExchangeRateAPIRates(): Promise<Record<string, number> | null> {
  try {
    const response = await fetch(EXCHANGE_RATE_API_URL, {
      method: 'GET',
      headers: { Accept: 'application/json' },
    });
    if (!response.ok) return null;
    const data = (await response.json()) as { result?: string; rates?: Record<string, number> };
    if (data.result !== 'success' || !data.rates) return null;
    return data.rates;
  } catch {
    return null;
  }
}

```

## `src/services/deltaSyncService.ts`

```typescript
/**
 * Delta Sync Service
 * 
 * Provides delta-sync functionality for Google Sheets data:
 * - Initial load: Full snapshot
 * - Subsequent updates: Only changes (delta) since last version
 * - Automatic polling for changes
 * - Retry logic with exponential backoff
 */

import { getDeltaCacheEntry, setDeltaCacheEntry, getLastVersion, VIEWDATA_MIGRATION_MODE } from './firestoreCacheService';
import { logger } from '../utils/logger';
import { isArray, isString } from '../utils/typeGuards';
import { transformInWorker, getTransformerId } from './workerService';
import type { DataRow } from './sheets';

// Configuration
const APPS_SCRIPT_URL = import.meta.env.VITE_APPS_SCRIPT_URL || '';
const DELTA_SYNC_ENABLED = import.meta.env.VITE_DELTA_SYNC_ENABLED !== 'false'; // Default: true
const POLL_INTERVAL_MINUTES = parseInt(import.meta.env.VITE_DELTA_SYNC_POLL_MINUTES || '15', 10);
const API_TOKEN = import.meta.env.VITE_APPS_SCRIPT_TOKEN || ''; // Optional token
// Request timeout: Configurable via environment variable
// Delta sync uses a longer timeout since it may need to fetch large snapshots (e.g. Apps Script cold start)
const DELTA_SYNC_TIMEOUT_SECONDS = parseInt(import.meta.env.VITE_DELTA_SYNC_TIMEOUT_SECONDS || '60', 10); // Default: 60 seconds for delta sync (covers cold start / slow networks)
const DELTA_SYNC_TIMEOUT = DELTA_SYNC_TIMEOUT_SECONDS * 1000;
// Regular fetch timeout (used by fetchService) - shorter for faster feedback
const FETCH_TIMEOUT_SECONDS = parseInt(import.meta.env.VITE_FETCH_TIMEOUT_SECONDS || '30', 10);
const FETCH_TIMEOUT = FETCH_TIMEOUT_SECONDS * 1000;
const MAX_RETRIES = 3;
const INITIAL_RETRY_DELAY = 1000; // 1 second

/**
 * Snapshot response from Apps Script API
 * 
 * Contains a complete snapshot of sheet data with version information.
 */
export interface SnapshotResponse {
  /** Whether the request was successful */
  ok: boolean;
  /** Version number (changeId) of this snapshot */
  version: number;
  /** Column headers from the sheet */
  headers: string[];
  /** Data rows with key and values */
  rows: Array<{ key: string; values: unknown[] }>;
  /** ISO timestamp when snapshot was generated */
  generatedAt: string;
  /** Error message if request failed */
  error?: string;
}

/**
 * Changes response from Apps Script API
 * 
 * Contains incremental changes since a specific version.
 */
export interface ChangesResponse {
  /** Whether the request was successful */
  ok: boolean;
  /** Version number changes are from */
  fromVersion: number;
  /** Version number changes are to */
  toVersion: number;
  /** Array of individual changes */
  changes: Array<{
    id: number;
    tsISO: string;
    key: string;
    rowIndex: number;
    changedColumns: string[];
    values: unknown[];
  }>;
  /** Whether a full resync is needed instead of incremental updates */
  needsFullResync?: boolean;
  /** Error message if request failed */
  error?: string;
}

/**
 * Delta sync configuration
 * 
 * Configuration object for delta sync operations.
 */
export interface DeltaSyncConfig {
  /** Name of the sheet to sync */
  sheetName: string;
  /** Base URL for Apps Script API */
  apiBaseUrl: string;
  /** Optional API token for authentication */
  token?: string;
  /** Poll interval in minutes (default: 15) */
  pollMinutes?: number;
  /** Name of the key column for row identification */
  keyColumnName?: string;
  /** Callback function called when data is updated */
  onUpdate?: (data: unknown, version: number) => void;
  /** Callback function called on errors */
  onError?: (error: Error) => void;
  /** Data type name for worker transformer (e.g. "Benjamin Graham", "Score Board"). Used with sheetName for getTransformerId. */
  dataTypeName?: string;
  /** Additional data for transformers that need it (e.g. industryPe1Map, industryPe2Map, smaDataMap for Score Board). */
  additionalData?: Record<string, unknown>;
}

/**
 * Convert SnapshotResponse to format expected by transformers
 * 
 * Converts the snapshot response from Apps Script API into the format
 * expected by data transformer functions. Transformers expect:
 * { data: DataRow[]; meta: { fields: string[] | null } }
 * 
 * @param snapshot - Snapshot response from Apps Script API
 * @returns Object with data array and meta fields in transformer format
 * 
 * @example
 * ```typescript
 * const snapshot = await loadSnapshot(config);
 * const transformerFormat = snapshotToTransformerFormat(snapshot);
 * const transformed = transformer(transformerFormat);
 * ```
 */
export function snapshotToTransformerFormat(snapshot: SnapshotResponse): { data: DataRow[]; meta: { fields: string[] | null } } {
  // Validate snapshot structure
  if (!snapshot || typeof snapshot !== 'object') {
    throw new Error('Invalid snapshot: snapshot is not an object');
  }
  
  if (!snapshot.headers) {
    throw new Error(`Invalid snapshot: headers is undefined or null. Snapshot structure: ${JSON.stringify(Object.keys(snapshot || {}))}`);
  }
  
  if (!isArray(snapshot.headers)) {
    throw new Error(`Invalid snapshot: headers is not an array. Got: ${typeof snapshot.headers}`);
  }
  
  if (!snapshot.rows) {
    throw new Error(`Invalid snapshot: rows is undefined or null. Snapshot structure: ${JSON.stringify(Object.keys(snapshot || {}))}`);
  }
  
  if (!isArray(snapshot.rows)) {
    throw new Error(`Invalid snapshot: rows is not an array. Got: ${typeof snapshot.rows}. Snapshot structure: ${JSON.stringify(Object.keys(snapshot))}`);
  }
  
  const dataRows: DataRow[] = [];
  
  snapshot.rows.forEach((row) => {
    if (!row || typeof row !== 'object' || !isArray(row.values)) {
      logger.warn('Skipping invalid row in snapshot', { component: 'deltaSyncService', operation: 'snapshotToTransformerFormat', row });
      return;
    }
    
    const dataRow: DataRow = {};
    snapshot.headers.forEach((header, index) => {
      if (!isString(header)) {
        logger.warn('Skipping invalid header', { component: 'deltaSyncService', operation: 'snapshotToTransformerFormat', header });
        return;
      }
      
      const value = row.values[index];
      // Convert unknown value to DataRow value type (string | number | undefined)
      if (value === null || value === undefined || value === '') {
        dataRow[header] = '';
      } else if (typeof value === 'string' || typeof value === 'number') {
        dataRow[header] = value;
      } else {
        // Convert other types to string
        dataRow[header] = String(value);
      }
    });
    dataRows.push(dataRow);
  });
  
  return {
    data: dataRows,
    meta: { fields: snapshot.headers && snapshot.headers.length > 0 ? snapshot.headers : null },
  };
}

/**
 * Initialize delta sync for a sheet
 * 
 * Initializes delta sync by loading an initial snapshot and caching it.
 * If cached data exists, returns it immediately. Otherwise, fetches a full
 * snapshot from the API and caches it.
 * 
 * @template T - The type of data after transformation
 * @param config - Delta sync configuration
 * @param cacheKey - Cache key to store/retrieve data
 * @param transformer - Function to transform data rows into target type
 * @returns Promise resolving to data array and version number
 * @throws {Error} If delta sync is disabled or API base URL is missing
 * 
 * @example
 * ```typescript
 * // Initialize delta sync for a sheet
 * const config: DeltaSyncConfig = {
 *   sheetName: 'DashBoard',
 *   apiBaseUrl: APPS_SCRIPT_URL,
 * };
 * 
 * const { data, version } = await initSync<ScoreBoardData[]>(
 *   config,
 *   CACHE_KEYS.SCORE_BOARD,
 *   transformScoreBoardData
 * );
 * 
 * // data: Array of transformed data
 * // version: Current version number for polling
 * console.log(`Loaded ${data.length} items, version ${version}`);
 * ```
 */
export async function initSync<T>(
  config: DeltaSyncConfig,
  cacheKey: string,
  transformer: (results: { data: DataRow[]; meta: { fields: string[] | null } }) => T[]
): Promise<{ data: T[]; version: number }> {
  if (!DELTA_SYNC_ENABLED) {
    throw new Error('Delta sync is disabled');
  }

  if (!config.apiBaseUrl) {
    throw new Error('API base URL is required');
  }

  // Check if we have existing cache with version
  const existingEntry = await getDeltaCacheEntry<T[]>(cacheKey);
  if (existingEntry) {
    // Return cached data
    return {
      data: existingEntry.data,
      version: existingEntry.version,
    };
  }

  // Load initial snapshot
  let snapshot: SnapshotResponse;
  try {
    snapshot = await loadSnapshot(config);
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to load snapshot for sheet "${config.sheetName}": ${errorMessage}`);
  }
  
  // Validate snapshot response
  if (!snapshot || !snapshot.ok) {
    const errorMsg = snapshot?.error || 'Unknown error';
    throw new Error(`Snapshot request failed for sheet "${config.sheetName}": ${errorMsg}`);
  }
  
  let transformerFormat: { data: DataRow[]; meta: { fields: string[] | null } };
  try {
    transformerFormat = snapshotToTransformerFormat(snapshot);
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to transform snapshot data for sheet "${config.sheetName}": ${errorMessage}. Snapshot version: ${snapshot.version}, Headers: ${snapshot.headers?.length || 0}, Rows: ${snapshot.rows?.length || 0}`);
  }
  
  // Try to use Web Worker for transformation, fallback to main thread
  let transformedData: T[];
  const transformerId = getTransformerId(config.dataTypeName ?? config.sheetName, config.sheetName);

  if (transformerId) {
    try {
      transformedData = await transformInWorker<T>(
        transformerId,
        transformerFormat.data,
        transformerFormat.meta,
        undefined, // progressCallback (delta sync doesn't use progress callbacks)
        config.additionalData,
        transformer // fallback transformer
      );
    } catch (workerError) {
      // Fallback to main thread transformation
      logger.debug(
        `Worker transformation failed for ${config.sheetName}, using main thread`,
        { component: 'deltaSyncService', sheetName: config.sheetName, error: workerError }
      );
      transformedData = transformer(transformerFormat);
    }
  } else {
    // No transformer ID found, use main thread
    transformedData = transformer(transformerFormat);
  }
  
  // Cache the snapshot (cutover: no appCache writes for view-docs)
  if (VIEWDATA_MIGRATION_MODE !== 'cutover') {
    setDeltaCacheEntry(cacheKey, transformedData, snapshot.version, true);
  }

  return {
    data: transformedData,
    version: snapshot.version,
  };
}

/**
 * Load full snapshot from API
 * 
 * Fetches a complete snapshot of sheet data from the Apps Script API.
 * This is used for initial load or when a full resync is needed.
 * 
 * @param config - Delta sync configuration
 * @returns Promise resolving to snapshot response
 * @throws {Error} If fetch fails or response is invalid
 * 
 * @example
 * ```typescript
 * const snapshot = await loadSnapshot({
 *   sheetName: 'DashBoard',
 *   apiBaseUrl: APPS_SCRIPT_URL
 * });
 * ```
 */
export async function loadSnapshot(config: DeltaSyncConfig): Promise<SnapshotResponse> {
  const token = config.token || API_TOKEN || undefined;
  const usePost = !!token;
  const url = usePost ? config.apiBaseUrl : buildSnapshotUrl(config);
  const headers = buildAuthHeaders(token);
  
  try {
    const init: RequestInit = usePost
      ? {
          method: 'POST',
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'snapshot', sheet: config.sheetName, token }),
        }
      : { method: 'GET', headers };
    
    const rawResponse = await fetchWithRetry<unknown>(
      url,
      init,
      MAX_RETRIES,
      DELTA_SYNC_TIMEOUT
    );
    
    // Handle case where API returns a 2D array directly (legacy format)
    // This happens when Apps Script returns data in the old format: [["Header1", "Header2"], ["Value1", "Value2"], ...]
    if (isArray(rawResponse) && rawResponse.length > 0) {
      // Check if first element is an array (indicating 2D array format)
      if (isArray(rawResponse[0])) {
        // Convert 2D array to SnapshotResponse format
        const headerRow = rawResponse[0];
        const headers: string[] = headerRow.map((h: unknown) => String(h || ''));
        
        const rows = rawResponse.slice(1).map((row: unknown, index: number) => {
          if (!isArray(row)) {
            logger.warn('Skipping invalid row in 2D array response', { component: 'deltaSyncService', operation: 'loadSnapshot', rowIndex: index });
            return { key: String(index), values: [] };
          }
          return {
            key: String(index),
            values: row.map((v: unknown) => v),
          };
        });
        
        logger.debug('Converted 2D array to SnapshotResponse format', { 
          component: 'deltaSyncService', 
          operation: 'loadSnapshot', 
          headersCount: headers.length, 
          rowsCount: rows.length 
        });
        
        return {
          ok: true,
          version: Date.now(), // Use timestamp as version for legacy format
          headers: headers,
          rows: rows,
          generatedAt: new Date().toISOString(),
        };
      }
    }
    
    // Validate response structure for new format
    if (!rawResponse || typeof rawResponse !== 'object' || Array.isArray(rawResponse)) {
      throw new Error(`Invalid snapshot response: expected object, got ${Array.isArray(rawResponse) ? 'array' : typeof rawResponse}`);
    }
    
    const response = rawResponse as SnapshotResponse;
    
    // Check if response indicates failure
    if (response.ok === false) {
      const errorMsg = response.error || 'Unknown error from API';
      throw new Error(`Snapshot API returned error: ${errorMsg}`);
    }
    
    // Validate required fields
    if (!isArray(response.headers)) {
      throw new Error(`Invalid snapshot response: headers is not an array. Response type: ${typeof response.headers}, Response keys: ${isArray(response) ? 'array' : Object.keys(response).join(', ')}`);
    }
    
    if (!isArray(response.rows)) {
      throw new Error(`Invalid snapshot response: rows is not an array. Response type: ${typeof response.rows}, Response keys: ${isArray(response) ? 'array' : Object.keys(response).join(', ')}`);
    }
    
    if (typeof response.version !== 'number') {
      throw new Error(`Invalid snapshot response: version is not a number. Got: ${typeof response.version}`);
    }
    
    return response;
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const isTimeout = errorMessage.includes('timeout') || errorMessage.includes('Request timeout');
    // Log timeout as warning (app falls back to regular fetch); other failures as error
    if (isTimeout) {
      logger.warn(
        `Snapshot request timed out for sheet "${config.sheetName}" (will use fallback if available)`,
        { component: 'deltaSyncService', operation: 'loadSnapshot', sheetName: config.sheetName, url, hasAuth: !!token }
      );
    } else {
      logger.error(
        `Failed to load snapshot for sheet "${config.sheetName}"`,
        error,
        { component: 'deltaSyncService', operation: 'loadSnapshot', sheetName: config.sheetName, url, hasAuth: !!token }
      );
    }
    throw error;
  }
}

/**
 * Poll for changes since last version
 * 
 * Fetches incremental changes from the Apps Script API since a specific version.
 * Used for efficient updates without reloading all data.
 * 
 * @param config - Delta sync configuration
 * @param sinceVersion - Version number to fetch changes from
 * @returns Promise resolving to changes response
 * @throws {Error} If fetch fails or response is invalid
 * 
 * @example
 * ```typescript
 * const changes = await pollChanges(config, lastVersion);
 * if (changes.changes.length > 0) {
 *   // Process changes
 * }
 * ```
 */
export async function pollChanges(
  config: DeltaSyncConfig,
  sinceVersion: number
): Promise<ChangesResponse> {
  const token = config.token || API_TOKEN || undefined;
  const usePost = !!token;
  const url = usePost ? config.apiBaseUrl : buildChangesUrl(config, sinceVersion);
  const headers = buildAuthHeaders(token);
  
  const init: RequestInit = usePost
    ? {
        method: 'POST',
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'changes', sheet: config.sheetName, since: sinceVersion, token }),
      }
    : { method: 'GET', headers };
  
  return fetchWithRetry<ChangesResponse>(url, init);
}

/**
 * Apply changes to cached data
 * 
 * Analyzes changes response and determines if a full snapshot reload is needed.
 * Simplified implementation: if changes are detected or full resync is needed,
 * returns a signal to reload snapshot rather than merging changes incrementally.
 * 
 * @template T - The type of cached data
 * @param changes - Changes response from API
 * @param cacheKey - Cache key to check/update
 * @returns Object indicating if reload is needed, with version and optional cached data
 * 
 * @example
 * ```typescript
 * const result = applyChangesToCache<ScoreBoardData[]>(changes, CACHE_KEYS.SCORE_BOARD);
 * if (result.needsReload) {
 *   // Reload full snapshot
 * } else if (result.data) {
 *   // Use cached data
 * }
 * ```
 */
/**
 * Apply changes to cached data
 * 
 * Analyzes changes response and determines if a full snapshot reload is needed.
 * Simplified implementation: if changes are detected or full resync is needed,
 * returns a signal to reload snapshot rather than merging changes incrementally.
 * 
 * **Edge Cases:**
 * - **Version mismatch**: If needsFullResync is true, triggers full reload
 * - **No existing cache**: If cache doesn't exist, triggers full snapshot load
 * - **Changes detected**: Reloads full snapshot (simpler than incremental merge)
 * 
 * **Why full reload instead of incremental merge?**
 * - Simpler and more reliable than trying to merge individual row changes
 * - Ensures data consistency (no partial updates)
 * - Full snapshot is still efficient with delta sync (only changed rows are sent)
 * 
 * @template T - The type of cached data
 * @param changes - Changes response from API
 * @param cacheKey - Cache key to check/update
 * @returns Object indicating if reload is needed, with version and optional cached data
 * 
 * @example
 * ```typescript
 * const result = applyChangesToCache<ScoreBoardData[]>(changes, CACHE_KEYS.SCORE_BOARD);
 * if (result.needsReload) {
 *   // Reload full snapshot
 * } else if (result.data) {
 *   // Use cached data
 * }
 * ```
 */
export async function applyChangesToCache<T>(
  changes: ChangesResponse,
  cacheKey: string
): Promise<{ needsReload: boolean; version: number; data?: T[] }> {
  const existing = await getDeltaCacheEntry<T[]>(cacheKey);

  // Edge case: Full resync needed (version mismatch or server request)
  if (!changes.ok || changes.needsFullResync) {
    // Need full reload
    return {
      needsReload: true,
      version: changes.toVersion || 0,
    };
  }

  if (!changes.changes || changes.changes.length === 0) {
    // No changes, return existing cache
    if (existing) {
      return {
        needsReload: false,
        version: changes.toVersion,
        data: existing.data,
      };
    }
    // Edge case: No existing cache - need to load snapshot
    return {
      needsReload: true,
      version: changes.toVersion,
    };
  }

  // Changes detected - need to reload snapshot to get updated data
  // (This is simpler and more reliable than trying to merge changes incrementally)
  return {
    needsReload: true,
    version: changes.toVersion,
  };
}

/**
 * Build snapshot URL (no token in querystring - use header or POST body)
 */
function buildSnapshotUrl(config: DeltaSyncConfig): string {
  const url = new URL(config.apiBaseUrl);
  url.searchParams.set('action', 'snapshot');
  url.searchParams.set('sheet', config.sheetName);
  return url.toString();
}

/**
 * Build changes URL (no token in querystring - use header or POST body)
 */
function buildChangesUrl(config: DeltaSyncConfig, sinceVersion: number): string {
  const url = new URL(config.apiBaseUrl);
  url.searchParams.set('action', 'changes');
  url.searchParams.set('sheet', config.sheetName);
  url.searchParams.set('since', String(sinceVersion));
  return url.toString();
}

/**
 * Build request headers. Header-first; body token kept for backward compat.
 * Apps Script reads from body until header API is available.
 */
function buildAuthHeaders(token: string | undefined): Record<string, string> {
  const headers: Record<string, string> = { Accept: 'application/json' };
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  return headers;
}

/**
 * Fetch with retry and exponential backoff
 */
async function fetchWithRetry<T>(
  url: string,
  options: RequestInit,
  retries: number = MAX_RETRIES,
  timeout: number = DELTA_SYNC_TIMEOUT
): Promise<T> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
    });
    
    clearTimeout(timeoutId);

    if (!response.ok) {
      if (response.status === 401) {
        throw new Error('Unauthorized: Invalid or missing API token');
      }
      if (response.status === 404) {
        throw new Error(`Not found: ${url}`);
      }
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    let data: unknown;
    try {
      data = await response.json();
    } catch (parseError: unknown) {
      const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
      throw new Error(`Failed to parse JSON response: ${errorMessage}`);
    }
    
    // Check for error in response object
    if (data && typeof data === 'object' && !Array.isArray(data) && 'error' in data) {
      const errorData = data as { error?: unknown };
      if (errorData.error) {
        throw new Error(String(errorData.error));
      }
    }

    return data as T;
  } catch (error: unknown) {
    clearTimeout(timeoutId);
    
    const isTimeout = error instanceof Error && error.name === 'AbortError';

    // Retry on timeout, network errors, or 5xx errors
    if (retries > 0 && (isTimeout || error instanceof TypeError || (error instanceof Error && error.message.includes('HTTP 5')))) {
      const delay = INITIAL_RETRY_DELAY * Math.pow(2, MAX_RETRIES - retries);
      const reason = isTimeout ? 'timeout' : 'request failure';
      logger.warn(`Request ${reason}, retrying in ${delay}ms... (${retries} retries left)`, { component: 'deltaSyncService', retries, delay });
      
      await new Promise(resolve => setTimeout(resolve, delay));
      return fetchWithRetry<T>(url, options, retries - 1, timeout);
    }

    if (isTimeout) {
      throw new Error(`Request timeout after ${timeout}ms`);
    }

    throw error;
  }
}

/**
 * Check if delta sync is enabled
 */
export function isDeltaSyncEnabled(): boolean {
  return DELTA_SYNC_ENABLED && !!APPS_SCRIPT_URL;
}

/**
 * Get poll interval in milliseconds
 */
export function getPollIntervalMs(): number {
  return POLL_INTERVAL_MINUTES * 60 * 1000;
}

```

## `src/services/exportService.ts`

```typescript
import Papa from 'papaparse';

export interface ExportColumn<T = unknown> {
  key: string;
  label: string;
  accessor?: (item: T) => unknown;
}

export interface ExportOptions {
  filename?: string;
  includeHeaders?: boolean;
  delimiter?: string;
  includeMetadata?: boolean;
  metadata?: {
    tableName?: string;
    exportDate?: Date;
    filterInfo?: string;
    rowCount?: number;
  };
}

/**
 * Format a value for CSV export with proper formatting
 */
function formatValueForCSV(value: unknown): string {
  if (value === null || value === undefined) {
    return '';
  }

  // Handle dates
  if (value instanceof Date) {
    return value.toLocaleDateString('sv-SE') + ' ' + value.toLocaleTimeString('sv-SE', { hour: '2-digit', minute: '2-digit' });
  }

  // Handle numbers with proper formatting
  if (typeof value === 'number') {
    // Format with appropriate decimal places
    if (Number.isInteger(value)) {
      return value.toString();
    }
    // Round to 2 decimal places for non-integers
    return value.toFixed(2);
  }

  // Handle objects
  if (typeof value === 'object') {
    return JSON.stringify(value);
  }

  // Handle strings - escape quotes and wrap in quotes if contains delimiter or newline
  const stringValue = String(value);
  if (stringValue.includes(',') || stringValue.includes('\n') || stringValue.includes('"')) {
    return `"${stringValue.replace(/"/g, '""')}"`;
  }

  return stringValue;
}

/**
 * Exports data to CSV format using papaparse with improved formatting
 * @param data Array of data objects to export
 * @param columns Column definitions with key, label, and optional accessor function
 * @param options Export options (filename, includeHeaders, delimiter, includeMetadata)
 */
export function exportToCSV<T extends Record<string, unknown>>(
  data: T[],
  columns: ExportColumn<T>[],
  options: ExportOptions = {}
): void {
  const {
    filename = 'export',
    includeHeaders = true,
    delimiter = ',',
    includeMetadata = true,
    metadata,
  } = options;

  // Prepare CSV data
  const csvData: unknown[][] = [];

  // Add metadata header if requested
  if (includeMetadata && metadata) {
    const metaRows: string[] = [];
    if (metadata.tableName) {
      metaRows.push(`Table: ${metadata.tableName}`);
    }
    if (metadata.exportDate) {
      metaRows.push(`Export Date: ${metadata.exportDate.toLocaleString('sv-SE')}`);
    }
    if (metadata.filterInfo) {
      metaRows.push(`Filters: ${metadata.filterInfo}`);
    }
    if (metadata.rowCount !== undefined) {
      metaRows.push(`Rows: ${metadata.rowCount}`);
    }
    if (metaRows.length > 0) {
      csvData.push([metaRows.join(' | ')]);
      csvData.push([]); // Empty row separator
    }
  }

  // Add headers if requested
  if (includeHeaders) {
    csvData.push(columns.map((col) => col.label));
  }

  // Add data rows with formatted values
  data.forEach((item) => {
    const row = columns.map((col) => {
      let value: unknown;
      if (col.accessor) {
        value = col.accessor(item);
      } else {
        value = item[col.key];
      }
      return formatValueForCSV(value);
    });
    csvData.push(row);
  });

  // Convert to CSV string using papaparse
  const csv = Papa.unparse(csvData, {
    delimiter,
    newline: '\n',
    header: false, // We're handling headers manually
    quotes: true, // Quote fields that contain delimiter
    escapeChar: '"',
  });

  // Add UTF-8 BOM for Excel compatibility
  const BOM = '\uFEFF';
  const csvWithBOM = BOM + csv;

  // Create blob and download
  const blob = new Blob([csvWithBOM], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);

  link.setAttribute('href', url);
  link.setAttribute('download', `${filename}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Exports data to Excel format (CSV with .xlsx extension and proper formatting)
 * Note: For true Excel format, you would need the xlsx library.
 * This implementation creates a CSV file with .xlsx extension for compatibility.
 * @param data Array of data objects to export
 * @param columns Column definitions with key, label, and optional accessor function
 * @param options Export options (filename, includeHeaders)
 */
export function exportToExcel<T extends Record<string, unknown>>(
  data: T[],
  columns: ExportColumn<T>[],
  options: ExportOptions = {}
): void {
  const {
    filename = 'export',
    includeHeaders = true,
  } = options;

  // For now, we'll use CSV format with .xlsx extension
  // For true Excel format, install and use the 'xlsx' library
  exportToCSV(data, columns, {
    ...options,
    filename,
    includeHeaders,
    delimiter: ',',
  });

  // Note: To implement true Excel export, uncomment and use the following:
  /*
  import * as XLSX from 'xlsx';
  
  // Create workbook
  const wb = XLSX.utils.book_new();
  
  // Prepare data
  const wsData: unknown[][] = [];
  
  if (includeHeaders) {
    wsData.push(columns.map((col) => col.label));
  }
  
  data.forEach((item) => {
    const row = columns.map((col) => {
      if (col.accessor) {
        return col.accessor(item);
      }
      return item[col.key] ?? '';
    });
    wsData.push(row);
  });
  
  const ws = XLSX.utils.aoa_to_sheet(wsData);
  XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
  
  // Write file
  XLSX.writeFile(wb, `${filename}.xlsx`);
  */
}

/**
 * Exports filtered and sorted table data
 * @param allData Complete dataset
 * @param filteredData Filtered dataset (what user sees)
 * @param columns Column definitions
 * @param format Export format ('csv' | 'excel')
 * @param options Export options
 */
export function exportTableData<T extends Record<string, unknown>>(
  allData: T[],
  filteredData: T[],
  columns: ExportColumn<T>[],
  format: 'csv' | 'excel' = 'csv',
  options: ExportOptions = {}
): void {
  // Export the filtered data (what user sees)
  if (format === 'excel') {
    exportToExcel(filteredData, columns, options);
  } else {
    exportToCSV(filteredData, columns, options);
  }
}

/**
 * Shows a progress indicator for large exports
 * @param total Total number of items
 * @param current Current item being processed
 * @param onProgress Callback with progress percentage
 */
export function exportWithProgress<T extends Record<string, unknown>>(
  data: T[],
  columns: ExportColumn<T>[],
  format: 'csv' | 'excel' = 'csv',
  options: ExportOptions = {},
  onProgress?: (progress: number) => void
): Promise<void> {
  return new Promise((resolve) => {
    // For small datasets, export immediately
    if (data.length < 1000) {
      if (format === 'excel') {
        exportToExcel(data, columns, options);
      } else {
        exportToCSV(data, columns, options);
      }
      onProgress?.(100);
      resolve();
      return;
    }

    // For large datasets, show progress
    let processed = 0;
    const total = data.length;
    const batchSize = 100;

    const processBatch = (startIndex: number) => {
      const endIndex = Math.min(startIndex + batchSize, total);
      
      // Process batch
      for (let i = startIndex; i < endIndex; i++) {
        processed++;
        const progress = Math.round((processed / total) * 100);
        onProgress?.(progress);
      }

      if (endIndex < total) {
        // Process next batch asynchronously
        setTimeout(() => processBatch(endIndex), 0);
      } else {
        // All data processed, now export
        if (format === 'excel') {
          exportToExcel(data, columns, options);
        } else {
          exportToCSV(data, columns, options);
        }
        onProgress?.(100);
        resolve();
      }
    };

    processBatch(0);
  });
}

```

## `src/services/filterStorageService.ts`

```typescript
/**
 * Filter Storage Service
 * 
 * Provides functionality to save and load filter combinations in localStorage.
 * Filters are stored per table (tableId) and can be named for easy retrieval.
 */

import { FilterValues } from '../components/AdvancedFilters';
import { logger } from '../utils/logger';

/**
 * Saved filter interface
 * 
 * Represents a saved filter combination with metadata.
 */
export interface SavedFilter {
  /** Name of the saved filter */
  name: string;
  /** Filter values (column filters, search terms, etc.) */
  values: FilterValues;
  /** Timestamp when filter was created (milliseconds since epoch) */
  createdAt: number;
  /** ID of the table this filter belongs to */
  tableId: string;
}

// localStorage key prefix for filters
const FILTER_STORAGE_PREFIX = 'filters:';

/**
 * Get storage key for a specific filter
 */
function getFilterKey(tableId: string, filterName: string): string {
  return `${FILTER_STORAGE_PREFIX}${tableId}:${filterName}`;
}

/**
 * Get storage key for listing all filters for a table
 */
function getTableFiltersKey(tableId: string): string {
  return `${FILTER_STORAGE_PREFIX}${tableId}:list`;
}

/**
 * Save a filter with a name for a specific table
 * 
 * Saves a filter combination to localStorage with a name for easy retrieval.
 * If a filter with the same name already exists, it will be updated.
 * 
 * @param tableId - ID of the table this filter belongs to
 * @param name - Name to save the filter under
 * @param values - Filter values to save
 * @throws {Error} If tableId or name is missing, or localStorage quota is exceeded
 * 
 * @example
 * ```typescript
 * saveFilter('scoreBoard', 'High Score Stocks', {
 *   searchTerm: '',
 *   columnFilters: { score: { min: 80 } }
 * });
 * ```
 */
export function saveFilter(tableId: string, name: string, values: FilterValues): void {
  try {
    if (!tableId || !name || !name.trim()) {
      throw new Error('Table ID and filter name are required');
    }

    const filterKey = getFilterKey(tableId, name.trim());
    const savedFilter: SavedFilter = {
      name: name.trim(),
      values,
      createdAt: Date.now(),
      tableId,
    };

    localStorage.setItem(filterKey, JSON.stringify(savedFilter));

    // Update the list of saved filters for this table
    const savedFilters = getSavedFilters(tableId);
    const existingIndex = savedFilters.findIndex(f => f.name === name.trim());
    
    if (existingIndex >= 0) {
      // Update existing filter
      savedFilters[existingIndex] = savedFilter;
    } else {
      // Add new filter
      savedFilters.push(savedFilter);
    }

    // Save updated list
    const listKey = getTableFiltersKey(tableId);
    localStorage.setItem(listKey, JSON.stringify(savedFilters.map(f => f.name)));

    logger.debug(`Filter "${name}" saved for table "${tableId}"`, { component: 'filterStorageService', operation: 'saveFilter', tableId, name });
  } catch (error) {
    logger.error(`Error saving filter "${name}" for table "${tableId}"`, error, { component: 'filterStorageService', operation: 'saveFilter', tableId, name });
    if (error instanceof DOMException && error.name === 'QuotaExceededError') {
      throw new Error('LocalStorage quota exceeded. Please clear some saved filters.');
    }
    throw error;
  }
}

/**
 * Load a saved filter by name for a specific table
 * 
 * Retrieves a saved filter from localStorage by name.
 * 
 * @param tableId - ID of the table the filter belongs to
 * @param name - Name of the filter to load
 * @returns Filter values if found, null otherwise
 * 
 * @example
 * ```typescript
 * const filter = loadFilter('scoreBoard', 'High Score Stocks');
 * if (filter) {
 *   applyFilters(filter);
 * }
 * ```
 */
export function loadFilter(tableId: string, name: string): FilterValues | null {
  try {
    if (!tableId || !name) {
      return null;
    }

    const filterKey = getFilterKey(tableId, name);
    const stored = localStorage.getItem(filterKey);

    if (!stored) {
      return null;
    }

    const savedFilter: SavedFilter = JSON.parse(stored);
    
    // Verify it's for the correct table
    if (savedFilter.tableId !== tableId) {
      logger.warn(`Filter "${name}" belongs to different table. Expected "${tableId}", got "${savedFilter.tableId}"`, { component: 'filterStorageService', operation: 'loadFilter', tableId, name, expectedTableId: savedFilter.tableId });
      return null;
    }

    return savedFilter.values;
  } catch (error) {
    logger.error(`Error loading filter "${name}" for table "${tableId}"`, error, { component: 'filterStorageService', operation: 'loadFilter', tableId, name });
    return null;
  }
}

/**
 * Get all saved filters for a specific table
 * 
 * Retrieves all saved filters for a specific table, sorted by creation date
 * (newest first).
 * 
 * @param tableId - ID of the table to get filters for
 * @returns Array of saved filters, sorted by creation date (newest first)
 * 
 * @example
 * ```typescript
 * const filters = getSavedFilters('scoreBoard');
 * filters.forEach(filter => {
 *   console.log(filter.name, filter.createdAt);
 * });
 * ```
 */
export function getSavedFilters(tableId: string): SavedFilter[] {
  try {
    if (!tableId) {
      return [];
    }

    const listKey = getTableFiltersKey(tableId);
    const filterNamesJson = localStorage.getItem(listKey);

    if (!filterNamesJson) {
      return [];
    }

    const filterNames: string[] = JSON.parse(filterNamesJson);
    const savedFilters: SavedFilter[] = [];

    for (const name of filterNames) {
      const filterKey = getFilterKey(tableId, name);
      const stored = localStorage.getItem(filterKey);
      
      if (stored) {
        try {
          const savedFilter: SavedFilter = JSON.parse(stored);
          // Only include filters for this table
          if (savedFilter.tableId === tableId) {
            savedFilters.push(savedFilter);
          }
        } catch (error) {
          logger.error(`Error parsing filter "${name}"`, error, { component: 'filterStorageService', operation: 'getSavedFilters', tableId, name });
          // Remove corrupted filter from list
          deleteFilter(tableId, name);
        }
      }
    }

    // Sort by creation date (newest first)
    return savedFilters.sort((a, b) => b.createdAt - a.createdAt);
  } catch (error) {
    logger.error(`Error getting saved filters for table "${tableId}"`, error, { component: 'filterStorageService', operation: 'getSavedFilters', tableId });
    return [];
  }
}

/**
 * Delete a saved filter
 * 
 * Removes a saved filter from localStorage.
 * 
 * @param tableId - ID of the table the filter belongs to
 * @param name - Name of the filter to delete
 * 
 * @example
 * ```typescript
 * deleteFilter('scoreBoard', 'High Score Stocks');
 * ```
 */
export function deleteFilter(tableId: string, name: string): void {
  try {
    if (!tableId || !name) {
      return;
    }

    const filterKey = getFilterKey(tableId, name);
    localStorage.removeItem(filterKey);

    // Update the list of saved filters
    const listKey = getTableFiltersKey(tableId);
    const filterNamesJson = localStorage.getItem(listKey);

    if (filterNamesJson) {
      const filterNames: string[] = JSON.parse(filterNamesJson);
      const updatedNames = filterNames.filter(n => n !== name);
      
      if (updatedNames.length > 0) {
        localStorage.setItem(listKey, JSON.stringify(updatedNames));
      } else {
        localStorage.removeItem(listKey);
      }
    }

    logger.debug(`Filter "${name}" deleted for table "${tableId}"`, { component: 'filterStorageService', operation: 'deleteFilter', tableId, name });
  } catch (error) {
    logger.error(`Error deleting filter "${name}" for table "${tableId}"`, error, { component: 'filterStorageService', operation: 'deleteFilter', tableId, name });
  }
}

/**
 * Clear all saved filters for a specific table
 * 
 * Removes all saved filters for a specific table from localStorage.
 * 
 * @param tableId - ID of the table to clear filters for
 * 
 * @example
 * ```typescript
 * clearAllFilters('scoreBoard');
 * ```
 */
export function clearAllFilters(tableId: string): void {
  try {
    if (!tableId) {
      return;
    }

    const savedFilters = getSavedFilters(tableId);
    for (const filter of savedFilters) {
      const filterKey = getFilterKey(tableId, filter.name);
      localStorage.removeItem(filterKey);
    }

    const listKey = getTableFiltersKey(tableId);
    localStorage.removeItem(listKey);

    logger.debug(`All filters cleared for table "${tableId}"`, { component: 'filterStorageService', operation: 'clearAllFilters', tableId });
  } catch (error) {
    logger.error(`Error clearing filters for table "${tableId}"`, error, { component: 'filterStorageService', operation: 'clearAllFilters', tableId });
  }
}


```

## `src/services/filterTemplateService.ts`

```typescript
/**
 * Filter Template Service
 * 
 * Provides functionality to save and load filter templates.
 * Templates are predefined filter combinations that can be quickly applied.
 */

import { FilterValues } from '../types/filters';
import { saveFilter, loadFilter, getSavedFilters, SavedFilter } from './filterStorageService';
import { logger } from '../utils/logger';

export interface FilterTemplate {
  id: string;
  name: string;
  description?: string;
  filter: FilterValues;
  category?: string;
  isSystem?: boolean; // System templates cannot be deleted
}

const SYSTEM_TEMPLATES_KEY = 'filterTemplates:system';
const USER_TEMPLATES_KEY = 'filterTemplates:user';

/**
 * Get system filter templates (predefined)
 */
export function getSystemTemplates(): FilterTemplate[] {
  return [
    {
      id: 'high-score',
      name: 'High Score Stocks',
      description: 'Stocks with score > 80',
      filter: { score: { min: 80 } },
      category: 'score',
      isSystem: true,
    },
    {
      id: 'medium-score',
      name: 'Medium Score Stocks',
      description: 'Stocks with score 50-80',
      filter: { score: { min: 50, max: 80 } },
      category: 'score',
      isSystem: true,
    },
    {
      id: 'low-score',
      name: 'Low Score Stocks',
      description: 'Stocks with score < 50',
      filter: { score: { max: 50 } },
      category: 'score',
      isSystem: true,
    },
    {
      id: 'low-pe',
      name: 'Low P/E Stocks',
      description: 'Stocks with P/E < 10',
      filter: { pe: { max: 10 } },
      category: 'pe',
      isSystem: true,
    },
    {
      id: 'high-pe',
      name: 'High P/E Stocks',
      description: 'Stocks with P/E > 20',
      filter: { pe: { min: 20 } },
      category: 'pe',
      isSystem: true,
    },
  ];
}

/**
 * Get user-created templates for a table
 */
export function getUserTemplates(tableId: string): FilterTemplate[] {
  try {
    const savedFilters = getSavedFilters(tableId);
    return savedFilters
      .filter((filter) => filter.name.startsWith('template:'))
      .map((filter) => ({
        id: filter.name,
        name: filter.name.replace('template:', ''),
        filter: filter.values,
        category: 'user',
        isSystem: false,
      }));
  } catch (error) {
    logger.error('Error getting user templates', error, {
      component: 'filterTemplateService',
      operation: 'getUserTemplates',
      tableId,
    });
    return [];
  }
}

/**
 * Get all templates (system + user) for a table
 */
export function getAllTemplates(tableId: string): FilterTemplate[] {
  const systemTemplates = getSystemTemplates();
  const userTemplates = getUserTemplates(tableId);
  return [...systemTemplates, ...userTemplates];
}

/**
 * Save a user template
 */
export function saveTemplate(tableId: string, name: string, filter: FilterValues, description?: string): void {
  try {
    // Prefix with 'template:' to distinguish from regular saved filters
    const templateName = `template:${name}`;
    saveFilter(tableId, templateName, filter);
    logger.debug(`Template saved: ${templateName}`, {
      component: 'filterTemplateService',
      operation: 'saveTemplate',
      tableId,
      name,
    });
  } catch (error) {
    logger.error('Error saving template', error, {
      component: 'filterTemplateService',
      operation: 'saveTemplate',
      tableId,
      name,
    });
    throw error;
  }
}

/**
 * Load a template
 */
export function loadTemplate(tableId: string, templateId: string): FilterValues | null {
  try {
    // Check if it's a system template
    const systemTemplates = getSystemTemplates();
    const systemTemplate = systemTemplates.find((t) => t.id === templateId);
    if (systemTemplate) {
      return systemTemplate.filter;
    }

    // Check user templates
    const templateName = templateId.startsWith('template:') ? templateId : `template:${templateId}`;
    return loadFilter(tableId, templateName);
  } catch (error) {
    logger.error('Error loading template', error, {
      component: 'filterTemplateService',
      operation: 'loadTemplate',
      tableId,
      templateId,
    });
    return null;
  }
}

/**
 * Delete a user template
 */
export function deleteTemplate(tableId: string, templateId: string): void {
  try {
    // System templates cannot be deleted
    const systemTemplates = getSystemTemplates();
    if (systemTemplates.find((t) => t.id === templateId)) {
      throw new Error('Cannot delete system template');
    }

    const templateName = templateId.startsWith('template:') ? templateId : `template:${templateId}`;
    const savedFilters = getSavedFilters(tableId);
    const filter = savedFilters.find((f) => f.name === templateName);
    if (filter) {
      // Use the existing deleteFilter function
      const { deleteFilter } = require('./filterStorageService');
      deleteFilter(tableId, templateName);
    }
  } catch (error) {
    logger.error('Error deleting template', error, {
      component: 'filterTemplateService',
      operation: 'deleteTemplate',
      tableId,
      templateId,
    });
    throw error;
  }
}

```

## `src/services/firestoreCacheService.ts`

```typescript
/**
 * Firestore Cache Service
 * 
 * Provides caching functionality with TTL (Time To Live) using Firebase Firestore.
 * Cache is shared between all authenticated users.
 * Uses Firestore collection "appCache" for centralized cache storage.
 */

import { 
  doc, 
  getDoc, 
  setDoc, 
  deleteDoc,
  collection,
  query,
  getDocs,
  serverTimestamp,
  Timestamp 
} from 'firebase/firestore';
import { db } from '../config/firebase';
import { logger } from '../utils/logger';
import { DeltaCacheEntry } from './cacheService';

// Re-export CACHE_KEYS for convenience
export { CACHE_KEYS } from './cacheKeys';
import { CACHE_KEYS } from './cacheKeys';

// Default TTL: 30 minutes
const DEFAULT_TTL_MINUTES = parseInt(import.meta.env.VITE_CACHE_DEFAULT_TTL_MINUTES || '30', 10);
export const DEFAULT_TTL = DEFAULT_TTL_MINUTES * 60 * 1000;

// Firestore collection name
const CACHE_COLLECTION = 'appCache';
const VIEWDATA_COLLECTION = 'viewData';
const CACHE_PREFIX = 'cache:';

/** Migration mode: dual-write (write both), dual-read (read viewData first, fallback appCache), cutover (viewData only) */
export const VIEWDATA_MIGRATION_MODE = (
  import.meta.env.VITE_VIEWDATA_MIGRATION_MODE || 'dual-read'
) as 'dual-write' | 'dual-read' | 'cutover';

/** Cache keys for view-docs; cutover skips appCache writes for these */
const VIEW_CACHE_KEYS = new Set([
  CACHE_KEYS.SCORE_BOARD,
  CACHE_KEYS.BENJAMIN_GRAHAM,
  CACHE_KEYS.PE_INDUSTRY,
  CACHE_KEYS.SMA,
]);

/**
 * Returns true when appCache write should be blocked (cutover mode + view-doc key).
 * currency_rates_usd and other non-view-doc keys always return false.
 */
export function shouldBlockAppCacheWriteInCutover(key: string, mode: string): boolean {
  return mode === 'cutover' && VIEW_CACHE_KEYS.has(key);
}

/**
 * Firestore cache entry interface (TTL-based)
 */
interface FirestoreCacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
  lastUpdated?: Timestamp;
  version?: number; // Optional, for delta sync compatibility
  lastSnapshotAt?: number;
}

/**
 * Get document reference for cache key
 */
function getCacheDocRef(key: string) {
  // Remove 'cache:' prefix if present for cleaner document IDs
  const docId = key.startsWith(CACHE_PREFIX) ? key.slice(CACHE_PREFIX.length) : key;
  return doc(db, CACHE_COLLECTION, docId);
}

/**
 * Get viewData document reference
 */
function getViewDataDocRef(viewId: string) {
  return doc(db, VIEWDATA_COLLECTION, viewId);
}

/**
 * ViewData document structure (stored in Firestore)
 */
export interface ViewDataPayload<T = unknown> {
  data: T;
  timestamp: number;
  ttl: number;
  schemaVersion: number;
  source: string;
  updatedBy: string;
  meta?: { lastSnapshotAt?: number };
}

/**
 * Get view data from viewData/{viewId}
 */
export async function getViewData<T>(viewId: string): Promise<ViewDataPayload<T> | null> {
  try {
    const docRef = getViewDataDocRef(viewId);
    const docSnap = await getDoc(docRef);
    if (!docSnap.exists()) return null;
    const docData = docSnap.data();
    const now = Date.now();
    if (!docData.data || typeof docData.timestamp !== 'number' || typeof docData.ttl !== 'number') {
      logger.warn('Invalid viewData structure', { component: 'firestoreCacheService', operation: 'getViewData', viewId });
      return null;
    }
    const age = now - docData.timestamp;
    if (age > docData.ttl) return null;
    return docData as ViewDataPayload<T>;
  } catch (error: unknown) {
    const isPermissionError =
      (error as { code?: string })?.code === 'permission-denied' ||
      ((error as { name?: string; code?: string })?.name === 'FirebaseError' && (error as { code?: string })?.code === 'permission-denied');
    logger.warn(`Failed to get viewData for "${viewId}"`, {
      component: 'firestoreCacheService',
      operation: 'getViewData',
      viewId,
      error,
      permissionDenied: isPermissionError,
    });
    return null;
  }
}

/**
 * Set view data to viewData/{viewId}
 */
export async function setViewData<T>(
  viewId: string,
  data: T,
  options?: { ttl?: number; source?: string; updatedBy?: string }
): Promise<void> {
  const ttl = options?.ttl ?? DEFAULT_TTL;
  const now = Date.now();
  const payload: ViewDataPayload<T> = {
    data,
    timestamp: now,
    ttl,
    schemaVersion: 1,
    source: options?.source ?? 'client-refresh',
    updatedBy: options?.updatedBy ?? 'system',
  };
  try {
    const docRef = getViewDataDocRef(viewId);
    await setDoc(docRef, payload, { merge: false });
    logger.info('viewData saved', { component: 'firestoreCacheService', operation: 'setViewData', viewId });
  } catch (error) {
    logger.error(`Failed to set viewData for "${viewId}"`, { component: 'firestoreCacheService', operation: 'setViewData', viewId, error });
    throw error;
  }
}

/**
 * Get view data with dual-read fallback to appCache when in dual-read mode
 * - dual-write: read from appCache only (fallback)
 * - dual-read: read viewData first, fallback to appCache if missing/denied
 * - cutover: read viewData only, no fallback
 */
export async function getViewDataWithFallback<T>(
  viewId: string,
  options: { fallback: () => Promise<T | null> }
): Promise<{ data: T; source: 'viewData' | 'appCache' } | null> {
  const mode = VIEWDATA_MIGRATION_MODE;
  if (mode === 'dual-write') {
    const fallbackData = await options.fallback();
    if (fallbackData) {
      logger.info('CACHE_SOURCE=appCache', { component: 'firestoreCacheService', operation: 'getViewDataWithFallback', viewId, mode });
      return { data: fallbackData, source: 'appCache' };
    }
    return null;
  }
  const viewPayload = await getViewData<T>(viewId);
  if (viewPayload) {
    logger.info('CACHE_SOURCE=viewData', { component: 'firestoreCacheService', operation: 'getViewDataWithFallback', viewId, mode });
    return { data: viewPayload.data, source: 'viewData' };
  }
  if (mode === 'cutover') return null;
  const fallbackData = await options.fallback();
  if (fallbackData) {
    logger.info('CACHE_SOURCE=appCache', { component: 'firestoreCacheService', operation: 'getViewDataWithFallback', viewId, mode });
    return { data: fallbackData, source: 'appCache' };
  }
  return null;
}

/**
 * Get cached data if it exists and is not expired
 * 
 * Retrieves cached data from Firestore. Supports both TTL-based and
 * version-based (delta sync) cache entries. Automatically checks expiration.
 * 
 * @template T - The type of data being retrieved
 * @param key - Cache key to retrieve data for
 * @returns Promise resolving to cached data, or null if not found, expired, or invalid
 * 
 * @example
 * ```typescript
 * // Check cache before fetching
 * const cachedData = await getCachedData<BenjaminGrahamData[]>(CACHE_KEYS.BENJAMIN_GRAHAM);
 * if (cachedData) {
 *   // Use cached data immediately
 *   setData(cachedData);
 * } else {
 *   // Fetch fresh data
 *   const freshData = await fetchBenjaminGrahamData();
 *   await setCachedData(CACHE_KEYS.BENJAMIN_GRAHAM, freshData);
 * }
 * ```
 */
export async function getCachedData<T>(key: string): Promise<T | null> {
  try {
    const docRef = getCacheDocRef(key);
    const docSnap = await getDoc(docRef);
    
    if (!docSnap.exists()) {
      return null;
    }
    
    const docData = docSnap.data();
    const now = Date.now();
    
    // Check if it's a delta cache entry (has version property)
    if (docData.version !== undefined) {
      const entry = docData as FirestoreCacheEntry<T>;
      
      // Check TTL fallback if provided
      if (entry.ttl && entry.timestamp) {
        const age = now - entry.timestamp;
        if (age > entry.ttl) {
          // Cache expired, try to delete it (may fail for non-editor users)
          await deleteDoc(docRef).catch(err => {
            // Only log if it's not a permission error (expected for non-editor users)
            const isPermissionError = err?.code === 'permission-denied' || 
                                      (err?.name === 'FirebaseError' && err?.code === 'permission-denied');
            if (!isPermissionError) {
              logger.warn('Failed to delete expired cache entry', { 
                component: 'firestoreCacheService', 
                operation: 'getCachedData', 
                key, 
                error: err 
              });
            }
          });
          return null;
        }
      }
      
      return entry.data;
    } else if (docData.timestamp && docData.ttl) {
      // TTL-based cache entry
      const entry = docData as FirestoreCacheEntry<T>;
      const age = now - entry.timestamp;
      
      // Check if cache is expired
      if (age > entry.ttl) {
        // Cache expired, try to delete it (may fail for non-editor users)
        await deleteDoc(docRef).catch(err => {
          // Only log if it's not a permission error (expected for non-editor users)
          const isPermissionError = err?.code === 'permission-denied' || 
                                    (err?.name === 'FirebaseError' && err?.code === 'permission-denied');
          if (!isPermissionError) {
            logger.warn('Failed to delete expired cache entry', { 
              component: 'firestoreCacheService', 
              operation: 'getCachedData', 
              key, 
              error: err 
            });
          }
        });
        return null;
      }
      
      return entry.data;
    }
    
    // Invalid cache entry structure
    logger.warn('Invalid cache entry structure', { 
      component: 'firestoreCacheService', 
      operation: 'getCachedData', 
      key 
    });
    return null;
  } catch (error) {
    logger.warn(`Failed to get cached data for key "${key}"`, { 
      component: 'firestoreCacheService', 
      operation: 'getCachedData', 
      key, 
      error 
    });
    return null;
  }
}

/**
 * Get delta cache entry with version information
 * 
 * Retrieves a delta cache entry including version information for delta sync.
 * This is used to determine the last known version when requesting incremental updates.
 * 
 * @template T - The type of data being retrieved
 * @param key - Cache key to retrieve delta cache entry for
 * @returns Promise resolving to delta cache entry with version info, or null if not found or expired
 */
export async function getDeltaCacheEntry<T>(key: string): Promise<DeltaCacheEntry<T> | null> {
  try {
    const docRef = getCacheDocRef(key);
    const docSnap = await getDoc(docRef);
    
    if (!docSnap.exists()) {
      return null;
    }
    
    const docData = docSnap.data();
    const now = Date.now();
    
    // Check if it's a delta cache entry
    if (docData.version !== undefined) {
      const entry = docData as FirestoreCacheEntry<T>;
      
      // Check TTL fallback if provided
      if (entry.ttl && entry.timestamp) {
        const age = now - entry.timestamp;
        if (age > entry.ttl) {
          // Try to delete expired cache (may fail for non-editor users - that's OK)
          await deleteDoc(docRef).catch(() => {
            // Silently ignore deletion errors (permission errors are expected for non-editor users)
          });
          return null;
        }
      }
      
      return {
        data: entry.data,
        version: entry.version || 0,
        lastSnapshotAt: entry.lastSnapshotAt || entry.timestamp || now,
        lastUpdated: entry.timestamp || now,
        timestamp: entry.timestamp,
        ttl: entry.ttl,
      };
    }
    
    return null;
  } catch (error) {
    logger.warn(`Failed to get delta cache entry for key "${key}"`, { 
      component: 'firestoreCacheService', 
      operation: 'getDeltaCacheEntry', 
      key, 
      error 
    });
    return null;
  }
}

/**
 * Get last version from cache
 * 
 * Convenience function to get the last version number from a delta cache entry.
 * Returns 0 if no cache entry exists, indicating a full sync is needed.
 * 
 * @param key - Cache key to get last version for
 * @returns Promise resolving to last version number (changeId), or 0 if not found
 */
export async function getLastVersion(key: string): Promise<number> {
  const entry = await getDeltaCacheEntry(key);
  return entry?.version || 0;
}

/**
 * Set data in cache with TTL
 * 
 * Stores data in Firestore with a time-to-live (TTL) expiration.
 * 
 * @template T - The type of data being cached
 * @param key - Cache key to store data under
 * @param data - Data to cache
 * @param ttl - Time to live in milliseconds (default: DEFAULT_TTL)
 * 
 * @example
 * ```typescript
 * const data = await fetchBenjaminGrahamData();
 * await setCachedData(CACHE_KEYS.BENJAMIN_GRAHAM, data, DEFAULT_TTL);
 * ```
 */
export async function setCachedData<T>(key: string, data: T, ttl: number = DEFAULT_TTL): Promise<void> {
  // cutover: block appCache writes for view-docs; currency_rates_usd always allowed
  if (shouldBlockAppCacheWriteInCutover(key, VIEWDATA_MIGRATION_MODE)) {
    logger.info('CUTOVER_BLOCK_APP_CACHE_WRITE', { component: 'firestoreCacheService', operation: 'setCachedData', key });
    return;
  }
  try {
    const docRef = getCacheDocRef(key);
    const now = Date.now();
    
    // Determine data size for logging
    const dataSize = Array.isArray(data) ? data.length : 'unknown';
    
    logger.debug('Saving data to Firestore cache', { 
      component: 'firestoreCacheService', 
      operation: 'setCachedData', 
      key,
      dataSize,
      ttlMinutes: Math.round(ttl / 60000)
    });
    
    const entry: FirestoreCacheEntry<T> = {
      data,
      timestamp: now,
      ttl,
      lastUpdated: serverTimestamp() as any, // Firestore will convert this
    };
    
    await setDoc(docRef, entry, { merge: false });
    
    logger.info('Data saved to Firestore cache successfully', { 
      component: 'firestoreCacheService', 
      operation: 'setCachedData', 
      key,
      dataSize,
      ttlMinutes: Math.round(ttl / 60000)
    });
  } catch (error) {
    logger.error(`Failed to set cached data for key "${key}"`, { 
      component: 'firestoreCacheService', 
      operation: 'setCachedData', 
      key, 
      error 
    });
    throw error;
  }
}

/**
 * Set delta cache entry with version information
 * 
 * Stores data in Firestore with version information for delta sync support.
 * Tracks whether the entry is a full snapshot or an incremental update.
 * 
 * @template T - The type of data being cached
 * @param key - Cache key to store data under
 * @param data - Data to cache
 * @param version - Current version (changeId) from the server
 * @param isSnapshot - Whether this is a full snapshot (true) or incremental update (false)
 * @param ttl - TTL in ms (default: DEFAULT_TTL). Delta entries expire so cache can be pruned.
 */
export async function setDeltaCacheEntry<T>(
  key: string,
  data: T,
  version: number,
  isSnapshot: boolean = false,
  ttl?: number
): Promise<void> {
  try {
    const docRef = getCacheDocRef(key);
    const now = Date.now();
    
    // Get existing entry to preserve lastSnapshotAt if not a snapshot
    const existing = await getDeltaCacheEntry<T>(key);
    
    const effectiveTtl = ttl ?? DEFAULT_TTL;
    const entry: FirestoreCacheEntry<T> = {
      data,
      version,
      timestamp: now,
      ttl: effectiveTtl,
      lastSnapshotAt: isSnapshot ? now : (existing?.lastSnapshotAt || now),
      lastUpdated: serverTimestamp() as any, // Firestore will convert this
    };
    
    await setDoc(docRef, entry, { merge: false });
  } catch (error) {
    logger.warn(`Failed to set delta cache entry for key "${key}"`, { 
      component: 'firestoreCacheService', 
      operation: 'setDeltaCacheEntry', 
      key, 
      error 
    });
    throw error;
  }
}

/**
 * Get cache age in milliseconds
 * 
 * Returns the age of a cache entry in milliseconds, or null if the cache
 * doesn't exist or is invalid.
 * 
 * @param key - Cache key to get age for
 * @returns Promise resolving to cache age in milliseconds, or null if not found
 */
export async function getCacheAge(key: string): Promise<number | null> {
  try {
    const docRef = getCacheDocRef(key);
    const docSnap = await getDoc(docRef);
    
    if (!docSnap.exists()) {
      return null;
    }
    
    const docData = docSnap.data();
    const now = Date.now();
    
    // Check if it's a delta cache entry
    if (docData.version !== undefined) {
      const entry = docData as FirestoreCacheEntry<unknown>;
      if (entry.timestamp) {
        return now - entry.timestamp;
      }
      // Fallback to lastUpdated if timestamp not available
      if (entry.lastUpdated) {
        const lastUpdated = entry.lastUpdated as Timestamp;
        return now - lastUpdated.toMillis();
      }
      return null;
    } else if (docData.timestamp) {
      // TTL-based cache entry
      return now - docData.timestamp;
    }
    
    return null;
  } catch (error) {
    logger.warn(`Failed to get cache age for key "${key}"`, { 
      component: 'firestoreCacheService', 
      operation: 'getCacheAge', 
      key, 
      error 
    });
    return null;
  }
}

/**
 * Generic helper: migrate a wrongly named cache document to the correct document ID.
 * Used for one-time migrations (e.g. eIndustry -> peIndustry) from substring(8) bug.
 * Not exported.
 */
async function migrateCacheDocument(
  oldDocId: string,
  cacheKey: string,
  migrationFlag: string
): Promise<boolean> {
  try {
    if (localStorage.getItem(migrationFlag) === 'true') {
      return true;
    }
  } catch (error) {
    logger.warn('Could not check migration flag', {
      component: 'firestoreCacheService',
      operation: 'migrateCacheDocument',
      oldDocId,
      migrationFlag,
      error,
    });
  }

  try {
    const oldRef = doc(db, CACHE_COLLECTION, oldDocId);
    const oldSnap = await getDoc(oldRef);

    if (!oldSnap.exists()) {
      try {
        localStorage.setItem(migrationFlag, 'true');
      } catch {
        /* ignore */
      }
      return true;
    }

    const oldData = oldSnap.data() as FirestoreCacheEntry<unknown>;
    const correctRef = getCacheDocRef(cacheKey);
    const correctSnap = await getDoc(correctRef);

    if (correctSnap.exists()) {
      try {
        await deleteDoc(oldRef);
        logger.info('Deleted old cache document (correct document already exists)', {
          component: 'firestoreCacheService',
          operation: 'migrateCacheDocument',
          oldDocId,
          cacheKey,
        });
      } catch (deleteError: unknown) {
        const err = deleteError as { code?: string; name?: string };
        const isPermissionError =
          err?.code === 'permission-denied' ||
          (err?.name === 'FirebaseError' && err?.code === 'permission-denied');
        if (isPermissionError) {
          logger.warn('Could not delete old document (insufficient permissions). Migration will be retried later.', {
            component: 'firestoreCacheService',
            operation: 'migrateCacheDocument',
            oldDocId,
          });
          return true;
        }
        logger.error('Failed to delete old cache document', deleteError, {
          component: 'firestoreCacheService',
          operation: 'migrateCacheDocument',
          oldDocId,
          cacheKey,
        });
        return false;
      }
    } else {
      // cutover: no appCache writes for view-docs (mark migration done)
      if (VIEWDATA_MIGRATION_MODE === 'cutover' && VIEW_CACHE_KEYS.has(cacheKey)) {
        try {
          localStorage.setItem(migrationFlag, 'true');
        } catch {
          /* ignore */
        }
        return true;
      }
      try {
        if (oldData.version !== undefined) {
          await setDeltaCacheEntry(
            cacheKey,
            oldData.data,
            oldData.version ?? 0,
            oldData.lastSnapshotAt !== undefined,
            oldData.ttl
          );
        } else {
          await setCachedData(cacheKey, oldData.data, oldData.ttl ?? DEFAULT_TTL);
        }

        try {
          await deleteDoc(oldRef);
          logger.info('Migrated cache document to correct ID and deleted old document', {
            component: 'firestoreCacheService',
            operation: 'migrateCacheDocument',
            oldDocId,
            cacheKey,
          });
        } catch (deleteError: unknown) {
          const err = deleteError as { code?: string; name?: string };
          const isPermissionError =
            err?.code === 'permission-denied' ||
            (err?.name === 'FirebaseError' && err?.code === 'permission-denied');
          if (isPermissionError) {
            logger.warn('Migrated but could not delete old document (insufficient permissions). Migration will be retried later.', {
              component: 'firestoreCacheService',
              operation: 'migrateCacheDocument',
              oldDocId,
              cacheKey,
            });
            return true;
          }
          logger.error('Migrated but failed to delete old document', deleteError, {
            component: 'firestoreCacheService',
            operation: 'migrateCacheDocument',
            oldDocId,
            cacheKey,
          });
          return true;
        }
      } catch (copyError) {
        logger.error('Failed to copy cache document to correct ID', copyError, {
          component: 'firestoreCacheService',
          operation: 'migrateCacheDocument',
          oldDocId,
          cacheKey,
        });
        return false;
      }
    }

    try {
      localStorage.setItem(migrationFlag, 'true');
    } catch {
      /* ignore */
    }
    return true;
  } catch (error) {
    logger.error('Failed to migrate cache document', error, {
      component: 'firestoreCacheService',
      operation: 'migrateCacheDocument',
      oldDocId,
      cacheKey,
      migrationFlag,
    });
    return false;
  }
}

/**
 * Migrate cache from coreBoard to scoreBoard
 * 
 * This function migrates data from the incorrectly named 'coreBoard' document
 * to the correct 'scoreBoard' document in Firestore. This is a one-time migration
 * that runs automatically on app start.
 * 
 * Migration logic:
 * - If coreBoard exists and scoreBoard doesn't: copy coreBoard to scoreBoard, then delete coreBoard
 * - If both exist: keep scoreBoard (it's the correct one), delete coreBoard
 * - If neither exists: nothing to migrate
 * 
 * @returns Promise resolving to true if migration succeeded or was already done, false on error
 */
export async function migrateCoreBoardToScoreBoard(): Promise<boolean> {
  const MIGRATION_FLAG = 'firestore:migration:coreBoard-to-scoreBoard';
  
  // Check if migration already completed
  try {
    if (localStorage.getItem(MIGRATION_FLAG) === 'true') {
      return true; // Already migrated
    }
  } catch (error) {
    // If localStorage is not available, continue anyway
    logger.warn('Could not check migration flag', {
      component: 'firestoreCacheService',
      operation: 'migrateCoreBoardToScoreBoard',
      error,
    });
  }

  try {
    const coreBoardRef = doc(db, CACHE_COLLECTION, 'coreBoard');
    const scoreBoardRef = doc(db, CACHE_COLLECTION, 'scoreBoard');
    
    // Check if coreBoard exists
    const coreBoardSnap = await getDoc(coreBoardRef);
    
    if (!coreBoardSnap.exists()) {
      // No coreBoard to migrate, mark as done
      try {
        localStorage.setItem(MIGRATION_FLAG, 'true');
      } catch {
        // Ignore localStorage errors
      }
      return true; // Nothing to migrate
    }

    const coreBoardData = coreBoardSnap.data() as FirestoreCacheEntry<unknown>;
    
    // Check if scoreBoard already exists
    const scoreBoardSnap = await getDoc(scoreBoardRef);
    
    if (scoreBoardSnap.exists()) {
      // scoreBoard already exists (correct name), just delete coreBoard
      try {
        await deleteDoc(coreBoardRef);
        logger.info('Deleted old coreBoard document (scoreBoard already exists)', {
          component: 'firestoreCacheService',
          operation: 'migrateCoreBoardToScoreBoard',
        });
      } catch (deleteError: any) {
        // Check if it's a permission error
        const isPermissionError = deleteError?.code === 'permission-denied' || 
                                  (deleteError?.name === 'FirebaseError' && deleteError?.code === 'permission-denied');
        
        if (isPermissionError) {
          logger.warn('Could not delete coreBoard (insufficient permissions). Migration will be retried later.', {
            component: 'firestoreCacheService',
            operation: 'migrateCoreBoardToScoreBoard',
          });
          // Don't set flag - allow retry later
          return true; // Not a critical error
        }
        
        // Other error
        logger.error('Failed to delete coreBoard document', deleteError, {
          component: 'firestoreCacheService',
          operation: 'migrateCoreBoardToScoreBoard',
        });
        return false;
      }
    } else {
      // scoreBoard doesn't exist, copy coreBoard to scoreBoard
      // cutover: no appCache writes for view-docs
      if (VIEWDATA_MIGRATION_MODE === 'cutover') {
        try {
          localStorage.setItem(MIGRATION_FLAG, 'true');
        } catch {
          /* ignore */
        }
        return true;
      }
      try {
        // Determine cache type and copy accordingly
        if (coreBoardData.version !== undefined) {
          // Delta cache entry
          await setDeltaCacheEntry(
            CACHE_KEYS.SCORE_BOARD,
            coreBoardData.data,
            coreBoardData.version || 0,
            coreBoardData.lastSnapshotAt !== undefined,
            coreBoardData.ttl
          );
        } else {
          // TTL-based cache entry
          await setCachedData(
            CACHE_KEYS.SCORE_BOARD,
            coreBoardData.data,
            coreBoardData.ttl || DEFAULT_TTL
          );
        }

        // Now delete coreBoard
        try {
          await deleteDoc(coreBoardRef);
          logger.info('Migrated coreBoard to scoreBoard and deleted old document', {
            component: 'firestoreCacheService',
            operation: 'migrateCoreBoardToScoreBoard',
          });
        } catch (deleteError: any) {
          // Check if it's a permission error
          const isPermissionError = deleteError?.code === 'permission-denied' || 
                                    (deleteError?.name === 'FirebaseError' && deleteError?.code === 'permission-denied');
          
          if (isPermissionError) {
            logger.warn('Migrated coreBoard to scoreBoard but could not delete old document (insufficient permissions). Migration will be retried later.', {
              component: 'firestoreCacheService',
              operation: 'migrateCoreBoardToScoreBoard',
            });
            // Don't set flag - allow retry later
            return true; // Migration succeeded, deletion can be done later
          }
          
          // Other error
          logger.error('Migrated coreBoard to scoreBoard but failed to delete old document', deleteError, {
            component: 'firestoreCacheService',
            operation: 'migrateCoreBoardToScoreBoard',
          });
          // Still return true since migration succeeded
        }
      } catch (copyError) {
        logger.error('Failed to copy coreBoard to scoreBoard', copyError, {
          component: 'firestoreCacheService',
          operation: 'migrateCoreBoardToScoreBoard',
        });
        return false;
      }
    }
    
    // Mark migration as complete
    try {
      localStorage.setItem(MIGRATION_FLAG, 'true');
    } catch {
      // Ignore localStorage errors
    }
    
    return true;
  } catch (error) {
    logger.error('Failed to migrate coreBoard to scoreBoard', error, {
      component: 'firestoreCacheService',
      operation: 'migrateCoreBoardToScoreBoard',
    });
    return false;
  }
}

/**
 * Migrate eIndustry -> peIndustry (truncated cache doc ID from substring(8) bug).
 */
export async function migrateEIndustryToPeIndustry(): Promise<boolean> {
  return migrateCacheDocument(
    'eIndustry',
    CACHE_KEYS.PE_INDUSTRY,
    'firestore:migration:eIndustry-to-peIndustry'
  );
}

/**
 * Migrate enjaminGraham -> benjaminGraham (truncated cache doc ID from substring(8) bug).
 */
export async function migrateEnjaminGrahamToBenjaminGraham(): Promise<boolean> {
  return migrateCacheDocument(
    'enjaminGraham',
    CACHE_KEYS.BENJAMIN_GRAHAM,
    'firestore:migration:enjaminGraham-to-benjaminGraham'
  );
}

/**
 * Migrate ma -> sma (truncated cache doc ID from substring(8) bug).
 */
export async function migrateMaToSma(): Promise<boolean> {
  return migrateCacheDocument('ma', CACHE_KEYS.SMA, 'firestore:migration:ma-to-sma');
}

/**
 * Run all truncated-cache-document migrations (eIndustry, enjaminGraham, ma).
 * Call at app start after auth, alongside migrateCoreBoardToScoreBoard.
 */
export async function runTruncatedCacheMigrations(): Promise<void> {
  await migrateEIndustryToPeIndustry();
  await migrateEnjaminGrahamToBenjaminGraham();
  await migrateMaToSma();
}

/** ViewIds for viewData collection (used when clearing all) */
const VIEWDATA_VIEW_IDS = ['score', 'score-board', 'entry-exit-benjamin-graham', 'fundamental-pe-industry', 'threshold-industry'] as const;

/**
 * Clear viewData docs (admin only, for refresh)
 */
async function clearViewDataDocs(): Promise<void> {
  for (const viewId of VIEWDATA_VIEW_IDS) {
    try {
      const docRef = getViewDataDocRef(viewId);
      await deleteDoc(docRef);
      logger.debug('Cleared viewData doc', { component: 'firestoreCacheService', operation: 'clearViewDataDocs', viewId });
    } catch (err) {
      const isPerm = (err as { code?: string })?.code === 'permission-denied';
      if (!isPerm) logger.warn('Failed to clear viewData doc', { component: 'firestoreCacheService', operation: 'clearViewDataDocs', viewId, error: err });
    }
  }
}

/**
 * Clear cache for a specific key or all cache entries
 * 
 * Removes cache entries from Firestore. If a key is provided, only that
 * entry is removed. If no key is provided, clears all appCache (except currency_rates_usd)
 * and viewData docs.
 * 
 * Note: Cache clearing requires editor/admin permissions. If the user doesn't
 * have permission, this function will silently fail (cache will expire via TTL anyway).
 * 
 * @param key - Optional cache key to clear. If not provided, clears all cache entries (except currency_rates_usd) + viewData
 * @returns Promise<{ cleared: boolean }> - cleared true if all requested entries were removed, false otherwise (e.g. permission-denied)
 */
export async function clearCache(key?: string): Promise<{ cleared: boolean }> {
  try {
    if (key) {
      const docRef = getCacheDocRef(key);
      logger.debug('Clearing specific cache entry', { 
        component: 'firestoreCacheService', 
        operation: 'clearCache', 
        key 
      });
      await deleteDoc(docRef);
      logger.info('Cache entry cleared successfully', { 
        component: 'firestoreCacheService', 
        operation: 'clearCache', 
        key 
      });
      return { cleared: true };
    }
    // Clear viewData docs (admin refresh)
    await clearViewDataDocs();
    // Clear all appCache entries EXCEPT currency_rates_usd
    logger.debug('Clearing appCache entries (excluding currency_rates_usd)', { 
      component: 'firestoreCacheService', 
      operation: 'clearCache' 
    });
    const cacheCollection = collection(db, CACHE_COLLECTION);
    const q = query(cacheCollection);
    const querySnapshot = await getDocs(q);
    
    const docsToDelete = querySnapshot.docs.filter((d) => d.id !== 'currency_rates_usd');
    const docCount = docsToDelete.length;
    logger.info(`Found ${docCount} appCache entries to clear (excluding currency_rates_usd)`, { 
      component: 'firestoreCacheService', 
      operation: 'clearCache',
      docCount 
    });
    
    if (docCount === 0) {
      logger.debug('No appCache entries found to clear', { 
        component: 'firestoreCacheService', 
        operation: 'clearCache' 
      });
      return { cleared: true };
    }
    
    const deletePromises = docsToDelete.map(docSnap => deleteDoc(docSnap.ref));
    const deleteResults = await Promise.allSettled(deletePromises);
    
    const successful = deleteResults.filter(r => r.status === 'fulfilled').length;
    const failed = deleteResults.filter(r => r.status === 'rejected').length;
    
    logger.info('Cache clearing completed', { 
      component: 'firestoreCacheService', 
      operation: 'clearCache',
      total: docCount,
      successful,
      failed 
    });
    
    if (failed > 0) {
      const failedDocs = deleteResults
        .map((result, index) => result.status === 'rejected' ? querySnapshot.docs[index].id : null)
        .filter(Boolean);
      logger.warn('Some cache entries failed to delete', { 
        component: 'firestoreCacheService', 
        operation: 'clearCache',
        failedCount: failed,
        failedDocs 
      });
      return { cleared: false };
    }
    return { cleared: true };
  } catch (error: any) {
    const isPermissionError = error?.code === 'permission-denied' || 
                              (error?.name === 'FirebaseError' && error?.code === 'permission-denied');
    
    if (isPermissionError) {
      logger.info('Cache clear skipped (insufficient permissions - cache will expire via TTL)', { 
        component: 'firestoreCacheService', 
        operation: 'clearCache', 
        key,
        note: 'This is expected for non-editor users. Cache will expire naturally via TTL.'
      });
      return { cleared: false };
    }
    
    logger.warn('Failed to clear cache', { 
      component: 'firestoreCacheService', 
      operation: 'clearCache', 
      key, 
      error 
    });
    return { cleared: false };
  }
}

```

## `src/services/migrations/__tests__/runMigrations.test.ts`

```typescript
/**
 * Unit tests for runMigrations.
 * Verifies idempotency and that migrations run as expected.
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { migrateFromLocalStorage } from '../migrateFromLocalStorage';
import { runPreAuthMigrations, runPostAuthMigrations } from '../runMigrations';

vi.mock('../../utils/logger', () => ({
  logger: {
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  },
}));

vi.mock('../../firestoreCacheService', () => ({
  migrateCoreBoardToScoreBoard: vi.fn().mockResolvedValue(true),
  runTruncatedCacheMigrations: vi.fn().mockResolvedValue(undefined),
}));

vi.mock('../../appConfigService', () => ({
  getApiKeysFromFirestore: vi.fn().mockResolvedValue(null),
}));

vi.mock('../../../config/apiKeys', () => ({
  setApiKeysCacheFromFirestore: vi.fn(),
}));

import { migrateCoreBoardToScoreBoard, runTruncatedCacheMigrations } from '../../firestoreCacheService';
import { getApiKeysFromFirestore } from '../../appConfigService';
import { setApiKeysCacheFromFirestore } from '../../../config/apiKeys';

describe('migrateFromLocalStorage', () => {
  const MIGRATION_FLAG = 'cache:migrated-to-firestore';

  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
  });

  it('should clear cache keys and set migration flag on first run', () => {
    localStorage.setItem('cache:scoreBoard', 'old-data');
    localStorage.setItem('cache:other', 'data');

    migrateFromLocalStorage();

    expect(localStorage.getItem('cache:scoreBoard')).toBeNull();
    expect(localStorage.getItem('cache:other')).toBeNull();
    expect(localStorage.getItem(MIGRATION_FLAG)).toBe('true');
  });

  it('should be idempotent - second run does nothing', () => {
    localStorage.setItem('cache:test', 'data');
    migrateFromLocalStorage();
    localStorage.setItem('cache:new-key', 'new-data'); // Simulate new cache between runs
    migrateFromLocalStorage();

    // Second run should not clear - flag already set, so it returns early
    expect(localStorage.getItem('cache:new-key')).toBe('new-data');
  });

  it('should clear currency_rates_usd', () => {
    localStorage.setItem('currency_rates_usd', 'rates');

    migrateFromLocalStorage();

    expect(localStorage.getItem('currency_rates_usd')).toBeNull();
  });
});

describe('runPreAuthMigrations', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
  });

  it('should run without throwing', () => {
    runPreAuthMigrations();
    runPreAuthMigrations(); // Idempotent - second call fine
  });
});

describe('runPostAuthMigrations', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(migrateCoreBoardToScoreBoard).mockResolvedValue(true);
    vi.mocked(runTruncatedCacheMigrations).mockResolvedValue(undefined);
  });

  it('should run Firestore migrations', async () => {
    await runPostAuthMigrations();

    expect(migrateCoreBoardToScoreBoard).toHaveBeenCalledTimes(1);
    expect(runTruncatedCacheMigrations).toHaveBeenCalledTimes(1);
  });

  it('should not throw when Firestore migration fails', async () => {
    vi.mocked(migrateCoreBoardToScoreBoard).mockRejectedValue(new Error('Firestore error'));

    await expect(runPostAuthMigrations()).resolves.not.toThrow();
  });

  it('should load API keys', async () => {
    vi.mocked(getApiKeysFromFirestore).mockResolvedValue({ someKey: 'value' });

    await runPostAuthMigrations();

    expect(getApiKeysFromFirestore).toHaveBeenCalledTimes(1);
    expect(setApiKeysCacheFromFirestore).toHaveBeenCalledWith({ someKey: 'value' });
  });
});

```

## `src/services/migrations/index.ts`

```typescript
export { migrateFromLocalStorage } from './migrateFromLocalStorage';
export { runPreAuthMigrations, runPostAuthMigrations } from './runMigrations';

```

## `src/services/migrations/migrateFromLocalStorage.ts`

```typescript
/**
 * Migrate from localStorage cache to Firestore cache.
 * Clears all localStorage cache entries on first load after migration.
 * Idempotent: uses flag 'cache:migrated-to-firestore' to skip if already run.
 */

import { logger } from '../../utils/logger';

const MIGRATION_FLAG = 'cache:migrated-to-firestore';

export function migrateFromLocalStorage(): void {
  try {
    if (localStorage.getItem(MIGRATION_FLAG)) {
      return; // Already migrated
    }

    const keysToRemove: string[] = ['currency_rates_usd'];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('cache:')) {
        keysToRemove.push(key);
      }
    }

    keysToRemove.forEach((key) => localStorage.removeItem(key));
    localStorage.setItem(MIGRATION_FLAG, 'true');

    logger.info('Migrated from localStorage cache to Firestore cache', {
      component: 'migrateFromLocalStorage',
      operation: 'migrateFromLocalStorage',
      clearedKeys: keysToRemove.length,
    });
  } catch (error) {
    logger.warn('Failed to migrate from localStorage cache', {
      component: 'migrateFromLocalStorage',
      operation: 'migrateFromLocalStorage',
      error,
    });
  }
}

```

## `src/services/migrations/runMigrations.ts`

```typescript
/**
 * Runs app migrations at startup.
 * - runPreAuthMigrations: localStorage only, no auth needed (call in main.tsx)
 * - runPostAuthMigrations: Firestore migrations, requires authenticated user (call in App when currentUser exists)
 * All migrations are idempotent (safe to run multiple times).
 */

import { logger } from '../../utils/logger';
import { migrateFromLocalStorage } from './migrateFromLocalStorage';
import { migrateCoreBoardToScoreBoard, runTruncatedCacheMigrations } from '../firestoreCacheService';
import { getApiKeysFromFirestore } from '../appConfigService';
import { setApiKeysCacheFromFirestore } from '../../config/apiKeys';

/** Runs migrations that do not require auth (localStorage). Call in main.tsx before render. */
export function runPreAuthMigrations(): void {
  migrateFromLocalStorage();
}

/**
 * Runs migrations and post-auth setup that require an authenticated user.
 * Call in App when currentUser exists. Idempotent.
 */
export async function runPostAuthMigrations(): Promise<void> {
  try {
    await migrateCoreBoardToScoreBoard();
  } catch (error) {
    logger.warn('Firestore cache migration failed', {
      component: 'runMigrations',
      operation: 'migrateCoreBoardToScoreBoard',
      error,
    });
  }

  try {
    await runTruncatedCacheMigrations();
  } catch (error) {
    logger.warn('Firestore truncated cache migrations failed', {
      component: 'runMigrations',
      operation: 'runTruncatedCacheMigrations',
      error,
    });
  }

  try {
    const keys = await getApiKeysFromFirestore();
    if (keys) setApiKeysCacheFromFirestore(keys);
  } catch {
    // Ignore; getApiKeys() will use env fallback
  }
}

```

## `src/services/notificationService.ts`

```typescript
/**
 * Notification Service
 * 
 * Provides desktop notifications and in-app notification management.
 * Supports browser Notification API for desktop notifications.
 */

import { logger } from '../utils/logger';

export type NotificationType = 'data-update' | 'error' | 'success' | 'info' | 'warning';

export interface Notification {
  id: string;
  type: NotificationType;
  title: string;
  message: string;
  timestamp: number;
  read: boolean;
  persistent?: boolean;
  actions?: NotificationAction[];
  data?: Record<string, unknown>;
}

export interface NotificationAction {
  action: string;
  title: string;
}

export interface NotificationPermission {
  state: 'default' | 'granted' | 'denied';
}

class NotificationService {
  private static instance: NotificationService;
  private permissionState: NotificationPermission['state'] = 'default';
  private notificationQueue: Notification[] = [];
  private maxQueueSize = 50;

  private constructor() {
    this.checkPermission();
  }

  static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }

  /**
   * Check current notification permission state
   */
  private checkPermission(): void {
    if (!('Notification' in window)) {
      logger.warn('Browser does not support notifications', { component: 'NotificationService' });
      this.permissionState = 'denied';
      return;
    }

    this.permissionState = Notification.permission;
  }

  /**
   * Request notification permission from user
   */
  async requestPermission(): Promise<boolean> {
    if (!('Notification' in window)) {
      logger.warn('Browser does not support notifications', { component: 'NotificationService' });
      return false;
    }

    if (this.permissionState === 'granted') {
      return true;
    }

    if (this.permissionState === 'denied') {
      logger.warn('Notification permission denied', { component: 'NotificationService' });
      return false;
    }

    try {
      const permission = await Notification.requestPermission();
      this.permissionState = permission;
      return permission === 'granted';
    } catch (error) {
      logger.error('Error requesting notification permission', error, { component: 'NotificationService' });
      return false;
    }
  }

  /**
   * Get current permission state
   */
  getPermissionState(): NotificationPermission['state'] {
    return this.permissionState;
  }

  /**
   * Create a desktop notification
   */
  private createDesktopNotification(notification: Notification): void {
    if (this.permissionState !== 'granted') {
      logger.debug('Notification permission not granted, skipping desktop notification', {
        component: 'NotificationService',
        notificationId: notification.id,
      });
      return;
    }

    try {
      const options: NotificationOptions = {
        body: notification.message,
        icon: '/favicon.ico',
        badge: '/favicon.ico',
        tag: notification.id,
        requireInteraction: notification.persistent || false,
        timestamp: notification.timestamp,
        data: notification.data,
      };

      const desktopNotification = new Notification(notification.title, options);

      // Handle notification click
      desktopNotification.onclick = () => {
        window.focus();
        desktopNotification.close();
      };

      // Auto-close after 5 seconds (unless persistent)
      if (!notification.persistent) {
        setTimeout(() => {
          desktopNotification.close();
        }, 5000);
      }
    } catch (error) {
      logger.error('Error creating desktop notification', error, {
        component: 'NotificationService',
        notificationId: notification.id,
      });
    }
  }

  /**
   * Create a notification
   */
  createNotification(
    type: NotificationType,
    title: string,
    message: string,
    options?: {
      persistent?: boolean;
      actions?: NotificationAction[];
      data?: Record<string, unknown>;
      showDesktop?: boolean;
    }
  ): Notification {
    const notification: Notification = {
      id: `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      type,
      title,
      message,
      timestamp: Date.now(),
      read: false,
      persistent: options?.persistent || false,
      actions: options?.actions,
      data: options?.data,
    };

    // Add to queue
    this.addToQueue(notification);

    // Show desktop notification if enabled and permission granted
    if (options?.showDesktop !== false && this.permissionState === 'granted') {
      this.createDesktopNotification(notification);
    }

    return notification;
  }

  /**
   * Add notification to queue
   */
  private addToQueue(notification: Notification): void {
    this.notificationQueue.unshift(notification); // Add to beginning

    // Limit queue size
    if (this.notificationQueue.length > this.maxQueueSize) {
      this.notificationQueue = this.notificationQueue.slice(0, this.maxQueueSize);
    }
  }

  /**
   * Get all notifications
   */
  getNotifications(): Notification[] {
    return [...this.notificationQueue];
  }

  /**
   * Get unread notifications
   */
  getUnreadNotifications(): Notification[] {
    return this.notificationQueue.filter((n) => !n.read);
  }

  /**
   * Mark notification as read
   */
  markAsRead(notificationId: string): void {
    const notification = this.notificationQueue.find((n) => n.id === notificationId);
    if (notification) {
      notification.read = true;
    }
  }

  /**
   * Mark all notifications as read
   */
  markAllAsRead(): void {
    this.notificationQueue.forEach((n) => {
      n.read = true;
    });
  }

  /**
   * Remove notification
   */
  removeNotification(notificationId: string): void {
    this.notificationQueue = this.notificationQueue.filter((n) => n.id !== notificationId);
  }

  /**
   * Clear all notifications
   */
  clearAll(): void {
    this.notificationQueue = [];
  }

  /**
   * Clear old notifications (older than specified days)
   */
  clearOldNotifications(days: number = 7): void {
    const cutoffTime = Date.now() - days * 24 * 60 * 60 * 1000;
    this.notificationQueue = this.notificationQueue.filter((n) => n.timestamp > cutoffTime);
  }

  /**
   * Get notification count
   */
  getNotificationCount(): number {
    return this.notificationQueue.length;
  }

  /**
   * Get unread notification count
   */
  getUnreadCount(): number {
    return this.notificationQueue.filter((n) => !n.read).length;
  }
}

export const notificationService = NotificationService.getInstance();

```

## `src/services/personalPortfolioService.ts`

```typescript
/**
 * Personal Portfolio Service
 * 
 * Provides functionality to save and load personal portfolio data in Firestore.
 * Each user has their own portfolio stored in userPortfolios/{userId}.
 * Falls back to localStorage if Firestore is unavailable.
 */

import { doc, setDoc, getDoc, Timestamp } from 'firebase/firestore';
import { db } from '../config/firebase';
import { logger } from '../utils/logger';
import { PortfolioItem, PortfolioPosition, UserPortfolio } from '../types/portfolio';
import { EntryExitValues } from '../contexts/EntryExitContext';
import { getExchangeRate } from './currencyService';

const COLLECTION_NAME = 'userPortfolios';
const STORAGE_KEY = 'personalPortfolio';
const LEGACY_BROKER = '—';

/**
 * Normalize a portfolio item: if it has no positions, create one from legacy quantity/investedAmount/investmentCurrency.
 */
export function normalizePortfolioItem(item: PortfolioItem): PortfolioItem {
  if (item.positions && item.positions.length > 0) {
    return item;
  }
  return {
    ...item,
    positions: [
      {
        broker: LEGACY_BROKER,
        quantity: item.quantity,
        investedAmount: item.investedAmount ?? null,
        investmentCurrency: item.investmentCurrency ?? 'USD',
      },
    ],
  };
}

/**
 * Get user portfolio from Firestore
 */
export async function getUserPortfolio(userId: string): Promise<UserPortfolio | null> {
  try {
    const docRef = doc(db, COLLECTION_NAME, userId);
    const docSnap = await getDoc(docRef);

    if (!docSnap.exists()) {
      // Try to load from localStorage as fallback
      return getPortfolioFromLocalStorage(userId);
    }

    const data = docSnap.data();
    const raw = (data.portfolio as PortfolioItem[]) || [];
    const portfolio = raw.map(normalizePortfolioItem);
    return {
      userId,
      portfolio,
      updatedAt: (data.updatedAt as Timestamp).toDate(),
    };
  } catch (error) {
    // Handle permissions errors gracefully - fallback to localStorage
    if (error instanceof Error && error.message.includes('permission')) {
      logger.warn('Permission denied when getting user portfolio, using localStorage', {
        component: 'personalPortfolioService',
        operation: 'getUserPortfolio',
        userId,
        error: error.message,
      });
      return getPortfolioFromLocalStorage(userId);
    }
    
    logger.error('Error getting user portfolio', error, {
      component: 'personalPortfolioService',
      operation: 'getUserPortfolio',
      userId,
    });
    // Fallback to localStorage
    return getPortfolioFromLocalStorage(userId);
  }
}

/**
 * Save user portfolio to Firestore
 */
export async function saveUserPortfolio(
  userId: string,
  portfolio: PortfolioItem[]
): Promise<void> {
  try {
    const docRef = doc(db, COLLECTION_NAME, userId);
    
    const portfolioData: Omit<UserPortfolio, 'updatedAt'> & { updatedAt: Timestamp } = {
      userId,
      portfolio,
      updatedAt: Timestamp.fromDate(new Date()),
    };

    await setDoc(docRef, portfolioData, { merge: true });

    // Also save to localStorage as backup
    savePortfolioToLocalStorage(userId, portfolio);

    logger.debug(`User portfolio saved for ${userId}`, {
      component: 'personalPortfolioService',
      operation: 'saveUserPortfolio',
      userId,
      itemCount: portfolio.length,
    });
  } catch (error) {
    // Handle permissions errors gracefully
    if (error instanceof Error && error.message.includes('permission')) {
      logger.warn('Permission denied when saving user portfolio, using localStorage', {
        component: 'personalPortfolioService',
        operation: 'saveUserPortfolio',
        userId,
        error: error.message,
      });
      // Save to localStorage as fallback
      savePortfolioToLocalStorage(userId, portfolio);
      return;
    }
    
    logger.error('Error saving user portfolio', error, {
      component: 'personalPortfolioService',
      operation: 'saveUserPortfolio',
      userId,
    });
    // Save to localStorage as fallback
    savePortfolioToLocalStorage(userId, portfolio);
  }
}

/**
 * Total quantity from positions.
 */
function totalQuantityFromPositions(positions: PortfolioPosition[]): number {
  return positions.reduce((sum, p) => sum + (p.quantity || 0), 0);
}

/**
 * Compute average price in USD from positions (async due to exchange rates).
 */
export async function computeAveragePriceUSD(
  positions: PortfolioPosition[]
): Promise<number | null> {
  let totalInvestedUSD = 0;
  let totalQty = 0;
  for (const p of positions) {
    const qty = p.quantity || 0;
    if (qty <= 0) continue;
    totalQty += qty;
    const amt = p.investedAmount;
    const ccy = (p.investmentCurrency || 'USD').toUpperCase();
    if (amt != null && amt > 0) {
      const rate = ccy === 'USD' ? 1 : await getExchangeRate(ccy, 'USD');
      if (rate != null) totalInvestedUSD += amt * rate;
    }
  }
  if (totalQty <= 0) return null;
  return totalInvestedUSD / totalQty;
}

/**
 * Apply aggregated quantity and averagePrice to item from its positions.
 */
async function applyAggregatesToItem(item: PortfolioItem): Promise<PortfolioItem> {
  const positions = item.positions && item.positions.length > 0 ? item.positions : [];
  const quantity = totalQuantityFromPositions(positions);
  const averagePrice = await computeAveragePriceUSD(positions);
  return {
    ...item,
    quantity,
    averagePrice,
    positions,
  };
}

/**
 * Add a portfolio item (with at least one position). Same ticker + same broker: merge into that position; else append position.
 */
export async function addPortfolioItem(
  userId: string,
  item: PortfolioItem
): Promise<void> {
  const currentPortfolio = await getUserPortfolio(userId);
  const portfolio = currentPortfolio?.portfolio || [];
  const newPositions = item.positions && item.positions.length > 0
    ? [...item.positions]
    : [{
        broker: LEGACY_BROKER,
        quantity: item.quantity,
        investedAmount: item.investedAmount ?? null,
        investmentCurrency: item.investmentCurrency ?? 'USD',
      }];

  const existingIndex = portfolio.findIndex(
    (p) => p.ticker.toLowerCase() === item.ticker.toLowerCase()
  );

  let nextItem: PortfolioItem;
  if (existingIndex >= 0) {
    const existing = portfolio[existingIndex];
    const positions = [...(existing.positions || [])];
    for (const newPos of newPositions) {
      const sameBroker = positions.find(
        (p) => p.broker.trim().toLowerCase() === newPos.broker.trim().toLowerCase()
      );
      const sameCurrency =
        (sameBroker?.investmentCurrency || 'USD').toUpperCase() ===
        (newPos.investmentCurrency || 'USD').toUpperCase();
      if (sameBroker && sameCurrency) {
        sameBroker.quantity += newPos.quantity;
        sameBroker.investedAmount =
          (sameBroker.investedAmount ?? 0) + (newPos.investedAmount ?? 0);
      } else {
        positions.push({ ...newPos });
      }
    }
    nextItem = await applyAggregatesToItem({
      ...existing,
      positions,
    });
    portfolio[existingIndex] = nextItem;
  } else {
    nextItem = await applyAggregatesToItem({
      ...item,
      positions: newPositions,
    });
    portfolio.push(nextItem);
  }

  await saveUserPortfolio(userId, portfolio);
}

/**
 * Remove a portfolio item by ticker
 */
export async function removePortfolioItem(
  userId: string,
  ticker: string
): Promise<void> {
  const currentPortfolio = await getUserPortfolio(userId);
  if (!currentPortfolio) {
    return;
  }
  
  const portfolio = currentPortfolio.portfolio.filter(
    p => p.ticker.toLowerCase() !== ticker.toLowerCase()
  );
  
  await saveUserPortfolio(userId, portfolio);
}

/**
 * Update a portfolio item. If updates include positions, quantity and averagePrice are recomputed.
 */
export async function updatePortfolioItem(
  userId: string,
  ticker: string,
  updates: Partial<PortfolioItem>
): Promise<void> {
  const currentPortfolio = await getUserPortfolio(userId);
  if (!currentPortfolio) {
    return;
  }

  const portfolio = await Promise.all(
    currentPortfolio.portfolio.map(async (p) => {
      if (p.ticker.toLowerCase() !== ticker.toLowerCase()) {
        return p;
      }
      const merged = { ...p, ...updates };
      if (merged.positions && merged.positions.length > 0) {
        return applyAggregatesToItem(merged);
      }
      return merged;
    })
  );

  await saveUserPortfolio(userId, portfolio);
}

/**
 * Get portfolio from localStorage (fallback)
 */
function getPortfolioFromLocalStorage(userId: string): UserPortfolio | null {
  try {
    const key = `${STORAGE_KEY}_${userId}`;
    const stored = localStorage.getItem(key);
    if (!stored) {
      return null;
    }
    
    const data = JSON.parse(stored);
    const raw = data.portfolio || [];
    const portfolio = raw.map((item: PortfolioItem) => normalizePortfolioItem(item));
    return {
      userId,
      portfolio,
      updatedAt: data.updatedAt ? new Date(data.updatedAt) : new Date(),
    };
  } catch (error) {
    logger.warn('Error reading portfolio from localStorage', {
      component: 'personalPortfolioService',
      operation: 'getPortfolioFromLocalStorage',
      userId,
      error,
    });
    return null;
  }
}

/**
 * Save portfolio to localStorage (fallback)
 */
function savePortfolioToLocalStorage(userId: string, portfolio: PortfolioItem[]): void {
  try {
    const key = `${STORAGE_KEY}_${userId}`;
    const data = {
      userId,
      portfolio,
      updatedAt: new Date().toISOString(),
    };
    localStorage.setItem(key, JSON.stringify(data));
  } catch (error) {
    logger.warn('Error saving portfolio to localStorage', {
      component: 'personalPortfolioService',
      operation: 'savePortfolioToLocalStorage',
      userId,
      error,
    });
  }
}

/**
 * Get currency for a stock from EntryExitValues
 * 
 * Returns the currency for a stock from EntryExitValues map,
 * or defaults to 'USD' if not found.
 * 
 * @param ticker - Stock ticker symbol
 * @param companyName - Company name
 * @param entryExitValues - Map of EntryExitValues keyed by `${ticker}-${companyName}`
 * @returns Currency string (default: 'USD')
 * 
 * @example
 * ```typescript
 * const currency = getCurrencyForStock('AAPL', 'Apple Inc.', entryExitValues);
 * // Returns 'USD' or the currency from EntryExitValues
 * ```
 */
/** Nasdaq Nordic ticker suffixes that typically trade in SEK */
const SEK_TICKER_SUFFIXES = ['-B', '-A'];

function inferCurrencyFromTicker(ticker: string): string {
  const upper = ticker.toUpperCase();
  if (SEK_TICKER_SUFFIXES.some((s) => upper.endsWith(s))) {
    return 'SEK';
  }
  return 'USD';
}

export function getCurrencyForStock(
  ticker: string,
  companyName: string,
  entryExitValues: Map<string, EntryExitValues>
): string {
  const key = `${ticker}-${companyName}`;
  const entryExitValue = entryExitValues.get(key);
  const currency = entryExitValue?.currency;
  if (currency && currency.trim() !== '') {
    return currency;
  }
  return inferCurrencyFromTicker(ticker);
}

```

## `src/services/shareableLinkService.ts`

```typescript
/**
 * Shareable Link Service
 * 
 * Provides functionality to save and load filter state as shareable links via Firestore.
 */

import { collection, doc, setDoc, getDoc, deleteDoc, Timestamp, query, where, getDocs, orderBy, limit } from 'firebase/firestore';
import { db } from '../config/firebase';
import { FilterValues } from '../types/filters';
import { logger } from '../utils/logger';

export interface ShareableLink {
  id: string;
  filterState: FilterValues;
  viewId: string;
  sortConfig?: {
    key: string;
    direction: 'asc' | 'desc';
  };
  tableId: string;
  createdAt: Date;
  expiresAt?: Date;
  createdBy: string;
  name?: string;
  description?: string;
}

const COLLECTION_NAME = 'shareableLinks';
const DEFAULT_EXPIRY_DAYS = 30;

/**
 * Generate a short unique ID for the link
 */
function generateLinkId(): string {
  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
}

/**
 * Save a shareable link to Firestore
 */
export async function saveShareableLink(
  filterState: FilterValues,
  viewId: string,
  tableId: string,
  userId: string,
  options?: {
    name?: string;
    description?: string;
    expiresInDays?: number;
    sortConfig?: { key: string; direction: 'asc' | 'desc' };
  }
): Promise<string> {
  try {
    const linkId = generateLinkId();
    const now = new Date();
    const expiresAt = options?.expiresInDays
      ? new Date(now.getTime() + options.expiresInDays * 24 * 60 * 60 * 1000)
      : new Date(now.getTime() + DEFAULT_EXPIRY_DAYS * 24 * 60 * 60 * 1000);

    const linkData: Omit<ShareableLink, 'id'> = {
      filterState,
      viewId,
      tableId,
      createdAt: now,
      expiresAt,
      createdBy: userId,
      name: options?.name,
      description: options?.description,
      sortConfig: options?.sortConfig,
    };

    const docRef = doc(collection(db, COLLECTION_NAME), linkId);
    await setDoc(docRef, {
      ...linkData,
      createdAt: Timestamp.fromDate(linkData.createdAt),
      expiresAt: linkData.expiresAt ? Timestamp.fromDate(linkData.expiresAt) : null,
    });

    logger.debug(`Shareable link saved: ${linkId}`, {
      component: 'shareableLinkService',
      operation: 'saveShareableLink',
      linkId,
      tableId,
    });

    return linkId;
  } catch (error) {
    logger.error('Error saving shareable link', error, {
      component: 'shareableLinkService',
      operation: 'saveShareableLink',
    });
    throw error;
  }
}

/**
 * Load a shareable link from Firestore
 */
export async function loadShareableLink(linkId: string): Promise<ShareableLink | null> {
  try {
    const docRef = doc(collection(db, COLLECTION_NAME), linkId);
    const docSnap = await getDoc(docRef);

    if (!docSnap.exists()) {
      logger.warn(`Shareable link not found: ${linkId}`, {
        component: 'shareableLinkService',
        operation: 'loadShareableLink',
        linkId,
      });
      return null;
    }

    const data = docSnap.data();
    const now = new Date();

    // Check if link has expired
    if (data.expiresAt) {
      const expiresAt = (data.expiresAt as Timestamp).toDate();
      if (expiresAt < now) {
        logger.warn(`Shareable link expired: ${linkId}`, {
          component: 'shareableLinkService',
          operation: 'loadShareableLink',
          linkId,
          expiresAt,
        });
        return null;
      }
    }

    const link: ShareableLink = {
      id: linkId,
      filterState: data.filterState as FilterValues,
      viewId: data.viewId as string,
      tableId: data.tableId as string,
      createdAt: (data.createdAt as Timestamp).toDate(),
      expiresAt: data.expiresAt ? (data.expiresAt as Timestamp).toDate() : undefined,
      createdBy: data.createdBy as string,
      name: data.name as string | undefined,
      description: data.description as string | undefined,
      sortConfig: data.sortConfig as { key: string; direction: 'asc' | 'desc' } | undefined,
    };

    return link;
  } catch (error) {
    logger.error('Error loading shareable link', error, {
      component: 'shareableLinkService',
      operation: 'loadShareableLink',
      linkId,
    });
    throw error;
  }
}

/**
 * Get all shareable links created by a user
 */
export async function getUserShareableLinks(userId: string, limitCount: number = 50): Promise<ShareableLink[]> {
  try {
    const q = query(
      collection(db, COLLECTION_NAME),
      where('createdBy', '==', userId),
      orderBy('createdAt', 'desc'),
      limit(limitCount)
    );

    const querySnapshot = await getDocs(q);
    const links: ShareableLink[] = [];

    querySnapshot.forEach((doc) => {
      const data = doc.data();
      const now = new Date();

      // Skip expired links
      if (data.expiresAt) {
        const expiresAt = (data.expiresAt as Timestamp).toDate();
        if (expiresAt < now) {
          return;
        }
      }

      links.push({
        id: doc.id,
        filterState: data.filterState as FilterValues,
        viewId: data.viewId as string,
        tableId: data.tableId as string,
        createdAt: (data.createdAt as Timestamp).toDate(),
        expiresAt: data.expiresAt ? (data.expiresAt as Timestamp).toDate() : undefined,
        createdBy: data.createdBy as string,
        name: data.name as string | undefined,
        description: data.description as string | undefined,
        sortConfig: data.sortConfig as { key: string; direction: 'asc' | 'desc' } | undefined,
      });
    });

    return links;
  } catch (error) {
    logger.error('Error getting user shareable links', error, {
      component: 'shareableLinkService',
      operation: 'getUserShareableLinks',
      userId,
    });
    throw error;
  }
}

/**
 * Delete a shareable link
 */
export async function deleteShareableLink(linkId: string, userId: string): Promise<void> {
  try {
    // Verify ownership before deleting
    const link = await loadShareableLink(linkId);
    if (!link) {
      throw new Error('Link not found');
    }

    if (link.createdBy !== userId) {
      throw new Error('Unauthorized: You can only delete your own links');
    }

    const docRef = doc(collection(db, COLLECTION_NAME), linkId);
    await deleteDoc(docRef);

    logger.debug(`Shareable link deleted: ${linkId}`, {
      component: 'shareableLinkService',
      operation: 'deleteShareableLink',
      linkId,
      userId,
    });
  } catch (error) {
    logger.error('Error deleting shareable link', error, {
      component: 'shareableLinkService',
      operation: 'deleteShareableLink',
      linkId,
      userId,
    });
    throw error;
  }
}

/**
 * Generate a shareable URL
 */
export function generateShareableUrl(linkId: string): string {
  const baseUrl = window.location.origin;
  return `${baseUrl}/share/${linkId}`;
}

```

## `src/services/sharedThresholdService.ts`

```typescript
/**
 * Shared Threshold Service
 *
 * Manages shared threshold data in Firestore (sharedData/threshold).
 * Read: any authenticated user. Write: admin only.
 * localStorage is read-cache/fallback only.
 */

import { doc, setDoc, getDoc, serverTimestamp } from 'firebase/firestore';
import { User } from 'firebase/auth';
import { db } from '../config/firebase';
import { logger } from '../utils/logger';
import { getViewDataWithFallback, setViewData } from './firestoreCacheService';

export interface ThresholdValues {
  irr: number;
  leverageF2Min: number;
  leverageF2Max: number;
  ro40Min: number;
  ro40Max: number;
  cashSdebtMin: number;
  cashSdebtMax: number;
  currentRatioMin: number;
  currentRatioMax: number;
}

const STORAGE_KEY = 'sharedThresholdValues';
const LEGACY_STORAGE_KEY = 'thresholdValues';


/**
 * Load shared threshold values from localStorage (fallback only).
 * Migrates from legacy key (thresholdValues) if present.
 */
export function loadFromLocalStorage(): Record<string, ThresholdValues> | null {
  try {
    let stored = localStorage.getItem(STORAGE_KEY);
    if (!stored) {
      stored = localStorage.getItem(LEGACY_STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored) as Record<string, ThresholdValues>;
        localStorage.setItem(STORAGE_KEY, stored);
        return parsed;
      }
    } else {
      return JSON.parse(stored);
    }
  } catch (error: unknown) {
    logger.error('Error loading shared threshold from localStorage', error, {
      component: 'sharedThresholdService',
      operation: 'sharedThreshold.loadFailed',
    });
  }
  return null;
}

/**
 * Save to localStorage (read-cache only, never triggers Firestore write).
 */
export function saveToLocalStorage(values: Record<string, ThresholdValues>): void {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(values));
  } catch (error: unknown) {
    logger.error('Error saving shared threshold to localStorage', error, {
      component: 'sharedThresholdService',
      operation: 'saveToLocalStorage',
    });
  }
}

/**
 * Load shared threshold values from Firestore.
 * Uses viewData/threshold-industry first (dual-read/cutover), fallback to sharedData/threshold.
 * Requires authenticated user for Firestore read; returns null when no user.
 * Falls back to localStorage on error.
 */
export async function loadSharedThresholdValues(
  user: User | null
): Promise<Record<string, ThresholdValues> | null> {
  if (!user) {
    return loadFromLocalStorage();
  }

  try {
    const result = await getViewDataWithFallback<{ values: Record<string, ThresholdValues> }>('threshold-industry', {
      fallback: async () => {
        const docRef = doc(db, 'sharedData', 'threshold');
        const docSnap = await getDoc(docRef);
        if (docSnap.exists()) {
          const data = docSnap.data();
          const values = (data.values || {}) as Record<string, ThresholdValues>;
          if (Object.keys(values).length > 0) return { values };
        }
        return null;
      },
    });
    if (result && result.data.values && Object.keys(result.data.values).length > 0) {
      saveToLocalStorage(result.data.values);
      return result.data.values;
    }
    return loadFromLocalStorage();
  } catch (error: unknown) {
    logger.error('Error loading shared threshold from Firestore', error, {
      component: 'sharedThresholdService',
      operation: 'sharedThreshold.loadFailed',
    });
    return loadFromLocalStorage();
  }
}

export interface SaveSharedThresholdOptions {
  user: User | null;
  userRole: string | null;
}

/**
 * Save shared threshold values to Firestore.
 * Admin only; throws if userRole !== 'admin'.
 * No retry on permission denied.
 */
export async function saveSharedThresholdValues(
  values: Record<string, ThresholdValues>,
  options: SaveSharedThresholdOptions
): Promise<void> {
  const { user, userRole } = options;

  if (userRole !== 'admin') {
    logger.warn('Threshold save denied: user is not admin', {
      component: 'sharedThresholdService',
      operation: 'sharedThreshold.saveDenied',
    });
    throw new Error('sharedThreshold.saveDenied');
  }

  if (!user) {
    logger.warn('Threshold save denied: no authenticated user', {
      component: 'sharedThresholdService',
      operation: 'sharedThreshold.saveDenied',
    });
    throw new Error('sharedThreshold.saveDenied');
  }

  try {
    const docRef = doc(db, 'sharedData', 'threshold');
    await setDoc(
      docRef,
      {
        values,
        updatedAt: serverTimestamp(),
        updatedBy: user.uid,
      },
      { merge: true }
    );

    await setViewData('threshold-industry', { values }, { source: 'client-refresh', updatedBy: user.uid }).catch((e) =>
      logger.warn('Failed to write viewData threshold-industry', { component: 'sharedThresholdService', error: e })
    );

    saveToLocalStorage(values);
  } catch (error: unknown) {
    logger.error('Error saving shared threshold to Firestore', error, {
      component: 'sharedThresholdService',
      operation: 'sharedThreshold.saveFailed',
    });
    throw error;
  }
}

```

## `src/services/sheets/benjaminGrahamService.ts`

```typescript
/**
 * Benjamin Graham Service
 * 
 * Fetches and transforms Benjamin Graham valuation data from Google Sheets.
 */

import { BenjaminGrahamData } from '../../types/stock';
import { CACHE_KEYS, DEFAULT_TTL } from '../firestoreCacheService';
import { fetchWithFallback } from './fetchService';
import { getValue, isValidValue, parseNumericValueNullable } from './dataTransformers';
import { isBenjaminGrahamData } from '../../utils/typeGuards';
import type { DataRow, ProgressCallback } from './types';

// Benjamin Graham data configuration
const BENJAMIN_GRAHAM_SHEET_ID = '1KOOSLJVGdDZHBV1MUmb4D9oVIKUJj5TIgYCerjkWYcE';
const BENJAMIN_GRAHAM_GID = '1180885830';
const BENJAMIN_GRAHAM_CSV_URL = `https://docs.google.com/spreadsheets/d/${BENJAMIN_GRAHAM_SHEET_ID}/export?format=csv&gid=${BENJAMIN_GRAHAM_GID}`;

/**
 * Transformer function for Benjamin Graham data
 * Exported for use in background sync persist.
 */
export function transformBenjaminGrahamData(results: { data: DataRow[]; meta: { fields: string[] | null } }): BenjaminGrahamData[] {
  const benjaminGrahamData = results.data
    .map((row: DataRow) => {
      const companyName = getValue(['Company Name', 'Company', 'company'], row);
      const ticker = getValue(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
      const priceStr = getValue(['Price', 'price', 'PRICE'], row);
      const benjaminGrahamStr = getValue(['Benjamin Graham', 'benjamin graham', 'Benjamin', 'benjamin'], row);
      
      // Only process if company name is valid (not #N/A)
      if (!isValidValue(companyName)) {
        return null;
      }
      
      // Filter out rows where Ticker is N/A (DashBoard rule: if Ticker is N/A, don't fetch data)
      if (!isValidValue(ticker)) {
        return null;
      }
      
      // Parse Price value as number (handle #N/A)
      const price = parseNumericValueNullable(priceStr);
      
      // Parse Benjamin Graham value as number (handle #N/A)
      const benjaminGraham = parseNumericValueNullable(benjaminGrahamStr);
      
      // Parse IV (FCF) if it exists
      const ivFcfStr = getValue(['IV (FCF)', 'IV(FCF)', 'iv fcf', 'ivfcf'], row);
      const ivFcf = parseNumericValueNullable(ivFcfStr);
      
      // Parse IRR1 if it exists
      const irr1Str = getValue(['IRR1', 'irr1', 'IRR 1', 'irr 1'], row);
      const irr1 = parseNumericValueNullable(irr1Str);
      
      // Include row if both company name and ticker are valid (we already checked above)
      return {
        companyName: companyName,
        ticker: ticker,
        price: price,
        benjaminGraham: benjaminGraham,
        ivFcf: ivFcf, // Include if it exists
        irr1: irr1, // Include if it exists
      };
    })
    .filter((data): data is BenjaminGrahamData => data !== null && isBenjaminGrahamData(data));
  
  return benjaminGrahamData;
}

/**
 * Fetches Benjamin Graham data from Google Sheets
 * 
 * Retrieves company valuation data including Benjamin Graham value, price, IV (FCF), and IRR1.
 * Tries Apps Script API first (fast), falls back to CSV proxy if needed (slower).
 * 
 * @param forceRefresh - If true, bypasses cache and forces network request (default: false)
 * @param progressCallback - Optional callback for progress updates during fetch/parse/transform
 * @returns Promise resolving to array of Benjamin Graham data entries
 * @throws {Error} If data fetch fails or required columns are missing
 */
export async function fetchBenjaminGrahamData(
  forceRefresh: boolean = false,
  progressCallback?: ProgressCallback
): Promise<BenjaminGrahamData[]> {
  return fetchWithFallback<BenjaminGrahamData>({
    sheetName: 'DashBoard',
    dataTypeName: 'Benjamin Graham',
    transformer: transformBenjaminGrahamData,
    requiredColumns: ['Benjamin Graham', 'Company Name', 'Ticker'],
    cacheKey: CACHE_KEYS.BENJAMIN_GRAHAM,
    forceRefresh,
    ttl: DEFAULT_TTL,
    progressCallback,
    csvUrl: BENJAMIN_GRAHAM_CSV_URL,
  });
}

```

## `src/services/sheets/dataTransformers.ts`

```typescript
/**
 * Data Transformers
 * 
 * Helper functions for transforming and parsing data from Google Sheets.
 * Includes value extraction, validation, parsing, and industry mapping functions.
 */

import type { DataRow } from './types';
import { isDataRow, isString, isNumber } from '../../utils/typeGuards';
import {
  INDUSTRY_IRR_MAP,
  INDUSTRY_LEVERAGE_F2_MAP,
  INDUSTRY_RO40_MAP,
  INDUSTRY_CASH_SDEBT_MAP,
  INDUSTRY_CURRENT_RATIO_MAP,
} from '../../config/industryThresholds';

/**
 * Helper function to get value from row with case-insensitive matching
 * 
 * Searches for a value in a data row by trying multiple possible column names.
 * Performs both exact and case-insensitive matching.
 * 
 * @param possibleNames - Array of possible column names to search for
 * @param row - Data row object to search in
 * @returns The found value as a trimmed string, or empty string if not found
 */
export function getValue(possibleNames: string[], row: DataRow): string {
  if (!isDataRow(row)) {
    return '';
  }
  
  for (const name of possibleNames) {
    if (!isString(name)) continue;
    
    // Try exact match first
    const value = row[name];
    if (value !== undefined && value !== null && value !== '') {
      return String(value).trim();
    }
    // Try case-insensitive match
    const lowerName = name.toLowerCase();
    for (const key in row) {
      if (key.toLowerCase() === lowerName) {
        const val = row[key];
        if (val !== undefined && val !== null && val !== '') {
          return String(val).trim();
        }
      }
    }
  }
  return '';
}

/**
 * Helper function to validate values (filter out #N/A, etc.)
 * 
 * Checks if a value is valid by filtering out common Excel error values,
 * "Loading..." text, and empty strings.
 * 
 * @param value - The value to validate
 * @returns True if the value is valid, false otherwise
 */
export function isValidValue(value: string): boolean {
  if (!value) return false;
  const normalized = value.trim().toUpperCase();
  return normalized !== '#N/A' && normalized !== 'N/A' && normalized !== '#NUM!' && normalized !== '#VALUE!' && normalized !== '#DIV/0!' && normalized !== '#REF!' && normalized !== 'LOADING...';
}

/**
 * Helper function to parse numeric values that can distinguish between invalid (null) and actual zero (0)
 * 
 * Parses a string value to a number, handling Excel error values and invalid formats.
 * Returns null for invalid values, allowing distinction between missing data and zero.
 * 
 * @param valueStr - String value to parse (may contain commas, spaces, currency symbols)
 * @returns Parsed number, or null if value is invalid or an error value
 */
export function parseNumericValueNullable(valueStr: string): number | null {
  if (!isString(valueStr) || !isValidValue(valueStr)) return null;
  
  // Remove common prefixes and clean the string
  let cleaned = String(valueStr)
    .replace(/,/g, '.')
    .replace(/\s/g, '')
    .replace(/#/g, '')
    .replace(/%/g, '')
    .replace(/\$/g, '');
  
  const parsed = parseFloat(cleaned);
  if (!isNumber(parsed) || isNaN(parsed) || !isFinite(parsed)) return null;
  
  return parsed;
}

/**
 * Helper function to get value from row with case-insensitive matching (allows 0 values)
 * 
 * Similar to getValue(), but allows zero (0) as a valid value instead of treating it
 * as missing data. Useful for numeric fields where zero is meaningful.
 * 
 * @param possibleNames - Array of possible column names to search for
 * @param row - Data row object to search in
 * @returns The found value as a trimmed string, or empty string if not found
 */
export function getValueAllowZero(possibleNames: string[], row: DataRow): string {
  for (const name of possibleNames) {
    // Try exact match first
    if (row[name] !== undefined && row[name] !== null) {
      const value = row[name];
      // Om värdet är 0 (nummer eller sträng "0"), returnera "0"
      if (value === 0 || value === '0') {
        return '0';
      }
      // Om värdet är en tom sträng, hoppa över
      if (value === '') {
        continue;
      }
      return String(value).trim();
    }
    // Try case-insensitive match
    const lowerName = name.toLowerCase();
    for (const key in row) {
      if (key.toLowerCase() === lowerName) {
        const value = row[key];
        // Tillåt 0 som ett giltigt värde
        if (value !== undefined && value !== null) {
          // Om värdet är 0 (nummer eller sträng "0"), returnera "0"
          if (value === 0 || value === '0') {
            return '0';
          }
          // Om värdet är en tom sträng, hoppa över
          if (value === '') {
            continue;
          }
          return String(value).trim();
        }
      }
    }
  }
  return '';
}

/**
 * Helper function to parse percentage values that can distinguish between invalid (null) and actual zero (0)
 * 
 * Parses a percentage string value to a number, handling Excel error values and percentage symbols.
 * Returns null for invalid values, allowing distinction between missing data and zero percent.
 * 
 * @param valueStr - String value to parse (may contain %, commas, spaces)
 * @returns Parsed number (percentage as decimal, e.g., 15% becomes 15), or null if invalid
 */
export function parsePercentageValueNullable(valueStr: string): number | null {
  if (!isString(valueStr) || !isValidValue(valueStr)) return null;
  
  // Remove % sign and clean the string
  let cleaned = String(valueStr)
    .replace(/,/g, '.')
    .replace(/\s/g, '')
    .replace(/#/g, '')
    .replace(/%/g, '')
    .replace(/\$/g, '');
  
  const parsed = parseFloat(cleaned);
  if (!isNumber(parsed) || isNaN(parsed) || !isFinite(parsed)) return null;
  
  return parsed;
}

/**
 * Helper function to calculate median
 * 
 * Calculates the median value from an array of numbers.
 * Returns null for empty arrays.
 * 
 * @param values - Array of numbers to calculate median from
 * @returns Median value, or null if array is empty
 */
export function calculateMedian(values: number[]): number | null {
  if (!Array.isArray(values) || values.length === 0) return null;
  
  // Filter out invalid numbers
  const validNumbers = values.filter(v => isNumber(v) && !isNaN(v) && isFinite(v));
  if (validNumbers.length === 0) return null;
  
  const sorted = [...validNumbers].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  
  if (sorted.length % 2 === 0) {
    return (sorted[mid - 1] + sorted[mid]) / 2;
  } else {
    return sorted[mid];
  }
}

/**
 * Helper function to find IRR threshold for an industry
 * 
 * Looks up the IRR (Internal Rate of Return) threshold value for a given industry
 * from the industry thresholds configuration. Performs case-insensitive matching.
 * 
 * @param industryName - Name of the industry to look up
 * @returns IRR threshold value, or 0 if industry not found
 */
export function findIRRForIndustry(industryName: string): number {
  if (!isString(industryName)) return 0;
  
  const trimmed = industryName.trim();
  if (trimmed.length === 0) return 0;
  
  // Try exact match first
  const exactMatch = INDUSTRY_IRR_MAP[trimmed];
  if (isNumber(exactMatch)) {
    return exactMatch;
  }
  
  // Try case-insensitive match
  const lowerTrimmed = trimmed.toLowerCase();
  for (const [key, value] of Object.entries(INDUSTRY_IRR_MAP)) {
    if (isString(key) && key.toLowerCase() === lowerTrimmed && isNumber(value)) {
      return value;
    }
  }
  
  return 0; // Not found
}

/**
 * Helper function to find Leverage F2 thresholds for an industry
 * 
 * Looks up the Leverage F2 threshold range (min/max) for a given industry
 * from the industry thresholds configuration. Performs case-insensitive matching.
 * 
 * @param industryName - Name of the industry to look up
 * @returns Object with min and max threshold values, or { min: 0, max: 0 } if not found
 */
export function findLeverageF2ForIndustry(industryName: string): { min: number; max: number } {
  const trimmed = industryName.trim();
  
  // Try exact match first
  if (INDUSTRY_LEVERAGE_F2_MAP[trimmed] !== undefined) {
    const { greenMax, redMin } = INDUSTRY_LEVERAGE_F2_MAP[trimmed];
    return { min: greenMax, max: redMin };
  }
  
  // Try case-insensitive match
  const lowerTrimmed = trimmed.toLowerCase();
  for (const [key, value] of Object.entries(INDUSTRY_LEVERAGE_F2_MAP)) {
    if (key.toLowerCase() === lowerTrimmed) {
      const { greenMax, redMin } = value;
      return { min: greenMax, max: redMin };
    }
  }
  
  return { min: 0, max: 0 }; // Not found
}

/**
 * Helper function to find RO40 thresholds for an industry
 * 
 * Looks up the RO40 (Return on 40%) threshold range (min/max) for a given industry
 * from the industry thresholds configuration. Performs case-insensitive matching.
 * 
 * @param industryName - Name of the industry to look up
 * @returns Object with min and max threshold values, or { min: 0, max: 0 } if not found
 */
export function findRO40ForIndustry(industryName: string): { min: number; max: number } {
  const trimmed = industryName.trim();
  
  // Try exact match first
  if (INDUSTRY_RO40_MAP[trimmed] !== undefined) {
    return INDUSTRY_RO40_MAP[trimmed];
  }
  
  // Try case-insensitive match
  const lowerTrimmed = trimmed.toLowerCase();
  for (const [key, value] of Object.entries(INDUSTRY_RO40_MAP)) {
    if (key.toLowerCase() === lowerTrimmed) {
      return value;
    }
  }
  
  return { min: 0, max: 0 }; // Not found
}

/**
 * Helper function to find Cash/SDebt thresholds for an industry
 * 
 * Looks up the Cash/SDebt threshold range (min/max) for a given industry
 * from the industry thresholds configuration. Performs case-insensitive matching.
 * 
 * @param industryName - Name of the industry to look up
 * @returns Object with min and max threshold values, or { min: 0, max: 0 } if not found
 */
export function findCashSdebtForIndustry(industryName: string): { min: number; max: number } {
  const trimmed = industryName.trim();
  
  // Try exact match first
  if (INDUSTRY_CASH_SDEBT_MAP[trimmed] !== undefined) {
    return INDUSTRY_CASH_SDEBT_MAP[trimmed];
  }
  
  // Try case-insensitive match
  const lowerTrimmed = trimmed.toLowerCase();
  for (const [key, value] of Object.entries(INDUSTRY_CASH_SDEBT_MAP)) {
    if (key.toLowerCase() === lowerTrimmed) {
      return value;
    }
  }
  
  return { min: 0, max: 0 }; // Not found
}

/**
 * Helper function to find Current Ratio thresholds for an industry
 * 
 * Looks up the Current Ratio threshold range (min/max) for a given industry
 * from the industry thresholds configuration. Performs case-insensitive matching.
 * 
 * @param industryName - Name of the industry to look up
 * @returns Object with min and max threshold values, or { min: 0, max: 0 } if not found
 */
export function findCurrentRatioForIndustry(industryName: string): { min: number; max: number } {
  const trimmed = industryName.trim();
  
  // Try exact match first
  if (INDUSTRY_CURRENT_RATIO_MAP[trimmed] !== undefined) {
    return INDUSTRY_CURRENT_RATIO_MAP[trimmed];
  }
  
  // Try case-insensitive match
  const lowerTrimmed = trimmed.toLowerCase();
  for (const [key, value] of Object.entries(INDUSTRY_CURRENT_RATIO_MAP)) {
    if (key.toLowerCase() === lowerTrimmed) {
      return value;
    }
  }
  
  return { min: 0, max: 0 }; // Not found
}

```

## `src/services/sheets/fetchConfig.ts`

```typescript
/**
 * Fetch service configuration: Apps Script URL, CORS proxies, timeouts.
 * URL validation runs at module load (side effect).
 */

import { logger } from '../../utils/logger';

export const APPS_SCRIPT_URL = import.meta.env.VITE_APPS_SCRIPT_URL || '';

export const CORS_PROXIES = [
  'https://api.allorigins.win/raw?url=',
  'https://corsproxy.io/?',
];

const FETCH_TIMEOUT_SECONDS_NUM = parseInt(import.meta.env.VITE_FETCH_TIMEOUT_SECONDS || '30', 10);
export const FETCH_TIMEOUT_SECONDS = FETCH_TIMEOUT_SECONDS_NUM;
export const FETCH_TIMEOUT = FETCH_TIMEOUT_SECONDS_NUM * 1000;

// Validate Apps Script URL format at startup (warn only, don't fail)
if (APPS_SCRIPT_URL) {
  if (import.meta.env.DEV) {
    if (APPS_SCRIPT_URL.includes('/library/')) {
      logger.error(
        'Invalid Apps Script URL: Looks like a library deployment, not a Web App! Expected format: https://script.google.com/macros/s/SCRIPT_ID/exec. SOLUTION: Redeploy as "Web app" (not "Library") in Apps Script → Deploy → New deployment',
        undefined,
        { component: 'fetchService', operation: 'validateAppsScriptUrl' }
      );
    } else if (!APPS_SCRIPT_URL.includes('script.google.com/macros/s/') || !APPS_SCRIPT_URL.endsWith('/exec')) {
      logger.warn(
        'Apps Script URL format may be incorrect. Expected: https://script.google.com/macros/s/SCRIPT_ID/exec',
        { component: 'fetchService', operation: 'validateAppsScriptUrl' }
      );
    } else {
      logger.info(
        'Apps Script URL configured successfully. Status: Ready to use (will bypass CSV proxy)',
        { component: 'fetchService', operation: 'validateAppsScriptUrl' }
      );
    }
  }
} else {
  const isProduction = import.meta.env.PROD;
  const isVercel = typeof window !== 'undefined' && window.location.hostname.includes('vercel.app');

  if (isProduction || isVercel) {
    if (import.meta.env.DEV) {
      logger.error(
        'Apps Script URL NOT configured in Vercel! App will fall back to slower CSV proxy method. TO FIX: Go to Vercel Dashboard → Your Project → Settings → Environment Variables → Add VITE_APPS_SCRIPT_URL → Select all environments → Save and REDEPLOY',
        undefined,
        { component: 'fetchService', operation: 'validateAppsScriptUrl' }
      );
    }
  } else {
    if (import.meta.env.DEV) {
      logger.info(
        'Apps Script URL not configured locally. App will use CSV fallback. To enable locally: Create .env.local file with VITE_APPS_SCRIPT_URL=your-apps-script-url',
        { component: 'fetchService', operation: 'validateAppsScriptUrl' }
      );
    }
  }
}

```

## `src/services/sheets/fetchCsv.ts`

```typescript
/**
 * Fetch CSV data from Google Sheets via CORS proxies.
 */

import Papa from 'papaparse';
import { getCachedData, setCachedData, DEFAULT_TTL } from '../firestoreCacheService';
import { createErrorHandler, isNetworkError } from '../../utils/errorHandler';
import { logger } from '../../utils/logger';
import { checkRateLimit } from '../../utils/rateLimiter';
import { transformInWorker, getTransformerId } from '../workerService';
import type { DataRow, ProgressCallback } from './types';
import {
  CORS_PROXIES,
  FETCH_TIMEOUT,
  FETCH_TIMEOUT_SECONDS,
} from './fetchConfig';
import { validateCSVText } from './fetchValidation';

export async function fetchCSVData<T>(
  csvUrl: string,
  dataTypeName: string,
  transformer: (results: { data: DataRow[]; meta: { fields: string[] | null } }) => T[],
  requiredColumns?: string[],
  cacheKey?: string,
  forceRefresh: boolean = false,
  ttl: number = DEFAULT_TTL,
  progressCallback?: ProgressCallback,
  additionalData?: Record<string, unknown>
): Promise<T[]> {
  if (cacheKey && !forceRefresh) {
    const cachedData = await getCachedData<T[]>(cacheKey);
    if (cachedData !== null) {
      logger.debug(`Using cached ${dataTypeName} data`, { component: 'fetchService', dataTypeName });
      progressCallback?.({ stage: 'complete', percentage: 100, message: 'Using cached data' });
      return cachedData;
    }
  }

  const rateLimitKey = `csv:${dataTypeName}`;
  const rateLimitResult = checkRateLimit('fetch', rateLimitKey);
  if (!rateLimitResult.allowed) {
    const error = new Error(
      `Rate limit exceeded for ${dataTypeName} CSV fetch. ${rateLimitResult.error || 'Please try again later.'}`
    );
    logger.error('Rate limit exceeded', error, {
      component: 'fetchService',
      dataTypeName,
      operation: 'fetchCSVData',
      rateLimitResult,
    });
    throw error;
  }

  logger.debug(
    `Using CSV proxy for ${dataTypeName} (slower method - configure VITE_APPS_SCRIPT_URL for 5-10x faster performance)`,
    { component: 'fetchService', dataTypeName, operation: 'fetchCSVData' }
  );

  progressCallback?.({
    stage: 'fetch',
    percentage: 0,
    message: `Fetching ${dataTypeName} data via CSV proxy...`,
  });

  const proxyErrors: Array<{ proxy: string; error: string }> = [];

  for (let i = 0; i < CORS_PROXIES.length; i++) {
    const proxy = CORS_PROXIES[i];
    try {
      const proxyUrl = `${proxy}${encodeURIComponent(csvUrl)}`;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT);

      let response: Response;
      try {
        response = await fetch(proxyUrl, {
          headers: { Accept: 'text/csv' },
          signal: controller.signal,
        });
        clearTimeout(timeoutId);
      } catch (fetchError: unknown) {
        clearTimeout(timeoutId);
        if (fetchError instanceof Error && fetchError.name === 'AbortError') {
          throw new Error(`Request timeout after ${FETCH_TIMEOUT_SECONDS} seconds`);
        }
        if (fetchError instanceof TypeError) {
          const errorMessage = fetchError.message.toLowerCase();
          if (
            errorMessage.includes('cors') ||
            errorMessage.includes('cross-origin') ||
            errorMessage.includes('access-control-allow-origin') ||
            errorMessage.includes('networkerror') ||
            errorMessage.includes('failed to fetch')
          ) {
            throw new Error('CORS policy blocked');
          }
        }
        throw fetchError;
      }

      if (!response.ok) {
        if (response.status === 408) {
          proxyErrors.push({ proxy, error: 'Request timeout (408)' });
          continue;
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      if (proxyErrors.length > 0) {
        logger.info(
          `${dataTypeName}: Successfully fetched via ${proxy.replace(/^https?:\/\//, '').replace(/\/.*$/, '')} (after ${proxyErrors.length} failed attempt${proxyErrors.length > 1 ? 's' : ''})`,
          { component: 'fetchService', dataTypeName, proxy, failedAttempts: proxyErrors.length }
        );
      }

      progressCallback?.({
        stage: 'fetch',
        percentage: 30,
        message: `Received ${dataTypeName} data, parsing...`,
      });

      const csvText = await response.text();
      validateCSVText(csvText);

      progressCallback?.({
        stage: 'parse',
        percentage: 40,
        message: `Parsing ${dataTypeName} CSV...`,
      });

      return await new Promise((resolve, reject) => {
        Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          transformHeader: (header: string) => header.trim(),
          complete: async (results) => {
            try {
              if (results.data.length > 0) {
                logger.debug(`${dataTypeName} CSV Headers: ${results.meta.fields?.join(', ') || 'none'}`, {
                  component: 'fetchService',
                  dataTypeName,
                  headers: results.meta.fields,
                });
                logger.debug(`${dataTypeName} First row sample`, {
                  component: 'fetchService',
                  dataTypeName,
                  firstRow: results.data[0],
                });
              }

              progressCallback?.({
                stage: 'transform',
                percentage: 80,
                message: `Transforming ${dataTypeName} data...`,
                rowsProcessed: results.data.length,
                totalRows: results.data.length,
              });

              const compatibleResults = {
                data: results.data as DataRow[],
                meta: { fields: results.meta.fields || null },
              };

              let transformedData: T[];
              const transformerId = getTransformerId(dataTypeName);
              if (transformerId) {
                try {
                  transformedData = await transformInWorker<T>(
                    transformerId,
                    compatibleResults.data,
                    compatibleResults.meta,
                    progressCallback,
                    additionalData,
                    transformer
                  );
                } catch (workerError) {
                  logger.debug(`Worker transformation failed for ${dataTypeName}, using main thread`, {
                    component: 'fetchService',
                    dataTypeName,
                    error: workerError,
                  });
                  transformedData = transformer(compatibleResults);
                }
              } else {
                transformedData = transformer(compatibleResults);
              }

              if (transformedData.length === 0) {
                logger.error(
                  `${dataTypeName} CSV parsing result: No valid data found`,
                  undefined,
                  {
                    component: 'fetchService',
                    dataTypeName,
                    totalRows: results.data.length,
                    headers: results.meta.fields,
                    firstRow: results.data[0],
                    csvPreview: csvText.substring(0, 500),
                  }
                );
                const columnsMsg = requiredColumns
                  ? `Please check that the Google Sheet has columns: ${requiredColumns.join(', ')}`
                  : '';
                reject(
                  new Error(
                    `No valid ${dataTypeName} data found in CSV. ` +
                      `Found ${results.data.length} rows. ` +
                      `Headers: ${results.meta.fields?.join(', ') || 'none'}. ` +
                      columnsMsg
                  )
                );
                return;
              }

              logger.info(
                `Successfully parsed ${transformedData.length} ${dataTypeName} entries from CSV`,
                { component: 'fetchService', dataTypeName, count: transformedData.length }
              );

              if (cacheKey) {
                logger.debug(`Saving ${dataTypeName} data to Firestore cache (CSV)`, {
                  component: 'fetchService',
                  dataTypeName,
                  cacheKey,
                  entryCount: transformedData.length,
                });
                try {
                  await setCachedData(cacheKey, transformedData, ttl);
                  logger.info(`${dataTypeName} data saved to Firestore cache successfully (CSV)`, {
                    component: 'fetchService',
                    dataTypeName,
                    cacheKey,
                    entryCount: transformedData.length,
                  });
                } catch (cacheError) {
                  logger.error(`Failed to save ${dataTypeName} data to Firestore cache (CSV)`, {
                    component: 'fetchService',
                    dataTypeName,
                    cacheKey,
                    error: cacheError,
                  });
                }
              }

              progressCallback?.({
                stage: 'complete',
                percentage: 100,
                message: `Successfully loaded ${transformedData.length} ${dataTypeName} entries`,
                rowsProcessed: transformedData.length,
                totalRows: transformedData.length,
              });

              resolve(transformedData);
            } catch (error: unknown) {
              const errorHandler = createErrorHandler({
                operation: `parse ${dataTypeName} CSV data`,
                component: 'fetchService',
                additionalInfo: { dataTypeName, proxy },
              });
              const formatted = errorHandler(error);
              reject(new Error(`Failed to parse ${dataTypeName} CSV data: ${formatted.message}`));
            }
          },
          error: (error: unknown) => {
            const errorHandler = createErrorHandler({
              operation: `parse ${dataTypeName} CSV`,
              component: 'fetchService',
              additionalInfo: { dataTypeName, proxy },
            });
            const formatted = errorHandler(error);
            reject(new Error(`${dataTypeName} CSV parsing error: ${formatted.message}`));
          },
        });
      });
    } catch (error: unknown) {
      const errorHandler = createErrorHandler({
        operation: 'fetch CSV via proxy',
        component: 'fetchService',
        additionalInfo: { proxy, csvUrl, dataTypeName },
      });
      const formatted = errorHandler(error);

      const isCorsError =
        isNetworkError(error) ||
        formatted.message.includes('CORS') ||
        formatted.message.includes('cross-origin') ||
        formatted.message.includes('Access-Control-Allow-Origin') ||
        formatted.message.includes('CORS policy blocked') ||
        (error instanceof TypeError && error.message.toLowerCase().includes('cors'));
      const isTimeoutError =
        formatted.message.includes('timeout') ||
        formatted.message.includes('408') ||
        formatted.message.includes('Request timeout');
      const isNetworkErr =
        isNetworkError(error) ||
        formatted.message.includes('Failed to fetch') ||
        formatted.message.includes('network');

      proxyErrors.push({
        proxy,
        error: isCorsError
          ? 'CORS blocked'
          : isTimeoutError
            ? 'Request timeout'
            : isNetworkErr
              ? 'Network error'
              : formatted.message.substring(0, 50),
      });

      if (isCorsError && i < CORS_PROXIES.length - 1) {
        continue;
      }

      if (i === CORS_PROXIES.length - 1) {
        logger.warn(
          `${dataTypeName}: All proxy attempts failed. Errors: ${proxyErrors.map((e) => `${e.proxy.replace(/^https?:\/\//, '').replace(/\/.*$/, '')}: ${e.error}`).join(', ')}`,
          { component: 'fetchService', dataTypeName, proxyErrors }
        );
      }

      if (i < CORS_PROXIES.length - 1 && !isCorsError) {
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
      continue;
    }
  }

  const errorSummary =
    proxyErrors.length > 0
      ? `\nProxy failures:\n${proxyErrors.map((e, idx) => `  ${idx + 1}. ${e.proxy.replace(/^https?:\/\//, '').replace(/\/.*$/, '')}: ${e.error}`).join('\n')}`
      : '';

  throw new Error(
    `Failed to fetch ${dataTypeName} data from all proxies (tried ${CORS_PROXIES.length} proxy${CORS_PROXIES.length > 1 ? 'ies' : ''}).${errorSummary}\n\n` +
      `SOLUTIONS:\n` +
      `1. Check your internet connection\n` +
      `2. Verify the Google Sheet is publicly accessible (Share → Anyone with the link → Viewer)\n` +
      `3. Configure Apps Script URL to bypass proxies: Set VITE_APPS_SCRIPT_URL environment variable\n` +
      `4. Wait a moment and refresh the page (proxy services may be temporarily unavailable)`
  );
}

```

## `src/services/sheets/fetchDataConversion.ts`

```typescript
/**
 * Data conversion helpers for fetch service (2D array to objects, mock parse result).
 */

import { is2DArray } from '../../utils/typeGuards';
import type { DataRow } from './types';

/**
 * Convert 2D array from Apps Script to object array format
 */
export function convert2DArrayToObjects(data: unknown[][]): DataRow[] {
  if (!is2DArray(data) || data.length === 0) {
    return [];
  }

  const headers = data[0].map((h: unknown) => String(h).trim());
  const rows: DataRow[] = [];

  for (let i = 1; i < data.length; i++) {
    const row: DataRow = {};
    const values = data[i];

    for (let j = 0; j < headers.length; j++) {
      const header = headers[j];
      const value = values[j];
      if (value === null || value === undefined || value === '') {
        row[header] = '';
      } else if (typeof value === 'string' || typeof value === 'number') {
        row[header] = value;
      } else {
        row[header] = String(value);
      }
    }
    rows.push(row);
  }

  return rows;
}

/**
 * Create a mock Papa.ParseResult-like object for compatibility with existing transformers
 */
export function createMockParseResult(data: DataRow[]): {
  data: DataRow[];
  meta: { fields: string[] | null };
} {
  const fields = data.length > 0 ? Object.keys(data[0]) : null;
  return {
    data,
    meta: { fields },
  };
}

```

## `src/services/sheets/fetchJson.ts`

```typescript
/**
 * Fetch JSON data from Apps Script API.
 */

import { getCachedData, setCachedData, DEFAULT_TTL } from '../firestoreCacheService';
import { createErrorHandler, isNetworkError } from '../../utils/errorHandler';
import { logger } from '../../utils/logger';
import { checkRateLimit } from '../../utils/rateLimiter';
import { transformInWorker, getTransformerId } from '../workerService';
import type { DataRow, ProgressCallback } from './types';
import { APPS_SCRIPT_URL } from './fetchConfig';
import { convert2DArrayToObjects, createMockParseResult } from './fetchDataConversion';

export async function fetchJSONData<T>(
  sheetName: string,
  dataTypeName: string,
  transformer: (results: { data: DataRow[]; meta: { fields: string[] | null } }) => T[],
  requiredColumns?: string[],
  cacheKey?: string,
  forceRefresh: boolean = false,
  ttl: number = DEFAULT_TTL,
  progressCallback?: ProgressCallback,
  additionalData?: Record<string, unknown>
): Promise<T[]> {
  if (cacheKey && !forceRefresh) {
    const cachedData = await getCachedData<T[]>(cacheKey);
    if (cachedData !== null) {
      logger.debug(`Using cached ${dataTypeName} data`, { component: 'fetchService', dataTypeName });
      progressCallback?.({ stage: 'complete', percentage: 100, message: 'Using cached data' });
      return cachedData;
    }
  }

  const rateLimitKey = `json:${sheetName}:${dataTypeName}`;
  const rateLimitResult = checkRateLimit('fetch', rateLimitKey);
  if (!rateLimitResult.allowed) {
    const error = new Error(
      `Rate limit exceeded for ${dataTypeName} data fetch. ${rateLimitResult.error || 'Please try again later.'}`
    );
    logger.error('Rate limit exceeded', error, {
      component: 'fetchService',
      dataTypeName,
      operation: 'fetchJSONData',
      rateLimitResult,
    });
    throw error;
  }

  if (!APPS_SCRIPT_URL) {
    const isProduction = import.meta.env.PROD;
    const isVercel = typeof window !== 'undefined' && window.location.hostname.includes('vercel.app');
    if (isProduction || isVercel) {
      logger.error(
        `Apps Script URL NOT configured in Vercel for ${dataTypeName}! App will fall back to slower CSV proxy method. TO FIX: Go to Vercel Dashboard → Your Project → Settings → Environment Variables → Add VITE_APPS_SCRIPT_URL → Select all environments → Save and REDEPLOY`,
        undefined,
        { component: 'fetchService', dataTypeName, operation: 'fetchJSONData' }
      );
    } else {
      logger.warn(
        `Apps Script URL not configured locally for ${dataTypeName}, falling back to CSV. To enable locally: Create .env.local file with VITE_APPS_SCRIPT_URL=your-apps-script-url`,
        { component: 'fetchService', dataTypeName, operation: 'fetchJSONData' }
      );
    }
    throw new Error('Apps Script URL not configured');
  }

  if (!APPS_SCRIPT_URL.includes('script.google.com/macros/s/') || !APPS_SCRIPT_URL.endsWith('/exec')) {
    logger.error(
      'Invalid Apps Script URL format. Expected: https://script.google.com/macros/s/SCRIPT_ID/exec',
      undefined,
      { component: 'fetchService', dataTypeName, operation: 'fetchJSONData' }
    );
    throw new Error('Invalid Apps Script URL format. Please check VITE_APPS_SCRIPT_URL environment variable.');
  }

  logger.debug(
    `Using Apps Script API for ${dataTypeName} (5-10x faster than CSV proxy)`,
    { component: 'fetchService', dataTypeName, operation: 'fetchJSONData' }
  );

  progressCallback?.({
    stage: 'fetch',
    percentage: 0,
    message: `Fetching ${dataTypeName} data from Apps Script API...`,
  });

  try {
    const url = `${APPS_SCRIPT_URL}?sheet=${encodeURIComponent(sheetName)}`;
    let response: Response;
    try {
      response = await fetch(url, {
        method: 'GET',
        headers: { Accept: 'application/json' },
        mode: 'cors',
      });
    } catch (fetchError: unknown) {
      if (fetchError instanceof TypeError && fetchError.message.includes('fetch')) {
        const isCorsError =
          fetchError.message.includes('CORS') ||
          fetchError.message.includes('cross-origin') ||
          fetchError.message.includes('Access-Control-Allow-Origin');
        if (isCorsError || url.includes('script.google.com')) {
          throw new Error(
            `CORS error: Apps Script is blocking cross-origin requests. ` +
              `SOLUTION: In Apps Script → Deploy → Manage deployments → Edit → ` +
              `Set "Who has access" to "Anyone" → Save and redeploy. ` +
              `Also verify the URL format: ${APPS_SCRIPT_URL}`
          );
        }
      }
      throw fetchError;
    }

    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Apps Script not found (404). Please verify the URL: ${APPS_SCRIPT_URL}`);
      }
      if (response.status === 401 || response.status === 403) {
        throw new Error(
          `Apps Script access denied (${response.status}). ` +
            `SOLUTION: In Apps Script → Deploy → Manage deployments → Edit → ` +
            `Set "Who has access" to "Anyone" → Save and redeploy.`
        );
      }
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    progressCallback?.({
      stage: 'fetch',
      percentage: 30,
      message: `Received ${dataTypeName} data, parsing...`,
    });

    let jsonData: unknown;
    try {
      jsonData = await response.json();
    } catch (parseError: unknown) {
      const errorHandler = createErrorHandler({
        operation: 'parse JSON response',
        component: 'fetchService',
        additionalInfo: { sheetName, dataTypeName },
      });
      const formatted = errorHandler(parseError);
      throw new Error(`Failed to parse JSON response: ${formatted.message}`);
    }

    if (!Array.isArray(jsonData) || jsonData.length === 0) {
      throw new Error('Invalid JSON response: expected non-empty array');
    }

    progressCallback?.({
      stage: 'parse',
      percentage: 40,
      message: `Parsing ${dataTypeName} JSON...`,
    });

    const dataRows = convert2DArrayToObjects(jsonData);
    if (dataRows.length === 0) {
      throw new Error('No data rows found after conversion');
    }

    if (dataRows.length > 0) {
      const fields = Object.keys(dataRows[0]);
      logger.debug(`${dataTypeName} JSON Headers: ${fields.join(', ')}`, {
        component: 'fetchService',
        dataTypeName,
        headers: fields,
      });
      logger.debug(`${dataTypeName} First row sample`, {
        component: 'fetchService',
        dataTypeName,
        firstRow: dataRows[0],
      });
    }

    const mockResults = createMockParseResult(dataRows);

    progressCallback?.({
      stage: 'transform',
      percentage: 80,
      message: `Transforming ${dataTypeName} data...`,
      rowsProcessed: dataRows.length,
      totalRows: dataRows.length,
    });

    let transformedData: T[];
    const transformerId = getTransformerId(dataTypeName, sheetName);
    if (transformerId) {
      try {
        transformedData = await transformInWorker<T>(
          transformerId,
          dataRows,
          mockResults.meta,
          progressCallback,
          additionalData,
          transformer
        );
      } catch (workerError) {
        logger.debug(`Worker transformation failed for ${dataTypeName}, using main thread`, {
          component: 'fetchService',
          dataTypeName,
          error: workerError,
        });
        transformedData = transformer(mockResults);
      }
    } else {
      transformedData = transformer(mockResults);
    }

    if (transformedData.length === 0) {
      const fields = dataRows.length > 0 ? Object.keys(dataRows[0]) : [];
      const columnsMsg = requiredColumns
        ? `Please check that the Google Sheet has columns: ${requiredColumns.join(', ')}`
        : '';
      throw new Error(
        `No valid ${dataTypeName} data found. ` +
          `Found ${dataRows.length} rows. ` +
          `Headers: ${fields.join(', ') || 'none'}. ` +
          columnsMsg
      );
    }

    logger.info(
      `Successfully loaded ${transformedData.length} ${dataTypeName} entries via Apps Script API (fast method)`,
      { component: 'fetchService', dataTypeName, count: transformedData.length }
    );

    if (cacheKey) {
      logger.debug(`Saving ${dataTypeName} data to Firestore cache`, {
        component: 'fetchService',
        dataTypeName,
        cacheKey,
        entryCount: transformedData.length,
      });
      try {
        await setCachedData(cacheKey, transformedData, ttl);
        logger.info(`${dataTypeName} data saved to Firestore cache successfully`, {
          component: 'fetchService',
          dataTypeName,
          cacheKey,
          entryCount: transformedData.length,
        });
      } catch (cacheError) {
        logger.error(`Failed to save ${dataTypeName} data to Firestore cache`, {
          component: 'fetchService',
          dataTypeName,
          cacheKey,
          error: cacheError,
        });
      }
    }

    progressCallback?.({
      stage: 'complete',
      percentage: 100,
      message: `Successfully loaded ${transformedData.length} ${dataTypeName} entries`,
      rowsProcessed: transformedData.length,
      totalRows: transformedData.length,
    });

    return transformedData;
  } catch (error: unknown) {
    const errorHandler = createErrorHandler({
      operation: `fetch ${dataTypeName} data from Apps Script`,
      component: 'fetchService',
      additionalInfo: { sheetName, dataTypeName, url: APPS_SCRIPT_URL },
    });
    const formatted = errorHandler(error);

    let errorGuidance = '';
    if (
      isNetworkError(error) ||
      formatted.message.includes('CORS') ||
      formatted.message.includes('cross-origin')
    ) {
      errorGuidance =
        `\n\nTroubleshooting CORS:\n` +
        `1. Go to Apps Script → Deploy → Manage deployments\n` +
        `2. Click edit (pencil icon) on your deployment\n` +
        `3. Verify "Who has access" is set to "Anyone"\n` +
        `4. Save and redeploy\n` +
        `5. Verify URL format: https://script.google.com/macros/s/SCRIPT_ID/exec`;
    } else if (formatted.message.includes('404') || formatted.message.includes('not found')) {
      errorGuidance =
        `\n\nTroubleshooting 404:\n` +
        `1. Verify VITE_APPS_SCRIPT_URL in Vercel Environment Variables\n` +
        `2. Test the URL directly in browser: ${APPS_SCRIPT_URL}?sheet=${sheetName}\n` +
        `3. Ensure Apps Script is deployed as "Web app" (not "Library")\n` +
        `4. URL should end with /exec (not /library/...)`;
    } else if (formatted.message.includes('Invalid Apps Script URL')) {
      errorGuidance =
        `\n\nExpected URL format: https://script.google.com/macros/s/SCRIPT_ID/exec\n` +
        `Current URL: ${APPS_SCRIPT_URL || '(not set)'}`;
    }

    const enhancedError = new Error(
      `Failed to fetch ${dataTypeName} data from Apps Script: ${formatted.message}. ` +
        `Please check your Apps Script URL configuration and ensure the sheet "${sheetName}" exists.${errorGuidance}`
    );
    if (error instanceof Error) {
      enhancedError.stack = error.stack;
      (enhancedError as Error & { cause?: unknown }).cause = error;
    }
    throw enhancedError;
  }
}

```

## `src/services/sheets/fetchService.ts`

```typescript
/**
 * Fetch Service - Barrel
 *
 * Re-exports fetch functions and helpers. Use this module for all fetch imports.
 */

import { DEFAULT_TTL } from '../firestoreCacheService';
import { logger } from '../../utils/logger';
import type { DataRow, ProgressCallback } from './types';
import { fetchJSONData } from './fetchJson';
import { fetchCSVData } from './fetchCsv';
import { convert2DArrayToObjects, createMockParseResult } from './fetchDataConversion';
import { validateCSVText } from './fetchValidation';

export { convert2DArrayToObjects, createMockParseResult };
export { validateCSVText };
export { fetchJSONData } from './fetchJson';
export { fetchCSVData } from './fetchCsv';

export interface FetchWithFallbackConfig<T> {
  sheetName: string;
  dataTypeName: string;
  transformer: (results: { data: DataRow[]; meta: { fields: string[] | null } }) => T[];
  requiredColumns?: string[];
  cacheKey?: string;
  forceRefresh?: boolean;
  ttl?: number;
  progressCallback?: ProgressCallback;
  csvUrl: string;
  additionalData?: Record<string, unknown>;
}

export async function fetchWithFallback<T>(
  config: FetchWithFallbackConfig<T>
): Promise<T[]> {
  const {
    sheetName,
    dataTypeName,
    transformer,
    requiredColumns,
    cacheKey,
    forceRefresh = false,
    ttl = DEFAULT_TTL,
    progressCallback,
    csvUrl,
    additionalData,
  } = config;

  try {
    return await fetchJSONData<T>(
      sheetName,
      dataTypeName,
      transformer,
      requiredColumns,
      cacheKey,
      forceRefresh,
      ttl,
      progressCallback,
      additionalData
    );
  } catch (error: unknown) {
    logger.warn(
      `Apps Script API failed for ${dataTypeName}, falling back to CSV proxy (slower method)`,
      { component: 'fetchService', dataTypeName, operation: 'fetchWithFallback', error }
    );

    return fetchCSVData<T>(
      csvUrl,
      dataTypeName,
      transformer,
      requiredColumns,
      cacheKey,
      forceRefresh,
      ttl,
      progressCallback,
      additionalData
    );
  }
}

```

## `src/services/sheets/fetchValidation.ts`

```typescript
/**
 * CSV response validation for fetch service.
 */

/**
 * Validates CSV text to ensure it's not HTML or empty
 *
 * Checks if the response is valid CSV data and not an HTML login page.
 * Throws descriptive errors if validation fails.
 *
 * @param csvText - The CSV text to validate
 * @throws {Error} If the text is empty, HTML, or doesn't appear to be valid CSV
 */
export function validateCSVText(csvText: string): void {
  if (!csvText || csvText.trim().length === 0) {
    throw new Error('Empty response from server');
  }

  const trimmedText = csvText.trim().toLowerCase();
  if (
    trimmedText.startsWith('<!doctype html') ||
    trimmedText.startsWith('<html') ||
    csvText.includes('accounts.google.com') ||
    csvText.includes('Sign in') ||
    csvText.includes('signin') ||
    csvText.includes('Google Account')
  ) {
    throw new Error(
      'Received HTML login page instead of CSV data. ' +
        'The Google Sheet is not publicly accessible. ' +
        'SOLUTION: Go to your Google Sheet → Click "Share" button → ' +
        'Change to "Anyone with the link" → Set permission to "Viewer" → Save. ' +
        'Then refresh this page.'
    );
  }

  if (!csvText.includes(',') && csvText.length > 100) {
    throw new Error('Response does not appear to be valid CSV data');
  }
}

```

## `src/services/sheets/index.ts`

```typescript
/**
 * Sheets Service - Barrel Export
 * 
 * Central export point for all sheets-related services.
 * Provides backward compatibility with existing imports.
 */

// Types
export type { DataRow, ProgressCallback } from './types';

// Data transformers (helper functions)
export {
  getValue,
  getValueAllowZero,
  isValidValue,
  parseNumericValueNullable,
  parsePercentageValueNullable,
  calculateMedian,
  findIRRForIndustry,
  findLeverageF2ForIndustry,
  findRO40ForIndustry,
  findCashSdebtForIndustry,
  findCurrentRatioForIndustry,
} from './dataTransformers';

// Fetch functions
export {
  convert2DArrayToObjects,
  createMockParseResult,
  fetchJSONData,
  fetchCSVData,
  fetchWithFallback,
  type FetchWithFallbackConfig,
} from './fetchService';

// Data fetching functions
export { fetchBenjaminGrahamData } from './benjaminGrahamService';
export { fetchSMAData } from './smaService';
export { fetchPEIndustryData } from './peIndustryService';
export { fetchScoreBoardData } from './scoreBoardService';
// Note: fetchThresholdIndustryData removed - threshold data is now static (see src/config/thresholdIndustryData.ts)

```

## `src/services/sheets/peIndustryService.ts`

```typescript
/**
 * P/E Industry Service
 * 
 * Fetches and transforms P/E Industry data from Google Sheets.
 * Groups companies by industry and calculates median P/E ratios.
 */

import { PEIndustryData } from '../../types/stock';
import { CACHE_KEYS, DEFAULT_TTL } from '../firestoreCacheService';
import { fetchWithFallback } from './fetchService';
import { getValue, isValidValue, parseNumericValueNullable, calculateMedian } from './dataTransformers';
import type { DataRow, ProgressCallback } from './types';

// P/E Industry data configuration
const PE_INDUSTRY_SHEET_ID = '1KOOSLJVGdDZHBV1MUmb4D9oVIKUJj5TIgYCerjkWYcE';
const PE_INDUSTRY_GID = '1180885830';
const PE_INDUSTRY_CSV_URL = `https://docs.google.com/spreadsheets/d/${PE_INDUSTRY_SHEET_ID}/export?format=csv&gid=${PE_INDUSTRY_GID}`;

/**
 * Transformer function for P/E Industry data
 */
export function transformPEIndustryData(results: { data: DataRow[]; meta: { fields: string[] | null } }): PEIndustryData[] {
  // Group data by industry
  const industryMap = new Map<string, { pe: number[], pe1: number[], pe2: number[], count: number }>();

  results.data.forEach((row: DataRow) => {
    const companyName = getValue(['Company Name', 'Company', 'company'], row);
    const ticker = getValue(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
    const industry = getValue(['INDUSTRY', 'Industry', 'industry'], row);
    
    // Filter out rows where Company Name, Ticker, or Industry is N/A
    if (!isValidValue(companyName) || !isValidValue(ticker) || !isValidValue(industry)) {
      return;
    }

    const peStr = getValue(['P/E', 'P/E', 'pe', 'PE'], row);
    const pe1Str = getValue(['P/E1', 'P/E 1', 'pe1', 'PE1'], row);
    const pe2Str = getValue(['P/E2', 'P/E 2', 'pe2', 'PE2'], row);

    let industryData = industryMap.get(industry);
    if (!industryData) {
      industryData = { pe: [], pe1: [], pe2: [], count: 0 };
      industryMap.set(industry, industryData);
    }
    industryData.count++;

    const pe = parseNumericValueNullable(peStr);
    const pe1 = parseNumericValueNullable(pe1Str);
    const pe2 = parseNumericValueNullable(pe2Str);

    // Include 0 values (actual zeros) but exclude null (invalid/missing)
    if (pe !== null) {
      industryData.pe.push(pe);
    }
    if (pe1 !== null) {
      industryData.pe1.push(pe1);
    }
    if (pe2 !== null) {
      industryData.pe2.push(pe2);
    }
  });

  // Convert to PEIndustryData array
  const peIndustryData: PEIndustryData[] = Array.from(industryMap.entries())
    .map(([industry, data]) => ({
      industry: industry,
      pe: calculateMedian(data.pe),
      pe1: calculateMedian(data.pe1),
      pe2: calculateMedian(data.pe2),
      companyCount: data.count,
    }))
    .filter(item => item.companyCount > 0); // Only include industries with at least one company
  
  return peIndustryData;
}

/**
 * Fetches P/E Industry data from Google Sheets
 * 
 * Retrieves industry-specific P/E ratio data by grouping companies by industry
 * and calculating median P/E, P/E1, and P/E2 values for each industry.
 * Tries Apps Script API first (fast), falls back to CSV proxy if needed (slower).
 * 
 * @param forceRefresh - If true, bypasses cache and forces network request (default: false)
 * @param progressCallback - Optional callback for progress updates during fetch/parse/transform
 * @returns Promise resolving to array of P/E Industry data entries, one per industry
 * @throws {Error} If data fetch fails or required columns are missing
 */
export async function fetchPEIndustryData(
  forceRefresh: boolean = false,
  progressCallback?: ProgressCallback
): Promise<PEIndustryData[]> {
  return fetchWithFallback<PEIndustryData>({
    sheetName: 'DashBoard',
    dataTypeName: 'P/E Industry',
    transformer: transformPEIndustryData,
    requiredColumns: ['INDUSTRY', 'P/E', 'P/E1', 'P/E2', 'Company Name', 'Ticker'],
    cacheKey: CACHE_KEYS.PE_INDUSTRY,
    forceRefresh,
    ttl: DEFAULT_TTL,
    progressCallback,
    csvUrl: PE_INDUSTRY_CSV_URL,
  });
}

```

## `src/services/sheets/scoreBoardService.ts`

```typescript
/**
 * Score Board Service
 * 
 * Fetches and transforms Score Board data from Google Sheets.
 * Combines data from multiple sources (PE Industry and SMA sheets).
 */

import { ScoreBoardData, PEIndustryData } from '../../types/stock';
import { CACHE_KEYS, DEFAULT_TTL } from '../firestoreCacheService';
import { fetchWithFallback } from './fetchService';
import { getValueAllowZero, isValidValue, parseNumericValueNullable, parsePercentageValueNullable } from './dataTransformers';
import { fetchPEIndustryData } from './peIndustryService';
import { fetchSMAData } from './smaService';
import { logger } from '../../utils/logger';
import type { DataRow, ProgressCallback } from './types';

// Score Board data configuration (uses same Dashboard sheet as P/E Industry)
const SCORE_BOARD_SHEET_ID = '1KOOSLJVGdDZHBV1MUmb4D9oVIKUJj5TIgYCerjkWYcE';
const SCORE_BOARD_GID = '1180885830';
const SCORE_BOARD_CSV_URL = `https://docs.google.com/spreadsheets/d/${SCORE_BOARD_SHEET_ID}/export?format=csv&gid=${SCORE_BOARD_GID}`;

/**
 * Creates transformer function for Score Board data
 * 
 * @param industryPe1Map - Map of industry to P/E1 median values
 * @param industryPe2Map - Map of industry to P/E2 median values
 * @param smaDataMap - Map of ticker to SMA data
 * @returns Transformer function
 */
export function createScoreBoardTransformer(
  industryPe1Map: Map<string, number>,
  industryPe2Map: Map<string, number>,
  smaDataMap: Map<string, { sma100: number | null; sma200: number | null; smaCross: string | null }>
) {
  return (results: { data: DataRow[]; meta: { fields: string[] | null } }): ScoreBoardData[] => {
    const scoreBoardData = results.data
      .map((row: DataRow) => {
        const companyName = getValueAllowZero(['Company Name', 'Company', 'company'], row);
        const ticker = getValueAllowZero(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
        const irrStr = getValueAllowZero(['IRR', 'irr', 'Irr'], row);
        const mungerQualityScoreStr = getValueAllowZero(['Munger Quality Score', 'Munger Quality Score', 'munger quality score', 'MUNGER QUALITY SCORE'], row);
        const valueCreationStr = getValueAllowZero(['VALUE CREATION', 'Value Creation', 'value creation', 'VALUE_CREATION'], row);
        const ro40CyStr = getValueAllowZero(['Ro40 CY', 'Ro40 CY', 'ro40 cy', 'RO40 CY'], row);
        const ro40F1Str = getValueAllowZero(['Ro40 F1', 'Ro40 F1', 'ro40 f1', 'RO40 F1'], row);
        const ro40F2Str = getValueAllowZero(['Ro40 F2', 'Ro40 F2', 'ro40 f2', 'RO40 F2'], row);
        const leverageF2Str = getValueAllowZero(['Leverage F2', 'Leverage F2', 'leverage f2', 'LEVERAGE F2'], row);
        const currentRatioStr = getValueAllowZero(['Current Ratio', 'Current Ratio', 'current ratio', 'CURRENT RATIO'], row);
        const cashSdebtStr = getValueAllowZero(['Cash/SDebt', 'Cash/SDebt', 'cash/sdebt', 'CASH/SDEBT'], row);
        
        // Detect division-by-zero for Cash/SDebt (should be treated as green)
        const isCashSdebtDivZero = cashSdebtStr && 
          (cashSdebtStr.trim().toUpperCase() === '#DIV/0!' || 
           cashSdebtStr.trim().toUpperCase() === 'INF' ||
           cashSdebtStr.trim().toUpperCase() === '∞');
        
        // Get (TB/S)/Price directly from Dashboard sheet
        const tbSPriceStr = getValueAllowZero(['(TB/S)/Price', '(TB/S)/Price', '(tb/s)/price', '(TB/S)/PRICE'], row);
        
        const pe1Str = getValueAllowZero(['P/E1', 'P/E 1', 'pe1', 'PE1'], row);
        const pe2Str = getValueAllowZero(['P/E2', 'P/E 2', 'pe2', 'PE2'], row);
        const industryStr = getValueAllowZero(['INDUSTRY', 'Industry', 'industry'], row);
        
        // Filter out rows where Company Name or Ticker is N/A (same rule as Benjamin Graham)
        if (!isValidValue(companyName) || !isValidValue(ticker)) {
          return null;
        }

        const irr = parseNumericValueNullable(irrStr);
        const mungerQualityScore = parseNumericValueNullable(mungerQualityScoreStr);
        const valueCreation = parsePercentageValueNullable(valueCreationStr);
        const ro40Cy = parsePercentageValueNullable(ro40CyStr);
        const ro40F1 = parsePercentageValueNullable(ro40F1Str);
        const ro40F2 = parsePercentageValueNullable(ro40F2Str);
        const leverageF2 = parseNumericValueNullable(leverageF2Str);
        const currentRatio = parseNumericValueNullable(currentRatioStr);
        const cashSdebt = parseNumericValueNullable(cashSdebtStr);
        // Om #DIV/0! detekteras, sätt cashSdebt till 0 istället för null
        const finalCashSdebt = isCashSdebtDivZero ? 0 : cashSdebt;
        
        // Parse (TB/S)/Price directly from column
        const tbSPrice = parseNumericValueNullable(tbSPriceStr);
        
        // Calculate P/E1 INDUSTRY (procentuell skillnad)
        const pe1 = parseNumericValueNullable(pe1Str);
        let pe1Industry: number | null = null;
        
        if (isValidValue(industryStr) && pe1 !== null && pe1 > 0) {
          const industryKey = industryStr.trim().toLowerCase();
          const pe1IndustryMedian = industryPe1Map.get(industryKey);
          
          if (pe1IndustryMedian !== undefined && pe1IndustryMedian > 0) {
            // Calculate percentage difference: (pe1 - pe1IndustryMedian) / pe1IndustryMedian * 100
            pe1Industry = ((pe1 - pe1IndustryMedian) / pe1IndustryMedian) * 100;
          }
        }
        
        // Calculate P/E2 INDUSTRY (procentuell skillnad)
        const pe2 = parseNumericValueNullable(pe2Str);
        let pe2Industry: number | null = null;
        
        if (isValidValue(industryStr) && pe2 !== null && pe2 > 0) {
          const industryKey = industryStr.trim().toLowerCase();
          const pe2IndustryMedian = industryPe2Map.get(industryKey);
          
          if (pe2IndustryMedian !== undefined && pe2IndustryMedian > 0) {
            // Calculate percentage difference: (pe2 - pe2IndustryMedian) / pe2IndustryMedian * 100
            pe2Industry = ((pe2 - pe2IndustryMedian) / pe2IndustryMedian) * 100;
          }
        }

        // Match SMA(100), SMA(200), and SMA Cross from SMA sheet by ticker
        const tickerKey = ticker.toLowerCase().trim();
        const smaMatch = smaDataMap.get(tickerKey);

        return {
          companyName: companyName,
          ticker: ticker,
          industry: industryStr || '',
          irr: irr,
          mungerQualityScore: mungerQualityScore,
          valueCreation: valueCreation,
          tbSPrice: tbSPrice,
          ro40Cy: ro40Cy,
          ro40F1: ro40F1,
          ro40F2: ro40F2,
          leverageF2: leverageF2,
          pe1Industry: pe1Industry,
          pe2Industry: pe2Industry,
          currentRatio: currentRatio,
          cashSdebt: finalCashSdebt,
          isCashSdebtDivZero: isCashSdebtDivZero || false,
          sma100: smaMatch ? smaMatch.sma100 : null, // Directly from SMA sheet
          sma200: smaMatch ? smaMatch.sma200 : null, // Directly from SMA sheet
          smaCross: smaMatch ? smaMatch.smaCross : null, // Directly from SMA sheet
        };
      })
      .filter((data): data is ScoreBoardData => data !== null);
    
    return scoreBoardData;
  };
}

/**
 * Fetches Score Board data from Google Sheets
 * 
 * Retrieves comprehensive scoring data including IRR, Munger Quality Score, Value Creation,
 * RO40, Leverage, P/E ratios, Current Ratio, Cash/SDebt, and SMA data.
 * Combines data from multiple sources (PE Industry and SMA sheets).
 * Tries Apps Script API first (fast), falls back to CSV proxy if needed (slower).
 * 
 * @param forceRefresh - If true, bypasses cache and forces network request (default: false)
 * @param progressCallback - Optional callback for progress updates during fetch/parse/transform
 * @returns Promise resolving to array of Score Board data entries
 * @throws {Error} If data fetch fails or required columns are missing
 */
export async function fetchScoreBoardData(
  forceRefresh: boolean = false,
  progressCallback?: ProgressCallback
): Promise<ScoreBoardData[]> {
  // Fetch PEIndustryData and SMAData in parallel (they are independent)
  logger.debug('Fetching PE Industry and SMA data in parallel...', { component: 'scoreBoardService', operation: 'fetchScoreBoardData' });
  
  const [peIndustryResult, smaResult] = await Promise.allSettled([
    fetchPEIndustryData(forceRefresh),
    fetchSMAData(forceRefresh),
  ]);

  // Process PEIndustryData results
  let peIndustryData: PEIndustryData[] = [];
  if (peIndustryResult.status === 'fulfilled') {
    peIndustryData = peIndustryResult.value;
  } else {
    logger.warn(
      'Failed to fetch PE Industry data for P/E1 INDUSTRY calculation',
      { component: 'scoreBoardService', operation: 'fetchScoreBoardData', error: peIndustryResult.reason }
    );
  }

  // Create maps for quick lookup: industry -> pe1 and pe2 (median)
  const industryPe1Map = new Map<string, number>();
  const industryPe2Map = new Map<string, number>();
  peIndustryData.forEach((peIndustry) => {
    if (peIndustry.pe1 !== null) {
      industryPe1Map.set(peIndustry.industry.toLowerCase(), peIndustry.pe1);
    }
    if (peIndustry.pe2 !== null) {
      industryPe2Map.set(peIndustry.industry.toLowerCase(), peIndustry.pe2);
    }
  });

  // Process SMAData results
  let smaDataMap = new Map<string, { sma100: number | null; sma200: number | null; smaCross: string | null }>();
  if (smaResult.status === 'fulfilled') {
    const smaData = smaResult.value;
    smaData.forEach((sma) => {
      const tickerKey = sma.ticker.toLowerCase().trim();
      smaDataMap.set(tickerKey, {
        sma100: sma.sma100,
        sma200: sma.sma200,
        smaCross: sma.smaCross,
      });
    });
  } else {
    logger.warn(
      'Failed to fetch SMA data for Score Board',
      { component: 'scoreBoardService', operation: 'fetchScoreBoardData', error: smaResult.reason }
    );
  }

  // Create transformer with the maps
  const transformer = createScoreBoardTransformer(industryPe1Map, industryPe2Map, smaDataMap);

  // Convert Maps to plain objects for worker serialization
  const industryPe1MapObj: Record<string, number> = {};
  industryPe1Map.forEach((value, key) => {
    industryPe1MapObj[key] = value;
  });
  
  const industryPe2MapObj: Record<string, number> = {};
  industryPe2Map.forEach((value, key) => {
    industryPe2MapObj[key] = value;
  });
  
  const smaDataMapObj: Record<string, { sma100: number | null; sma200: number | null; smaCross: string | null }> = {};
  smaDataMap.forEach((value, key) => {
    smaDataMapObj[key] = value;
  });

  return fetchWithFallback<ScoreBoardData>({
    sheetName: 'DashBoard',
    dataTypeName: 'Score Board',
    transformer,
    requiredColumns: ['Company Name', 'Ticker', 'IRR', 'Munger Quality Score', 'VALUE CREATION'],
    cacheKey: CACHE_KEYS.SCORE_BOARD,
    forceRefresh,
    ttl: DEFAULT_TTL,
    progressCallback,
    csvUrl: SCORE_BOARD_CSV_URL,
    additionalData: {
      industryPe1Map: industryPe1MapObj,
      industryPe2Map: industryPe2MapObj,
      smaDataMap: smaDataMapObj,
    },
  });
}

```

## `src/services/sheets/smaService.ts`

```typescript
/**
 * SMA Service
 * 
 * Fetches and transforms SMA (Simple Moving Average) data from Google Sheets.
 */

import { SMAData } from '../../types/stock';
import { CACHE_KEYS, DEFAULT_TTL } from '../firestoreCacheService';
import { fetchWithFallback } from './fetchService';
import { getValue, isValidValue, parseNumericValueNullable } from './dataTransformers';
import type { DataRow, ProgressCallback } from './types';

// SMA data configuration (uses same Dashboard sheet as Benjamin Graham)
const SMA_SHEET_ID = '1KOOSLJVGdDZHBV1MUmb4D9oVIKUJj5TIgYCerjkWYcE';
const SMA_GID = '1413104083';
const SMA_CSV_URL = `https://docs.google.com/spreadsheets/d/${SMA_SHEET_ID}/export?format=csv&gid=${SMA_GID}`;

/**
 * Transformer function for SMA data
 * Exported for use in background sync persist.
 */
export function transformSMAData(results: { data: DataRow[]; meta: { fields: string[] | null } }): SMAData[] {
  const smaData: SMAData[] = results.data
    .map((row: DataRow) => {
      const companyName = getValue(['Company Name', 'Company', 'company'], row);
      const ticker = getValue(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
      const sma100Str = getValue(['SMA(100)', 'SMA(100)', 'sma(100)', 'sma100', 'SMA100'], row);
      const sma200Str = getValue(['SMA(200)', 'SMA(200)', 'sma(200)', 'sma200', 'SMA200'], row);
      const smaCrossStr = getValue(['SMA Cross', 'SMA Cross', 'sma cross', 'smaCross', 'SMACross', 'SMA CROSS'], row);
      
      // Only process if company name is valid (not #N/A)
      if (!isValidValue(companyName)) {
        return null;
      }
      
      // Filter out rows where Ticker is N/A (DashBoard rule: if Ticker is N/A, don't fetch data)
      if (!isValidValue(ticker)) {
        return null;
      }
      
      // Parse SMA(100) value as number (handle #N/A)
      const sma100 = parseNumericValueNullable(sma100Str);
      
      // Parse SMA(200) value as number (handle #N/A)
      const sma200 = parseNumericValueNullable(sma200Str);
      
      // Extract SMA Cross value as text (handle #N/A and empty values)
      let smaCross: string | null = null;
      if (smaCrossStr && smaCrossStr.trim()) {
        const trimmed = smaCrossStr.trim();
        // Convert #N/A to null, otherwise use the value
        if (trimmed.toUpperCase() !== '#N/A' && trimmed.toUpperCase() !== 'N/A' && trimmed !== '') {
          smaCross = trimmed;
        }
      }
      
      return {
        companyName: companyName,
        ticker: ticker,
        sma100: sma100,
        sma200: sma200,
        smaCross: smaCross,
      };
    })
    .filter((data): data is SMAData => data !== null);
  
  return smaData;
}

/**
 * Fetches SMA (Simple Moving Average) data from Google Sheets
 * 
 * Retrieves technical analysis data including SMA(100), SMA(200), and SMA Cross signals.
 * Tries Apps Script API first (fast), falls back to CSV proxy if needed (slower).
 * 
 * @param forceRefresh - If true, bypasses cache and forces network request (default: false)
 * @param progressCallback - Optional callback for progress updates during fetch/parse/transform
 * @returns Promise resolving to array of SMA data entries
 * @throws {Error} If data fetch fails or required columns are missing
 */
export async function fetchSMAData(
  forceRefresh: boolean = false,
  progressCallback?: ProgressCallback
): Promise<SMAData[]> {
  return fetchWithFallback<SMAData>({
    sheetName: 'SMA',
    dataTypeName: 'SMA',
    transformer: transformSMAData,
    requiredColumns: ['Company Name', 'Ticker', 'SMA(100)', 'SMA(200)', 'SMA Cross'],
    cacheKey: CACHE_KEYS.SMA,
    forceRefresh,
    ttl: DEFAULT_TTL,
    progressCallback,
    csvUrl: SMA_CSV_URL,
  });
}

```

## `src/services/sheets/types.ts`

```typescript
/**
 * Types for sheets service
 * 
 * Shared types used across sheets service modules.
 */

/**
 * Type for row data (compatible with both CSV and JSON)
 * Values can be string, number, or undefined
 */
export type DataRow = Record<string, string | number | undefined>;

/**
 * Progress callback type for tracking fetch progress
 * 
 * @param progress - Progress information including stage, percentage, and optional details
 */
export type ProgressCallback = (progress: {
  stage: 'fetch' | 'parse' | 'transform' | 'complete';
  percentage: number;
  message?: string;
  rowsProcessed?: number;
  totalRows?: number;
}) => void;

```

## `src/services/userDataService.ts`

```typescript
/**
 * User Data Service
 *
 * Provides functionality to save and load shared manual data to Firebase Firestore.
 * This includes Entry/Exit values and Currency values.
 * Threshold values are managed by sharedThresholdService (sharedData/threshold).
 * Falls back to localStorage if user is not authenticated or Firestore is unavailable.
 */

import { 
  doc, 
  setDoc, 
  getDoc, 
  collection,
  writeBatch,
  serverTimestamp 
} from 'firebase/firestore';
import { db } from '../config/firebase';
import { User } from 'firebase/auth';
import { logger } from '../utils/logger';
import { isCurrencyString } from '../utils/typeGuards';

// Firestore collection names
const COLLECTIONS = {
  SHARED_DATA: 'sharedData',
  ENTRY_EXIT: 'entryExit',
  CURRENCY: 'currency',
} as const;

// LocalStorage keys (fallback)
const STORAGE_KEYS = {
  ENTRY_EXIT: 'entryExitValues',
  CURRENCY: 'tachart-currency-map',
} as const;

/**
 * Get shared data document reference
 */
function getSharedDataDoc(dataType: string) {
  return doc(db, COLLECTIONS.SHARED_DATA, dataType);
}

/**
 * Save Entry/Exit values to Firestore
 * 
 * Saves Entry/Exit values (entry1, entry2, exit1, exit2, currency, dateOfUpdate)
 * to Firestore. Falls back to localStorage if user is not authenticated.
 * Also saves to localStorage as backup even when using Firestore.
 * 
 * @param user - Firebase user object, or null if not authenticated
 * @param values - Entry/Exit values to save, keyed by ticker symbol
 * 
 * @example
 * ```typescript
 * await saveEntryExitValues(user, {
 *   'AAPL': { entry1: 150, entry2: 155, exit1: 160, exit2: 165, currency: 'USD', dateOfUpdate: '2024-01-01' }
 * });
 * ```
 */
export async function saveEntryExitValues(
  user: User | null,
  values: Record<string, { entry1: number; entry2: number; exit1: number; exit2: number; currency: string; dateOfUpdate: string | null }>
): Promise<void> {
  if (!user) {
    // Fallback to localStorage
    try {
      localStorage.setItem(STORAGE_KEYS.ENTRY_EXIT, JSON.stringify(values));
    } catch (error) {
      logger.error('Error saving EntryExit values to localStorage', error, { component: 'userDataService', operation: 'saveEntryExitValues' });
    }
    return;
  }

  try {
    const docRef = doc(db, COLLECTIONS.SHARED_DATA, COLLECTIONS.ENTRY_EXIT);
    await setDoc(docRef, {
      values,
      updatedAt: serverTimestamp(),
    }, { merge: true });
    
    // Also save to localStorage as backup
    try {
      localStorage.setItem(STORAGE_KEYS.ENTRY_EXIT, JSON.stringify(values));
    } catch (error) {
      logger.warn('Failed to save EntryExit values to localStorage backup', { component: 'userDataService', operation: 'saveEntryExitValues', error });
    }
  } catch (error) {
    logger.error('Error saving EntryExit values to Firestore', error, { component: 'userDataService', operation: 'saveEntryExitValues' });
    // Fallback to localStorage
    try {
      localStorage.setItem(STORAGE_KEYS.ENTRY_EXIT, JSON.stringify(values));
    } catch (localError) {
      logger.error('Error saving EntryExit values to localStorage fallback', localError, { component: 'userDataService', operation: 'saveEntryExitValues' });
    }
  }
}

/**
 * Load Entry/Exit values from Firestore
 * 
 * Loads Entry/Exit values from Firestore. Falls back to localStorage if
 * user is not authenticated or Firestore is unavailable. Also migrates
 * currency data from old separate collection if it exists.
 * 
 * @param user - Firebase user object, or null if not authenticated
 * @returns Entry/Exit values keyed by ticker symbol, or null if not found
 * 
 * @example
 * ```typescript
 * const values = await loadEntryExitValues(user);
 * if (values) {
 *   const aaplEntry = values['AAPL'];
 * }
 * ```
 */
export async function loadEntryExitValues(
  user: User | null
): Promise<Record<string, { entry1: number; entry2: number; exit1: number; exit2: number; currency: string; dateOfUpdate: string | null }> | null> {
  if (!user) {
    // Fallback to localStorage
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.ENTRY_EXIT);
      if (stored) {
        return JSON.parse(stored);
      }
    } catch (error) {
      logger.error('Error loading EntryExit values from localStorage', error, { component: 'userDataService', operation: 'loadEntryExitValues' });
    }
    return null;
  }

  try {
    const docRef = doc(db, COLLECTIONS.SHARED_DATA, COLLECTIONS.ENTRY_EXIT);
    const docSnap = await getDoc(docRef);
    
    let values: Record<string, { entry1: number; entry2: number; exit1: number; exit2: number; currency: string; dateOfUpdate: string | null }> = {};
    
    if (docSnap.exists()) {
      const data = docSnap.data();
      values = data.values || {};
    }
    
    // Migrate currency from old separate collection if it exists
    try {
      const currencyDocRef = doc(db, COLLECTIONS.SHARED_DATA, COLLECTIONS.CURRENCY);
      const currencyDocSnap = await getDoc(currencyDocRef);
      
      if (currencyDocSnap.exists()) {
        const currencyData = currencyDocSnap.data();
        const currencyValues = currencyData.values || {};
        
        // Merge currency into entryExit values
        for (const [key, currency] of Object.entries(currencyValues)) {
          if (!values[key]) {
            values[key] = { entry1: 0, entry2: 0, exit1: 0, exit2: 0, currency: isCurrencyString(currency) ? currency : 'USD', dateOfUpdate: null };
          } else if (!values[key].currency) {
            values[key].currency = isCurrencyString(currency) ? currency : 'USD';
          }
        }
      }
    } catch (currencyError) {
      // If currency migration fails, continue without it
      logger.warn('Failed to migrate currency data', { component: 'userDataService', operation: 'loadEntryExitValues', error: currencyError });
    }
    
    // Ensure all values have currency field
    for (const key in values) {
      if (!values[key].currency) {
        values[key].currency = 'USD';
      }
    }
    
    if (Object.keys(values).length > 0) {
      // Also save to localStorage as backup
      try {
        localStorage.setItem(STORAGE_KEYS.ENTRY_EXIT, JSON.stringify(values));
      } catch (error) {
        logger.warn('Failed to save EntryExit values to localStorage backup', { component: 'userDataService', operation: 'saveEntryExitValues', error });
      }
      
      return values;
    }
    
    // If no Firestore data, try localStorage
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.ENTRY_EXIT);
      if (stored) {
        const parsed = JSON.parse(stored);
        // Ensure all values have currency field
        for (const key in parsed) {
          if (!parsed[key].currency) {
            parsed[key].currency = 'USD';
          }
        }
        return parsed;
      }
    } catch (error) {
      logger.error('Error loading EntryExit values from localStorage', error, { component: 'userDataService', operation: 'loadEntryExitValues' });
    }
    
    // Also try to migrate from old currency localStorage
    try {
      const currencyStored = localStorage.getItem(STORAGE_KEYS.CURRENCY);
      if (currencyStored) {
        const currencyParsed = JSON.parse(currencyStored);
        const migrated: Record<string, { entry1: number; entry2: number; exit1: number; exit2: number; currency: string; dateOfUpdate: string | null }> = {};
        for (const [key, currency] of Object.entries(currencyParsed)) {
            migrated[key] = { entry1: 0, entry2: 0, exit1: 0, exit2: 0, currency: isCurrencyString(currency) ? currency : 'USD', dateOfUpdate: null };
        }
        if (Object.keys(migrated).length > 0) {
          return migrated;
        }
      }
    } catch (error) {
      logger.warn('Failed to migrate currency from localStorage', { component: 'userDataService', operation: 'loadEntryExitValues', error });
    }
    
    return null;
  } catch (error) {
    logger.error('Error loading EntryExit values from Firestore', error, { component: 'userDataService', operation: 'loadEntryExitValues' });
    // Fallback to localStorage
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.ENTRY_EXIT);
      if (stored) {
        const parsed = JSON.parse(stored);
        // Ensure all values have currency field
        for (const key in parsed) {
          if (!parsed[key].currency) {
            parsed[key].currency = 'USD';
          }
        }
        return parsed;
      }
    } catch (localError) {
      logger.error('Error loading EntryExit values from localStorage fallback', localError, { component: 'userDataService', operation: 'loadEntryExitValues' });
    }
    return null;
  }
}

/**
 * Save Currency values to Firestore
 * 
 * Saves currency mapping values to Firestore. Falls back to localStorage
 * if user is not authenticated. Also saves to localStorage as backup.
 * 
 * @param user - Firebase user object, or null if not authenticated
 * @param values - Currency values to save, keyed by ticker symbol
 * 
 * @example
 * ```typescript
 * await saveCurrencyValues(user, {
 *   'AAPL': 'USD',
 *   'VOLV-B': 'SEK'
 * });
 * ```
 */
export async function saveCurrencyValues(
  user: User | null,
  values: Record<string, string>
): Promise<void> {
  if (!user) {
    // Fallback to localStorage
    try {
      localStorage.setItem(STORAGE_KEYS.CURRENCY, JSON.stringify(values));
    } catch (error) {
      logger.error('Error saving Currency values to localStorage', error, { component: 'userDataService', operation: 'saveCurrencyValues' });
    }
    return;
  }

  try {
    const docRef = doc(db, COLLECTIONS.SHARED_DATA, COLLECTIONS.CURRENCY);
    await setDoc(docRef, {
      values,
      updatedAt: serverTimestamp(),
    }, { merge: true });
    
    // Also save to localStorage as backup
    try {
      localStorage.setItem(STORAGE_KEYS.CURRENCY, JSON.stringify(values));
    } catch (error) {
      logger.warn('Failed to save Currency values to localStorage backup', { component: 'userDataService', operation: 'saveCurrencyValues', error });
    }
  } catch (error) {
    logger.error('Error saving Currency values to Firestore', error, { component: 'userDataService', operation: 'saveCurrencyValues' });
    // Fallback to localStorage
    try {
      localStorage.setItem(STORAGE_KEYS.CURRENCY, JSON.stringify(values));
    } catch (localError) {
      logger.error('Error saving Currency values to localStorage fallback', localError, { component: 'userDataService', operation: 'saveCurrencyValues' });
    }
  }
}

/**
 * Load Currency values from Firestore
 * 
 * Loads currency mapping values from Firestore. Falls back to localStorage
 * if user is not authenticated or Firestore is unavailable.
 * 
 * @param user - Firebase user object, or null if not authenticated
 * @returns Currency values keyed by ticker symbol, or null if not found
 * 
 * @example
 * ```typescript
 * const currencies = await loadCurrencyValues(user);
 * if (currencies) {
 *   const aaplCurrency = currencies['AAPL']; // 'USD'
 * }
 * ```
 */
export async function loadCurrencyValues(
  user: User | null
): Promise<Record<string, string> | null> {
  if (!user) {
    // Fallback to localStorage
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.CURRENCY);
      if (stored) {
        return JSON.parse(stored);
      }
    } catch (error) {
      logger.error('Error loading Currency values from localStorage', error, { component: 'userDataService', operation: 'loadCurrencyValues' });
    }
    return null;
  }

  try {
    const docRef = doc(db, COLLECTIONS.SHARED_DATA, COLLECTIONS.CURRENCY);
    const docSnap = await getDoc(docRef);
    
    if (docSnap.exists()) {
      const data = docSnap.data();
      const values = data.values || {};
      
      // Also save to localStorage as backup
      try {
        localStorage.setItem(STORAGE_KEYS.CURRENCY, JSON.stringify(values));
      } catch (error) {
        logger.warn('Failed to save Currency values to localStorage backup', { component: 'userDataService', operation: 'saveCurrencyValues', error });
      }
      
      return values;
    }
    
    // If no Firestore data, try localStorage
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.CURRENCY);
      if (stored) {
        return JSON.parse(stored);
      }
    } catch (error) {
      logger.error('Error loading Currency values from localStorage', error, { component: 'userDataService', operation: 'loadCurrencyValues' });
    }
    
    return null;
  } catch (error) {
    logger.error('Error loading Currency values from Firestore', error, { component: 'userDataService', operation: 'loadCurrencyValues' });
    // Fallback to localStorage
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.CURRENCY);
      if (stored) {
        return JSON.parse(stored);
      }
    } catch (localError) {
      logger.error('Error loading Currency values from localStorage fallback', localError, { component: 'userDataService', operation: 'loadCurrencyValues' });
    }
    return null;
  }
}

```

## `src/services/userPreferencesService.ts`

```typescript
/**
 * User Preferences Service
 * 
 * Provides functionality to save and load user preferences in Firestore.
 */

import { doc, setDoc, getDoc, Timestamp } from 'firebase/firestore';
import { db } from '../config/firebase';
import { logger } from '../utils/logger';

export interface NotificationPreferences {
  enabled: boolean;
  desktopNotifications: boolean;
  dataUpdates: boolean;
  errors: boolean;
  success: boolean;
  info: boolean;
  warning: boolean;
  soundEnabled: boolean;
  doNotDisturb: boolean;
  doNotDisturbStart?: string; // HH:mm format
  doNotDisturbEnd?: string; // HH:mm format
}

export interface UserPreferences {
  userId: string;
  notifications: NotificationPreferences;
  updatedAt: Date;
}

const COLLECTION_NAME = 'userPreferences';

export const DEFAULT_NOTIFICATION_PREFERENCES: NotificationPreferences = {
  enabled: true,
  desktopNotifications: false,
  dataUpdates: true,
  errors: true,
  success: false,
  info: false,
  warning: true,
  soundEnabled: false,
  doNotDisturb: false,
};

/**
 * Get user preferences from Firestore
 */
export async function getUserPreferences(userId: string): Promise<UserPreferences | null> {
  try {
    const docRef = doc(db, COLLECTION_NAME, userId);
    const docSnap = await getDoc(docRef);

    if (!docSnap.exists()) {
      return null;
    }

    const data = docSnap.data();
    return {
      userId,
      notifications: (data.notifications as NotificationPreferences) || DEFAULT_NOTIFICATION_PREFERENCES,
      updatedAt: (data.updatedAt as Timestamp).toDate(),
    };
  } catch (error) {
    // Handle permissions errors gracefully - return null instead of throwing
    // This allows the app to continue working with default preferences
    if (error instanceof Error && error.message.includes('permission')) {
      logger.warn('Permission denied when getting user preferences, using defaults', {
        component: 'userPreferencesService',
        operation: 'getUserPreferences',
        userId,
        error: error.message,
      });
      return null; // Return null to use default preferences
    }
    
    logger.error('Error getting user preferences', error, {
      component: 'userPreferencesService',
      operation: 'getUserPreferences',
      userId,
    });
    // For non-permission errors, still return null to prevent app crash
    return null;
  }
}

/**
 * Save user preferences to Firestore
 */
export async function saveUserPreferences(
  userId: string,
  preferences: Partial<UserPreferences>
): Promise<void> {
  try {
    const docRef = doc(db, COLLECTION_NAME, userId);
    
    // Get existing preferences or use defaults
    const existing = await getUserPreferences(userId);
    const currentPreferences: UserPreferences = existing || {
      userId,
      notifications: DEFAULT_NOTIFICATION_PREFERENCES,
      updatedAt: new Date(),
    };

    // Merge with new preferences
    const updatedPreferences: UserPreferences = {
      ...currentPreferences,
      ...preferences,
      updatedAt: new Date(),
    };

    await setDoc(docRef, {
      ...updatedPreferences,
      updatedAt: Timestamp.fromDate(updatedPreferences.updatedAt),
    }, { merge: true });

    logger.debug(`User preferences saved for ${userId}`, {
      component: 'userPreferencesService',
      operation: 'saveUserPreferences',
      userId,
    });
  } catch (error) {
    // Handle permissions errors gracefully
    if (error instanceof Error && error.message.includes('permission')) {
      logger.warn('Permission denied when saving user preferences', {
        component: 'userPreferencesService',
        operation: 'saveUserPreferences',
        userId,
        error: error.message,
      });
      // Don't throw - silently fail to prevent app crash
      return;
    }
    
    logger.error('Error saving user preferences', error, {
      component: 'userPreferencesService',
      operation: 'saveUserPreferences',
      userId,
    });
    // Don't throw to prevent app crash - preferences are not critical
  }
}

/**
 * Update notification preferences
 */
export async function updateNotificationPreferences(
  userId: string,
  preferences: Partial<NotificationPreferences>
): Promise<void> {
  try {
    const existing = await getUserPreferences(userId);
    const currentNotifications = existing?.notifications || DEFAULT_NOTIFICATION_PREFERENCES;

    const updatedNotifications: NotificationPreferences = {
      ...currentNotifications,
      ...preferences,
    };

    await saveUserPreferences(userId, {
      notifications: updatedNotifications,
    });
  } catch (error) {
    logger.error('Error updating notification preferences', error, {
      component: 'userPreferencesService',
      operation: 'updateNotificationPreferences',
      userId,
    });
    throw error;
  }
}

```

## `src/services/workerService.ts`

```typescript
/**
 * Worker Service
 * 
 * Manages Web Worker instances for data transformation.
 * Provides a unified API for transforming data in workers with fallback to main thread.
 */

import type { DataRow, ProgressCallback } from './sheets/types';
// Vite ?worker import ensures the worker is compiled to .js in build (avoids .ts → video/mp2t MIME on Vercel)
import DataTransformWorker from '../workers/dataTransformWorker.ts?worker';

// Check if Web Workers are supported
const WORKERS_SUPPORTED = typeof Worker !== 'undefined';

// Worker instance (singleton pattern)
let workerInstance: Worker | null = null;
let workerLoadPromise: Promise<Worker> | null = null;

// Job counter for unique job IDs
let jobCounter = 0;

// Pending jobs map
const pendingJobs = new Map<string, {
  resolve: (data: unknown[]) => void;
  reject: (error: Error) => void;
  progressCallback?: ProgressCallback;
}>();

// Timeout IDs per job – cleared on complete/error to avoid timer leak
const jobTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

/**
 * Load worker instance (lazy loading)
 */
async function loadWorker(): Promise<Worker> {
  if (workerInstance) {
    return workerInstance;
  }

  if (workerLoadPromise) {
    return workerLoadPromise;
  }

  workerLoadPromise = new Promise((resolve, reject) => {
    try {
      const worker = new DataTransformWorker();

      // Set up message handler
      worker.onmessage = (e: MessageEvent) => {
        const message = e.data;

        if (message.type === 'progress') {
          const job = pendingJobs.get(message.jobId);
          if (job?.progressCallback) {
            job.progressCallback({
              stage: message.stage,
              percentage: message.percentage,
              message: message.message,
              rowsProcessed: message.rowsProcessed,
              totalRows: message.totalRows,
            });
          }
        } else if (message.type === 'complete') {
          const job = pendingJobs.get(message.jobId);
          if (job) {
            const tid = jobTimeouts.get(message.jobId);
            if (tid != null) {
              clearTimeout(tid);
              jobTimeouts.delete(message.jobId);
            }
            pendingJobs.delete(message.jobId);
            job.resolve(message.data);
          }
        } else if (message.type === 'error') {
          const job = pendingJobs.get(message.jobId);
          if (job) {
            const tid = jobTimeouts.get(message.jobId);
            if (tid != null) {
              clearTimeout(tid);
              jobTimeouts.delete(message.jobId);
            }
            pendingJobs.delete(message.jobId);
            job.reject(new Error(message.error));
          }
        }
      };

      worker.onerror = (errorEvent) => {
        // Handle worker errors
        // ErrorEvent has: error, message, filename, lineno, colno
        let errorMessage = errorEvent.message;
        
        if (!errorMessage && errorEvent.error) {
          if (errorEvent.error instanceof Error) {
            errorMessage = errorEvent.error.message;
          } else {
            errorMessage = String(errorEvent.error);
          }
        }
        
        if (!errorMessage) {
          errorMessage = `Worker error at ${errorEvent.filename || 'unknown'}:${errorEvent.lineno || '?'}:${errorEvent.colno || '?'}`;
        }
        
        const errorDetails = {
          message: errorMessage,
          filename: errorEvent.filename,
          lineno: errorEvent.lineno,
          colno: errorEvent.colno,
          error: errorEvent.error,
        };
        
        console.error('Worker error:', errorDetails);
        
        // Reject the loading promise if worker hasn't been assigned yet (initialization error)
        if (workerInstance !== worker && workerLoadPromise) {
          const currentPromise = workerLoadPromise;
          workerLoadPromise = null;
          currentPromise.catch(() => {}); // Prevent unhandled rejection warning
          reject(new Error(`Failed to load worker: ${errorMessage}`));
          return; // Early return for initialization errors
        }
        
        // Reject all pending jobs and clear their timeouts
        for (const [jobId, job] of pendingJobs.entries()) {
          const tid = jobTimeouts.get(jobId);
          if (tid != null) {
            clearTimeout(tid);
            jobTimeouts.delete(jobId);
          }
          pendingJobs.delete(jobId);
          job.reject(new Error(`Worker error: ${errorMessage}`));
        }
        
        // Clean up worker instance
        workerInstance = null;
        workerLoadPromise = null;
      };

      workerInstance = worker;
      resolve(worker);
    } catch (error) {
      workerLoadPromise = null;
      reject(error instanceof Error ? error : new Error('Failed to load worker'));
    }
  });

  return workerLoadPromise;
}

/**
 * Transform data in Web Worker with fallback to main thread
 * 
 * @template T - The type of data returned after transformation
 * @param transformerId - Identifier for the transformer function
 * @param data - Raw data rows to transform
 * @param meta - Metadata about the data (fields)
 * @param progressCallback - Optional callback for progress updates
 * @param additionalData - Additional data needed for some transformers (e.g., ScoreBoard maps)
 * @param fallbackTransformer - Transformer function to use as fallback if worker fails
 * @returns Promise resolving to transformed data
 */
export async function transformInWorker<T>(
  transformerId: string,
  data: DataRow[],
  meta: { fields: string[] | null },
  progressCallback?: ProgressCallback,
  additionalData?: Record<string, unknown>,
  fallbackTransformer?: (results: { data: DataRow[]; meta: { fields: string[] | null } }) => T[]
): Promise<T[]> {
  // Fallback to main thread if workers not supported
  if (!WORKERS_SUPPORTED) {
    return transformInMainThread<T>(transformerId, data, meta, progressCallback, fallbackTransformer);
  }

  try {
    const worker = await loadWorker();
    const jobId = `job-${++jobCounter}`;

    return new Promise<T[]>((resolve, reject) => {
      // Store job info
      pendingJobs.set(jobId, {
        resolve: (data: unknown[]) => resolve(data as T[]),
        reject,
        progressCallback,
      });

      // Send transform message to worker
      worker.postMessage({
        type: 'transform',
        transformerId,
        data,
        meta,
        jobId,
        ...additionalData, // Spread additional data (e.g., industryPe1Map, etc.)
      });

      // Timeout after 60 seconds
      const timeoutId = setTimeout(() => {
        if (pendingJobs.has(jobId)) {
          jobTimeouts.delete(jobId);
          pendingJobs.delete(jobId);
          // Fallback to main thread on timeout
          if (fallbackTransformer) {
            transformInMainThread<T>(transformerId, data, meta, progressCallback, fallbackTransformer)
              .then(resolve)
              .catch(reject);
          } else {
            reject(new Error('Worker transformation timeout'));
          }
        }
      }, 60000);
      jobTimeouts.set(jobId, timeoutId);
    });
  } catch (error) {
    // Fallback to main thread on error
    console.warn('Worker transformation failed, falling back to main thread:', error);
    if (fallbackTransformer) {
      return transformInMainThread<T>(transformerId, data, meta, progressCallback, fallbackTransformer);
    }
    throw error;
  }
}

/**
 * Transform data in main thread (fallback)
 * 
 * This function uses the provided transformer function directly in the main thread.
 * Used as fallback when Workers are not supported or fail.
 */
async function transformInMainThread<T>(
  transformerId: string,
  data: DataRow[],
  meta: { fields: string[] | null },
  progressCallback?: ProgressCallback,
  transformer?: (results: { data: DataRow[]; meta: { fields: string[] | null } }) => T[]
): Promise<T[]> {
  if (!transformer) {
    throw new Error(`Main thread transformation requires transformer function for ${transformerId}`);
  }

  const results = { data, meta };

  try {
    progressCallback?.({
      stage: 'transform',
      percentage: 0,
      message: `Transforming ${transformerId} data (main thread)...`,
      totalRows: data.length,
    });

    const transformedData = transformer(results);

    progressCallback?.({
      stage: 'complete',
      percentage: 100,
      message: 'Transformation complete',
      rowsProcessed: transformedData.length,
      totalRows: transformedData.length,
    });

    return transformedData;
  } catch (error) {
    progressCallback?.({
      stage: 'transform',
      percentage: 0,
      message: `Transformation failed: ${error instanceof Error ? error.message : String(error)}`,
    });
    throw error;
  }
}

/**
 * Map data type name or sheet name to transformer ID
 */
export function getTransformerId(dataTypeName: string, sheetName?: string): string | null {
  const lowerName = dataTypeName.toLowerCase();
  
  if (lowerName.includes('benjamin graham') || lowerName.includes('benjamin-graham')) {
    return 'benjamin-graham';
  }
  if (lowerName.includes('score board') || lowerName.includes('score-board')) {
    return 'score-board';
  }
  if (lowerName.includes('pe industry') || lowerName.includes('pe-industry') || lowerName.includes('p/e industry')) {
    return 'pe-industry';
  }
  if (lowerName.includes('sma')) {
    return 'sma';
  }
  // Threshold Industry requires large industry maps - use main thread instead
  // if (lowerName.includes('threshold industry') || lowerName.includes('threshold-industry')) {
  //   return 'threshold-industry';
  // }
  
  // Try sheet name as fallback
  if (sheetName) {
    const lowerSheet = sheetName.toLowerCase();
    if (lowerSheet === 'sma') {
      return 'sma';
    }
    if (lowerSheet === 'dashboard') {
      // Dashboard can be multiple types, need more context
      return null;
    }
  }
  
  return null;
}

/**
 * Check if Web Workers are supported
 */
export function isWorkerSupported(): boolean {
  return WORKERS_SUPPORTED;
}

/**
 * Terminate worker instance (cleanup)
 */
export function terminateWorker(): void {
  if (workerInstance) {
    workerInstance.terminate();
    workerInstance = null;
    workerLoadPromise = null;
    // Clear all job timeouts and reject pending jobs
    for (const [jobId, job] of pendingJobs.entries()) {
      const tid = jobTimeouts.get(jobId);
      if (tid != null) {
        clearTimeout(tid);
        jobTimeouts.delete(jobId);
      }
      pendingJobs.delete(jobId);
      job.reject(new Error('Worker terminated'));
    }
  }
}

```

## `src/stories/assets/accessibility.png`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/accessibility.svg`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/addon-library.png`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/assets.png`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/avif-test-image.avif`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/context.png`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/discord.svg`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/docs.png`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/figma-plugin.png`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/github.svg`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/share.png`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/styling.png`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/testing.png`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/theming.png`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/tutorials.svg`

*(Binärfil – se repo för asset.)*

## `src/stories/assets/youtube.svg`

*(Binärfil – se repo för asset.)*

## `src/stories/button.css`

```css
.storybook-button {
  display: inline-block;
  cursor: pointer;
  border: 0;
  border-radius: 3em;
  font-weight: 700;
  line-height: 1;
  font-family: 'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;
}
.storybook-button--primary {
  background-color: #555ab9;
  color: white;
}
.storybook-button--secondary {
  box-shadow: rgba(0, 0, 0, 0.15) 0px 0px 0px 1px inset;
  background-color: transparent;
  color: #333;
}
.storybook-button--small {
  padding: 10px 16px;
  font-size: 12px;
}
.storybook-button--medium {
  padding: 11px 20px;
  font-size: 14px;
}
.storybook-button--large {
  padding: 12px 24px;
  font-size: 16px;
}

```

## `src/stories/Button.stories.ts`

```typescript
import type { Meta, StoryObj } from '@storybook/react-vite';

import { fn } from 'storybook/test';

import { Button } from './Button';

// More on how to set up stories at: https://storybook.js.org/docs/writing-stories#default-export
const meta = {
  title: 'Example/Button',
  component: Button,
  parameters: {
    // Optional parameter to center the component in the Canvas. More info: https://storybook.js.org/docs/configure/story-layout
    layout: 'centered',
  },
  // This component will have an automatically generated Autodocs entry: https://storybook.js.org/docs/writing-docs/autodocs
  tags: ['autodocs'],
  // More on argTypes: https://storybook.js.org/docs/api/argtypes
  argTypes: {
    backgroundColor: { control: 'color' },
  },
  // Use `fn` to spy on the onClick arg, which will appear in the actions panel once invoked: https://storybook.js.org/docs/essentials/actions#story-args
  args: { onClick: fn() },
} satisfies Meta<typeof Button>;

export default meta;
type Story = StoryObj<typeof meta>;

// More on writing stories with args: https://storybook.js.org/docs/writing-stories/args
export const Primary: Story = {
  args: {
    primary: true,
    label: 'Button',
  },
};

export const Secondary: Story = {
  args: {
    label: 'Button',
  },
};

export const Large: Story = {
  args: {
    size: 'large',
    label: 'Button',
  },
};

export const Small: Story = {
  args: {
    size: 'small',
    label: 'Button',
  },
};

```

## `src/stories/Button.tsx`

```tsx
import React from 'react';

import './button.css';

export interface ButtonProps {
  /** Is this the principal call to action on the page? */
  primary?: boolean;
  /** What background color to use */
  backgroundColor?: string;
  /** How large should the button be? */
  size?: 'small' | 'medium' | 'large';
  /** Button contents */
  label: string;
  /** Optional click handler */
  onClick?: () => void;
}

/** Primary UI component for user interaction */
export const Button = ({
  primary = false,
  size = 'medium',
  backgroundColor,
  label,
  ...props
}: ButtonProps) => {
  const mode = primary ? 'storybook-button--primary' : 'storybook-button--secondary';
  return (
    <button
      type="button"
      className={['storybook-button', `storybook-button--${size}`, mode].join(' ')}
      style={{ backgroundColor }}
      {...props}
    >
      {label}
    </button>
  );
};

```

## `src/stories/Configure.mdx`

```mdx
import { Meta } from "@storybook/addon-docs/blocks";

import Github from "./assets/github.svg";
import Discord from "./assets/discord.svg";
import Youtube from "./assets/youtube.svg";
import Tutorials from "./assets/tutorials.svg";
import Styling from "./assets/styling.png";
import Context from "./assets/context.png";
import Assets from "./assets/assets.png";
import Docs from "./assets/docs.png";
import Share from "./assets/share.png";
import FigmaPlugin from "./assets/figma-plugin.png";
import Testing from "./assets/testing.png";
import Accessibility from "./assets/accessibility.png";
import Theming from "./assets/theming.png";
import AddonLibrary from "./assets/addon-library.png";

export const RightArrow = () => <svg 
    viewBox="0 0 14 14" 
    width="8px" 
    height="14px" 
    style={{ 
      marginLeft: '4px',
      display: 'inline-block',
      shapeRendering: 'inherit',
      verticalAlign: 'middle',
      fill: 'currentColor',
      'path fill': 'currentColor'
    }}
>
  <path d="m11.1 7.35-5.5 5.5a.5.5 0 0 1-.7-.7L10.04 7 4.9 1.85a.5.5 0 1 1 .7-.7l5.5 5.5c.2.2.2.5 0 .7Z" />
</svg>

<Meta title="Configure your project" />

<div className="sb-container">
  <div className='sb-section-title'>
    # Configure your project

    Because Storybook works separately from your app, you'll need to configure it for your specific stack and setup. Below, explore guides for configuring Storybook with popular frameworks and tools. If you get stuck, learn how you can ask for help from our community.
  </div>
  <div className="sb-section">
    <div className="sb-section-item">
      <img
        src={Styling}
        alt="A wall of logos representing different styling technologies"
      />
      <h4 className="sb-section-item-heading">Add styling and CSS</h4>
      <p className="sb-section-item-paragraph">Like with web applications, there are many ways to include CSS within Storybook. Learn more about setting up styling within Storybook.</p>
      <a
        href="https://storybook.js.org/docs/configure/styling-and-css/?renderer=react&ref=configure"
        target="_blank"
      >Learn more<RightArrow /></a>
    </div>
    <div className="sb-section-item">
      <img
        src={Context}
        alt="An abstraction representing the composition of data for a component"
      />
      <h4 className="sb-section-item-heading">Provide context and mocking</h4>
      <p className="sb-section-item-paragraph">Often when a story doesn't render, it's because your component is expecting a specific environment or context (like a theme provider) to be available.</p>
      <a
        href="https://storybook.js.org/docs/writing-stories/decorators/?renderer=react&ref=configure#context-for-mocking"
        target="_blank"
      >Learn more<RightArrow /></a>
    </div>
    <div className="sb-section-item">
      <img src={Assets} alt="A representation of typography and image assets" />
      <div>
        <h4 className="sb-section-item-heading">Load assets and resources</h4>
        <p className="sb-section-item-paragraph">To link static files (like fonts) to your projects and stories, use the
        `staticDirs` configuration option to specify folders to load when
        starting Storybook.</p>
        <a
          href="https://storybook.js.org/docs/configure/images-and-assets/?renderer=react&ref=configure"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
    </div>
  </div>
</div>
<div className="sb-container">
  <div className='sb-section-title'>
    # Do more with Storybook

    Now that you know the basics, let's explore other parts of Storybook that will improve your experience. This list is just to get you started. You can customise Storybook in many ways to fit your needs.
  </div>

  <div className="sb-section">
    <div className="sb-features-grid">
      <div className="sb-grid-item">
        <img src={Docs} alt="A screenshot showing the autodocs tag being set, pointing a docs page being generated" />
        <h4 className="sb-section-item-heading">Autodocs</h4>
        <p className="sb-section-item-paragraph">Auto-generate living,
          interactive reference documentation from your components and stories.</p>
        <a
          href="https://storybook.js.org/docs/writing-docs/autodocs/?renderer=react&ref=configure"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
      <div className="sb-grid-item">
        <img src={Share} alt="A browser window showing a Storybook being published to a chromatic.com URL" />
        <h4 className="sb-section-item-heading">Publish to Chromatic</h4>
        <p className="sb-section-item-paragraph">Publish your Storybook to review and collaborate with your entire team.</p>
        <a
          href="https://storybook.js.org/docs/sharing/publish-storybook/?renderer=react&ref=configure#publish-storybook-with-chromatic"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
      <div className="sb-grid-item">
        <img src={FigmaPlugin} alt="Windows showing the Storybook plugin in Figma" />
        <h4 className="sb-section-item-heading">Figma Plugin</h4>
        <p className="sb-section-item-paragraph">Embed your stories into Figma to cross-reference the design and live
          implementation in one place.</p>
        <a
          href="https://storybook.js.org/docs/sharing/design-integrations/?renderer=react&ref=configure#embed-storybook-in-figma-with-the-plugin"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
      <div className="sb-grid-item">
        <img src={Testing} alt="Screenshot of tests passing and failing" />
        <h4 className="sb-section-item-heading">Testing</h4>
        <p className="sb-section-item-paragraph">Use stories to test a component in all its variations, no matter how
          complex.</p>
        <a
          href="https://storybook.js.org/docs/writing-tests/?renderer=react&ref=configure"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
      <div className="sb-grid-item">
        <img src={Accessibility} alt="Screenshot of accessibility tests passing and failing" />
        <h4 className="sb-section-item-heading">Accessibility</h4>
        <p className="sb-section-item-paragraph">Automatically test your components for a11y issues as you develop.</p>
        <a
          href="https://storybook.js.org/docs/writing-tests/accessibility-testing/?renderer=react&ref=configure"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
      <div className="sb-grid-item">
        <img src={Theming} alt="Screenshot of Storybook in light and dark mode" />
        <h4 className="sb-section-item-heading">Theming</h4>
        <p className="sb-section-item-paragraph">Theme Storybook's UI to personalize it to your project.</p>
        <a
          href="https://storybook.js.org/docs/configure/theming/?renderer=react&ref=configure"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
    </div>
  </div>
</div>
<div className='sb-addon'>
  <div className='sb-addon-text'>
    <h4>Addons</h4>
    <p className="sb-section-item-paragraph">Integrate your tools with Storybook to connect workflows.</p>
    <a
        href="https://storybook.js.org/addons/?ref=configure"
        target="_blank"
      >Discover all addons<RightArrow /></a>
  </div>
  <div className='sb-addon-img'>
    <img src={AddonLibrary} alt="Integrate your tools with Storybook to connect workflows." />
  </div>
</div>

<div className="sb-section sb-socials">
    <div className="sb-section-item">
      <img src={Github} alt="Github logo" className="sb-explore-image"/>
      Join our contributors building the future of UI development.

      <a
        href="https://github.com/storybookjs/storybook"
        target="_blank"
      >Star on GitHub<RightArrow /></a>
    </div>
    <div className="sb-section-item">
      <img src={Discord} alt="Discord logo" className="sb-explore-image"/>
      <div>
        Get support and chat with frontend developers.

        <a
          href="https://discord.gg/storybook"
          target="_blank"
        >Join Discord server<RightArrow /></a>
      </div>
    </div>
    <div className="sb-section-item">
      <img src={Youtube} alt="Youtube logo" className="sb-explore-image"/>
      <div>
        Watch tutorials, feature previews and interviews.

        <a
          href="https://www.youtube.com/@chromaticui"
          target="_blank"
        >Watch on YouTube<RightArrow /></a>
      </div>
    </div>
    <div className="sb-section-item">
      <img src={Tutorials} alt="A book" className="sb-explore-image"/>
      <p>Follow guided walkthroughs on for key workflows.</p>

      <a
          href="https://storybook.js.org/tutorials/?ref=configure"
          target="_blank"
        >Discover tutorials<RightArrow /></a>
    </div>
</div>

<style>
  {`
  .sb-container {
    margin-bottom: 48px;
  }

  .sb-section {
    width: 100%;
    display: flex;
    flex-direction: row;
    gap: 20px;
  }

  img {
    object-fit: cover;
  }

  .sb-section-title {
    margin-bottom: 32px;
  }

  .sb-section a:not(h1 a, h2 a, h3 a) {
    font-size: 14px;
  }

  .sb-section-item, .sb-grid-item {
    flex: 1;
    display: flex;
    flex-direction: column;
  }

  .sb-section-item-heading {
    padding-top: 20px !important;
    padding-bottom: 5px !important;
    margin: 0 !important;
  }
  .sb-section-item-paragraph {
    margin: 0;
    padding-bottom: 10px;
  }

  .sb-chevron {
    margin-left: 5px;
  }

  .sb-features-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    grid-gap: 32px 20px;
  }

  .sb-socials {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
  }

  .sb-socials p {
    margin-bottom: 10px;
  }

  .sb-explore-image {
    max-height: 32px;
    align-self: flex-start;
  }

  .sb-addon {
    width: 100%;
    display: flex;
    align-items: center;
    position: relative;
    background-color: #EEF3F8;
    border-radius: 5px;
    border: 1px solid rgba(0, 0, 0, 0.05);
    background: #EEF3F8;
    height: 180px;
    margin-bottom: 48px;
    overflow: hidden;
  }

  .sb-addon-text {
    padding-left: 48px;
    max-width: 240px;
  }

  .sb-addon-text h4 {
    padding-top: 0px;
  }

  .sb-addon-img {
    position: absolute;
    left: 345px;
    top: 0;
    height: 100%;
    width: 200%;
    overflow: hidden;
  }

  .sb-addon-img img {
    width: 650px;
    transform: rotate(-15deg);
    margin-left: 40px;
    margin-top: -72px;
    box-shadow: 0 0 1px rgba(255, 255, 255, 0);
    backface-visibility: hidden;
  }

  @media screen and (max-width: 800px) {
    .sb-addon-img {
      left: 300px;
    }
  }

  @media screen and (max-width: 600px) {
    .sb-section {
      flex-direction: column;
    }

    .sb-features-grid {
      grid-template-columns: repeat(1, 1fr);
    }

    .sb-socials {
      grid-template-columns: repeat(2, 1fr);
    }

    .sb-addon {
      height: 280px;
      align-items: flex-start;
      padding-top: 32px;
      overflow: hidden;
    }

    .sb-addon-text {
      padding-left: 24px;
    }

    .sb-addon-img {
      right: 0;
      left: 0;
      top: 130px;
      bottom: 0;
      overflow: hidden;
      height: auto;
      width: 124%;
    }

    .sb-addon-img img {
      width: 1200px;
      transform: rotate(-12deg);
      margin-left: 0;
      margin-top: 48px;
      margin-bottom: -40px;
      margin-left: -24px;
    }
  }
  `}
</style>

```

## `src/stories/header.css`

```css
.storybook-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  padding: 15px 20px;
  font-family: 'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;
}

.storybook-header svg {
  display: inline-block;
  vertical-align: top;
}

.storybook-header h1 {
  display: inline-block;
  vertical-align: top;
  margin: 6px 0 6px 10px;
  font-weight: 700;
  font-size: 20px;
  line-height: 1;
}

.storybook-header button + button {
  margin-left: 10px;
}

.storybook-header .welcome {
  margin-right: 10px;
  color: #333;
  font-size: 14px;
}

```

## `src/stories/Header.stories.ts`

```typescript
import type { Meta, StoryObj } from '@storybook/react-vite';

import { fn } from 'storybook/test';

import { Header } from './Header';

const meta = {
  title: 'Example/Header',
  component: Header,
  // This component will have an automatically generated Autodocs entry: https://storybook.js.org/docs/writing-docs/autodocs
  tags: ['autodocs'],
  parameters: {
    // More on how to position stories at: https://storybook.js.org/docs/configure/story-layout
    layout: 'fullscreen',
  },
  args: {
    onLogin: fn(),
    onLogout: fn(),
    onCreateAccount: fn(),
  },
} satisfies Meta<typeof Header>;

export default meta;
type Story = StoryObj<typeof meta>;

export const LoggedIn: Story = {
  args: {
    user: {
      name: 'Jane Doe',
    },
  },
};

export const LoggedOut: Story = {};

```

## `src/stories/Header.tsx`

```tsx
import React from 'react';

import { Button } from './Button';
import './header.css';

type User = {
  name: string;
};

export interface HeaderProps {
  user?: User;
  onLogin?: () => void;
  onLogout?: () => void;
  onCreateAccount?: () => void;
}

export const Header = ({ user, onLogin, onLogout, onCreateAccount }: HeaderProps) => (
  <header>
    <div className="storybook-header">
      <div>
        <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
          <g fill="none" fillRule="evenodd">
            <path
              d="M10 0h12a10 10 0 0110 10v12a10 10 0 01-10 10H10A10 10 0 010 22V10A10 10 0 0110 0z"
              fill="#FFF"
            />
            <path
              d="M5.3 10.6l10.4 6v11.1l-10.4-6v-11zm11.4-6.2l9.7 5.5-9.7 5.6V4.4z"
              fill="#555AB9"
            />
            <path
              d="M27.2 10.6v11.2l-10.5 6V16.5l10.5-6zM15.7 4.4v11L6 10l9.7-5.5z"
              fill="#91BAF8"
            />
          </g>
        </svg>
        <h1>Acme</h1>
      </div>
      <div>
        {user ? (
          <>
            <span className="welcome">
              Welcome, <b>{user.name}</b>!
            </span>
            <Button size="small" onClick={onLogout} label="Log out" />
          </>
        ) : (
          <>
            <Button size="small" onClick={onLogin} label="Log in" />
            <Button primary size="small" onClick={onCreateAccount} label="Sign up" />
          </>
        )}
      </div>
    </div>
  </header>
);

```

## `src/stories/page.css`

```css
.storybook-page {
  margin: 0 auto;
  padding: 48px 20px;
  max-width: 600px;
  color: #333;
  font-size: 14px;
  line-height: 24px;
  font-family: 'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;
}

.storybook-page h2 {
  display: inline-block;
  vertical-align: top;
  margin: 0 0 4px;
  font-weight: 700;
  font-size: 32px;
  line-height: 1;
}

.storybook-page p {
  margin: 1em 0;
}

.storybook-page a {
  color: inherit;
}

.storybook-page ul {
  margin: 1em 0;
  padding-left: 30px;
}

.storybook-page li {
  margin-bottom: 8px;
}

.storybook-page .tip {
  display: inline-block;
  vertical-align: top;
  margin-right: 10px;
  border-radius: 1em;
  background: #e7fdd8;
  padding: 4px 12px;
  color: #357a14;
  font-weight: 700;
  font-size: 11px;
  line-height: 12px;
}

.storybook-page .tip-wrapper {
  margin-top: 40px;
  margin-bottom: 40px;
  font-size: 13px;
  line-height: 20px;
}

.storybook-page .tip-wrapper svg {
  display: inline-block;
  vertical-align: top;
  margin-top: 3px;
  margin-right: 4px;
  width: 12px;
  height: 12px;
}

.storybook-page .tip-wrapper svg path {
  fill: #1ea7fd;
}

```

## `src/stories/Page.stories.ts`

```typescript
import type { Meta, StoryObj } from '@storybook/react-vite';

import { expect, userEvent, within } from 'storybook/test';

import { Page } from './Page';

const meta = {
  title: 'Example/Page',
  component: Page,
  parameters: {
    // More on how to position stories at: https://storybook.js.org/docs/configure/story-layout
    layout: 'fullscreen',
  },
} satisfies Meta<typeof Page>;

export default meta;
type Story = StoryObj<typeof meta>;

export const LoggedOut: Story = {};

// More on component testing: https://storybook.js.org/docs/writing-tests/interaction-testing
export const LoggedIn: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const loginButton = canvas.getByRole('button', { name: /Log in/i });
    await expect(loginButton).toBeInTheDocument();
    await userEvent.click(loginButton);
    await expect(loginButton).not.toBeInTheDocument();

    const logoutButton = canvas.getByRole('button', { name: /Log out/i });
    await expect(logoutButton).toBeInTheDocument();
  },
};

```

## `src/stories/Page.tsx`

```tsx
import React from 'react';

import { Header } from './Header';
import './page.css';

type User = {
  name: string;
};

export const Page: React.FC = () => {
  const [user, setUser] = React.useState<User>();

  return (
    <article>
      <Header
        user={user}
        onLogin={() => setUser({ name: 'Jane Doe' })}
        onLogout={() => setUser(undefined)}
        onCreateAccount={() => setUser({ name: 'Jane Doe' })}
      />

      <section className="storybook-page">
        <h2>Pages in Storybook</h2>
        <p>
          We recommend building UIs with a{' '}
          <a href="https://componentdriven.org" target="_blank" rel="noopener noreferrer">
            <strong>component-driven</strong>
          </a>{' '}
          process starting with atomic components and ending with pages.
        </p>
        <p>
          Render pages with mock data. This makes it easy to build and review page states without
          needing to navigate to them in your app. Here are some handy patterns for managing page
          data in Storybook:
        </p>
        <ul>
          <li>
            Use a higher-level connected component. Storybook helps you compose such data from the
            "args" of child component stories
          </li>
          <li>
            Assemble data in the page component from your services. You can mock these services out
            using Storybook.
          </li>
        </ul>
        <p>
          Get a guided tutorial on component-driven development at{' '}
          <a href="https://storybook.js.org/tutorials/" target="_blank" rel="noopener noreferrer">
            Storybook tutorials
          </a>
          . Read more in the{' '}
          <a href="https://storybook.js.org/docs" target="_blank" rel="noopener noreferrer">
            docs
          </a>
          .
        </p>
        <div className="tip-wrapper">
          <span className="tip">Tip</span> Adjust the width of the canvas with the{' '}
          <svg width="10" height="10" viewBox="0 0 12 12" xmlns="http://www.w3.org/2000/svg">
            <g fill="none" fillRule="evenodd">
              <path
                d="M1.5 5.2h4.8c.3 0 .5.2.5.4v5.1c-.1.2-.3.3-.4.3H1.4a.5.5 0 01-.5-.4V5.7c0-.3.2-.5.5-.5zm0-2.1h6.9c.3 0 .5.2.5.4v7a.5.5 0 01-1 0V4H1.5a.5.5 0 010-1zm0-2.1h9c.3 0 .5.2.5.4v9.1a.5.5 0 01-1 0V2H1.5a.5.5 0 010-1zm4.3 5.2H2V10h3.8V6.2z"
                id="a"
                fill="#999"
              />
            </g>
          </svg>
          Viewports addon in the toolbar
        </div>
      </section>
    </article>
  );
};

```

## `src/test/fixtures/mockApi.ts`

```typescript
/**
 * API Mock Fixtures
 * 
 * Provides mock implementations of API responses for testing.
 */

import { vi } from 'vitest';

/**
 * Create a mock successful Apps Script API response
 */
export function createMockAppsScriptResponse(data: unknown[][]) {
  return {
    ok: true,
    status: 200,
    json: vi.fn().mockResolvedValue(data),
    text: vi.fn().mockResolvedValue(JSON.stringify(data)),
  } as Response;
}

/**
 * Create a mock CSV proxy response
 */
export function createMockCSVResponse(csvData: string) {
  return {
    ok: true,
    status: 200,
    text: vi.fn().mockResolvedValue(csvData),
  } as Response;
}

/**
 * Create a mock error response
 */
export function createMockErrorResponse(status: number, statusText: string, body?: unknown) {
  return {
    ok: false,
    status,
    statusText,
    json: vi.fn().mockResolvedValue(body || { error: statusText }),
    text: vi.fn().mockResolvedValue(JSON.stringify(body || { error: statusText })),
  } as Response;
}

/**
 * Create a mock network error
 */
export function createMockNetworkError(message: string = 'Failed to fetch') {
  return new TypeError(message);
}

/**
 * Create a mock timeout error
 */
export function createMockTimeoutError() {
  return new Error('Request timeout after 30 seconds');
}

/**
 * Mock fetch for successful Apps Script response
 */
export function mockFetchSuccess(data: unknown[][]) {
  global.fetch = vi.fn().mockResolvedValue(createMockAppsScriptResponse(data));
}

/**
 * Mock fetch for error response
 */
export function mockFetchError(status: number, statusText: string) {
  global.fetch = vi.fn().mockResolvedValue(createMockErrorResponse(status, statusText));
}

/**
 * Mock fetch for network error
 */
export function mockFetchNetworkError() {
  global.fetch = vi.fn().mockRejectedValue(createMockNetworkError());
}

/**
 * Create sample Apps Script 2D array response
 */
export function createSampleAppsScriptData(headers: string[], rows: unknown[][]) {
  return [headers, ...rows];
}

/**
 * Create sample CSV data
 */
export function createSampleCSVData(headers: string[], rows: unknown[][]) {
  const csvRows = [
    headers.join(','),
    ...rows.map(row => row.join(',')),
  ];
  return csvRows.join('\n');
}

```

## `src/test/fixtures/mockFirebase.ts`

```typescript
/**
 * Firebase Mock Fixtures
 * 
 * Provides mock implementations of Firebase services for testing.
 */

import { vi } from 'vitest';
import { User } from 'firebase/auth';
import { Timestamp } from 'firebase/firestore';

/**
 * Create a mock Firebase User
 */
export function createMockFirebaseUser(overrides: Partial<User> = {}): User {
  return {
    uid: 'test-user-id',
    email: 'test@example.com',
    displayName: 'Test User',
    emailVerified: true,
    isAnonymous: false,
    metadata: {
      creationTime: '2024-01-01T00:00:00Z',
      lastSignInTime: '2024-01-01T00:00:00Z',
    },
    providerData: [],
    refreshToken: 'mock-refresh-token',
    tenantId: null,
    delete: vi.fn(),
    getIdToken: vi.fn().mockResolvedValue('mock-id-token'),
    getIdTokenResult: vi.fn().mockResolvedValue({
      token: 'mock-id-token',
      authTime: '2024-01-01T00:00:00Z',
      issuedAtTime: '2024-01-01T00:00:00Z',
      expirationTime: '2024-01-02T00:00:00Z',
      signInProvider: 'password',
      claims: { role: 'viewer1' },
    }),
    reload: vi.fn().mockResolvedValue(undefined),
    toJSON: vi.fn().mockReturnValue({}),
    ...overrides,
  } as User;
}

/**
 * Create a mock Firestore document snapshot
 */
export function createMockFirestoreDoc<T>(data: T, exists: boolean = true) {
  return {
    exists: () => exists,
    id: 'test-doc-id',
    data: () => (exists ? data : undefined),
    metadata: {
      hasPendingWrites: false,
      isFromCache: false,
    },
    ref: {
      id: 'test-doc-id',
      path: 'test/path',
    },
  };
}

/**
 * Create a mock Firestore query snapshot
 */
export function createMockFirestoreQuerySnapshot<T>(docs: Array<{ id: string; data: T }>) {
  return {
    docs: docs.map(doc => createMockFirestoreDoc(doc.data)),
    empty: docs.length === 0,
    size: docs.length,
    metadata: {
      hasPendingWrites: false,
      isFromCache: false,
    },
    query: {},
    forEach: (callback: (doc: ReturnType<typeof createMockFirestoreDoc>) => void) => {
      docs.forEach(doc => {
        callback(createMockFirestoreDoc(doc.data));
      });
    },
  };
}

/**
 * Create a mock Firestore Timestamp
 */
export function createMockTimestamp(date: Date = new Date()): Timestamp {
  return {
    seconds: Math.floor(date.getTime() / 1000),
    nanoseconds: (date.getTime() % 1000) * 1000000,
    toDate: () => date,
    toMillis: () => date.getTime(),
    isEqual: vi.fn(),
    valueOf: () => date.getTime(),
  } as unknown as Timestamp;
}

/**
 * Mock Firebase Auth
 */
export function mockFirebaseAuth(user: User | null = null) {
  return {
    currentUser: user,
    onAuthStateChanged: vi.fn((callback) => {
      callback(user);
      return vi.fn(); // Return unsubscribe function
    }),
    signInWithEmailAndPassword: vi.fn().mockResolvedValue({ user }),
    signOut: vi.fn().mockResolvedValue(undefined),
    createUserWithEmailAndPassword: vi.fn().mockResolvedValue({ user }),
  };
}

/**
 * Mock Firestore document reference
 */
export function mockFirestoreDocRef(collection: string, id: string) {
  return {
    id,
    path: `${collection}/${id}`,
    parent: {
      id: collection,
      path: collection,
    },
  };
}

/**
 * Mock Firestore collection reference
 */
export function mockFirestoreCollectionRef(collection: string) {
  return {
    id: collection,
    path: collection,
  };
}

```

## `src/test/helpers.ts`

```typescript
import { 
  ScoreBoardData, 
  ThresholdIndustryData, 
  BenjaminGrahamData,
  SMAData,
  EntryExitData,
  PEIndustryData
} from '../types/stock';
import type { EntryExitValuesForScore } from '../types/score';
import { ScoreData } from '../components/views/ScoreView';

/**
 * Create mock ScoreBoardData for testing
 */
export function createMockScoreBoardData(overrides: Partial<ScoreBoardData> = {}): ScoreBoardData {
  return {
    companyName: 'Test Company',
    ticker: 'TEST',
    industry: 'Test Industry',
    irr: null,
    mungerQualityScore: null,
    valueCreation: null,
    tbSPrice: null,
    ro40Cy: null,
    ro40F1: null,
    ro40F2: null,
    leverageF2: null,
    pe1Industry: null,
    pe2Industry: null,
    currentRatio: null,
    cashSdebt: null,
    isCashSdebtDivZero: false,
    sma100: null,
    sma200: null,
    smaCross: null,
    price: null,
    ...overrides,
  };
}

/**
 * Create mock ThresholdIndustryData for testing
 */
export function createMockThresholdData(overrides: Partial<ThresholdIndustryData> = {}): ThresholdIndustryData {
  return {
    industry: 'Test Industry',
    irr: 25,
    leverageF2Min: 2.0,
    leverageF2Max: 3.0,
    ro40Min: 0.15,
    ro40Max: 0.25,
    cashSdebtMin: 0.7,
    cashSdebtMax: 1.2,
    currentRatioMin: 1.1,
    currentRatioMax: 2.0,
    ...overrides,
  };
}

/**
 * Create mock BenjaminGrahamData for testing
 */
export function createMockBenjaminGrahamData(overrides: Partial<BenjaminGrahamData> = {}): BenjaminGrahamData {
  return {
    companyName: 'Test Company',
    ticker: 'TEST',
    price: 100,
    benjaminGraham: 90,
    ...overrides,
  };
}

/**
 * Create mock EntryExitValues for testing
 */
export function createMockEntryExitValues(overrides: Partial<EntryExitValuesForScore> = {}): EntryExitValuesForScore {
  return {
    entry1: 0,
    entry2: 0,
    exit1: 0,
    exit2: 0,
    currency: 'USD',
    dateOfUpdate: null,
    ...overrides,
  };
}

/**
 * Create a Map of EntryExitValues for testing
 */
export function createMockEntryExitValuesMap(
  entries: Array<{ ticker: string; companyName: string; values: Partial<EntryExitValuesForScore> }> = []
): Map<string, EntryExitValuesForScore> {
  const map = new Map<string, EntryExitValuesForScore>();
  entries.forEach(({ ticker, companyName, values }) => {
    const key = `${ticker}-${companyName}`;
    map.set(key, createMockEntryExitValues(values));
  });
  return map;
}

/**
 * Create mock SMAData for testing
 */
export function createMockSMAData(overrides: Partial<SMAData> = {}): SMAData {
  return {
    companyName: 'Test Company',
    ticker: 'TEST',
    sma100: 100,
    sma200: 95,
    smaCross: null,
    ...overrides,
  };
}

/**
 * Create mock EntryExitData for testing
 */
export function createMockEntryExitData(overrides: Partial<EntryExitData> = {}): EntryExitData {
  return {
    companyName: 'Test Company',
    ticker: 'TEST',
    currency: 'USD',
    entry1: 100,
    entry2: 90,
    exit1: 150,
    exit2: 140,
    dateOfUpdate: '2024-01-01',
    ...overrides,
  };
}

/**
 * Create mock PEIndustryData for testing
 */
export function createMockPEIndustryData(overrides: Partial<PEIndustryData> = {}): PEIndustryData {
  return {
    industry: 'Test Industry',
    pe: 15,
    pe1: 20,
    pe2: 18,
    companyCount: 10,
    ...overrides,
  };
}

/**
 * Create mock ScoreData for testing
 */
export function createMockScoreData(overrides: Partial<ScoreData> = {}): ScoreData {
  return {
    companyName: 'Test Company',
    ticker: 'TEST',
    score: 50,
    scoreBoardData: createMockScoreBoardData(),
    ...overrides,
  };
}

/**
 * Generate a large array of ScoreBoardData
 */
export function generateLargeScoreBoardDataSet(count: number): ScoreBoardData[] {
  const industries = ['Technology', 'Finance', 'Healthcare', 'Energy', 'Consumer'];
  const data: ScoreBoardData[] = [];
  
  for (let i = 0; i < count; i++) {
    const industry = industries[i % industries.length];
    data.push(createMockScoreBoardData({
      companyName: `Company ${i + 1}`,
      ticker: `TICK${String(i + 1).padStart(3, '0')}`,
      industry,
      irr: Math.random() * 50,
      mungerQualityScore: Math.random() * 100,
      valueCreation: (Math.random() - 0.5) * 20,
      tbSPrice: Math.random() * 2,
      ro40F1: Math.random() * 30,
      ro40F2: Math.random() * 30,
      currentRatio: Math.random() * 3,
      cashSdebt: Math.random() * 2,
      leverageF2: Math.random() * 5,
      pe1Industry: (Math.random() - 0.5) * 20,
      pe2Industry: (Math.random() - 0.5) * 20,
      sma100: 100 + Math.random() * 50,
      sma200: 90 + Math.random() * 50,
      smaCross: Math.random() > 0.5 ? 'GOLDEN CROSS' : 'DEATH CROSS',
      price: 100 + Math.random() * 50,
    }));
  }
  
  return data;
}

/**
 * Generate edge case ScoreBoardData with null values and extreme values
 */
export function generateEdgeCaseScoreBoardData(): ScoreBoardData[] {
  return [
    // All null values
    createMockScoreBoardData({
      companyName: 'Null Company',
      ticker: 'NULL',
      industry: 'Test Industry',
      irr: null,
      mungerQualityScore: null,
      valueCreation: null,
      tbSPrice: null,
      ro40F1: null,
      ro40F2: null,
      currentRatio: null,
      cashSdebt: null,
      leverageF2: null,
      pe1Industry: null,
      pe2Industry: null,
      sma100: null,
      sma200: null,
      smaCross: null,
      price: null,
    }),
    // Extreme positive values
    createMockScoreBoardData({
      companyName: 'Extreme High',
      ticker: 'HIGH',
      industry: 'Test Industry',
      irr: 999,
      mungerQualityScore: 100,
      valueCreation: 999,
      tbSPrice: 999,
      ro40F1: 999,
      ro40F2: 999,
      currentRatio: 999,
      cashSdebt: 999,
      leverageF2: 999,
      pe1Industry: 999,
      pe2Industry: 999,
      sma100: 9999,
      sma200: 9999,
      price: 9999,
    }),
    // Extreme negative values
    createMockScoreBoardData({
      companyName: 'Extreme Low',
      ticker: 'LOW',
      industry: 'Test Industry',
      irr: -999,
      mungerQualityScore: 0,
      valueCreation: -999,
      tbSPrice: 0.01,
      ro40F1: -999,
      ro40F2: -999,
      currentRatio: 0.01,
      cashSdebt: 0.01,
      leverageF2: 0.01,
      pe1Industry: -999,
      pe2Industry: -999,
      sma100: 0.01,
      sma200: 0.01,
      price: 0.01,
    }),
    // Special characters in text fields
    createMockScoreBoardData({
      companyName: "Company & Co. <Special> 'Chars'",
      ticker: 'SP&L',
      industry: 'Test & Industry',
    }),
    // DivZero case
    createMockScoreBoardData({
      companyName: 'DivZero Company',
      ticker: 'DIV0',
      industry: 'Test Industry',
      cashSdebt: null,
      isCashSdebtDivZero: true,
    }),
    // Empty strings
    createMockScoreBoardData({
      companyName: '',
      ticker: '',
      industry: '',
    }),
  ];
}

/**
 * Generate large array of BenjaminGrahamData
 */
export function generateLargeBenjaminGrahamDataSet(count: number): BenjaminGrahamData[] {
  const data: BenjaminGrahamData[] = [];
  
  for (let i = 0; i < count; i++) {
    data.push(createMockBenjaminGrahamData({
      companyName: `Company ${i + 1}`,
      ticker: `TICK${String(i + 1).padStart(3, '0')}`,
      price: 50 + Math.random() * 200,
      benjaminGraham: 40 + Math.random() * 180,
      ivFcf: Math.random() > 0.5 ? 100 + Math.random() * 150 : null,
      irr1: Math.random() > 0.5 ? Math.random() * 50 : null,
    }));
  }
  
  return data;
}

/**
 * Generate large array of SMAData
 */
export function generateLargeSMADataSet(count: number): SMAData[] {
  const data: SMAData[] = [];
  const crossTypes = ['GOLDEN CROSS', 'DEATH CROSS', null];
  
  for (let i = 0; i < count; i++) {
    data.push(createMockSMAData({
      companyName: `Company ${i + 1}`,
      ticker: `TICK${String(i + 1).padStart(3, '0')}`,
      sma100: 80 + Math.random() * 100,
      sma200: 70 + Math.random() * 100,
      smaCross: crossTypes[i % crossTypes.length],
    }));
  }
  
  return data;
}

/**
 * Generate large array of EntryExitData
 */
export function generateLargeEntryExitDataSet(count: number): EntryExitData[] {
  const data: EntryExitData[] = [];
  const currencies = ['USD', 'EUR', 'SEK'];
  
  for (let i = 0; i < count; i++) {
    const basePrice = 100 + Math.random() * 100;
    data.push(createMockEntryExitData({
      companyName: `Company ${i + 1}`,
      ticker: `TICK${String(i + 1).padStart(3, '0')}`,
      currency: currencies[i % currencies.length],
      entry1: basePrice * 0.9,
      entry2: basePrice * 0.8,
      exit1: basePrice * 1.5,
      exit2: basePrice * 1.4,
      dateOfUpdate: `2024-${String((i % 12) + 1).padStart(2, '0')}-01`,
    }));
  }
  
  return data;
}

/**
 * Generate large array of ThresholdIndustryData
 */
export function generateLargeThresholdDataSet(count: number): ThresholdIndustryData[] {
  const industries = ['Technology', 'Finance', 'Healthcare', 'Energy', 'Consumer', 'Manufacturing', 'Retail', 'Telecom'];
  const data: ThresholdIndustryData[] = [];
  
  for (let i = 0; i < count; i++) {
    const industry = industries[i % industries.length];
    data.push(createMockThresholdData({
      industry: `${industry} ${Math.floor(i / industries.length) + 1}`,
      irr: 15 + Math.random() * 20,
      leverageF2Min: 1.5 + Math.random(),
      leverageF2Max: 2.5 + Math.random(),
      ro40Min: 0.1 + Math.random() * 0.1,
      ro40Max: 0.2 + Math.random() * 0.1,
      cashSdebtMin: 0.5 + Math.random() * 0.5,
      cashSdebtMax: 1.0 + Math.random() * 0.5,
      currentRatioMin: 1.0 + Math.random() * 0.5,
      currentRatioMax: 1.5 + Math.random() * 0.5,
    }));
  }
  
  return data;
}

/**
 * Generate large array of PEIndustryData
 */
export function generateLargePEIndustryDataSet(count: number): PEIndustryData[] {
  const industries = ['Technology', 'Finance', 'Healthcare', 'Energy', 'Consumer'];
  const data: PEIndustryData[] = [];
  
  for (let i = 0; i < count; i++) {
    const industry = industries[i % industries.length];
    data.push(createMockPEIndustryData({
      industry: `${industry} ${Math.floor(i / industries.length) + 1}`,
      pe: 10 + Math.random() * 30,
      pe1: 15 + Math.random() * 30,
      pe2: 12 + Math.random() * 30,
      companyCount: 5 + Math.floor(Math.random() * 20),
    }));
  }
  
  return data;
}

/**
 * Generate large array of ScoreData
 */
export function generateLargeScoreDataSet(count: number): ScoreData[] {
  const data: ScoreData[] = [];
  
  for (let i = 0; i < count; i++) {
    data.push(createMockScoreData({
      companyName: `Company ${i + 1}`,
      ticker: `TICK${String(i + 1).padStart(3, '0')}`,
      score: Math.random() * 100,
      scoreBoardData: createMockScoreBoardData({
        companyName: `Company ${i + 1}`,
        ticker: `TICK${String(i + 1).padStart(3, '0')}`,
      }),
    }));
  }
  
  return data;
}

/**
 * Create filter combinations for testing
 */
export interface FilterCombination {
  companyName?: string;
  ticker?: string;
  industry?: string;
  irr?: { min?: number; max?: number };
  mungerQualityScore?: { min?: number; max?: number };
  valueCreation?: { min?: number; max?: number };
  ro40F1?: { min?: number; max?: number };
  ro40F2?: { min?: number; max?: number };
  currentRatio?: { min?: number; max?: number };
  score?: { min?: number; max?: number };
  price?: { min?: number; max?: number };
  benjaminGraham?: { min?: number; max?: number };
}

/**
 * Common filter combinations for testing
 */
export const COMMON_FILTER_COMBINATIONS: FilterCombination[] = [
  // Single filters
  { companyName: 'Test' },
  { ticker: 'TEST' },
  { industry: 'Test Industry' },
  { irr: { min: 20, max: 30 } },
  { mungerQualityScore: { min: 50, max: 75 } },
  
  // Two filters
  { companyName: 'Test', industry: 'Test Industry' },
  { irr: { min: 20 }, mungerQualityScore: { min: 50 } },
  { ticker: 'TEST', valueCreation: { min: 0 } },
  
  // Three filters
  { companyName: 'Test', industry: 'Test Industry', irr: { min: 20 } },
  { ticker: 'TEST', ro40F1: { min: 10 }, ro40F2: { min: 10 } },
  
  // Range filters
  { irr: { min: 15, max: 25 } },
  { mungerQualityScore: { min: 40, max: 60 } },
  { valueCreation: { min: -10, max: 10 } },
  
  // Extreme ranges
  { irr: { min: 0, max: 1000 } },
  { mungerQualityScore: { min: 0, max: 100 } },
];


```

## `src/test/helpers/apiHelpers.ts`

```typescript
/**
 * API Test Helpers
 * 
 * Provides helper functions for mocking API calls in tests.
 */

import { vi } from 'vitest';
import {
  createMockAppsScriptResponse,
  createMockCSVResponse,
  createMockErrorResponse,
  createMockNetworkError,
  createSampleAppsScriptData,
} from '../fixtures/mockApi';

/**
 * Mock successful fetch response
 */
export function mockFetchSuccess(data: unknown[][] | Response) {
  if (data instanceof Response) {
    global.fetch = vi.fn().mockResolvedValue(data);
  } else {
    global.fetch = vi.fn().mockResolvedValue(createMockAppsScriptResponse(data));
  }
}

/**
 * Mock fetch error response
 */
export function mockFetchError(status: number, statusText: string, body?: unknown) {
  global.fetch = vi.fn().mockResolvedValue(createMockErrorResponse(status, statusText, body));
}

/**
 * Mock fetch network error
 */
export function mockFetchNetworkError(message: string = 'Failed to fetch') {
  global.fetch = vi.fn().mockRejectedValue(createMockNetworkError(message));
}

/**
 * Mock Apps Script API response
 */
export function mockAppsScriptResponse(headers: string[], rows: unknown[][]) {
  const data = createSampleAppsScriptData(headers, rows);
  mockFetchSuccess(data);
}

/**
 * Mock CSV proxy response
 */
export function mockCSVResponse(csvData: string) {
  global.fetch = vi.fn().mockResolvedValue(createMockCSVResponse(csvData));
}

/**
 * Reset fetch mock
 */
export function resetFetchMock() {
  vi.restoreAllMocks();
  global.fetch = vi.fn();
}

/**
 * Create a delay mock for testing timeouts
 */
export function mockFetchDelay(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

```

## `src/test/helpers/firebaseHelpers.ts`

```typescript
/**
 * Firebase Test Helpers
 * 
 * Provides helper functions for mocking Firebase services in tests.
 */

import { vi } from 'vitest';
import { User } from 'firebase/auth';
import { createMockFirebaseUser, createMockFirestoreDoc } from '../fixtures/mockFirebase';

/**
 * Setup mock Firebase Auth
 */
export function mockFirebaseAuth(user: User | null = null) {
  const mockAuth = {
    currentUser: user,
    onAuthStateChanged: vi.fn((callback) => {
      callback(user);
      return vi.fn(); // Return unsubscribe function
    }),
    signInWithEmailAndPassword: vi.fn().mockResolvedValue({ user }),
    signOut: vi.fn().mockResolvedValue(undefined),
    createUserWithEmailAndPassword: vi.fn().mockResolvedValue({ user }),
  };

  return mockAuth;
}

/**
 * Mock Firestore document
 */
export function mockFirestoreDoc<T>(data: T, exists: boolean = true) {
  return createMockFirestoreDoc(data, exists);
}

/**
 * Mock Firestore collection query
 */
export function mockFirestoreCollection<T>(docs: Array<{ id: string; data: T }>) {
  return {
    docs: docs.map(doc => createMockFirestoreDoc(doc.data)),
    empty: docs.length === 0,
    size: docs.length,
    forEach: vi.fn((callback) => {
      docs.forEach(doc => {
        callback(createMockFirestoreDoc(doc.data));
      });
    }),
  };
}

/**
 * Mock Firestore error
 */
export function mockFirestoreError(code: string, message: string) {
  return {
    code,
    message,
    name: 'FirestoreError',
  };
}

/**
 * Setup complete Firebase mocks
 */
export function setupFirebaseMocks(options: {
  user?: User | null;
  firestoreData?: Record<string, unknown>;
} = {}) {
  const { user = createMockFirebaseUser(), firestoreData = {} } = options;

  const auth = mockFirebaseAuth(user);

  const firestore = {
    doc: vi.fn((collection, id) => ({
      id,
      path: `${collection}/${id}`,
    })),
    collection: vi.fn((collection) => ({
      id: collection,
      path: collection,
    })),
    getDoc: vi.fn((docRef) => {
      const key = docRef.path;
      const data = firestoreData[key];
      return Promise.resolve(createMockFirestoreDoc(data || null, !!data));
    }),
    setDoc: vi.fn().mockResolvedValue(undefined),
    updateDoc: vi.fn().mockResolvedValue(undefined),
    deleteDoc: vi.fn().mockResolvedValue(undefined),
    getDocs: vi.fn().mockResolvedValue({
      docs: [],
      empty: true,
      size: 0,
    }),
  };

  return { auth, firestore, user };
}

// Re-export for convenience
export { createMockFirebaseUser } from '../fixtures/mockFirebase';

```

## `src/test/helpers/renderHelpers.tsx`

```tsx
/**
 * Render Helpers for Testing
 *
 * Provides utility functions for rendering React components in tests
 * with all necessary providers and contexts. Provider tree matches main.tsx + App.tsx:
 * Theme → Toast → Auth → Notification → LoadingProgress → Refresh → AutoRefresh → EntryExit → Threshold.
 */

import React, { ReactElement } from 'react';
import { render, RenderOptions } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { ThemeProvider } from '../../contexts/ThemeContext';
import { AuthProvider, AuthContext, type AuthContextType } from '../../contexts/AuthContext';
import { ToastProvider } from '../../contexts/ToastContext';
import { RefreshProvider } from '../../contexts/RefreshContext';
import { AutoRefreshProvider } from '../../contexts/AutoRefreshContext';
import { LoadingProgressProvider } from '../../contexts/LoadingProgressContext';
import { EntryExitProvider } from '../../contexts/EntryExitContext';
import { ThresholdProvider } from '../../contexts/ThresholdContext';
import { NotificationProvider } from '../../contexts/NotificationContext';
import { User } from 'firebase/auth';
import { createMockFirebaseUser } from '../fixtures/mockFirebase';
import { vi } from 'vitest';

/** Build a stable mock auth value for tests so useAuth() returns the given user without Firebase. */
function getMockAuthValue(user: User | null, userRole?: 'admin' | 'viewer' | null): AuthContextType {
  return {
    currentUser: user,
    userRole: userRole ?? null,
    viewerPermissions: null,
    loading: false,
    login: vi.fn().mockResolvedValue(undefined),
    signup: vi.fn().mockResolvedValue({ user } as { user: User }),
    logout: vi.fn().mockResolvedValue(undefined),
    refreshUserRole: vi.fn().mockResolvedValue(undefined),
  };
}

interface AllTheProvidersProps {
  children: React.ReactNode;
  user?: User | null;
  userRole?: 'admin' | 'viewer' | null;
}

/** Inner tree under Auth: matches App.tsx order (LoadingProgress → Refresh → AutoRefresh → …). */
function AuthAndBelow({ children }: { children: React.ReactNode }) {
  return (
    <NotificationProvider>
      <LoadingProgressProvider>
        <RefreshProvider>
          <AutoRefreshProvider>
            <EntryExitProvider>
              <ThresholdProvider>
                {children}
              </ThresholdProvider>
            </EntryExitProvider>
          </AutoRefreshProvider>
        </RefreshProvider>
      </LoadingProgressProvider>
    </NotificationProvider>
  );
}

/**
 * Wrapper component with all providers (order matches main.tsx + App.tsx).
 * When options.user is provided, Auth is mocked with that user; otherwise AuthProvider is used.
 */
function AllTheProviders({ children, user, userRole }: AllTheProvidersProps) {
  const authContent = <AuthAndBelow>{children}</AuthAndBelow>;

  return (
    <BrowserRouter>
      <ThemeProvider>
        <ToastProvider>
          {user !== undefined ? (
            <AuthContext.Provider value={getMockAuthValue(user, userRole)}>
              {authContent}
            </AuthContext.Provider>
          ) : (
            <AuthProvider>
              {authContent}
            </AuthProvider>
          )}
        </ToastProvider>
      </ThemeProvider>
    </BrowserRouter>
  );
}

/**
 * Render component with all providers
 */
export function renderWithProviders(
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'> & { user?: User | null; userRole?: 'admin' | 'viewer' | null }
) {
  const { user, userRole, ...renderOptions } = options || {};
  
  const Wrapper = ({ children }: { children: React.ReactNode }) => (
    <AllTheProviders user={user} userRole={userRole}>{children}</AllTheProviders>
  );

  return render(ui, { wrapper: Wrapper, ...renderOptions });
}

/**
 * Render component with mock authenticated user.
 * When userRole is 'admin', threshold/entry-exit editing is enabled.
 */
export function renderWithAuth(
  ui: ReactElement,
  user: User = createMockFirebaseUser(),
  options?: Omit<RenderOptions, 'wrapper'> & { userRole?: 'admin' | 'viewer' | null }
) {
  const { userRole = 'admin', ...rest } = options || {};
  return renderWithProviders(ui, { ...rest, user, userRole });
}

/**
 * Wait for data to load in component
 */
export async function waitForDataLoad(
  queryFn: () => HTMLElement | null,
  options: { timeout?: number } = {}
): Promise<HTMLElement> {
  const { timeout = 5000 } = options;
  const startTime = Date.now();

  while (Date.now() - startTime < timeout) {
    const element = queryFn();
    if (element) {
      return element;
    }
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  throw new Error('Data did not load within timeout');
}

```

## `src/test/integration/userFlows.test.tsx`

```tsx
/**
 * Integration Tests for User Flows
 * 
 * Tests complete user flows that span multiple components and services.
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { screen, waitFor, fireEvent } from '@testing-library/react';
import { renderWithAuth } from '../helpers/renderHelpers';
import { setupFirebaseMocks, createMockFirebaseUser } from '../helpers/firebaseHelpers';
import { createMockScoreBoardData } from '../helpers';
import App from '../../App';

// Mock all data hooks
vi.mock('../../hooks/useScoreBoardData', () => ({
  useScoreBoardData: () => ({
    data: [createMockScoreBoardData({ companyName: 'Test Company', ticker: 'TEST', score: 75 })],
    loading: false,
    error: null,
  }),
}));

vi.mock('../../hooks/useBenjaminGrahamData', () => ({
  useBenjaminGrahamData: () => ({
    data: [],
    loading: false,
    error: null,
  }),
}));

vi.mock('../../hooks/usePEIndustryData', () => ({
  usePEIndustryData: () => ({
    data: [],
    loading: false,
    error: null,
  }),
}));

vi.mock('../../hooks/useThresholdIndustryData', () => ({
  useThresholdIndustryData: () => ({
    data: [],
    loading: false,
    error: null,
    lastUpdated: new Date(),
    refetch: vi.fn(),
  }),
}));

// Mock Firebase
vi.mock('../../config/firebase', () => ({
  auth: {},
  db: {},
  functions: {},
}));

describe('User Flows Integration Tests', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
    setupFirebaseMocks();
  });

  describe('Login → View Score Board → Filter → Save Filter → Load Filter', () => {
    it('should complete full filter workflow', async () => {
      const user = createMockFirebaseUser();
      setupFirebaseMocks({ user });
      
      renderWithAuth(<App />, user);

      // Wait for app to load
      await waitFor(() => {
        expect(screen.getByText(/Score Board|Score/i)).toBeInTheDocument();
      });

      // Navigate to Score Board (if not already there)
      const scoreBoardLink = screen.queryByText(/Score Board/i);
      if (scoreBoardLink) {
        fireEvent.click(scoreBoardLink);
      }

      // Wait for table to render
      await waitFor(() => {
        expect(screen.getByText('Test Company')).toBeInTheDocument();
      });

      // Open filters
      const filterButton = screen.getByLabelText(/filter|Filter/i);
      fireEvent.click(filterButton);

      // Apply a filter (e.g., search for company name)
      const searchInput = screen.getByPlaceholderText(/sök|search/i);
      fireEvent.change(searchInput, { target: { value: 'Test' } });

      await waitFor(() => {
        expect(screen.getByText('Test Company')).toBeInTheDocument();
      });

      // Note: Full filter save/load would require more complex setup
      // This demonstrates the flow structure
    });
  });

  describe('View Entry/Exit → Edit values → Save to Firestore', () => {
    it('should allow editing and saving Entry/Exit values', async () => {
      const user = createMockFirebaseUser({ 
        uid: 'editor-user',
        email: 'editor@example.com',
      } as User);
      setupFirebaseMocks({ user });

      // Mock user role as editor (must include canView so Sidebar does not throw)
      vi.mock('../../hooks/useUserRole', () => ({
        useUserRole: () => ({
          hasRole: true,
          userRole: 'editor',
          isEditor: true,
          isAdmin: false,
          canView: () => true,
          getAllowedViews: () => null,
          refreshUserRole: vi.fn(),
        }),
      }));

      renderWithAuth(<App />, user);

      // Navigate to Entry/Exit view
      await waitFor(() => {
        const entryExitLink = screen.queryByText(/Entry|Exit|Benjamin Graham/i);
        if (entryExitLink) {
          fireEvent.click(entryExitLink);
        }
      });

      // Wait for table
      await waitFor(() => {
        expect(screen.getByText(/Company|Ticker/i)).toBeInTheDocument();
      });

      // Find and edit an entry value
      const entryInputs = screen.queryAllByDisplayValue('0');
      if (entryInputs.length > 0) {
        fireEvent.change(entryInputs[0], { target: { value: '100' } });
        fireEvent.blur(entryInputs[0]);

        // Value should be updated (Firestore save is mocked)
        await waitFor(() => {
          expect(entryInputs[0]).toHaveValue(100);
        });
      }
    });
  });

  describe('Search → Navigate → View details', () => {
    it('should allow searching and navigating to results', async () => {
      const user = createMockFirebaseUser();
      setupFirebaseMocks({ user });
      
      renderWithAuth(<App />, user);

      // Find search input
      await waitFor(() => {
        const searchInput = screen.queryByPlaceholderText(/sök|search/i);
        if (searchInput) {
          fireEvent.change(searchInput, { target: { value: 'Test' } });
        }
      });

      // Wait for search results
      await waitFor(() => {
        const results = screen.queryAllByText(/Test/i);
        expect(results.length).toBeGreaterThan(0);
      }, { timeout: 2000 });
    });
  });

  describe('Apply filters → Sort → Paginate', () => {
    it('should handle filter, sort, and pagination together', async () => {
      const user = createMockFirebaseUser();
      setupFirebaseMocks({ user });
      
      renderWithAuth(<App />, user);

      // Wait for table to load
      await waitFor(() => {
        expect(screen.getByText(/Company|Ticker/i)).toBeInTheDocument();
      });

      // Apply filter
      const filterButton = screen.queryByLabelText(/filter/i);
      if (filterButton) {
        fireEvent.click(filterButton);
        
        const searchInput = screen.queryByPlaceholderText(/sök/i);
        if (searchInput) {
          fireEvent.change(searchInput, { target: { value: 'Test' } });
        }
      }

      // Sort (click column header)
      const sortableHeaders = screen.queryAllByRole('columnheader');
      if (sortableHeaders.length > 0) {
        fireEvent.click(sortableHeaders[0]);
      }

      // Paginate (if pagination is visible)
      const nextPageButton = screen.queryByLabelText(/next|nästa/i);
      if (nextPageButton) {
        fireEvent.click(nextPageButton);
      }

      // All operations should work together
      await waitFor(() => {
        expect(screen.getByText(/Test/i)).toBeInTheDocument();
      });
    });
  });
});

```

## `src/test/setup.ts`

```typescript
// Test setup file for Vitest
import { expect, afterEach, beforeEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import * as matchers from '@testing-library/jest-dom/matchers';

// Extend Vitest's expect with jest-dom matchers
expect.extend(matchers);

// Mock localStorage (Storage interface with length + key for migrations)
const localStorageMock = (() => {
  let store: Record<string, string> = {};

  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => {
      store[key] = value.toString();
    },
    removeItem: (key: string) => {
      delete store[key];
    },
    clear: () => {
      store = {};
    },
    get length() {
      return Object.keys(store).length;
    },
    key: (index: number) => {
      const keys = Object.keys(store);
      return keys[index] ?? null;
    },
  };
})();

Object.defineProperty(window, 'localStorage', {
  value: localStorageMock,
});

// Cleanup after each test
afterEach(() => {
  cleanup();
  localStorageMock.clear();
});


```

## `src/types/columnMetadata.ts`

```typescript
export interface ColumnMetadata {
  columnKey: string;
  dataSource: string;
  formula?: string;
  conditions?: string[];
  description?: string;
}

export interface TableMetadata {
  tableId: string;
  columns: ColumnMetadata[];
}


```

## `src/types/filters.ts`

```typescript
/**
 * Filter Types
 * 
 * Type definitions for advanced filtering with groups and AND/OR logic.
 */

export type FilterType = 'text' | 'number' | 'numberRange' | 'select' | 'boolean';

export interface FilterConfig {
  key: string;
  label: string;
  type: FilterType;
  options?: { value: string | number; label: string }[];
  min?: number;
  max?: number;
  step?: number;
}

export interface FilterValues {
  [key: string]: string | number | { min?: number; max?: number } | boolean | null;
}

export type FilterOperator = 'AND' | 'OR';

export interface FilterGroup {
  id: string;
  operator: FilterOperator;
  filters: FilterValues[];
}

export interface FilterGroupState {
  groups: FilterGroup[];
  groupOperator: FilterOperator; // Operator between groups
}

```

## `src/types/navigation.ts`

```typescript
export type ViewId =
  | 'score'
  | 'score-board'
  | 'entry-exit-benjamin-graham'
  | 'entry-exit-entry2'
  | 'entry-exit-exit1'
  | 'entry-exit-exit2'
  | 'entry-exit-irr1'
  | 'entry-exit-iv-fcf'
  | 'fundamental-pe-industry'
  | 'fundamental-current-ratio'
  | 'fundamental-cash-sdebt'
  | 'fundamental-ro40-cy'
  | 'fundamental-ro40-f1'
  | 'fundamental-ro40-f2'
  | 'teknikal-tachart'
  | 'threshold-industry'
  | 'personal-portfolio'
  | 'admin';

export interface NavigationItem {
  id: ViewId;
  label: string;
  children?: NavigationItem[];
}

export interface NavigationSection {
  id: string;
  label: string;
  items: NavigationItem[];
  collapsible?: boolean;
}


```

## `src/types/portfolio.ts`

```typescript
/**
 * Portfolio Types
 *
 * Type definitions for Personal Portfolio feature.
 * Supports multi-broker positions per ticker with optional migration from legacy single-position items.
 */

/** Single position at one broker (quantity, invested amount and currency). */
export interface PortfolioPosition {
  broker: string;
  quantity: number;
  investedAmount?: number | null;
  investmentCurrency?: string | null;
}

export interface PortfolioItem {
  ticker: string;
  companyName: string;
  quantity: number; // Total quantity (sum of positions), kept for backward compatibility
  currency: string; // Aktiens currency (från EntryExitValues)
  price: number | null; // Från benjaminGrahamData
  averagePrice: number | null; // Average purchase price in USD (calculated from positions)
  investedAmount?: number | null; // Legacy / derived; prefer positions for per-broker data
  investmentCurrency?: string | null; // Legacy; prefer positions
  /** Per-broker positions; if missing, item is normalized from quantity/investedAmount/investmentCurrency */
  positions?: PortfolioPosition[];
  [key: string]: unknown;
}

export interface UserPortfolio {
  userId: string;
  portfolio: PortfolioItem[];
  updatedAt: Date;
}

```

## `src/types/responsiveTable.ts`

```typescript
import { ReactNode } from 'react';

export interface ColumnConfig {
  key: string;
  label: string;
  required?: boolean;
  defaultVisible?: boolean;
}

export interface ResponsiveTableWrapperProps<T> {
  // Primära kolumner (alltid synliga på små skärmar)
  primaryColumns: ColumnConfig[];
  // Sekundära kolumner (i expanderbart kort)
  secondaryColumns: ColumnConfig[];
  // Data
  data: T[];
  // Render-funktioner
  renderPrimaryCell: (item: T, column: ColumnConfig, index: number) => ReactNode;
  renderSecondaryContent: (item: T, index: number) => ReactNode;
  // Befintliga funktioner
  onRowClick?: (item: T) => void;
  // Styling
  rowClassName?: (item: T, index: number) => string;
  // Table header rendering
  renderTableHeader?: () => ReactNode;
  // Empty state
  emptyMessage?: string;
  // Loading state
  isLoading?: boolean;
}

export interface ExpandedRowState {
  [key: string]: boolean;
}


```

## `src/types/score.ts`

```typescript
/**
 * Types used by score calculation (utils/calculateScore).
 * Kept separate from contexts so domain logic does not depend on React context types.
 */

export interface EntryExitValuesForScore {
  entry1: number;
  entry2: number;
  exit1: number;
  exit2: number;
  currency: string;
  dateOfUpdate: string | null;
}

```

## `src/types/stock.ts`

```typescript
export interface BenjaminGrahamData extends Record<string, unknown> {
  companyName: string;
  ticker: string;
  price: number | null; // null means invalid/missing value, 0 means actual zero
  benjaminGraham: number | null;
  ivFcf?: number | null; // Optional: IV (FCF) column from Dashboard sheet
  irr1?: number | null; // Optional: IRR1 column from Dashboard sheet
}

export interface PEIndustryData extends Record<string, unknown> {
  industry: string;
  pe: number | null; // null means invalid/missing value, 0 means actual zero
  pe1: number | null;
  pe2: number | null;
  companyCount: number; // This is a counter, not from Dashboard sheet
}

export interface ScoreBoardData extends Record<string, unknown> {
  companyName: string;
  ticker: string;
  industry: string; // Added: Industry from Dashboard sheet for threshold matching
  irr: number | null; // null means invalid/missing value, 0 means actual zero
  mungerQualityScore: number | null;
  valueCreation: number | null; // procent-värde
  tbSPrice: number | null; // Added: (TB/Share) / Price from Dashboard sheet
  ro40Cy: number | null;
  ro40F1: number | null;
  ro40F2: number | null;
  leverageF2: number | null;
  pe1Industry: number | null; // Added: procentuell skillnad mellan P/E1 från Dashboard och P/E1 INDUSTRY (median)
  pe2Industry: number | null; // Added: procentuell skillnad mellan P/E2 från Dashboard och P/E2 INDUSTRY (median)
  currentRatio: number | null; // Added: Current Ratio from Dashboard sheet
  cashSdebt: number | null; // Added: Cash/SDebt from Dashboard sheet
  isCashSdebtDivZero: boolean; // Added: Flag to track division-by-zero for Cash/SDebt (should be green)
  sma100: number | null; // Added: SMA(100) from SMA table (Technical section)
  sma200: number | null; // Added: SMA(200) from SMA table (Technical section)
  smaCross: string | null; // Added: SMA Cross from SMA table (Technical section)
  price?: number | null; // Added: Price from ENTRY/EXIT table for SMA color comparison
}

export interface ThresholdIndustryData extends Record<string, unknown> {
  industry: string;
  irr: number;
  leverageF2Min: number;
  leverageF2Max: number;
  ro40Min: number;
  ro40Max: number;
  cashSdebtMin: number;
  cashSdebtMax: number;
  currentRatioMin: number;
  currentRatioMax: number;
}

export interface SMAData extends Record<string, unknown> {
  companyName: string;
  ticker: string;
  sma100: number | null; // null means invalid/missing value, 0 means actual zero
  sma200: number | null; // null means invalid/missing value, 0 means actual zero
  smaCross: string | null; // null means missing value
}

export interface EntryExitData extends Record<string, unknown> {
  companyName: string;
  ticker: string;
  currency: string;
  entry1: number;
  entry2: number;
  exit1: number;
  exit2: number;
  dateOfUpdate: string | null;
}


```

## `src/utils/__tests__/calculateScore.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { calculateScore } from '../calculateScore';
import { ScoreBoardData, ThresholdIndustryData, BenjaminGrahamData } from '../../types/stock';
import {
  createMockScoreBoardData,
  createMockThresholdData,
  createMockBenjaminGrahamData,
  createMockEntryExitValuesMap,
} from '../../test/helpers';

describe('calculateScore', () => {
  const mockThresholdData: ThresholdIndustryData[] = [
    createMockThresholdData({
      industry: 'Test Industry',
      irr: 25,
      leverageF2Min: 2.0,
      leverageF2Max: 3.0,
      ro40Min: 0.15,
      ro40Max: 0.25,
      cashSdebtMin: 0.7,
      cashSdebtMax: 1.2,
      currentRatioMin: 1.1,
      currentRatioMax: 2.0,
    }),
  ];

  const mockBenjaminGrahamData: BenjaminGrahamData[] = [
    createMockBenjaminGrahamData({
      ticker: 'TEST',
      companyName: 'Test Company',
      price: 100,
    }),
  ];

  describe('3Band method metrics', () => {
    it('should calculate score with all GREEN values (3Band method)', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: 10, // GREEN (>= 0)
        mungerQualityScore: 70, // GREEN (>= 60)
        irr: 30, // GREEN (>= 25 threshold)
        ro40F1: 30, // GREEN (30% / 100 = 0.30 >= 0.25 max)
        ro40F2: 30, // GREEN (30% / 100 = 0.30 >= 0.25 max)
        leverageF2: 1.5, // GREEN (<= 2.0 min, inverted)
        cashSdebt: 1.5, // GREEN (>= 1.2 max)
        currentRatio: 1.5, // GREEN (>= 1.1 && < 2.0)
        pe1Industry: -5, // GREEN (<= 0)
        pe2Industry: -5, // GREEN (<= 0)
        tbSPrice: 1.5, // GREEN (>= 1.00)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      // All 3Band metrics are GREEN (factor 1.0)
      // VALUE CREATION: 10 * 1.0 = 10
      // Munger Quality Score: 10 * 1.0 = 10
      // IRR: 8 * 1.0 = 8
      // Ro40 F1: 6 * 1.0 = 6
      // Ro40 F2: 5 * 1.0 = 5
      // LEVERAGE F2: 5 * 1.0 = 5
      // Cash/SDebt: 4 * 1.0 = 4
      // Current Ratio: 3 * 1.0 = 3
      // P/E1 INDUSTRY: 2 * 1.0 = 2
      // P/E2 INDUSTRY: 1 * 1.0 = 1
      // (TB/S)/Price: 1 * 1.0 = 1
      // Total: 55 points (Fundamental)
      // Technical: 0 (no green values)
      // Total: 55 / 100 * 100 = 55.0
      expect(score).toBeCloseTo(55.0, 1);
    });

    it('should calculate score with all ORANGE values (3Band method)', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: 10, // GREEN (>= 0)
        mungerQualityScore: 50, // ORANGE (40-60)
        irr: 20, // RED (< 25 threshold)
        ro40F1: 20, // ORANGE (20% / 100 = 0.20, between 0.15-0.25)
        ro40F2: 20, // ORANGE (20% / 100 = 0.20, between 0.15-0.25)
        leverageF2: 2.5, // ORANGE (2.0 < 2.5 <= 3.0, inverted)
        cashSdebt: 0.9, // ORANGE (0.7 < 0.9 < 1.2)
        currentRatio: 1.5, // GREEN (>= 1.1 && < 2.0)
        pe1Industry: -5, // GREEN (<= 0)
        pe2Industry: -5, // GREEN (<= 0)
        tbSPrice: 1.5, // GREEN (>= 1.00)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      // Mix of GREEN and ORANGE
      // VALUE CREATION: 10 * 1.0 = 10 (GREEN)
      // Munger Quality Score: 10 * 0.7 = 7 (ORANGE)
      // IRR: 8 * 0.0 = 0 (RED)
      // Ro40 F1: 6 * 0.7 = 4.2 (ORANGE)
      // Ro40 F2: 5 * 0.7 = 3.5 (ORANGE)
      // LEVERAGE F2: 5 * 0.7 = 3.5 (ORANGE)
      // Cash/SDebt: 4 * 0.7 = 2.8 (ORANGE)
      // Current Ratio: 3 * 1.0 = 3 (GREEN)
      // P/E1 INDUSTRY: 2 * 1.0 = 2 (GREEN)
      // P/E2 INDUSTRY: 1 * 1.0 = 1 (GREEN)
      // (TB/S)/Price: 1 * 1.0 = 1 (GREEN)
      // Total: ~38 points
      expect(score).toBeGreaterThan(30);
      expect(score).toBeLessThan(45);
    });

    it('should calculate score with all RED values (3Band method)', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: -10, // RED (< 0)
        mungerQualityScore: 30, // RED (< 40)
        irr: 20, // RED (< 25 threshold)
        ro40F1: 10, // RED (10% / 100 = 0.10 <= 0.15 min)
        ro40F2: 10, // RED (10% / 100 = 0.10 <= 0.15 min)
        leverageF2: 4.0, // RED (> 3.0 max, inverted)
        cashSdebt: 0.5, // RED (<= 0.7 min)
        currentRatio: 0.8, // RED (< 1.1 min)
        pe1Industry: 5, // RED (> 0)
        pe2Industry: 5, // RED (> 0)
        tbSPrice: 0.5, // RED (< 1.00)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      // All 3Band metrics are RED (factor 0.0)
      // Total: 0 points
      expect(score).toBe(0);
    });

    it('should handle BLANK values (3Band method)', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        // All values are null (BLANK)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      // All metrics are BLANK (factor 0.0 for 3Band and GreenOnly)
      // totalPts = 0, score = (0 / 100) * 100 = 0
      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(0.1); // Should be 0, but allow for rounding
    });
  });

  describe('GreenOnly method metrics', () => {
    it('should calculate score with GREEN TheoEntry (GreenOnly method)', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        sma100: 90,
        sma200: 80,
        smaCross: 'GOLDEN',
      });

      const entryExitValues = createMockEntryExitValuesMap([
        {
          ticker: 'TEST',
          companyName: 'Test Company',
          values: {
            entry1: 100,
            exit1: 160, // RR1 = (160-100)/100*100 = 60%
          },
        },
      ]);

      const benjaminGrahamData = [
        createMockBenjaminGrahamData({
          ticker: 'TEST',
          companyName: 'Test Company',
          price: 100, // Price <= Entry1 * 1.05 (100 <= 105)
        }),
      ];

      const score = calculateScore(scoreBoardData, mockThresholdData, benjaminGrahamData, entryExitValues);

      // TheoEntry: GREEN (40 points)
      // SMA(100): GREEN (price 100 > sma100 90) = 2.5 points
      // SMA(200): GREEN (price 100 > sma200 80) = 2.5 points
      // SMA Cross: GREEN (GOLDEN = GREEN in calculateScore.ts) = 5 points
      // Total Technical: 50 points. With mock defaults, total score = 50.0
      expect(score).toBeCloseTo(50.0, 1);
    });

    it('should calculate score with BLANK TheoEntry (GreenOnly method)', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        sma100: 90,
        sma200: 80,
        smaCross: null,
      });

      const entryExitValues = createMockEntryExitValuesMap(); // No entry/exit values
      const benjaminGrahamData = [
        createMockBenjaminGrahamData({
          ticker: 'TEST',
          companyName: 'Test Company',
          price: 100,
        }),
      ];
      const score = calculateScore(scoreBoardData, mockThresholdData, benjaminGrahamData, entryExitValues);

      // TheoEntry: BLANK (0 points)
      // SMA(100): GREEN (2.5 points) if price > sma100
      // SMA(200): GREEN (2.5 points) if price > sma200
      // SMA Cross: BLANK (0 points)
      // Total Technical: 5 points
      expect(score).toBeCloseTo(5.0, 1);
    });
  });

  describe('Edge cases', () => {
    it('should handle missing industry in threshold data', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Unknown Industry',
        irr: 30,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      // IRR should be BLANK (no threshold found)
      // Score should be low or 0
      expect(score).toBe(0);
    });

    it('should handle null values correctly', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        irr: null,
        mungerQualityScore: null,
        valueCreation: null,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      // All null values should result in BLANK (0 points for 3Band)
      expect(score).toBe(0);
    });

    it('should handle empty arrays', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
      });

      const score = calculateScore(scoreBoardData, [], [], new Map());

      // Should still calculate but with BLANK values
      // totalPts = 0, score = (0 / 100) * 100 = 0
      expect(score).toBe(0);
    });

    it('should handle isCashSdebtDivZero special case', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        cashSdebt: null,
        isCashSdebtDivZero: true, // Should be GREEN
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      // Cash/SDebt with isDivZero should be GREEN (4 points for 3Band method)
      // Score should be at least 4 points
      expect(score).toBeGreaterThanOrEqual(4);
    });

    it('should scale score to 0-100 range', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: 10,
        mungerQualityScore: 70,
        irr: 30,
        ro40F1: 30,
        ro40F2: 30,
        leverageF2: 1.5,
        cashSdebt: 1.5,
        currentRatio: 1.5,
        pe1Industry: -5,
        pe2Industry: -5,
        tbSPrice: 1.5,
      });

      const entryExitValues = createMockEntryExitValuesMap([
        {
          ticker: 'TEST',
          companyName: 'Test Company',
          values: {
            entry1: 100,
            exit1: 160,
          },
        },
      ]);

      const benjaminGrahamData = [
        createMockBenjaminGrahamData({
          ticker: 'TEST',
          companyName: 'Test Company',
          price: 100,
        }),
      ];

      const score = calculateScore(scoreBoardData, mockThresholdData, benjaminGrahamData, entryExitValues);

      // Score should be between 0 and 100
      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(100);
    });

    it('should round score to 1 decimal place', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        mungerQualityScore: 50, // ORANGE (0.7 factor)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      // Score should have at most 1 decimal place
      const decimalPlaces = (score.toString().split('.')[1] || '').length;
      expect(decimalPlaces).toBeLessThanOrEqual(1);
    });
  });

  describe('Complete scenario', () => {
    it('should calculate complete score with mixed colors', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: 5, // GREEN
        mungerQualityScore: 50, // ORANGE
        irr: 30, // GREEN
        ro40F1: 20, // ORANGE
        ro40F2: 20, // ORANGE
        leverageF2: 2.5, // ORANGE
        cashSdebt: 1.0, // ORANGE
        currentRatio: 1.5, // GREEN
        pe1Industry: -2, // GREEN
        pe2Industry: -2, // GREEN
        tbSPrice: 1.2, // GREEN
        sma100: 90,
        sma200: 80,
        smaCross: 'DEATH',
      });

      const entryExitValues = createMockEntryExitValuesMap([
        {
          ticker: 'TEST',
          companyName: 'Test Company',
          values: {
            entry1: 100,
            exit1: 160,
          },
        },
      ]);

      const benjaminGrahamData = [
        createMockBenjaminGrahamData({
          ticker: 'TEST',
          companyName: 'Test Company',
          price: 100,
        }),
      ];

      const score = calculateScore(scoreBoardData, mockThresholdData, benjaminGrahamData, entryExitValues);

      // Should have a reasonable score
      expect(score).toBeGreaterThan(0);
      expect(score).toBeLessThanOrEqual(100);
      expect(score).toBeCloseTo(score, 1); // Rounded to 1 decimal
    });
  });

  describe('Additional edge cases', () => {
    it('should handle extreme positive values', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: 1000000,
        mungerQualityScore: 100,
        irr: 1000,
        ro40F1: 100,
        ro40F2: 100,
        leverageF2: 0.1,
        cashSdebt: 1000,
        currentRatio: 100,
        pe1Industry: -1000,
        pe2Industry: -1000,
        tbSPrice: 1000,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(100);
    });

    it('should handle extreme negative values', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: -1000000,
        mungerQualityScore: -100,
        irr: -1000,
        ro40F1: -100,
        ro40F2: -100,
        leverageF2: 1000,
        cashSdebt: -1000,
        currentRatio: -100,
        pe1Industry: 1000,
        pe2Industry: 1000,
        tbSPrice: -1000,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      expect(score).toBe(0);
    });

    it('should handle very small decimal values', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: 0.0001,
        mungerQualityScore: 0.0001,
        irr: 0.0001,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(100);
    });

    it('should handle boundary threshold values exactly at min', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        irr: 25, // Exactly at threshold min
        ro40F1: 15, // Exactly at threshold min (15% = 0.15)
        ro40F2: 15,
        leverageF2: 2.0, // Exactly at threshold min (inverted)
        cashSdebt: 0.7, // Exactly at threshold min
        currentRatio: 1.1, // Exactly at threshold min
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(100);
    });

    it('should handle boundary threshold values exactly at max', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        irr: 25,
        ro40F1: 25, // Exactly at threshold max (25% = 0.25)
        ro40F2: 25,
        leverageF2: 3.0, // Exactly at threshold max (inverted)
        cashSdebt: 1.2, // Exactly at threshold max
        currentRatio: 2.0, // Exactly at threshold max
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(100);
    });

    it('should handle values just below threshold boundaries', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        irr: 24.999, // Just below threshold
        ro40F1: 14.999,
        leverageF2: 3.001, // Just above max (inverted, so RED)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(100);
    });

    it('should handle values just above threshold boundaries', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        irr: 25.001, // Just above threshold
        ro40F1: 25.001,
        leverageF2: 1.999, // Just below min (inverted, so GREEN)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(100);
    });

    it('should handle NaN values gracefully', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: NaN as unknown as number,
        mungerQualityScore: NaN as unknown as number,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(100);
      expect(isNaN(score)).toBe(false);
    });

    it('should handle Infinity values gracefully', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: Infinity,
        mungerQualityScore: Infinity,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateScore(scoreBoardData, mockThresholdData, mockBenjaminGrahamData, entryExitValues);

      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(100);
      expect(isFinite(score)).toBe(true);
    });

    it('should handle multiple industries with different thresholds', () => {
      const thresholdData1 = createMockThresholdData({
        industry: 'Industry A',
        irr: 20,
      });
      const thresholdData2 = createMockThresholdData({
        industry: 'Industry B',
        irr: 30,
      });

      const scoreBoardData1 = createMockScoreBoardData({
        industry: 'Industry A',
        irr: 25, // GREEN for Industry A (>= 20)
      });
      const scoreBoardData2 = createMockScoreBoardData({
        industry: 'Industry B',
        irr: 25, // RED for Industry B (< 30)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score1 = calculateScore(scoreBoardData1, [thresholdData1, thresholdData2], mockBenjaminGrahamData, entryExitValues);
      const score2 = calculateScore(scoreBoardData2, [thresholdData1, thresholdData2], mockBenjaminGrahamData, entryExitValues);

      expect(score1).toBeGreaterThan(score2);
    });

    it('should handle concurrent entry/exit values for same ticker', () => {
      const entryExitValues = createMockEntryExitValuesMap([
        {
          ticker: 'TEST',
          companyName: 'Test Company',
          values: {
            entry1: 100,
            exit1: 200,
            entry2: 150,
            exit2: 250,
          },
        },
      ]);

      const benjaminGrahamData = [
        createMockBenjaminGrahamData({
          ticker: 'TEST',
          companyName: 'Test Company',
          price: 105, // Within tolerance of entry1
        }),
      ];

      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        sma100: 90,
        sma200: 80,
        smaCross: 'GOLDEN',
      });

      const score = calculateScore(scoreBoardData, mockThresholdData, benjaminGrahamData, entryExitValues);

      expect(score).toBeGreaterThan(0);
      expect(score).toBeLessThanOrEqual(100);
    });
  });
});


```

## `src/utils/__tests__/calculateScoreDetailed.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { calculateDetailedScoreBreakdown, calculateDetailedScore } from '../calculateScoreDetailed';
import {
  createMockScoreBoardData,
  createMockThresholdData,
  createMockBenjaminGrahamData,
  createMockEntryExitValuesMap,
} from '../../test/helpers';

describe('calculateScoreDetailed', () => {
  const mockThresholdData = [
    createMockThresholdData({
      industry: 'Test Industry',
      irr: 25,
      leverageF2Min: 2.0,
      leverageF2Max: 3.0,
      ro40Min: 0.15,
      ro40Max: 0.25,
      cashSdebtMin: 0.7,
      cashSdebtMax: 1.2,
      currentRatioMin: 1.1,
      currentRatioMax: 2.0,
    }),
  ];

  const mockBenjaminGrahamData = [
    createMockBenjaminGrahamData({
      ticker: 'TEST',
      companyName: 'Test Company',
      price: 100,
    }),
  ];

  describe('calculateDetailedScoreBreakdown', () => {
    it('should return correct breakdown structure', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: 10,
        mungerQualityScore: 70,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      expect(breakdown).toHaveProperty('totalScore');
      expect(breakdown).toHaveProperty('items');
      expect(breakdown).toHaveProperty('fundamentalTotal');
      expect(breakdown).toHaveProperty('technicalTotal');
      expect(Array.isArray(breakdown.items)).toBe(true);
    });

    it('should include all metrics in items array', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      // Should have 15 metrics total (11 fundamental + 4 technical)
      expect(breakdown.items.length).toBe(15);

      // Check that all expected metrics are present
      const metricNames = breakdown.items.map(item => item.metric);
      expect(metricNames).toContain('VALUE CREATION');
      expect(metricNames).toContain('Munger Quality Score');
      expect(metricNames).toContain('IRR');
      expect(metricNames).toContain('Ro40 F1');
      expect(metricNames).toContain('Ro40 F2');
      expect(metricNames).toContain('LEVERAGE F2');
      expect(metricNames).toContain('Cash/SDebt');
      expect(metricNames).toContain('Current Ratio');
      expect(metricNames).toContain('P/E1 INDUSTRY');
      expect(metricNames).toContain('P/E2 INDUSTRY');
      expect(metricNames).toContain('(TB/S)/Price');
      expect(metricNames).toContain('THEOENTRY');
      expect(metricNames).toContain('SMA(100)');
      expect(metricNames).toContain('SMA(200)');
      expect(metricNames).toContain('SMA CROSS');
    });

    it('should correctly categorize metrics as Fundamental or Technical', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      const fundamentalMetrics = breakdown.items.filter(item => item.category === 'Fundamental');
      const technicalMetrics = breakdown.items.filter(item => item.category === 'Technical');

      // Should have 11 fundamental metrics
      expect(fundamentalMetrics.length).toBe(11);
      // Should have 4 technical metrics (THEOENTRY, SMA(100), SMA(200), SMA CROSS)
      expect(technicalMetrics.length).toBe(4);

      // Verify specific categorizations
      expect(breakdown.items.find(item => item.metric === 'VALUE CREATION')?.category).toBe('Fundamental');
      expect(breakdown.items.find(item => item.metric === 'IRR')?.category).toBe('Fundamental');
      expect(breakdown.items.find(item => item.metric === 'THEOENTRY')?.category).toBe('Technical');
      expect(breakdown.items.find(item => item.metric === 'SMA(100)')?.category).toBe('Technical');
    });

    it('should calculate points correctly for each item', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: 10, // GREEN
        mungerQualityScore: 70, // GREEN
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      const valueCreationItem = breakdown.items.find(item => item.metric === 'VALUE CREATION');
      expect(valueCreationItem).toBeDefined();
      expect(valueCreationItem?.weight).toBe(7);
      expect(valueCreationItem?.color).toBe('GREEN');
      expect(valueCreationItem?.factor).toBe(1.0);
      expect(valueCreationItem?.points).toBe(7.0); // 7 * 1.0

      const mungerItem = breakdown.items.find(item => item.metric === 'Munger Quality Score');
      expect(mungerItem).toBeDefined();
      expect(mungerItem?.weight).toBe(7);
      expect(mungerItem?.color).toBe('GREEN');
      expect(mungerItem?.factor).toBe(1.0);
      expect(mungerItem?.points).toBe(7.0); // 7 * 1.0
    });

    it('should calculate fundamentalTotal and technicalTotal correctly', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: 10, // GREEN (7 points)
        mungerQualityScore: 70, // GREEN (7 points)
        irr: 30, // GREEN (6 points)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      // Calculate expected fundamental total
      const fundamentalItems = breakdown.items.filter(item => item.category === 'Fundamental');
      const expectedFundamentalTotal = fundamentalItems.reduce((sum, item) => sum + item.points, 0);

      expect(breakdown.fundamentalTotal).toBeCloseTo(expectedFundamentalTotal, 1);

      // Calculate expected technical total
      const technicalItems = breakdown.items.filter(item => item.category === 'Technical');
      const expectedTechnicalTotal = technicalItems.reduce((sum, item) => sum + item.points, 0);

      expect(breakdown.technicalTotal).toBeCloseTo(expectedTechnicalTotal, 1);
    });

    it('should calculate totalScore as sum of fundamental and technical totals', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: 10,
        mungerQualityScore: 70,
        irr: 30,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      const expectedTotal = breakdown.fundamentalTotal + breakdown.technicalTotal;
      expect(breakdown.totalScore).toBeCloseTo(Math.min(100, Math.max(0, expectedTotal)), 1);
    });

    it('should handle BLUE color correctly (factor 0.70)', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        mungerQualityScore: 50, // BLUE (40-60)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      const mungerItem = breakdown.items.find(item => item.metric === 'Munger Quality Score');
      expect(mungerItem?.color).toBe('BLUE');
      expect(mungerItem?.factor).toBe(0.70);
      expect(mungerItem?.points).toBeCloseTo(7 * 0.70, 1); // 4.9
    });

    it('should handle RED color correctly (factor 0.00)', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: -10, // RED (< 0)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      const valueCreationItem = breakdown.items.find(item => item.metric === 'VALUE CREATION');
      expect(valueCreationItem?.color).toBe('RED');
      expect(valueCreationItem?.factor).toBe(0.00);
      expect(valueCreationItem?.points).toBe(0.0);
    });

    it('should handle BLANK color correctly (factor 0.00)', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: null, // BLANK
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      const valueCreationItem = breakdown.items.find(item => item.metric === 'VALUE CREATION');
      expect(valueCreationItem?.color).toBe('BLANK');
      expect(valueCreationItem?.factor).toBe(0.00);
      expect(valueCreationItem?.points).toBe(0.0);
    });

    it('should handle THEOENTRY correctly (GreenOnly method)', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        sma100: 90,
        sma200: 80,
      });

      const entryExitValues = createMockEntryExitValuesMap([
        {
          ticker: 'TEST',
          companyName: 'Test Company',
          values: {
            entry1: 100,
            exit1: 160, // RR1 = 60%
          },
        },
      ]);

      const benjaminGrahamData = [
        createMockBenjaminGrahamData({
          ticker: 'TEST',
          companyName: 'Test Company',
          price: 100, // Price <= Entry1 * 1.05
        }),
      ];

      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        benjaminGrahamData,
        entryExitValues
      );

      const theoEntryItem = breakdown.items.find(item => item.metric === 'THEOENTRY');
      expect(theoEntryItem).toBeDefined();
      expect(theoEntryItem?.color).toBe('GREEN');
      expect(theoEntryItem?.weight).toBe(40);
      expect(theoEntryItem?.factor).toBe(1.0);
      expect(theoEntryItem?.points).toBe(40.0);
    });

    it('should handle THEOENTRY as BLANK when conditions not met', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
      });

      const entryExitValues = createMockEntryExitValuesMap(); // No entry/exit values
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      const theoEntryItem = breakdown.items.find(item => item.metric === 'THEOENTRY');
      expect(theoEntryItem?.color).toBe('BLANK');
      expect(theoEntryItem?.points).toBe(0.0);
    });

    it('should round totals to 1 decimal place', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        mungerQualityScore: 50, // BLUE (0.70 factor)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      // Check that totals are rounded to 1 decimal
      const fundamentalDecimalPlaces = (breakdown.fundamentalTotal.toString().split('.')[1] || '').length;
      const technicalDecimalPlaces = (breakdown.technicalTotal.toString().split('.')[1] || '').length;
      const totalDecimalPlaces = (breakdown.totalScore.toString().split('.')[1] || '').length;

      expect(fundamentalDecimalPlaces).toBeLessThanOrEqual(1);
      expect(technicalDecimalPlaces).toBeLessThanOrEqual(1);
      expect(totalDecimalPlaces).toBeLessThanOrEqual(1);
    });
  });

  describe('calculateDetailedScore', () => {
    it('should return a score between 0 and 100', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: 10,
        mungerQualityScore: 70,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateDetailedScore(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(100);
    });

    it('should return same total as breakdown totalScore', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        valueCreation: 10,
        mungerQualityScore: 70,
        irr: 30,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );
      const score = calculateDetailedScore(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      expect(score).toBeCloseTo(breakdown.totalScore, 1);
    });

    it('should round score to 1 decimal place', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        mungerQualityScore: 50, // BLUE (0.70 factor)
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const score = calculateDetailedScore(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      const decimalPlaces = (score.toString().split('.')[1] || '').length;
      expect(decimalPlaces).toBeLessThanOrEqual(1);
    });
  });

  describe('Edge cases', () => {
    it('should handle missing industry in threshold data', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Unknown Industry',
        irr: 30,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      const irrItem = breakdown.items.find(item => item.metric === 'IRR');
      expect(irrItem?.color).toBe('BLANK');
      expect(irrItem?.points).toBe(0.0);
    });

    it('should handle empty arrays', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
      });

      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        [],
        [],
        new Map()
      );

      // Should still return breakdown structure
      expect(breakdown).toHaveProperty('totalScore');
      expect(breakdown).toHaveProperty('items');
      expect(breakdown.items.length).toBe(15);
    });

    it('should handle isCashSdebtDivZero special case', () => {
      const scoreBoardData = createMockScoreBoardData({
        industry: 'Test Industry',
        cashSdebt: null,
        isCashSdebtDivZero: true,
      });

      const entryExitValues = createMockEntryExitValuesMap();
      const breakdown = calculateDetailedScoreBreakdown(
        scoreBoardData,
        mockThresholdData,
        mockBenjaminGrahamData,
        entryExitValues
      );

      const cashSdebtItem = breakdown.items.find(item => item.metric === 'Cash/SDebt');
      expect(cashSdebtItem?.color).toBe('GREEN');
      expect(cashSdebtItem?.points).toBe(5.0); // 5 * 1.0
    });
  });
});


```

## `src/utils/__tests__/dataTransformers.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import {
  getValue,
  isValidValue,
  parseNumericValueNullable,
  parsePercentageValueNullable,
  getValueAllowZero,
  calculateMedian,
  findIRRForIndustry,
  findLeverageF2ForIndustry,
  findRO40ForIndustry,
  findCashSdebtForIndustry,
  findCurrentRatioForIndustry,
} from '../../services/sheets/dataTransformers';
import type { DataRow } from '../../services/sheets/types';

describe('dataTransformers Edge Cases', () => {
  describe('getValue edge cases', () => {
    it('should handle empty row', () => {
      const row: DataRow = {};
      expect(getValue(['Test'], row)).toBe('');
    });

    it('should handle row with null values', () => {
      const row: DataRow = { Test: null as unknown as string };
      expect(getValue(['Test'], row)).toBe('');
    });

    it('should handle row with undefined values', () => {
      const row: DataRow = { Test: undefined as unknown as string };
      expect(getValue(['Test'], row)).toBe('');
    });

    it('should handle case-insensitive matching', () => {
      const row: DataRow = { TEST: 'value', test: 'other' };
      expect(getValue(['Test'], row)).toBe('value');
    });

    it('should handle whitespace in values', () => {
      const row: DataRow = { Test: '  value  ' };
      expect(getValue(['Test'], row)).toBe('value');
    });

    it('should handle special characters in column names', () => {
      const row: DataRow = { 'Test-Column': 'value', 'Test_Column': 'other' };
      expect(getValue(['Test-Column'], row)).toBe('value');
    });
  });

  describe('isValidValue edge cases', () => {
    it('should reject empty string', () => {
      expect(isValidValue('')).toBe(false);
    });

    it('should reject whitespace-only string', () => {
      expect(isValidValue('   ')).toBe(false);
    });

    it('should reject #N/A variations', () => {
      expect(isValidValue('#N/A')).toBe(false);
      expect(isValidValue('N/A')).toBe(false);
      expect(isValidValue('n/a')).toBe(false);
      expect(isValidValue('#n/a')).toBe(false);
    });

    it('should reject Excel error values', () => {
      expect(isValidValue('#NUM!')).toBe(false);
      expect(isValidValue('#VALUE!')).toBe(false);
      expect(isValidValue('#DIV/0!')).toBe(false);
      expect(isValidValue('#REF!')).toBe(false);
    });

    it('should accept valid values', () => {
      expect(isValidValue('Valid Value')).toBe(true);
      expect(isValidValue('123')).toBe(true);
      expect(isValidValue('0')).toBe(true);
    });
  });

  describe('parseNumericValueNullable edge cases', () => {
    it('should handle empty string', () => {
      expect(parseNumericValueNullable('')).toBeNull();
    });

    it('should handle #N/A', () => {
      expect(parseNumericValueNullable('#N/A')).toBeNull();
    });

    it('should handle strings with commas', () => {
      expect(parseNumericValueNullable('1,234.56')).toBe(1234.56);
    });

    it('should handle strings with currency symbols', () => {
      expect(parseNumericValueNullable('$123.45')).toBe(123.45);
    });

    it('should handle strings with percentage signs', () => {
      expect(parseNumericValueNullable('50%')).toBe(50);
    });

    it('should handle strings with spaces', () => {
      expect(parseNumericValueNullable('  123  ')).toBe(123);
    });

    it('should handle zero value', () => {
      expect(parseNumericValueNullable('0')).toBe(0);
    });

    it('should handle negative values', () => {
      expect(parseNumericValueNullable('-123.45')).toBe(-123.45);
    });

    it('should handle very large numbers', () => {
      expect(parseNumericValueNullable('999999999')).toBe(999999999);
    });

    it('should handle very small numbers', () => {
      expect(parseNumericValueNullable('0.000001')).toBe(0.000001);
    });

    it('should handle scientific notation', () => {
      expect(parseNumericValueNullable('1.23e5')).toBe(123000);
    });

    it('should return null for invalid formats', () => {
      expect(parseNumericValueNullable('abc')).toBeNull();
      expect(parseNumericValueNullable('12.34.56')).toBeNull();
    });
  });

  describe('parsePercentageValueNullable edge cases', () => {
    it('should handle percentage strings', () => {
      expect(parsePercentageValueNullable('50%')).toBe(50);
      expect(parsePercentageValueNullable('15.5%')).toBe(15.5);
    });

    it('should handle percentage with spaces', () => {
      expect(parsePercentageValueNullable('  50%  ')).toBe(50);
    });

    it('should handle percentage with commas', () => {
      expect(parsePercentageValueNullable('1,234.56%')).toBe(1234.56);
    });

    it('should return null for invalid percentage', () => {
      expect(parsePercentageValueNullable('abc%')).toBeNull();
    });
  });

  describe('getValueAllowZero edge cases', () => {
    it('should return "0" for zero value', () => {
      const row: DataRow = { Test: 0 };
      expect(getValueAllowZero(['Test'], row)).toBe('0');
    });

    it('should return "0" for string "0"', () => {
      const row: DataRow = { Test: '0' };
      expect(getValueAllowZero(['Test'], row)).toBe('0');
    });

    it('should skip empty strings', () => {
      const row: DataRow = { Test: '' };
      expect(getValueAllowZero(['Test'], row)).toBe('');
    });
  });

  describe('calculateMedian edge cases', () => {
    it('should return null for empty array', () => {
      expect(calculateMedian([])).toBeNull();
    });

    it('should handle single value', () => {
      expect(calculateMedian([5])).toBe(5);
    });

    it('should handle two values', () => {
      expect(calculateMedian([5, 10])).toBe(7.5);
    });

    it('should handle odd number of values', () => {
      expect(calculateMedian([1, 3, 5, 7, 9])).toBe(5);
    });

    it('should handle even number of values', () => {
      expect(calculateMedian([1, 3, 5, 7])).toBe(4);
    });

    it('should handle unsorted array', () => {
      expect(calculateMedian([9, 1, 5, 3, 7])).toBe(5);
    });

    it('should handle negative values', () => {
      expect(calculateMedian([-5, -3, -1, 1, 3, 5])).toBe(0);
    });

    it('should handle duplicate values', () => {
      expect(calculateMedian([5, 5, 5, 5, 5])).toBe(5);
    });

    it('should handle decimal values', () => {
      expect(calculateMedian([1.1, 2.2, 3.3, 4.4, 5.5])).toBe(3.3);
    });
  });

  describe('Industry threshold finders edge cases', () => {
    it('should handle empty industry name', () => {
      expect(findIRRForIndustry('')).toBe(0);
      expect(findIRRForIndustry('   ')).toBe(0);
    });

    it('should handle case-insensitive industry matching', () => {
      // Assuming 'Technology' exists in thresholds
      const result1 = findIRRForIndustry('Technology');
      const result2 = findIRRForIndustry('technology');
      const result3 = findIRRForIndustry('TECHNOLOGY');
      expect(result1).toBe(result2);
      expect(result2).toBe(result3);
    });

    it('should handle industry with whitespace', () => {
      const result1 = findIRRForIndustry('Technology');
      const result2 = findIRRForIndustry('  Technology  ');
      expect(result1).toBe(result2);
    });

    it('should return default values for unknown industry', () => {
      expect(findIRRForIndustry('Unknown Industry XYZ')).toBe(0);
      expect(findLeverageF2ForIndustry('Unknown Industry XYZ')).toEqual({ min: 0, max: 0 });
      expect(findRO40ForIndustry('Unknown Industry XYZ')).toEqual({ min: 0, max: 0 });
      expect(findCashSdebtForIndustry('Unknown Industry XYZ')).toEqual({ min: 0, max: 0 });
      expect(findCurrentRatioForIndustry('Unknown Industry XYZ')).toEqual({ min: 0, max: 0 });
    });

    it('should handle special characters in industry names', () => {
      // Should not throw, even if industry doesn't exist
      expect(() => findIRRForIndustry('Industry & Co.')).not.toThrow();
      expect(() => findIRRForIndustry('Industry-Corp')).not.toThrow();
      expect(() => findIRRForIndustry('Industry_Corp')).not.toThrow();
    });
  });
});

```

## `src/utils/__tests__/envValidator.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { validateEnvironmentVariables, EnvValidationResult } from '../envValidator';

// Mock logger
vi.mock('../logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  },
}));

describe('envValidator', () => {
  const originalEnv = import.meta.env;

  beforeEach(() => {
    vi.clearAllMocks();
    // Reset to default valid values
    vi.stubEnv('VITE_FIREBASE_API_KEY', 'AIzaSyAbCdEfGhIjKlMnOpQrStUvWxYz1234567890');
    vi.stubEnv('VITE_FIREBASE_AUTH_DOMAIN', 'test-project.firebaseapp.com');
    vi.stubEnv('VITE_FIREBASE_PROJECT_ID', 'test-project');
    vi.stubEnv('VITE_FIREBASE_STORAGE_BUCKET', 'test-project.appspot.com');
    vi.stubEnv('VITE_FIREBASE_MESSAGING_SENDER_ID', '123456789012');
    vi.stubEnv('VITE_FIREBASE_APP_ID', '1:123456789012:web:abcdef1234567890');
  });

  afterEach(() => {
    vi.unstubAllEnvs();
  });

  describe('validateEnvironmentVariables', () => {
    it('should return valid when all required variables are correct', () => {
      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should detect missing Firebase API Key', () => {
      vi.unstubEnv('VITE_FIREBASE_API_KEY');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('VITE_FIREBASE_API_KEY is missing or undefined');
    });

    it('should detect invalid Firebase API Key format', () => {
      vi.stubEnv('VITE_FIREBASE_API_KEY', 'invalid-key');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('format is invalid'))).toBe(true);
    });

    it('should detect too short Firebase API Key', () => {
      vi.stubEnv('VITE_FIREBASE_API_KEY', 'AIza123');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('too short'))).toBe(true);
    });

    it('should detect missing Firebase Auth Domain', () => {
      vi.unstubEnv('VITE_FIREBASE_AUTH_DOMAIN');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('VITE_FIREBASE_AUTH_DOMAIN is missing or undefined');
    });

    it('should detect invalid Firebase Auth Domain format', () => {
      vi.stubEnv('VITE_FIREBASE_AUTH_DOMAIN', 'invalid-domain.com');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('firebaseapp.com'))).toBe(true);
    });

    it('should detect missing Firebase Project ID', () => {
      vi.unstubEnv('VITE_FIREBASE_PROJECT_ID');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('VITE_FIREBASE_PROJECT_ID is missing or undefined');
    });

    it('should detect empty Firebase Project ID', () => {
      vi.stubEnv('VITE_FIREBASE_PROJECT_ID', '   ');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('cannot be empty'))).toBe(true);
    });

    it('should detect missing Firebase Storage Bucket', () => {
      vi.unstubEnv('VITE_FIREBASE_STORAGE_BUCKET');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('VITE_FIREBASE_STORAGE_BUCKET is missing or undefined');
    });

    it('should detect invalid Firebase Storage Bucket format', () => {
      vi.stubEnv('VITE_FIREBASE_STORAGE_BUCKET', 'invalid-bucket.com');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('appspot.com'))).toBe(true);
    });

    it('should detect missing Firebase Messaging Sender ID', () => {
      vi.unstubEnv('VITE_FIREBASE_MESSAGING_SENDER_ID');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('VITE_FIREBASE_MESSAGING_SENDER_ID is missing or undefined');
    });

    it('should detect invalid Firebase Messaging Sender ID format', () => {
      vi.stubEnv('VITE_FIREBASE_MESSAGING_SENDER_ID', 'not-a-number');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('numeric string'))).toBe(true);
    });

    it('should detect missing Firebase App ID', () => {
      vi.unstubEnv('VITE_FIREBASE_APP_ID');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('VITE_FIREBASE_APP_ID is missing or undefined');
    });

    it('should detect invalid Firebase App ID format', () => {
      vi.stubEnv('VITE_FIREBASE_APP_ID', 'invalid-app-id');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('format is invalid'))).toBe(true);
    });

    it('should validate Apps Script URL format', () => {
      vi.stubEnv('VITE_APPS_SCRIPT_URL', 'https://script.google.com/macros/s/SCRIPT_ID/exec');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(true);
      expect(result.warnings).toHaveLength(0);
    });

    it('should warn about invalid Apps Script URL format', () => {
      vi.stubEnv('VITE_APPS_SCRIPT_URL', 'https://script.google.com/library/SCRIPT_ID');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(true); // Still valid, just warning
      expect(result.warnings.some(w => w.includes('library deployment'))).toBe(true);
    });

    it('should validate optional numeric variables', () => {
      vi.stubEnv('VITE_FETCH_TIMEOUT_SECONDS', '30');
      vi.stubEnv('VITE_CACHE_DEFAULT_TTL_MINUTES', '20');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(true);
      expect(result.warnings).toHaveLength(0);
    });

    it('should warn about invalid optional numeric variables', () => {
      vi.stubEnv('VITE_FETCH_TIMEOUT_SECONDS', 'invalid');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(true);
      expect(result.warnings.some(w => w.includes('VITE_FETCH_TIMEOUT_SECONDS'))).toBe(true);
    });

    it('should warn about out of range optional numeric variables', () => {
      vi.stubEnv('VITE_FETCH_TIMEOUT_SECONDS', '1000'); // Too high

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(true);
      expect(result.warnings.some(w => w.includes('exceeds maximum'))).toBe(true);
    });

    it('should validate optional boolean variables', () => {
      vi.stubEnv('VITE_DELTA_SYNC_ENABLED', 'true');
      vi.stubEnv('VITE_CACHE_WARMING_ENABLED', 'false');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(true);
      expect(result.warnings).toHaveLength(0);
    });

    it('should warn about invalid optional boolean variables', () => {
      vi.stubEnv('VITE_DELTA_SYNC_ENABLED', 'yes');

      const result = validateEnvironmentVariables();

      expect(result.isValid).toBe(true);
      expect(result.warnings.some(w => w.includes('VITE_DELTA_SYNC_ENABLED'))).toBe(true);
    });

    it('should throw error in production when required vars are missing', () => {
      vi.unstubEnv('VITE_FIREBASE_API_KEY');
      vi.stubEnv('PROD', 'true');

      // In production, should throw
      expect(() => validateEnvironmentVariables()).toThrow();
    });

    it('should not throw in development when required vars are missing', () => {
      vi.unstubEnv('VITE_FIREBASE_API_KEY');
      vi.stubEnv('PROD', 'false');

      // In development, should not throw
      expect(() => validateEnvironmentVariables()).not.toThrow();
    });
  });
});

```

## `src/utils/__tests__/errorHandler.test.ts`

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import {
  formatError,
  logError,
  createErrorHandler,
  isErrorType,
  isNetworkError,
  isQuotaError,
  FormattedError,
} from '../errorHandler';

// Mock logger
const mockLogger = {
  debug: vi.fn(),
  info: vi.fn(),
  warn: vi.fn(),
  error: vi.fn(),
};

vi.mock('../logger', () => ({
  logger: mockLogger,
}));

describe('errorHandler', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('formatError', () => {
    it('should format Error object', () => {
      const error = new Error('Test error');
      const result = formatError(error);

      expect(result.message).toBe('Test error');
      expect(result.userMessage).toBe('Test error');
      expect(result.originalError).toBe(error);
    });

    it('should format string error', () => {
      const error = 'String error';
      const result = formatError(error);

      expect(result.message).toBe('String error');
      expect(result.userMessage).toBe('String error');
    });

    it('should format error with context', () => {
      const error = new Error('Test error');
      const context = { component: 'test', operation: 'testOperation' };
      const result = formatError(error, context);

      expect(result.context).toEqual(context);
    });

    it('should format CORS error with user-friendly message', () => {
      const error = new Error('CORS error');
      const result = formatError(error);

      expect(result.userMessage).toContain('Connection error');
    });

    it('should format timeout error with user-friendly message', () => {
      const error = new Error('Request timeout');
      const result = formatError(error);

      expect(result.userMessage).toContain('timeout');
    });

    it('should format 404 error with user-friendly message', () => {
      const error = new Error('404 not found');
      const result = formatError(error);

      expect(result.userMessage).toContain('not found');
    });

    it('should format quota error with user-friendly message', () => {
      const error = new Error('QuotaExceededError');
      const result = formatError(error);

      expect(result.userMessage).toContain('Storage limit');
    });

    it('should format network error with user-friendly message', () => {
      const error = new Error('NetworkError');
      const result = formatError(error);

      expect(result.userMessage).toContain('Network error');
    });

    it('should format Firebase error with user-friendly message', () => {
      const error = new Error('Firebase error');
      const result = formatError(error);

      expect(result.userMessage).toContain('Configuration error');
    });

    it('should handle unknown error type', () => {
      const error = { someProperty: 'value' };
      const result = formatError(error);

      expect(result.message).toBeTruthy();
    });

    it('should include operation in user message when provided', () => {
      const error = new Error('Test error');
      const context = { operation: 'fetch data' };
      const result = formatError(error, context);

      expect(result.userMessage).toContain('fetch data');
    });
  });

  describe('logError', () => {
    it('should log error with logger', () => {
      const error = new Error('Test error');
      const context = { component: 'test', operation: 'testOperation' };

      logError(error, context);

      expect(mockLogger.error).toHaveBeenCalledWith(
        'Test error',
        error,
        expect.objectContaining({
          component: 'test',
          operation: 'testOperation',
        })
      );
    });

    it('should handle string error', () => {
      logError('String error');

      expect(mockLogger.error).toHaveBeenCalled();
    });

    it('should handle unknown error type', () => {
      logError({ someProperty: 'value' });

      expect(mockLogger.error).toHaveBeenCalled();
    });
  });

  describe('createErrorHandler', () => {
    it('should create error handler function', () => {
      const context = { component: 'test', operation: 'testOperation' };
      const handler = createErrorHandler(context);

      expect(typeof handler).toBe('function');
    });

    it('should handle errors with created handler', () => {
      const context = { component: 'test', operation: 'testOperation' };
      const handler = createErrorHandler(context);
      const error = new Error('Test error');

      const result = handler(error);

      expect(result.message).toBe('Test error');
      expect(mockLogger.error).toHaveBeenCalled();
    });
  });

  describe('isErrorType', () => {
    it('should detect error by name', () => {
      const error = new Error('Test error');
      error.name = 'CustomError';

      expect(isErrorType(error, 'CustomError')).toBe(true);
    });

    it('should detect error by message', () => {
      const error = new Error('NetworkError occurred');

      expect(isErrorType(error, 'NetworkError')).toBe(true);
    });

    it('should detect error in string', () => {
      expect(isErrorType('NetworkError occurred', 'NetworkError')).toBe(true);
    });

    it('should return false for non-matching error', () => {
      const error = new Error('Test error');

      expect(isErrorType(error, 'NetworkError')).toBe(false);
    });
  });

  describe('isNetworkError', () => {
    it('should detect NetworkError', () => {
      const error = new Error('NetworkError');
      expect(isNetworkError(error)).toBe(true);
    });

    it('should detect Failed to fetch', () => {
      const error = new Error('Failed to fetch');
      expect(isNetworkError(error)).toBe(true);
    });

    it('should detect CORS error', () => {
      const error = new Error('CORS error');
      expect(isNetworkError(error)).toBe(true);
    });

    it('should detect timeout error', () => {
      const error = new Error('timeout');
      expect(isNetworkError(error)).toBe(true);
    });

    it('should return false for non-network error', () => {
      const error = new Error('Other error');
      expect(isNetworkError(error)).toBe(false);
    });
  });

  describe('isQuotaError', () => {
    it('should detect QuotaExceededError', () => {
      const error = new Error('QuotaExceededError');
      expect(isQuotaError(error)).toBe(true);
    });

    it('should detect quota error in message', () => {
      const error = new Error('quota exceeded');
      expect(isQuotaError(error)).toBe(true);
    });

    it('should return false for non-quota error', () => {
      const error = new Error('Other error');
      expect(isQuotaError(error)).toBe(false);
    });
  });
});

```

## `src/utils/__tests__/inputValidator.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import {
  validateTextInput,
  validateNumberInput,
  validateNumberRange,
  validateSelectInput,
  sanitizeSearchQuery,
  validateEntryExitValue,
  validateFilterName,
  ValidationResult,
} from '../inputValidator';

describe('inputValidator', () => {
  describe('validateTextInput', () => {
    it('should validate text input with default options', () => {
      const result = validateTextInput('test');
      expect(result.isValid).toBe(true);
    });

    it('should validate empty string when allowEmpty is true', () => {
      const result = validateTextInput('');
      expect(result.isValid).toBe(true);
    });

    it('should reject empty string when required is true', () => {
      const result = validateTextInput('', { required: true });
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('required');
    });

    it('should validate max length', () => {
      const longText = 'a'.repeat(201);
      const result = validateTextInput(longText, { maxLength: 200 });
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('200');
    });

    it('should validate min length', () => {
      const result = validateTextInput('ab', { minLength: 5 });
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('5');
    });
  });

  describe('validateNumberInput', () => {
    it('should validate valid number', () => {
      const result = validateNumberInput(100);
      expect(result.isValid).toBe(true);
    });

    it('should validate number string', () => {
      const result = validateNumberInput('100');
      expect(result.isValid).toBe(true);
    });

    it('should reject NaN', () => {
      const result = validateNumberInput(NaN);
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('valid number');
    });

    it('should validate min value', () => {
      const result = validateNumberInput(50, { min: 100 });
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('100');
    });

    it('should validate max value', () => {
      const result = validateNumberInput(150, { max: 100 });
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('100');
    });

    it('should validate decimal places', () => {
      const result = validateNumberInput(100.123, { maxDecimals: 2 });
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('decimal');
    });

    it('should reject decimals when allowDecimal is false', () => {
      const result = validateNumberInput(100.5, { allowDecimal: false });
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('whole number');
    });

    it('should validate required number', () => {
      const result = validateNumberInput(null, { required: true });
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('required');
    });
  });

  describe('validateNumberRange', () => {
    it('should validate valid range', () => {
      const result = validateNumberRange({ min: 10, max: 20 });
      expect(result.isValid).toBe(true);
    });

    it('should validate range with only min', () => {
      const result = validateNumberRange({ min: 10 });
      expect(result.isValid).toBe(true);
    });

    it('should validate range with only max', () => {
      const result = validateNumberRange({ max: 20 });
      expect(result.isValid).toBe(true);
    });

    it('should reject range where min > max', () => {
      const result = validateNumberRange({ min: 20, max: 10 });
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('less than or equal');
    });

    it('should validate required range', () => {
      const result = validateNumberRange(null, { required: true });
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('required');
    });
  });

  describe('validateSelectInput', () => {
    const allowedOptions = ['option1', 'option2', 'option3'];

    it('should validate valid selection', () => {
      const result = validateSelectInput('option1', allowedOptions);
      expect(result.isValid).toBe(true);
    });

    it('should reject invalid selection', () => {
      const result = validateSelectInput('invalid', allowedOptions);
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('Invalid');
    });

    it('should validate required selection', () => {
      const result = validateSelectInput(null, allowedOptions, { required: true });
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('select');
    });
  });

  describe('sanitizeSearchQuery', () => {
    it('should sanitize search query', () => {
      const result = sanitizeSearchQuery('test query');
      expect(result).toBe('test query');
    });

    it('should remove HTML tags', () => {
      const result = sanitizeSearchQuery('test<script>alert("xss")</script>');
      expect(result).not.toContain('<script>');
    });

    it('should escape special characters', () => {
      const result = sanitizeSearchQuery('test & query');
      expect(result).toContain('&amp;');
    });

    it('should limit length', () => {
      const longQuery = 'a'.repeat(300);
      const result = sanitizeSearchQuery(longQuery, 200);
      expect(result.length).toBeLessThanOrEqual(200);
    });

    it('should trim whitespace', () => {
      const result = sanitizeSearchQuery('  test query  ');
      expect(result).toBe('test query');
    });

    it('should escape regex special characters', () => {
      const result = sanitizeSearchQuery('test.*+?^${}()[]\\');
      expect(result).not.toContain('.*+?');
    });

    it('should handle empty string', () => {
      const result = sanitizeSearchQuery('');
      expect(result).toBe('');
    });

    it('should handle null/undefined', () => {
      expect(sanitizeSearchQuery(null as any)).toBe('');
      expect(sanitizeSearchQuery(undefined as any)).toBe('');
    });
  });

  describe('validateEntryExitValue', () => {
    it('should validate entry1 value', () => {
      const result = validateEntryExitValue('entry1', 100);
      expect(result.isValid).toBe(true);
    });

    it('should reject negative entry1 value', () => {
      const result = validateEntryExitValue('entry1', -10);
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('0');
    });

    it('should reject entry1 value exceeding max', () => {
      const result = validateEntryExitValue('entry1', 2000000);
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('1000000');
    });

    it('should validate entry1 with 2 decimals', () => {
      const result = validateEntryExitValue('entry1', 100.12);
      expect(result.isValid).toBe(true);
    });

    it('should reject entry1 with more than 2 decimals', () => {
      const result = validateEntryExitValue('entry1', 100.123);
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('2 decimal');
    });

    it('should validate currency', () => {
      const result = validateEntryExitValue('currency', 'USD');
      expect(result.isValid).toBe(true);
    });

    it('should reject invalid currency', () => {
      const result = validateEntryExitValue('currency', 'INVALID');
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('Invalid');
    });

    it('should validate dateOfUpdate format', () => {
      const result = validateEntryExitValue('dateOfUpdate', '2024-01-01');
      expect(result.isValid).toBe(true);
    });

    it('should reject invalid dateOfUpdate format', () => {
      const result = validateEntryExitValue('dateOfUpdate', '2024/01/01');
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('YYYY-MM-DD');
    });

    it('should reject invalid date', () => {
      const result = validateEntryExitValue('dateOfUpdate', '2024-13-45');
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('Invalid date');
    });

    it('should allow null dateOfUpdate', () => {
      const result = validateEntryExitValue('dateOfUpdate', null);
      expect(result.isValid).toBe(true);
    });
  });

  describe('validateFilterName', () => {
    it('should validate valid filter name', () => {
      const result = validateFilterName('High Score Stocks');
      expect(result.isValid).toBe(true);
    });

    it('should reject empty filter name', () => {
      const result = validateFilterName('');
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('empty');
    });

    it('should reject filter name exceeding max length', () => {
      const longName = 'a'.repeat(51);
      const result = validateFilterName(longName);
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('50');
    });

    it('should reject filter name with dangerous characters', () => {
      const result = validateFilterName('Filter<script>');
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('invalid characters');
    });
  });
});

```

## `src/utils/__tests__/logger.test.ts`

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { logger, Logger, LogLevel } from '../logger';

// Mock console methods
const mockConsoleDebug = vi.spyOn(console, 'debug').mockImplementation(() => {});
const mockConsoleInfo = vi.spyOn(console, 'info').mockImplementation(() => {});
const mockConsoleWarn = vi.spyOn(console, 'warn').mockImplementation(() => {});
const mockConsoleError = vi.spyOn(console, 'error').mockImplementation(() => {});

describe('logger', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.stubEnv('PROD', 'false');
    vi.stubEnv('DEV', 'true');
  });

  afterEach(() => {
    vi.unstubAllEnvs();
    vi.restoreAllMocks();
  });

  describe('debug', () => {
    it('should log debug message in development', () => {
      logger.debug('Debug message');

      expect(mockConsoleDebug).toHaveBeenCalledWith(expect.stringContaining('[DEBUG]'));
    });

    it('should not log debug message in production', () => {
      vi.stubEnv('PROD', 'true');
      vi.stubEnv('DEV', 'false');

      logger.debug('Debug message');

      expect(mockConsoleDebug).not.toHaveBeenCalled();
    });

    it('should include context in message', () => {
      logger.debug('Debug message', { component: 'test', operation: 'testOp' });

      expect(mockConsoleDebug).toHaveBeenCalledWith(
        expect.stringContaining('component: test')
      );
    });
  });

  describe('info', () => {
    it('should log info message', () => {
      logger.info('Info message');

      expect(mockConsoleInfo).toHaveBeenCalledWith(expect.stringContaining('[INFO]'));
    });

    it('should include context in message', () => {
      logger.info('Info message', { component: 'test' });

      expect(mockConsoleInfo).toHaveBeenCalledWith(
        expect.stringContaining('component: test')
      );
    });
  });

  describe('warn', () => {
    it('should log warning message', () => {
      logger.warn('Warning message');

      expect(mockConsoleWarn).toHaveBeenCalledWith(expect.stringContaining('[WARN]'));
    });

    it('should include context in message', () => {
      logger.warn('Warning message', { component: 'test' });

      expect(mockConsoleWarn).toHaveBeenCalledWith(
        expect.stringContaining('component: test')
      );
    });
  });

  describe('error', () => {
    it('should log error message', () => {
      const error = new Error('Test error');
      logger.error('Error message', error);

      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.stringContaining('[ERROR]'),
        error
      );
    });

    it('should handle string error', () => {
      logger.error('Error message', 'String error');

      expect(mockConsoleError).toHaveBeenCalled();
    });

    it('should handle unknown error type', () => {
      logger.error('Error message', { someProperty: 'value' });

      expect(mockConsoleError).toHaveBeenCalled();
    });

    it('should include context in message', () => {
      const error = new Error('Test error');
      logger.error('Error message', error, { component: 'test' });

      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.stringContaining('component: test'),
        expect.anything()
      );
    });
  });

  describe('log', () => {
    it('should log with explicit level', () => {
      logger.log('info', 'Info message');

      expect(mockConsoleInfo).toHaveBeenCalled();
    });

    it('should log error with explicit level', () => {
      const error = new Error('Test error');
      logger.log('error', 'Error message', error);

      expect(mockConsoleError).toHaveBeenCalled();
    });
  });

  describe('configure', () => {
    it('should configure logger settings', () => {
      const testLogger = new Logger();
      testLogger.configure({ enableInProduction: true });

      // Configuration should be applied
      expect(testLogger).toBeDefined();
    });
  });

  describe('production vs development', () => {
    it('should show all logs in development', () => {
      vi.stubEnv('DEV', 'true');
      vi.stubEnv('PROD', 'false');

      logger.debug('Debug');
      logger.info('Info');
      logger.warn('Warn');
      logger.error('Error', new Error('Test'));

      expect(mockConsoleDebug).toHaveBeenCalled();
      expect(mockConsoleInfo).toHaveBeenCalled();
      expect(mockConsoleWarn).toHaveBeenCalled();
      expect(mockConsoleError).toHaveBeenCalled();
    });

    it('should only show warnings and errors in production', () => {
      vi.stubEnv('DEV', 'false');
      vi.stubEnv('PROD', 'true');

      logger.debug('Debug');
      logger.info('Info');
      logger.warn('Warn');
      logger.error('Error', new Error('Test'));

      expect(mockConsoleDebug).not.toHaveBeenCalled();
      expect(mockConsoleInfo).not.toHaveBeenCalled();
      expect(mockConsoleWarn).toHaveBeenCalled();
      expect(mockConsoleError).toHaveBeenCalled();
    });
  });
});

```

## `src/utils/__tests__/rateLimiter.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  checkRateLimit,
  resetRateLimit,
  resetAllRateLimits,
  getRateLimitStatus,
  RateLimiter,
} from '../rateLimiter';

// Mock logger
vi.mock('../logger', () => ({
  logger: {
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  },
}));

describe('rateLimiter', () => {
  beforeEach(() => {
    resetAllRateLimits();
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  describe('checkRateLimit', () => {
    it('should allow request within limit', () => {
      const result = checkRateLimit('fetch', 'test-key');
      expect(result.allowed).toBe(true);
      expect(result.remaining).toBeGreaterThan(0);
    });

    it('should track requests per operation type', () => {
      checkRateLimit('fetch', 'key1');
      checkRateLimit('search', 'key1');

      const fetchStatus = getRateLimitStatus('fetch', 'key1');
      const searchStatus = getRateLimitStatus('search', 'key1');

      expect(fetchStatus.remaining).toBe(9); // 10 - 1
      expect(searchStatus.remaining).toBe(29); // 30 - 1
    });

    it('should track requests per key', () => {
      checkRateLimit('fetch', 'key1');
      checkRateLimit('fetch', 'key2');

      const status1 = getRateLimitStatus('fetch', 'key1');
      const status2 = getRateLimitStatus('fetch', 'key2');

      expect(status1.remaining).toBe(9);
      expect(status2.remaining).toBe(9);
    });

    it('should block request when limit exceeded', () => {
      // Make 10 requests (the limit)
      for (let i = 0; i < 10; i++) {
        checkRateLimit('fetch', 'test-key');
      }

      // 11th request should be blocked
      const result = checkRateLimit('fetch', 'test-key');
      expect(result.allowed).toBe(false);
      expect(result.remaining).toBe(0);
      expect(result.error).toBeDefined();
    });

    it('should reset after time window', async () => {
      // Make 10 requests
      for (let i = 0; i < 10; i++) {
        checkRateLimit('fetch', 'test-key');
      }

      // Should be blocked
      let result = checkRateLimit('fetch', 'test-key');
      expect(result.allowed).toBe(false);

      // Advance time past window (60 seconds)
      await vi.advanceTimersByTimeAsync(61000);

      // Should be allowed again
      result = checkRateLimit('fetch', 'test-key');
      expect(result.allowed).toBe(true);
    });

    it('should have different limits for different operations', () => {
      // Fetch limit: 20 per minute
      for (let i = 0; i < 20; i++) {
        checkRateLimit('fetch', 'test-key');
      }
      expect(checkRateLimit('fetch', 'test-key').allowed).toBe(false);

      // Search limit: 30 per minute
      for (let i = 0; i < 30; i++) {
        checkRateLimit('search', 'test-key');
      }
      expect(checkRateLimit('search', 'test-key').allowed).toBe(false);
    });
  });

  describe('resetRateLimit', () => {
    it('should reset rate limit for specific key', () => {
      // Make requests
      checkRateLimit('fetch', 'test-key');
      checkRateLimit('fetch', 'test-key');

      resetRateLimit('fetch', 'test-key');

      const status = getRateLimitStatus('fetch', 'test-key');
      expect(status.remaining).toBe(10); // Reset to full limit
    });

    it('should not affect other keys', () => {
      checkRateLimit('fetch', 'key1');
      checkRateLimit('fetch', 'key2');

      resetRateLimit('fetch', 'key1');

      const status1 = getRateLimitStatus('fetch', 'key1');
      const status2 = getRateLimitStatus('fetch', 'key2');

      expect(status1.remaining).toBe(10);
      expect(status2.remaining).toBe(9);
    });
  });

  describe('resetAllRateLimits', () => {
    it('should reset all rate limits', () => {
      checkRateLimit('fetch', 'key1');
      checkRateLimit('search', 'key2');

      resetAllRateLimits();

      const status1 = getRateLimitStatus('fetch', 'key1');
      const status2 = getRateLimitStatus('search', 'key2');

      expect(status1.remaining).toBe(10);
      expect(status2.remaining).toBe(30);
    });
  });

  describe('getRateLimitStatus', () => {
    it('should return current status', () => {
      checkRateLimit('fetch', 'test-key');

      const status = getRateLimitStatus('fetch', 'test-key');

      expect(status.allowed).toBe(true);
      expect(status.remaining).toBe(9);
      expect(status.resetAt).toBeGreaterThan(Date.now());
    });

    it('should return correct status when limit exceeded', () => {
      for (let i = 0; i < 10; i++) {
        checkRateLimit('fetch', 'test-key');
      }

      const status = getRateLimitStatus('fetch', 'test-key');

      expect(status.allowed).toBe(false);
      expect(status.remaining).toBe(0);
    });
  });

  describe('RateLimiter class', () => {
    it('should allow custom configuration', () => {
      const limiter = new RateLimiter({ maxRequests: 5, windowMs: 30000 });

      for (let i = 0; i < 5; i++) {
        const result = limiter.checkLimit('test-key');
        expect(result.allowed).toBe(true);
      }

      const result = limiter.checkLimit('test-key');
      expect(result.allowed).toBe(false);
    });
  });
});

```

## `src/utils/__tests__/typeGuards.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import {
  isObject,
  isArray,
  isString,
  isNumber,
  isBoolean,
  isNullOrUndefined,
  isValidNumber,
  isNonEmptyString,
  hasKey,
  hasKeys,
  isDataRow,
  isDataRowArray,
  is2DArray,
  isValidTimestamp,
  isValidUrl,
  isValidEmail,
  isValidJsonString,
  isMap,
  isSet,
  isFunction,
  isPromise,
  isValidDate,
  isPositiveInteger,
  isNonNegativeInteger,
  isInRange,
  isBenjaminGrahamData,
  isCurrencyString,
  isCacheEntry,
  isDeltaCacheEntry,
} from '../typeGuards';

describe('typeGuards', () => {
  describe('isObject', () => {
    it('should return true for objects', () => {
      expect(isObject({})).toBe(true);
      expect(isObject({ key: 'value' })).toBe(true);
    });

    it('should return false for null', () => {
      expect(isObject(null)).toBe(false);
    });

    it('should return false for arrays', () => {
      expect(isObject([])).toBe(false);
    });

    it('should return false for primitives', () => {
      expect(isObject('string')).toBe(false);
      expect(isObject(123)).toBe(false);
      expect(isObject(true)).toBe(false);
    });
  });

  describe('isArray', () => {
    it('should return true for arrays', () => {
      expect(isArray([])).toBe(true);
      expect(isArray([1, 2, 3])).toBe(true);
    });

    it('should return false for non-arrays', () => {
      expect(isArray({})).toBe(false);
      expect(isArray('string')).toBe(false);
    });
  });

  describe('isString', () => {
    it('should return true for strings', () => {
      expect(isString('test')).toBe(true);
      expect(isString('')).toBe(true);
    });

    it('should return false for non-strings', () => {
      expect(isString(123)).toBe(false);
      expect(isString(null)).toBe(false);
    });
  });

  describe('isNumber', () => {
    it('should return true for valid numbers', () => {
      expect(isNumber(123)).toBe(true);
      expect(isNumber(0)).toBe(true);
      expect(isNumber(-123)).toBe(true);
      expect(isNumber(123.45)).toBe(true);
    });

    it('should return false for NaN', () => {
      expect(isNumber(NaN)).toBe(false);
    });

    it('should return false for Infinity', () => {
      expect(isNumber(Infinity)).toBe(false);
      expect(isNumber(-Infinity)).toBe(false);
    });

    it('should return false for non-numbers', () => {
      expect(isNumber('123')).toBe(false);
      expect(isNumber(null)).toBe(false);
    });
  });

  describe('isBoolean', () => {
    it('should return true for booleans', () => {
      expect(isBoolean(true)).toBe(true);
      expect(isBoolean(false)).toBe(true);
    });

    it('should return false for non-booleans', () => {
      expect(isBoolean(1)).toBe(false);
      expect(isBoolean('true')).toBe(false);
    });
  });

  describe('isNullOrUndefined', () => {
    it('should return true for null', () => {
      expect(isNullOrUndefined(null)).toBe(true);
    });

    it('should return true for undefined', () => {
      expect(isNullOrUndefined(undefined)).toBe(true);
    });

    it('should return false for other values', () => {
      expect(isNullOrUndefined(0)).toBe(false);
      expect(isNullOrUndefined('')).toBe(false);
    });
  });

  describe('isValidNumber', () => {
    it('should return true for valid numbers', () => {
      expect(isValidNumber(123)).toBe(true);
      expect(isValidNumber(0)).toBe(true);
    });

    it('should return false for NaN', () => {
      expect(isValidNumber(NaN)).toBe(false);
    });
  });

  describe('isNonEmptyString', () => {
    it('should return true for non-empty strings', () => {
      expect(isNonEmptyString('test')).toBe(true);
    });

    it('should return false for empty strings', () => {
      expect(isNonEmptyString('')).toBe(false);
      expect(isNonEmptyString('   ')).toBe(false);
    });
  });

  describe('hasKey', () => {
    it('should return true if object has key', () => {
      expect(hasKey({ test: 'value' }, 'test')).toBe(true);
    });

    it('should return false if object does not have key', () => {
      expect(hasKey({ test: 'value' }, 'other')).toBe(false);
    });
  });

  describe('hasKeys', () => {
    it('should return true if object has all keys', () => {
      expect(hasKeys({ a: 1, b: 2, c: 3 }, ['a', 'b'])).toBe(true);
    });

    it('should return false if object missing any key', () => {
      expect(hasKeys({ a: 1 }, ['a', 'b'])).toBe(false);
    });
  });

  describe('isDataRow', () => {
    it('should return true for valid DataRow', () => {
      expect(isDataRow({ key: 'value', num: 123 })).toBe(true);
    });

    it('should return false for invalid DataRow', () => {
      expect(isDataRow({ key: {} })).toBe(false);
      expect(isDataRow(null)).toBe(false);
    });
  });

  describe('isDataRowArray', () => {
    it('should return true for array of DataRow', () => {
      expect(isDataRowArray([{ key: 'value' }, { key: 'value2' }])).toBe(true);
    });

    it('should return false for non-array', () => {
      expect(isDataRowArray({})).toBe(false);
    });
  });

  describe('is2DArray', () => {
    it('should return true for 2D array', () => {
      expect(is2DArray([[1, 2], [3, 4]])).toBe(true);
    });

    it('should return false for 1D array', () => {
      expect(is2DArray([1, 2, 3])).toBe(false);
    });
  });

  describe('isValidTimestamp', () => {
    it('should return true for Date', () => {
      expect(isValidTimestamp(new Date())).toBe(true);
    });

    it('should return true for valid number timestamp', () => {
      expect(isValidTimestamp(Date.now())).toBe(true);
    });

    it('should return false for invalid timestamp', () => {
      expect(isValidTimestamp(0)).toBe(false);
      expect(isValidTimestamp(-1)).toBe(false);
    });
  });

  describe('isValidUrl', () => {
    it('should return true for valid URL', () => {
      expect(isValidUrl('https://example.com')).toBe(true);
      expect(isValidUrl('http://example.com/path')).toBe(true);
    });

    it('should return false for invalid URL', () => {
      expect(isValidUrl('not-a-url')).toBe(false);
      expect(isValidUrl('')).toBe(false);
    });
  });

  describe('isValidEmail', () => {
    it('should return true for valid email', () => {
      expect(isValidEmail('test@example.com')).toBe(true);
    });

    it('should return false for invalid email', () => {
      expect(isValidEmail('not-an-email')).toBe(false);
      expect(isValidEmail('test@')).toBe(false);
    });
  });

  describe('isValidJsonString', () => {
    it('should return true for valid JSON', () => {
      expect(isValidJsonString('{"key":"value"}')).toBe(true);
    });

    it('should return false for invalid JSON', () => {
      expect(isValidJsonString('not json')).toBe(false);
      expect(isValidJsonString('{key:value}')).toBe(false);
    });
  });

  describe('isMap', () => {
    it('should return true for Map', () => {
      expect(isMap(new Map())).toBe(true);
    });

    it('should return false for non-Map', () => {
      expect(isMap({})).toBe(false);
    });
  });

  describe('isSet', () => {
    it('should return true for Set', () => {
      expect(isSet(new Set())).toBe(true);
    });

    it('should return false for non-Set', () => {
      expect(isSet([])).toBe(false);
    });
  });

  describe('isFunction', () => {
    it('should return true for functions', () => {
      expect(isFunction(() => {})).toBe(true);
      expect(isFunction(function() {})).toBe(true);
    });

    it('should return false for non-functions', () => {
      expect(isFunction({})).toBe(false);
    });
  });

  describe('isPromise', () => {
    it('should return true for Promise', () => {
      expect(isPromise(Promise.resolve())).toBe(true);
    });

    it('should return false for non-Promise', () => {
      expect(isPromise({})).toBe(false);
    });
  });

  describe('isValidDate', () => {
    it('should return true for valid Date', () => {
      expect(isValidDate(new Date())).toBe(true);
    });

    it('should return false for invalid Date', () => {
      expect(isValidDate(new Date('invalid'))).toBe(false);
    });
  });

  describe('isPositiveInteger', () => {
    it('should return true for positive integers', () => {
      expect(isPositiveInteger(1)).toBe(true);
      expect(isPositiveInteger(100)).toBe(true);
    });

    it('should return false for zero', () => {
      expect(isPositiveInteger(0)).toBe(false);
    });

    it('should return false for negative numbers', () => {
      expect(isPositiveInteger(-1)).toBe(false);
    });
  });

  describe('isNonNegativeInteger', () => {
    it('should return true for non-negative integers', () => {
      expect(isNonNegativeInteger(0)).toBe(true);
      expect(isNonNegativeInteger(100)).toBe(true);
    });

    it('should return false for negative numbers', () => {
      expect(isNonNegativeInteger(-1)).toBe(false);
    });
  });

  describe('isInRange', () => {
    it('should return true for value in range', () => {
      expect(isInRange(50, 0, 100)).toBe(true);
      expect(isInRange(0, 0, 100)).toBe(true);
      expect(isInRange(100, 0, 100)).toBe(true);
    });

    it('should return false for value outside range', () => {
      expect(isInRange(-1, 0, 100)).toBe(false);
      expect(isInRange(101, 0, 100)).toBe(false);
    });
  });

  describe('isBenjaminGrahamData', () => {
    it('should return true for valid BenjaminGrahamData', () => {
      expect(isBenjaminGrahamData({
        companyName: 'Test',
        ticker: 'TEST',
        price: 100,
        benjaminGraham: 90,
      })).toBe(true);
    });

    it('should return false for invalid data', () => {
      expect(isBenjaminGrahamData({})).toBe(false);
      expect(isBenjaminGrahamData(null)).toBe(false);
    });
  });

  describe('isCurrencyString', () => {
    it('should return true for valid currency', () => {
      expect(isCurrencyString('USD')).toBe(true);
      expect(isCurrencyString('EUR')).toBe(true);
    });

    it('should return false for empty string', () => {
      expect(isCurrencyString('')).toBe(false);
    });

    it('should return false for too long string', () => {
      expect(isCurrencyString('A'.repeat(11))).toBe(false);
    });
  });

  describe('isCacheEntry', () => {
    it('should return true for valid CacheEntry', () => {
      expect(isCacheEntry({
        data: { test: 'value' },
        timestamp: Date.now(),
        ttl: 60000,
      })).toBe(true);
    });

    it('should return false for invalid CacheEntry', () => {
      expect(isCacheEntry({})).toBe(false);
    });
  });

  describe('isDeltaCacheEntry', () => {
    it('should return true for valid DeltaCacheEntry', () => {
      expect(isDeltaCacheEntry({
        data: { test: 'value' },
        version: 1,
      })).toBe(true);
    });

    it('should return false for invalid DeltaCacheEntry', () => {
      expect(isDeltaCacheEntry({})).toBe(false);
    });
  });
});

```

## `src/utils/__tests__/xssProtection.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import {
  escapeHtml,
  escapeHtmlAttribute,
  escapeJavaScript,
  isHtmlSafe,
  sanitizeHtml,
} from '../xssProtection';

describe('xssProtection', () => {
  describe('escapeHtml', () => {
    it('should escape HTML special characters', () => {
      expect(escapeHtml('<script>alert("xss")</script>')).toBe('&lt;script&gt;alert(&quot;xss&quot;)&lt;&#x2F;script&gt;');
    });

    it('should escape ampersand', () => {
      expect(escapeHtml('A & B')).toBe('A &amp; B');
    });

    it('should escape less than', () => {
      expect(escapeHtml('<div>')).toBe('&lt;div&gt;');
    });

    it('should escape greater than', () => {
      expect(escapeHtml('</div>')).toBe('&lt;&#x2F;div&gt;');
    });

    it('should escape quotes', () => {
      expect(escapeHtml('"test"')).toBe('&quot;test&quot;');
      expect(escapeHtml("'test'")).toBe('&#x27;test&#x27;');
    });

    it('should escape forward slash', () => {
      expect(escapeHtml('</script>')).toBe('&lt;&#x2F;script&gt;');
    });

    it('should handle null/undefined', () => {
      expect(escapeHtml(null)).toBe('');
      expect(escapeHtml(undefined)).toBe('');
    });

    it('should handle empty string', () => {
      expect(escapeHtml('')).toBe('');
    });

    it('should handle normal text without special characters', () => {
      expect(escapeHtml('Hello World')).toBe('Hello World');
    });
  });

  describe('escapeHtmlAttribute', () => {
    it('should escape HTML attribute special characters', () => {
      expect(escapeHtmlAttribute('test"value')).toBe('test&quot;value');
    });

    it('should escape quotes for attributes', () => {
      expect(escapeHtmlAttribute('test\'value')).toBe('test&#x27;value');
    });

    it('should escape ampersand', () => {
      expect(escapeHtmlAttribute('A & B')).toBe('A &amp; B');
    });

    it('should handle null/undefined', () => {
      expect(escapeHtmlAttribute(null)).toBe('');
      expect(escapeHtmlAttribute(undefined)).toBe('');
    });
  });

  describe('escapeJavaScript', () => {
    it('should escape JavaScript special characters', () => {
      expect(escapeJavaScript('test\'value')).toBe("test\\'value");
    });

    it('should escape backslash', () => {
      expect(escapeJavaScript('test\\value')).toBe('test\\\\value');
    });

    it('should escape newlines', () => {
      expect(escapeJavaScript('test\nvalue')).toBe('test\\nvalue');
    });

    it('should escape tabs', () => {
      expect(escapeJavaScript('test\tvalue')).toBe('test\\tvalue');
    });

    it('should handle null/undefined', () => {
      expect(escapeJavaScript(null)).toBe('');
      expect(escapeJavaScript(undefined)).toBe('');
    });
  });

  describe('isHtmlSafe', () => {
    it('should return true for safe HTML', () => {
      expect(isHtmlSafe('<div>Safe content</div>')).toBe(true);
    });

    it('should return false for script tags', () => {
      expect(isHtmlSafe('<script>alert("xss")</script>')).toBe(false);
    });

    it('should return false for javascript: protocol', () => {
      expect(isHtmlSafe('javascript:alert("xss")')).toBe(false);
    });

    it('should return false for event handlers', () => {
      expect(isHtmlSafe('<div onclick="alert(\'xss\')">')).toBe(false);
    });

    it('should return false for iframe tags', () => {
      expect(isHtmlSafe('<iframe src="evil.com"></iframe>')).toBe(false);
    });

    it('should return false for object tags', () => {
      expect(isHtmlSafe('<object data="evil.swf"></object>')).toBe(false);
    });

    it('should return false for embed tags', () => {
      expect(isHtmlSafe('<embed src="evil.swf"></embed>')).toBe(false);
    });

    it('should return true for null/undefined', () => {
      expect(isHtmlSafe(null)).toBe(true);
      expect(isHtmlSafe(undefined)).toBe(true);
    });

    it('should return true for empty string', () => {
      expect(isHtmlSafe('')).toBe(true);
    });
  });

  describe('sanitizeHtml', () => {
    it('should sanitize HTML by escaping', () => {
      const result = sanitizeHtml('<script>alert("xss")</script>');
      expect(result).not.toContain('<script>');
      expect(result).toContain('&lt;');
    });

    it('should handle null/undefined', () => {
      expect(sanitizeHtml(null)).toBe('');
      expect(sanitizeHtml(undefined)).toBe('');
    });

    it('should handle empty string', () => {
      expect(sanitizeHtml('')).toBe('');
    });
  });
});

```

## `src/utils/calculateScore.ts`

```typescript
import { ScoreBoardData, ThresholdIndustryData, BenjaminGrahamData } from '../types/stock';
import { EntryExitValuesForScore } from '../types/score';
import {
  COLOR_FACTOR_GREEN,
  COLOR_FACTOR_ORANGE_BLUE,
} from '../config/constants';
import {
  getIRRColor,
  getMungerQualityScoreColor,
  getValueCreationColor,
  getRo40Color,
  getLeverageF2Color,
  getCashSdebtColor,
  getCurrentRatioColor,
  getPEPercentageColor,
  getTBSPPriceColor,
  getSMAColor,
  getSMACrossColorStandard,
  isTheoEntryGreen,
} from './colorThresholds';
import type { ColorType } from './colorThresholds';

/**
 * 3-band color factors for score calculation
 *
 * These factors determine how much each color contributes to the total score:
 * - GREEN (1.00): Full points - indicates strong positive metric
 * - ORANGE/BLUE (0.70): Partial points - indicates moderate/acceptable metric
 * - RED (0.00): No points - indicates negative metric requiring attention
 * - BLANK (0.00): No points - indicates missing/invalid data
 *
 * The 0.70 factor for ORANGE/BLUE provides a middle ground between perfect (GREEN)
 * and problematic (RED), allowing for nuanced scoring that reflects real-world
 * business conditions where metrics may be acceptable but not optimal.
 */
const COLOR_FACTORS: Record<ColorType, number> = {
  GREEN: COLOR_FACTOR_GREEN,
  ORANGE: COLOR_FACTOR_ORANGE_BLUE,
  RED: 0.00,
  BLANK: 0.00,
};

/**
 * Metric configuration interface
 * 
 * Defines how each metric contributes to the overall score calculation.
 */
interface Metric {
  name: string;
  weight: number;
  method: '3Band' | 'GreenOnly';
}

/**
 * Metrics configuration with weights and calculation methods
 * 
 * Total weight: 105 points (55 fundamental + 50 technical), scaled to 100.
 * 
 * Weight distribution rationale:
 * - Fundamental metrics (55p): Core financial health indicators
 *   - VALUE CREATION (10p): Highest weight - measures actual value generation
 *   - Munger Quality Score (10p): Highest weight - comprehensive quality metric
 *   - IRR (8p): High weight - return on investment indicator
 *   - Lower weights for supporting metrics (P/E ratios, ratios, etc.)
 * 
 * - Technical metrics (50p): Market timing and technical indicators
 *   - TheoEntry (40p): Highest weight - entry/exit timing is critical for returns
 *   - SMA indicators (2.5p each): Lower weight - supporting trend indicators
 *   - SMA Cross (5p): Moderate weight - trend reversal signal
 * 
 * Calculation methods:
 * - 3Band: Uses color factors (GREEN=1.0, ORANGE=0.7, RED=0.0) for nuanced scoring
 * - GreenOnly: Binary scoring - full points if GREEN, 0 otherwise
 */
const METRICS: Metric[] = [
  // Fundamental (55p)
  { name: 'VALUE CREATION', weight: 10, method: '3Band' },
  { name: 'Munger Quality Score', weight: 10, method: '3Band' },
  { name: 'IRR', weight: 8, method: '3Band' },
  { name: 'Ro40 F1', weight: 6, method: '3Band' },
  { name: 'Ro40 F2', weight: 5, method: '3Band' },
  { name: 'LEVERAGE F2', weight: 5, method: '3Band' },
  { name: 'Cash/SDebt', weight: 4, method: '3Band' },
  { name: 'Current Ratio', weight: 3, method: '3Band' },
  { name: 'P/E1 INDUSTRY', weight: 2, method: '3Band' },
  { name: 'P/E2 INDUSTRY', weight: 1, method: '3Band' },
  { name: '(TB/S)/Price', weight: 1, method: '3Band' },
  // Technical (50p)
  { name: 'TheoEntry', weight: 40, method: 'GreenOnly' },
  { name: 'SMA(100)', weight: 2.5, method: 'GreenOnly' },
  { name: 'SMA(200)', weight: 2.5, method: 'GreenOnly' },
  { name: 'SMA Cross', weight: 5, method: 'GreenOnly' },
];

const TOTAL_ACTIVE_POINTS = 100; // 55 + 50 = 105, but scaled to 100

// Get price from BenjaminGrahamData
function getPriceFromBenjaminGraham(
  ticker: string,
  companyName: string,
  benjaminGrahamData: BenjaminGrahamData[]
): number | null {
  const match = benjaminGrahamData.find(
    item => item.ticker?.toLowerCase() === ticker.toLowerCase() ||
            item.companyName?.toLowerCase() === companyName.toLowerCase()
  );
  return match?.price ?? null;
}

// Get EntryExitValuesForScore
function getEntryExitValue(
  ticker: string,
  companyName: string,
  entryExitValues: Map<string, EntryExitValuesForScore>
): EntryExitValuesForScore | undefined {
  const key = `${ticker}-${companyName}`;
  return entryExitValues.get(key);
}

/**
 * Calculates the overall stock score (0-100) based on fundamental and technical metrics
 * 
 * This function implements a weighted scoring algorithm that evaluates stocks across
 * multiple dimensions:
 * 
 * **Scoring Algorithm:**
 * 1. For each metric, determines color classification (GREEN/ORANGE/RED/BLANK)
 * 2. Applies color factor to metric weight:
 *    - 3Band metrics: GREEN=1.0, ORANGE=0.7, RED=0.0
 *    - GreenOnly metrics: GREEN=full weight, otherwise=0
 * 3. Sums all metric points
 * 4. Scales to 0-100 range (total possible points = 100)
 * 5. Rounds to 1 decimal place
 * 
 * **Color Classification:**
 * - Metrics are classified using industry-specific thresholds where applicable
 * - Missing threshold data results in BLANK (0 points)
 * - Invalid/missing values result in BLANK (0 points)
 * 
 * **Edge Cases:**
 * - If threshold data is missing for an industry, that metric contributes 0 points
 * - If price data is missing, technical metrics (SMA, TheoEntry) contribute 0 points
 * - If entry/exit values are missing, TheoEntry contributes 0 points
 * 
 * @param scoreBoardData - Core stock data with fundamental and technical metrics
 * @param thresholdData - Industry-specific threshold values for metric classification
 * @param benjaminGrahamData - Price data for technical metric calculations
 * @param entryExitValues - Entry/exit values for TheoEntry calculation
 * @returns Stock score between 0.0 and 100.0 (rounded to 1 decimal)
 * 
 * @example
 * See unit tests for full usage examples.
 */
export function calculateScore(
  scoreBoardData: ScoreBoardData,
  thresholdData: ThresholdIndustryData[],
  benjaminGrahamData: BenjaminGrahamData[],
  entryExitValues: Map<string, EntryExitValuesForScore>
): number {
  let totalPts = 0;

  // Get price and entry exit values
  const price = getPriceFromBenjaminGraham(
    scoreBoardData.ticker,
    scoreBoardData.companyName,
    benjaminGrahamData
  );
  const entryExitValue = getEntryExitValue(
    scoreBoardData.ticker,
    scoreBoardData.companyName,
    entryExitValues
  );

  // Process each metric
  for (const metric of METRICS) {
    let color: ColorType = 'BLANK';

    switch (metric.name) {
      case 'VALUE CREATION':
        color = getValueCreationColor(scoreBoardData.valueCreation);
        break;
      case 'Munger Quality Score':
        color = getMungerQualityScoreColor(scoreBoardData.mungerQualityScore);
        break;
      case 'IRR':
        // Edge case: If threshold data is missing for this industry, getIRRColor returns BLANK (0 points)
        // This ensures missing threshold data doesn't break scoring, but also doesn't give false positives
        color = getIRRColor(scoreBoardData.irr, scoreBoardData.industry, thresholdData);
        break;
      case 'Ro40 F1':
        color = getRo40Color(scoreBoardData.ro40F1, scoreBoardData.industry, thresholdData);
        break;
      case 'Ro40 F2':
        color = getRo40Color(scoreBoardData.ro40F2, scoreBoardData.industry, thresholdData);
        break;
      case 'LEVERAGE F2':
        color = getLeverageF2Color(scoreBoardData.leverageF2, scoreBoardData.industry, thresholdData);
        break;
      case 'Cash/SDebt':
        color = getCashSdebtColor(
          scoreBoardData.cashSdebt,
          scoreBoardData.isCashSdebtDivZero,
          scoreBoardData.industry,
          thresholdData
        );
        break;
      case 'Current Ratio':
        color = getCurrentRatioColor(scoreBoardData.currentRatio, scoreBoardData.industry, thresholdData);
        break;
      case 'P/E1 INDUSTRY':
        color = getPEPercentageColor(scoreBoardData.pe1Industry);
        break;
      case 'P/E2 INDUSTRY':
        color = getPEPercentageColor(scoreBoardData.pe2Industry);
        break;
      case '(TB/S)/Price':
        color = getTBSPPriceColor(scoreBoardData.tbSPrice);
        break;
      case 'TheoEntry':
        color = isTheoEntryGreen(entryExitValue, price) ? 'GREEN' : 'BLANK';
        break;
      case 'SMA(100)':
        color = getSMAColor(price, scoreBoardData.sma100);
        break;
      case 'SMA(200)':
        color = getSMAColor(price, scoreBoardData.sma200);
        break;
      case 'SMA Cross':
        color = getSMACrossColorStandard(scoreBoardData.smaCross);
        break;
    }

    // Calculate points based on method
    if (metric.method === '3Band') {
      const factor = COLOR_FACTORS[color];
      totalPts += metric.weight * factor;
    } else if (metric.method === 'GreenOnly') {
      if (color === 'GREEN') {
        totalPts += metric.weight;
      }
      // Otherwise 0 points
    }
  }

  // Scale to 0-100
  const score100 = TOTAL_ACTIVE_POINTS > 0
    ? Math.max(0, Math.min(100, (totalPts / TOTAL_ACTIVE_POINTS) * 100))
    : 0;

  // Round to 1 decimal
  return Math.round(score100 * 10) / 10;
}

```

## `src/utils/calculateScoreDetailed.ts`

```typescript
import { ScoreBoardData, ThresholdIndustryData, BenjaminGrahamData } from '../types/stock';
import { EntryExitValuesForScore } from '../types/score';
import {
  COLOR_FACTOR_GREEN,
  COLOR_FACTOR_ORANGE_BLUE,
} from '../config/constants';
import {
  getIRRColor,
  getMungerQualityScoreColor,
  getValueCreationColor,
  getRo40Color,
  getLeverageF2Color,
  getCashSdebtColor,
  getCurrentRatioColor,
  getPEPercentageColor,
  getTBSPPriceColor,
  getSMAColor,
  getSMACrossColorDetailed,
  isTheoEntryGreen,
} from './colorThresholds';
import type { ColorType } from './colorThresholds';

/** Detailed view uses BLUE for middle band (maps ORANGE from colorThresholds). */
type DetailedColor = 'GREEN' | 'BLUE' | 'RED' | 'BLANK';

const COLOR_FACTORS: Record<DetailedColor, number> = {
  GREEN: COLOR_FACTOR_GREEN,
  BLUE: COLOR_FACTOR_ORANGE_BLUE,
  RED: 0.00,
  BLANK: 0.00,
};

/** Maps colorThresholds ColorType (ORANGE) to DetailedColor (BLUE) for factor lookup and display. */
function toDetailedColor(color: ColorType): DetailedColor {
  return color === 'ORANGE' ? 'BLUE' : (color as DetailedColor);
}

// Metrics configuration with weights
interface Metric {
  name: string;
  weight: number;
}

const METRICS: Metric[] = [
  // Fundamental (50p)
  { name: 'VALUE CREATION', weight: 7 },
  { name: 'Munger Quality Score', weight: 7 },
  { name: 'IRR', weight: 6 },
  { name: 'Ro40 F1', weight: 3 },
  { name: 'Ro40 F2', weight: 3 },
  { name: 'LEVERAGE F2', weight: 4 },
  { name: 'Cash/SDebt', weight: 5 },
  { name: 'Current Ratio', weight: 3 },
  { name: 'P/E1 INDUSTRY', weight: 5 },
  { name: 'P/E2 INDUSTRY', weight: 5 },
  { name: '(TB/S)/Price', weight: 2 },
  // Technical (50p)
  { name: 'THEOENTRY', weight: 40 },
  { name: 'SMA(100)', weight: 2.5 },
  { name: 'SMA(200)', weight: 2.5 },
  { name: 'SMA CROSS', weight: 5 },
];

const TOTAL_WEIGHT = 100; // 50 + 50

// Get price from BenjaminGrahamData
function getPriceFromBenjaminGraham(
  ticker: string,
  companyName: string,
  benjaminGrahamData: BenjaminGrahamData[]
): number | null {
  const match = benjaminGrahamData.find(
    item => item.ticker?.toLowerCase() === ticker.toLowerCase() ||
            item.companyName?.toLowerCase() === companyName.toLowerCase()
  );
  return match?.price ?? null;
}

// Get EntryExitValuesForScore
function getEntryExitValue(
  ticker: string,
  companyName: string,
  entryExitValues: Map<string, EntryExitValuesForScore>
): EntryExitValuesForScore | undefined {
  const key = `${ticker}-${companyName}`;
  return entryExitValues.get(key);
}

/**
 * Individual metric breakdown item
 * 
 * Represents how a single metric contributes to the overall score.
 */
export interface ScoreBreakdownItem {
  /** Metric name (e.g., 'VALUE CREATION', 'TheoEntry') */
  metric: string;
  /** Weight of this metric in the total score calculation */
  weight: number;
  /** Color classification: GREEN (1.00), BLUE (0.70), RED (0.00), or BLANK (0.00) */
  color: 'GREEN' | 'BLUE' | 'RED' | 'BLANK';
  /** Color factor applied: 1.00 (GREEN), 0.70 (BLUE/ORANGE), or 0.00 (RED/BLANK) */
  factor: number;
  /** Points contributed: weight * factor */
  points: number;
  /** Category: 'Fundamental' or 'Technical' */
  category: 'Fundamental' | 'Technical';
}

/**
 * Complete score breakdown structure
 * 
 * Provides detailed breakdown of how the score was calculated, allowing
 * users to understand which metrics contributed positively or negatively.
 */
export interface ScoreBreakdown {
  /** Total score (0-100) */
  totalScore: number;
  /** Array of individual metric contributions */
  items: ScoreBreakdownItem[];
  /** Sum of all fundamental metric points */
  fundamentalTotal: number;
  /** Sum of all technical metric points */
  technicalTotal: number;
}

/**
 * Calculates detailed score breakdown showing individual metric contributions
 * 
 * This function provides transparency into how the score was calculated by
 * breaking down each metric's contribution. Useful for:
 * - Understanding which metrics are driving the score
 * - Identifying areas for improvement
 * - Debugging score calculations
 * - Displaying score breakdown in UI tooltips
 * 
 * **Differences from calculateScore():**
 * - Returns detailed breakdown instead of just final score
 * - Separates fundamental vs technical totals
 * - Uses BLUE instead of ORANGE for consistency with detailed view
 * - Provides per-metric point contributions
 * 
 * **Score Breakdown Structure:**
 * - Each metric shows: name, weight, color, factor, points, category
 * - Fundamental total: Sum of all fundamental metric points
 * - Technical total: Sum of all technical metric points
 * - Total score: Sum of both categories (0-100)
 * 
 * @param scoreBoardData - Core stock data with fundamental and technical metrics
 * @param thresholdData - Industry-specific threshold values for metric classification
 * @param benjaminGrahamData - Price data for technical metric calculations
 * @param entryExitValues - Entry/exit values for TheoEntry calculation
 * @returns Detailed score breakdown with per-metric contributions
 * 
 * @example
 * ```typescript
 * const breakdown = calculateDetailedScoreBreakdown(
 *   scoreBoardData,
 *   thresholdData,
 *   benjaminGrahamData,
 *   entryExitValues
 * );
 * 
 * console.log(`Total Score: ${breakdown.totalScore}`);
 * console.log(`Fundamental: ${breakdown.fundamentalTotal}`);
 * console.log(`Technical: ${breakdown.technicalTotal}`);
 * breakdown.items.forEach(item => {
 *   console.log(`${item.metric}: ${item.points} points (${item.color})`);
 * });
 * ```
 */
export function calculateDetailedScoreBreakdown(
  scoreBoardData: ScoreBoardData,
  thresholdData: ThresholdIndustryData[],
  benjaminGrahamData: BenjaminGrahamData[],
  entryExitValues: Map<string, EntryExitValuesForScore>
): ScoreBreakdown {
  const items: ScoreBreakdownItem[] = [];
  let fundamentalTotal = 0;
  let technicalTotal = 0;

  // Get price and entry exit values
  const price = getPriceFromBenjaminGraham(
    scoreBoardData.ticker,
    scoreBoardData.companyName,
    benjaminGrahamData
  );
  const entryExitValue = getEntryExitValue(
    scoreBoardData.ticker,
    scoreBoardData.companyName,
    entryExitValues
  );

  // Define which metrics are Fundamental vs Technical
  const fundamentalMetrics = [
    'VALUE CREATION',
    'Munger Quality Score',
    'IRR',
    'Ro40 F1',
    'Ro40 F2',
    'LEVERAGE F2',
    'Cash/SDebt',
    'Current Ratio',
    'P/E1 INDUSTRY',
    'P/E2 INDUSTRY',
    '(TB/S)/Price',
  ];

  // Process each metric
  for (const metric of METRICS) {
    let color: ColorType = 'BLANK';

    switch (metric.name) {
      case 'VALUE CREATION':
        color = getValueCreationColor(scoreBoardData.valueCreation);
        break;
      case 'Munger Quality Score':
        color = getMungerQualityScoreColor(scoreBoardData.mungerQualityScore);
        break;
      case 'IRR':
        color = getIRRColor(scoreBoardData.irr, scoreBoardData.industry, thresholdData);
        break;
      case 'Ro40 F1':
        color = getRo40Color(scoreBoardData.ro40F1, scoreBoardData.industry, thresholdData);
        break;
      case 'Ro40 F2':
        color = getRo40Color(scoreBoardData.ro40F2, scoreBoardData.industry, thresholdData);
        break;
      case 'LEVERAGE F2':
        color = getLeverageF2Color(scoreBoardData.leverageF2, scoreBoardData.industry, thresholdData);
        break;
      case 'Cash/SDebt':
        color = getCashSdebtColor(
          scoreBoardData.cashSdebt,
          scoreBoardData.isCashSdebtDivZero,
          scoreBoardData.industry,
          thresholdData
        );
        break;
      case 'Current Ratio':
        color = getCurrentRatioColor(scoreBoardData.currentRatio, scoreBoardData.industry, thresholdData);
        break;
      case 'P/E1 INDUSTRY':
        color = getPEPercentageColor(scoreBoardData.pe1Industry);
        break;
      case 'P/E2 INDUSTRY':
        color = getPEPercentageColor(scoreBoardData.pe2Industry);
        break;
      case '(TB/S)/Price':
        color = getTBSPPriceColor(scoreBoardData.tbSPrice);
        break;
      case 'THEOENTRY':
        color = isTheoEntryGreen(entryExitValue, price) ? 'GREEN' : 'BLANK';
        break;
      case 'SMA(100)':
        color = getSMAColor(price, scoreBoardData.sma100);
        break;
      case 'SMA(200)':
        color = getSMAColor(price, scoreBoardData.sma200);
        break;
      case 'SMA CROSS':
        color = getSMACrossColorDetailed(scoreBoardData.smaCross);
        break;
    }

    // Map ORANGE -> BLUE for detailed view (factor lookup and display)
    const detailedColor = toDetailedColor(color);
    const factor = COLOR_FACTORS[detailedColor];
    const points = metric.weight * factor;
    
    // Determine category
    const category = fundamentalMetrics.includes(metric.name) ? 'Fundamental' : 'Technical';
    
    items.push({
      metric: metric.name,
      weight: metric.weight,
      color: detailedColor,
      factor: factor,
      points: points,
      category: category,
    });

    // Add to category total
    if (category === 'Fundamental') {
      fundamentalTotal += points;
    } else {
      technicalTotal += points;
    }
  }

  const totalScore = Math.round(Math.max(0, Math.min(100, fundamentalTotal + technicalTotal)) * 10) / 10;

  return {
    totalScore,
    items,
    fundamentalTotal: Math.round(fundamentalTotal * 10) / 10,
    technicalTotal: Math.round(technicalTotal * 10) / 10,
  };
}

/**
 * Calculates detailed score (0-100) using the detailed scoring algorithm
 * 
 * This function uses the same algorithm as calculateScore() but with
 * different metric weights optimized for the detailed view. The main
 * differences are:
 * 
 * - Different weight distribution (50p fundamental + 50p technical)
 * - Uses BLUE color classification instead of ORANGE
 * - SMA Cross has inverted logic (GOLDEN=RED, DEATH=GREEN) for detailed view
 * 
 * **When to use:**
 * - For detailed score view that matches the breakdown display
 * - When consistency with calculateDetailedScoreBreakdown() is required
 * - For alternative scoring perspective with balanced fundamental/technical weights
 * 
 * @param scoreBoardData - Core stock data with fundamental and technical metrics
 * @param thresholdData - Industry-specific threshold values for metric classification
 * @param benjaminGrahamData - Price data for technical metric calculations
 * @param entryExitValues - Entry/exit values for TheoEntry calculation
 * @returns Stock score between 0.0 and 100.0 (rounded to 1 decimal)
 * 
 * @example
 * ```typescript
 * const detailedScore = calculateDetailedScore(
 *   scoreBoardData,
 *   thresholdData,
 *   benjaminGrahamData,
 *   entryExitValues
 * );
 * // Returns: 78.5 (example score using detailed algorithm)
 * ```
 */
export function calculateDetailedScore(
  scoreBoardData: ScoreBoardData,
  thresholdData: ThresholdIndustryData[],
  benjaminGrahamData: BenjaminGrahamData[],
  entryExitValues: Map<string, EntryExitValuesForScore>
): number {
  let totalPoints = 0;

  // Get price and entry exit values
  const price = getPriceFromBenjaminGraham(
    scoreBoardData.ticker,
    scoreBoardData.companyName,
    benjaminGrahamData
  );
  const entryExitValue = getEntryExitValue(
    scoreBoardData.ticker,
    scoreBoardData.companyName,
    entryExitValues
  );

  // Process each metric
  for (const metric of METRICS) {
    let color: ColorType = 'BLANK';

    switch (metric.name) {
      case 'VALUE CREATION':
        color = getValueCreationColor(scoreBoardData.valueCreation);
        break;
      case 'Munger Quality Score':
        color = getMungerQualityScoreColor(scoreBoardData.mungerQualityScore);
        break;
      case 'IRR':
        color = getIRRColor(scoreBoardData.irr, scoreBoardData.industry, thresholdData);
        break;
      case 'Ro40 F1':
        color = getRo40Color(scoreBoardData.ro40F1, scoreBoardData.industry, thresholdData);
        break;
      case 'Ro40 F2':
        color = getRo40Color(scoreBoardData.ro40F2, scoreBoardData.industry, thresholdData);
        break;
      case 'LEVERAGE F2':
        color = getLeverageF2Color(scoreBoardData.leverageF2, scoreBoardData.industry, thresholdData);
        break;
      case 'Cash/SDebt':
        color = getCashSdebtColor(
          scoreBoardData.cashSdebt,
          scoreBoardData.isCashSdebtDivZero,
          scoreBoardData.industry,
          thresholdData
        );
        break;
      case 'Current Ratio':
        color = getCurrentRatioColor(scoreBoardData.currentRatio, scoreBoardData.industry, thresholdData);
        break;
      case 'P/E1 INDUSTRY':
        color = getPEPercentageColor(scoreBoardData.pe1Industry);
        break;
      case 'P/E2 INDUSTRY':
        color = getPEPercentageColor(scoreBoardData.pe2Industry);
        break;
      case '(TB/S)/Price':
        color = getTBSPPriceColor(scoreBoardData.tbSPrice);
        break;
      case 'THEOENTRY':
        color = isTheoEntryGreen(entryExitValue, price) ? 'GREEN' : 'BLANK';
        break;
      case 'SMA(100)':
        color = getSMAColor(price, scoreBoardData.sma100);
        break;
      case 'SMA(200)':
        color = getSMAColor(price, scoreBoardData.sma200);
        break;
      case 'SMA CROSS':
        color = getSMACrossColorDetailed(scoreBoardData.smaCross);
        break;
    }

    const detailedColor = toDetailedColor(color);
    const factor = COLOR_FACTORS[detailedColor];
    totalPoints += metric.weight * factor;
  }

  // Score is already 0-100 (total weight is 100)
  // Round to 1 decimal
  return Math.round(Math.max(0, Math.min(100, totalPoints)) * 10) / 10;
}


```

## `src/utils/colorThresholds/__tests__/colorLogic.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import {
  getIRRColor,
  getMungerQualityScoreColor,
  getValueCreationColor,
  getRo40Color,
  getLeverageF2Color,
  getCashSdebtColor,
  getCurrentRatioColor,
  getPEPercentageColor,
  getTBSPPriceColor,
  getSMAColor,
  getSMACrossColorStandard,
  getSMACrossColorDetailed,
} from '../colorLogic';
import { createMockThresholdData } from '../../../test/helpers';

describe('colorThresholds colorLogic', () => {
  const thresholdData = [
    createMockThresholdData({
      industry: 'Test Industry',
      irr: 25,
      ro40Min: 0.15,
      ro40Max: 0.25,
      leverageF2Min: 2.0,
      leverageF2Max: 3.0,
      cashSdebtMin: 0.7,
      cashSdebtMax: 1.2,
      currentRatioMin: 1.1,
      currentRatioMax: 2.0,
    }),
  ];

  describe('getIRRColor', () => {
    it('returns GREEN when irr >= threshold', () => {
      expect(getIRRColor(30, 'Test Industry', thresholdData)).toBe('GREEN');
      expect(getIRRColor(25, 'Test Industry', thresholdData)).toBe('GREEN');
    });
    it('returns RED when irr < threshold', () => {
      expect(getIRRColor(20, 'Test Industry', thresholdData)).toBe('RED');
    });
    it('returns BLANK for null, NaN, empty industry', () => {
      expect(getIRRColor(null, 'Test Industry', thresholdData)).toBe('BLANK');
      expect(getIRRColor(30, '', thresholdData)).toBe('BLANK');
      expect(getIRRColor(30, 'Unknown Industry', thresholdData)).toBe('BLANK');
    });
  });

  describe('getMungerQualityScoreColor', () => {
    it('returns RED when < 40', () => {
      expect(getMungerQualityScoreColor(30)).toBe('RED');
    });
    it('returns ORANGE when 40-60', () => {
      expect(getMungerQualityScoreColor(50)).toBe('ORANGE');
    });
    it('returns GREEN when >= 60', () => {
      expect(getMungerQualityScoreColor(70)).toBe('GREEN');
    });
    it('returns BLANK for null', () => {
      expect(getMungerQualityScoreColor(null)).toBe('BLANK');
    });
  });

  describe('getValueCreationColor', () => {
    it('returns GREEN when >= 0', () => expect(getValueCreationColor(10)).toBe('GREEN'));
    it('returns RED when < 0', () => expect(getValueCreationColor(-5)).toBe('RED'));
    it('returns BLANK for null', () => expect(getValueCreationColor(null)).toBe('BLANK'));
  });

  describe('getRo40Color', () => {
    it('returns RED when <= min (15%)', () => {
      expect(getRo40Color(10, 'Test Industry', thresholdData)).toBe('RED');
    });
    it('returns GREEN when >= max (25%)', () => {
      expect(getRo40Color(30, 'Test Industry', thresholdData)).toBe('GREEN');
    });
    it('returns ORANGE when between min and max', () => {
      expect(getRo40Color(20, 'Test Industry', thresholdData)).toBe('ORANGE');
    });
    it('returns BLANK for unknown industry', () => {
      expect(getRo40Color(20, 'Unknown', thresholdData)).toBe('BLANK');
    });
  });

  describe('getLeverageF2Color', () => {
    it('returns GREEN when <= min (2.0)', () => {
      expect(getLeverageF2Color(1.5, 'Test Industry', thresholdData)).toBe('GREEN');
    });
    it('returns ORANGE when between min and max', () => {
      expect(getLeverageF2Color(2.5, 'Test Industry', thresholdData)).toBe('ORANGE');
    });
    it('returns RED when > max (3.0)', () => {
      expect(getLeverageF2Color(4.0, 'Test Industry', thresholdData)).toBe('RED');
    });
  });

  describe('getCashSdebtColor', () => {
    it('returns GREEN when isDivZero', () => {
      expect(getCashSdebtColor(null, true, 'Test Industry', thresholdData)).toBe('GREEN');
    });
    it('returns RED when <= min', () => {
      expect(getCashSdebtColor(0.5, false, 'Test Industry', thresholdData)).toBe('RED');
    });
    it('returns GREEN when >= max', () => {
      expect(getCashSdebtColor(1.5, false, 'Test Industry', thresholdData)).toBe('GREEN');
    });
    it('returns ORANGE when between', () => {
      expect(getCashSdebtColor(0.9, false, 'Test Industry', thresholdData)).toBe('ORANGE');
    });
  });

  describe('getCurrentRatioColor', () => {
    it('returns RED when < min', () => {
      expect(getCurrentRatioColor(0.8, 'Test Industry', thresholdData)).toBe('RED');
    });
    it('returns GREEN when min <= x < max', () => {
      expect(getCurrentRatioColor(1.5, 'Test Industry', thresholdData)).toBe('GREEN');
    });
    it('returns ORANGE when >= max', () => {
      expect(getCurrentRatioColor(2.5, 'Test Industry', thresholdData)).toBe('ORANGE');
    });
  });

  describe('getPEPercentageColor', () => {
    it('returns GREEN when <= 0', () => expect(getPEPercentageColor(-5)).toBe('GREEN'));
    it('returns RED when > 0', () => expect(getPEPercentageColor(5)).toBe('RED'));
  });

  describe('getTBSPPriceColor', () => {
    it('returns GREEN when >= 1.0', () => expect(getTBSPPriceColor(1.5)).toBe('GREEN'));
    it('returns RED when < 1.0', () => expect(getTBSPPriceColor(0.5)).toBe('RED'));
  });

  describe('getSMAColor', () => {
    it('returns GREEN when price > sma', () => expect(getSMAColor(100, 90)).toBe('GREEN'));
    it('returns RED when price < sma', () => expect(getSMAColor(80, 90)).toBe('RED'));
    it('returns ORANGE when price === sma', () => expect(getSMAColor(100, 100)).toBe('ORANGE'));
    it('returns BLANK for null', () => expect(getSMAColor(null, 90)).toBe('BLANK'));
  });

  describe('getSMACrossColorStandard', () => {
    it('returns GREEN for GOLDEN', () => expect(getSMACrossColorStandard('GOLDEN')).toBe('GREEN'));
    it('returns RED for DEATH', () => expect(getSMACrossColorStandard('DEATH')).toBe('RED'));
    it('returns BLANK for null', () => expect(getSMACrossColorStandard(null)).toBe('BLANK'));
  });

  describe('getSMACrossColorDetailed', () => {
    it('returns RED for GOLDEN (inverted)', () => expect(getSMACrossColorDetailed('GOLDEN')).toBe('RED'));
    it('returns GREEN for DEATH (inverted)', () => expect(getSMACrossColorDetailed('DEATH')).toBe('GREEN'));
  });
});

```

## `src/utils/colorThresholds/__tests__/cssMapping.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { colorTypeToCssClass, COLORS } from '../cssMapping';

describe('colorThresholds cssMapping', () => {
  describe('colorTypeToCssClass', () => {
    it('returns green for GREEN', () => {
      expect(colorTypeToCssClass('GREEN')).toBe(COLORS.green);
    });
    it('returns red for RED', () => {
      expect(colorTypeToCssClass('RED')).toBe(COLORS.red);
    });
    it('returns blue for ORANGE by default', () => {
      expect(colorTypeToCssClass('ORANGE')).toBe(COLORS.blue);
    });
    it('returns yellow for ORANGE when orangeVariant=yellow', () => {
      expect(colorTypeToCssClass('ORANGE', { orangeVariant: 'yellow' })).toBe(COLORS.yellow);
    });
    it('returns null for BLANK', () => {
      expect(colorTypeToCssClass('BLANK')).toBeNull();
    });
  });
});

```

## `src/utils/colorThresholds/__tests__/theoEntryLogic.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import {
  isRR1Green,
  isEntry1Green,
  isRR2GreenForTheoEntry,
  isEntry2Green,
  isTheoEntryGreen,
} from '../theoEntryLogic';
import { createMockEntryExitValues } from '../../../test/helpers';

describe('colorThresholds theoEntryLogic', () => {
  describe('isRR1Green', () => {
    it('returns true when RR1 >= 60%, price <= entry1*1.05', () => {
      const values = createMockEntryExitValues({ entry1: 100, exit1: 160 }); // RR1 = 60%
      expect(isRR1Green(values, 100)).toBe(true); // price 100 <= 105
    });
    it('returns false when RR1 < 60%', () => {
      const values = createMockEntryExitValues({ entry1: 100, exit1: 150 }); // RR1 = 50%
      expect(isRR1Green(values, 100)).toBe(false);
    });
    it('returns false when price > entry1*1.05', () => {
      const values = createMockEntryExitValues({ entry1: 100, exit1: 160 });
      expect(isRR1Green(values, 110)).toBe(false); // 110 > 105
    });
    it('returns false for undefined entryExitValues', () => {
      expect(isRR1Green(undefined, 100)).toBe(false);
    });
  });

  describe('isEntry1Green', () => {
    it('returns true when price <= entry1*1.05', () => {
      const values = createMockEntryExitValues({ entry1: 100 });
      expect(isEntry1Green(values, 100)).toBe(true);
    });
    it('returns false when price > entry1*1.05', () => {
      const values = createMockEntryExitValues({ entry1: 100 });
      expect(isEntry1Green(values, 110)).toBe(false);
    });
  });

  describe('isRR2GreenForTheoEntry', () => {
    it('returns true when RR2 > 60%, price <= entry2*1.05', () => {
      const values = createMockEntryExitValues({ entry2: 90, exit2: 150 }); // RR2 > 60%
      expect(isRR2GreenForTheoEntry(values, 90)).toBe(true);
    });
  });

  describe('isEntry2Green', () => {
    it('returns true when price <= entry2*1.05', () => {
      const values = createMockEntryExitValues({ entry2: 90 });
      expect(isEntry2Green(values, 90)).toBe(true);
    });
  });

  describe('isTheoEntryGreen', () => {
    it('returns true when RR1 path is green', () => {
      const values = createMockEntryExitValues({ entry1: 100, exit1: 160 });
      expect(isTheoEntryGreen(values, 100)).toBe(true);
    });
  });
});

```

## `src/utils/colorThresholds/colorLogic.ts`

```typescript
/**
 * Centralized color classification logic.
 * Used by calculateScore, calculateScoreDetailed, and ScoreBoardTable (via cssMapping).
 */

import type { ThresholdIndustryData } from '../../types/stock';
import {
  MUNGER_QUALITY_SCORE_RED_THRESHOLD,
  MUNGER_QUALITY_SCORE_GREEN_THRESHOLD,
  TB_S_PRICE_GREEN_THRESHOLD,
} from '../../config/constants';
import type { ColorType } from './types';

export function getIRRColor(
  irrValue: number | null,
  industry: string,
  thresholdData: ThresholdIndustryData[]
): ColorType {
  if (irrValue === null || !isFinite(irrValue)) return 'BLANK';
  if (!industry || industry.trim() === '') return 'BLANK';

  const threshold = thresholdData.find(
    (t) => t.industry.toLowerCase() === industry.toLowerCase()
  );
  if (!threshold) return 'BLANK';

  const { irr: irrThreshold } = threshold;
  return irrValue >= irrThreshold ? 'GREEN' : 'RED';
}

export function getMungerQualityScoreColor(mungerQualityScore: number | null): ColorType {
  if (mungerQualityScore === null || !isFinite(mungerQualityScore)) return 'BLANK';
  if (mungerQualityScore < MUNGER_QUALITY_SCORE_RED_THRESHOLD) return 'RED';
  if (
    mungerQualityScore >= MUNGER_QUALITY_SCORE_RED_THRESHOLD &&
    mungerQualityScore <= MUNGER_QUALITY_SCORE_GREEN_THRESHOLD
  )
    return 'ORANGE';
  return 'GREEN';
}

export function getValueCreationColor(valueCreation: number | null): ColorType {
  if (valueCreation === null || !isFinite(valueCreation)) return 'BLANK';
  return valueCreation >= 0 ? 'GREEN' : 'RED';
}

export function getRo40Color(
  ro40Value: number | null,
  industry: string,
  thresholdData: ThresholdIndustryData[]
): ColorType {
  if (ro40Value === null || !isFinite(ro40Value)) return 'BLANK';
  if (!industry || industry.trim() === '') return 'BLANK';

  const threshold = thresholdData.find(
    (t) => t.industry.toLowerCase() === industry.toLowerCase()
  );
  if (!threshold) return 'BLANK';

  const { ro40Min, ro40Max } = threshold;
  const ro40Decimal = ro40Value / 100;
  if (ro40Decimal <= ro40Min) return 'RED';
  if (ro40Decimal >= ro40Max) return 'GREEN';
  return 'ORANGE';
}

export function getLeverageF2Color(
  leverageF2Value: number | null,
  industry: string,
  thresholdData: ThresholdIndustryData[]
): ColorType {
  if (leverageF2Value === null || !isFinite(leverageF2Value)) return 'BLANK';
  if (!industry || industry.trim() === '') return 'BLANK';

  const threshold = thresholdData.find(
    (t) => t.industry.toLowerCase() === industry.toLowerCase()
  );
  if (!threshold) return 'BLANK';

  const { leverageF2Min, leverageF2Max } = threshold;
  if (leverageF2Value <= leverageF2Min) return 'GREEN';
  if (leverageF2Value <= leverageF2Max) return 'ORANGE';
  return 'RED';
}

export function getCashSdebtColor(
  cashSdebt: number | null,
  isDivZero: boolean,
  industry: string,
  thresholdData: ThresholdIndustryData[]
): ColorType {
  if (isDivZero) return 'GREEN';
  if (cashSdebt === null || !isFinite(cashSdebt)) return 'BLANK';
  if (!industry || industry.trim() === '') return 'BLANK';

  const threshold = thresholdData.find(
    (t) => t.industry.toLowerCase() === industry.toLowerCase()
  );
  if (!threshold) return 'BLANK';

  const { cashSdebtMin, cashSdebtMax } = threshold;
  if (cashSdebt <= cashSdebtMin) return 'RED';
  if (cashSdebt >= cashSdebtMax) return 'GREEN';
  return 'ORANGE';
}

export function getCurrentRatioColor(
  currentRatio: number | null,
  industry: string,
  thresholdData: ThresholdIndustryData[]
): ColorType {
  if (currentRatio === null || !isFinite(currentRatio)) return 'BLANK';
  if (!industry || industry.trim() === '') return 'BLANK';

  const threshold = thresholdData.find(
    (t) => t.industry.toLowerCase() === industry.toLowerCase()
  );
  if (!threshold) return 'BLANK';

  const { currentRatioMin, currentRatioMax } = threshold;
  if (currentRatio < currentRatioMin) return 'RED';
  if (currentRatio >= currentRatioMin && currentRatio < currentRatioMax) return 'GREEN';
  return 'ORANGE';
}

export function getPEPercentageColor(peIndustry: number | null): ColorType {
  if (peIndustry === null || !isFinite(peIndustry)) return 'BLANK';
  return peIndustry <= 0 ? 'GREEN' : 'RED';
}

export function getTBSPPriceColor(tbSPrice: number | null): ColorType {
  if (tbSPrice === null || !isFinite(tbSPrice)) return 'BLANK';
  return tbSPrice >= TB_S_PRICE_GREEN_THRESHOLD ? 'GREEN' : 'RED';
}

export function getSMAColor(
  price: number | null | undefined,
  smaValue: number | null
): ColorType {
  if (
    price === null ||
    price === undefined ||
    !isFinite(price) ||
    smaValue === null ||
    !isFinite(smaValue)
  ) {
    return 'BLANK';
  }
  if (price > smaValue) return 'GREEN';
  if (price < smaValue) return 'RED';
  return 'ORANGE';
}

/** Standard: GOLDEN=GREEN, DEATH=RED (used by calculateScore, ScoreBoardTable) */
export function getSMACrossColorStandard(smaCross: string | null): ColorType {
  if (!smaCross) return 'BLANK';
  const upper = smaCross.toUpperCase();
  if (upper === 'GOLDEN') return 'GREEN';
  if (upper === 'DEATH') return 'RED';
  return 'BLANK';
}

/** Detailed/inverted: GOLDEN=RED, DEATH=GREEN (used by calculateScoreDetailed) */
export function getSMACrossColorDetailed(smaCross: string | null): ColorType {
  if (!smaCross) return 'BLANK';
  const upper = smaCross.toUpperCase();
  if (upper.includes('GOLDEN')) return 'RED';
  if (upper.includes('DEATH')) return 'GREEN';
  return 'BLANK';
}

```

## `src/utils/colorThresholds/cssMapping.ts`

```typescript
/**
 * Maps ColorType to CSS class strings for ScoreBoardTable.
 */

import type { ColorType } from './types';

export const COLORS = {
  red: 'text-red-700 dark:text-red-400',
  green: 'text-green-700 dark:text-green-200',
  blue: 'text-blue-700 dark:text-blue-400',
  yellow: 'text-yellow-700 dark:text-yellow-300',
} as const;

export interface ColorToCssOptions {
  /** Use yellow for ORANGE (SMA equal case). Default: blue */
  orangeVariant?: 'blue' | 'yellow';
}

/**
 * Maps ColorType to CSS class string. Returns null for BLANK.
 */
export function colorTypeToCssClass(
  color: ColorType,
  options?: ColorToCssOptions
): string | null {
  if (color === 'BLANK') return null;
  if (color === 'GREEN') return COLORS.green;
  if (color === 'RED') return COLORS.red;
  if (color === 'ORANGE') {
    return options?.orangeVariant === 'yellow' ? COLORS.yellow : COLORS.blue;
  }
  return null;
}

```

## `src/utils/colorThresholds/index.ts`

```typescript
/**
 * Centralized color logic and thresholds.
 * Single source of truth for ScoreBoardTable, calculateScore, calculateScoreDetailed.
 */

export type { ColorType } from './types';
export * from './colorLogic';
export * from './theoEntryLogic';
export { COLORS, colorTypeToCssClass } from './cssMapping';
export type { ColorToCssOptions } from './cssMapping';

```

## `src/utils/colorThresholds/theoEntryLogic.ts`

```typescript
/**
 * TheoEntry (RR1/RR2) green logic.
 * Used by calculateScore, calculateScoreDetailed, ScoreBoardTable.
 */

import type { EntryExitValuesForScore } from '../../types/score';
import {
  PRICE_TOLERANCE_GREEN,
  RR1_GREEN_THRESHOLD_PERCENT,
} from '../../config/constants';

function calculateRR1(entry1: number, exit1: number): number | null {
  if (!entry1 || !exit1 || entry1 === 0) return null;
  const rr1 = ((exit1 - entry1) / entry1) * 100;
  return isNaN(rr1) || !isFinite(rr1) ? null : rr1;
}

function calculateRR2(entry2: number, exit2: number): number | null {
  if (!entry2 || !exit2 || entry2 === 0) return null;
  const rr2 = ((exit2 - entry2) / entry2) * 100;
  return isNaN(rr2) || !isFinite(rr2) ? null : rr2;
}

export function isRR1Green(
  entryExitValues: EntryExitValuesForScore | undefined,
  price: number | null | undefined
): boolean {
  if (!entryExitValues) return false;
  const entry1 = entryExitValues.entry1 || 0;
  const exit1 = entryExitValues.exit1 || 0;
  const rr1 = calculateRR1(entry1, exit1);
  return (
    rr1 !== null &&
    rr1 >= RR1_GREEN_THRESHOLD_PERCENT &&
    price !== null &&
    price !== undefined &&
    price > 0 &&
    entry1 > 0 &&
    price <= entry1 * PRICE_TOLERANCE_GREEN
  );
}

export function isEntry1Green(
  entryExitValues: EntryExitValuesForScore | undefined,
  price: number | null | undefined
): boolean {
  if (!entryExitValues) return false;
  const entry1 = entryExitValues.entry1 || 0;
  return (
    entry1 > 0 &&
    price !== null &&
    price !== undefined &&
    price > 0 &&
    price <= entry1 * PRICE_TOLERANCE_GREEN
  );
}

export function isRR2GreenForTheoEntry(
  entryExitValues: EntryExitValuesForScore | undefined,
  price: number | null | undefined
): boolean {
  if (!entryExitValues) return false;
  const entry2 = entryExitValues.entry2 || 0;
  const exit2 = entryExitValues.exit2 || 0;
  const rr2 = calculateRR2(entry2, exit2);
  return (
    rr2 !== null &&
    rr2 > RR1_GREEN_THRESHOLD_PERCENT &&
    price !== null &&
    price !== undefined &&
    price > 0 &&
    entry2 > 0 &&
    price <= entry2 * PRICE_TOLERANCE_GREEN
  );
}

export function isEntry2Green(
  entryExitValues: EntryExitValuesForScore | undefined,
  price: number | null | undefined
): boolean {
  if (!entryExitValues) return false;
  const entry2 = entryExitValues.entry2 || 0;
  return (
    entry2 > 0 &&
    price !== null &&
    price !== undefined &&
    price > 0 &&
    price <= entry2 * PRICE_TOLERANCE_GREEN
  );
}

export function isTheoEntryGreen(
  entryExitValues: EntryExitValuesForScore | undefined,
  price: number | null | undefined
): boolean {
  const rr1Path = isRR1Green(entryExitValues, price) && isEntry1Green(entryExitValues, price);
  const rr2Path =
    isRR2GreenForTheoEntry(entryExitValues, price) && isEntry2Green(entryExitValues, price);
  return rr1Path || rr2Path;
}

```

## `src/utils/colorThresholds/types.ts`

```typescript
/**
 * Color classification types for score calculation and UI.
 * Single source of truth for color logic across ScoreBoardTable, calculateScore, calculateScoreDetailed.
 */

/** Color classification for score calculation (GREEN=1.0, ORANGE=0.70, RED=0, BLANK=0) */
export type ColorType = 'GREEN' | 'ORANGE' | 'RED' | 'BLANK';

```

## `src/utils/dataChangeDetector.ts`

```typescript
/**
 * Data Change Detector
 * 
 * Utility functions to detect changes in data arrays and generate change summaries.
 */

export interface DataChangeSummary {
  added: number;
  removed: number;
  updated: number;
  total: number;
  hasSignificantChanges: boolean;
}

/**
 * Compare two data arrays and detect changes
 * 
 * @param oldData Previous data array
 * @param newData New data array
 * @param getKey Function to extract unique key from data item
 * @param threshold Minimum percentage change to consider significant (default: 5%)
 * @returns Summary of changes
 */
export function detectDataChanges<T>(
  oldData: T[],
  newData: T[],
  getKey: (item: T) => string,
  threshold: number = 0.05
): DataChangeSummary {
  if (!oldData || oldData.length === 0) {
    return {
      added: newData.length,
      removed: 0,
      updated: 0,
      total: newData.length,
      hasSignificantChanges: newData.length > 0,
    };
  }

  if (!newData || newData.length === 0) {
    return {
      added: 0,
      removed: oldData.length,
      updated: 0,
      total: 0,
      hasSignificantChanges: oldData.length > 0,
    };
  }

  // Create maps for efficient lookup
  const oldMap = new Map<string, T>();
  const newMap = new Map<string, T>();

  oldData.forEach((item) => {
    const key = getKey(item);
    oldMap.set(key, item);
  });

  newData.forEach((item) => {
    const key = getKey(item);
    newMap.set(key, item);
  });

  // Detect changes
  let added = 0;
  let removed = 0;
  let updated = 0;

  // Find added items
  newMap.forEach((item, key) => {
    if (!oldMap.has(key)) {
      added++;
    }
  });

  // Find removed items
  oldMap.forEach((item, key) => {
    if (!newMap.has(key)) {
      removed++;
    }
  });

  // Find updated items (same key but different content)
  newMap.forEach((newItem, key) => {
    const oldItem = oldMap.get(key);
    if (oldItem && JSON.stringify(oldItem) !== JSON.stringify(newItem)) {
      updated++;
    }
  });

  const total = newData.length;
  const totalChanges = added + removed + updated;
  const changePercentage = total > 0 ? totalChanges / total : 0;
  const hasSignificantChanges = changePercentage >= threshold || totalChanges > 10;

  return {
    added,
    removed,
    updated,
    total,
    hasSignificantChanges,
  };
}

/**
 * Generate a human-readable change summary
 */
export function formatChangeSummary(summary: DataChangeSummary): string {
  const parts: string[] = [];

  if (summary.added > 0) {
    parts.push(`${summary.added} ${summary.added === 1 ? 'item added' : 'items added'}`);
  }
  if (summary.removed > 0) {
    parts.push(`${summary.removed} ${summary.removed === 1 ? 'item removed' : 'items removed'}`);
  }
  if (summary.updated > 0) {
    parts.push(`${summary.updated} ${summary.updated === 1 ? 'item updated' : 'items updated'}`);
  }

  if (parts.length === 0) {
    return 'No changes detected';
  }

  return parts.join(', ');
}

```

## `src/utils/envValidator.ts`

```typescript
/**
 * Environment Variables Validator
 * 
 * Validates all required and optional environment variables at application startup.
 * Ensures proper configuration before the app initializes.
 */

import { logger } from './logger';

export interface EnvValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

/**
 * Validates Firebase API Key format
 * Firebase API keys start with "AIza" and are typically 39 characters long
 */
function validateFirebaseApiKey(apiKey: string | undefined): { isValid: boolean; error?: string } {
  if (!apiKey || apiKey === 'undefined' || apiKey === 'missing-api-key') {
    return { isValid: false, error: 'VITE_FIREBASE_API_KEY is missing or undefined' };
  }

  if (!apiKey.startsWith('AIza')) {
    return { isValid: false, error: 'VITE_FIREBASE_API_KEY format is invalid. Expected to start with "AIza"' };
  }

  if (apiKey.length < 39) {
    return { isValid: false, error: 'VITE_FIREBASE_API_KEY appears to be too short (expected at least 39 characters)' };
  }

  return { isValid: true };
}

/**
 * Validates Firebase Auth Domain format
 * Should match pattern: *.firebaseapp.com
 */
function validateFirebaseAuthDomain(authDomain: string | undefined): { isValid: boolean; error?: string } {
  if (!authDomain || authDomain === 'undefined' || authDomain === 'missing-auth-domain') {
    return { isValid: false, error: 'VITE_FIREBASE_AUTH_DOMAIN is missing or undefined' };
  }

  if (!authDomain.endsWith('.firebaseapp.com')) {
    return { isValid: false, error: 'VITE_FIREBASE_AUTH_DOMAIN format is invalid. Expected: *.firebaseapp.com' };
  }

  return { isValid: true };
}

/**
 * Validates Firebase Project ID
 */
function validateFirebaseProjectId(projectId: string | undefined): { isValid: boolean; error?: string } {
  if (!projectId || projectId === 'undefined' || projectId === 'missing-project-id') {
    return { isValid: false, error: 'VITE_FIREBASE_PROJECT_ID is missing or undefined' };
  }

  if (projectId.trim().length === 0) {
    return { isValid: false, error: 'VITE_FIREBASE_PROJECT_ID cannot be empty' };
  }

  return { isValid: true };
}

/**
 * Validates Firebase Storage Bucket format
 * 
 * **Why this format?**
 * - Firebase Storage Bucket must end with `.appspot.com` for standard Firebase projects
 * - Some projects may use custom domains, but `.appspot.com` is the default format
 * - This validation ensures the bucket URL is correctly formatted for Firebase Storage API
 * 
 * **Edge Case: Custom Storage Buckets**
 * - If using a custom bucket (not `.appspot.com`), validation will fail
 * - In such cases, the bucket URL should still work but validation warns about format
 * 
 * @param storageBucket - Storage bucket URL to validate
 * @returns Validation result with isValid flag and optional error message
 */
function validateFirebaseStorageBucket(storageBucket: string | undefined): { isValid: boolean; error?: string } {
  if (!storageBucket || storageBucket === 'undefined' || storageBucket === 'missing-storage-bucket') {
    return { isValid: false, error: 'VITE_FIREBASE_STORAGE_BUCKET is missing or undefined' };
  }

  // Validate format: should end with .appspot.com for standard Firebase projects
  // Also accept gs:// prefix (Firebase Storage format) or just the bucket name
  const normalizedBucket = storageBucket.replace(/^gs:\/\//, '').trim();
  
  // Check if it's a valid bucket format (ends with .appspot.com or is a valid bucket name)
  if (!normalizedBucket.endsWith('.appspot.com') && !/^[a-z0-9][a-z0-9\-_\.]*[a-z0-9]$/.test(normalizedBucket)) {
    return { 
      isValid: false, 
      error: `VITE_FIREBASE_STORAGE_BUCKET format is invalid. Expected: PROJECT_ID.appspot.com or gs://PROJECT_ID.appspot.com. Current value: ${storageBucket.substring(0, 50)}${storageBucket.length > 50 ? '...' : ''}` 
    };
  }

  // If it doesn't end with .appspot.com, warn but don't fail in development
  if (!normalizedBucket.endsWith('.appspot.com')) {
    // In development, allow custom buckets but warn
    if (import.meta.env.DEV) {
      // Return valid but could add a warning here if needed
      return { isValid: true };
    }
    // In production, be stricter
    return { 
      isValid: false, 
      error: 'VITE_FIREBASE_STORAGE_BUCKET format is invalid. Expected: *.appspot.com' 
    };
  }

  return { isValid: true };
}

/**
 * Validates Firebase Messaging Sender ID
 * Should be a numeric string
 */
function validateFirebaseMessagingSenderId(messagingSenderId: string | undefined): { isValid: boolean; error?: string } {
  if (!messagingSenderId || messagingSenderId === 'undefined' || messagingSenderId === 'missing-messaging-sender-id') {
    return { isValid: false, error: 'VITE_FIREBASE_MESSAGING_SENDER_ID is missing or undefined' };
  }

  if (!/^\d+$/.test(messagingSenderId)) {
    return { isValid: false, error: 'VITE_FIREBASE_MESSAGING_SENDER_ID must be a numeric string' };
  }

  return { isValid: true };
}

/**
 * Validates Firebase App ID format
 * Should match pattern: 1:SENDER_ID:web:APP_ID
 */
function validateFirebaseAppId(appId: string | undefined): { isValid: boolean; error?: string } {
  if (!appId || appId === 'undefined' || appId === 'missing-app-id') {
    return { isValid: false, error: 'VITE_FIREBASE_APP_ID is missing or undefined' };
  }

  if (!/^1:\d+:web:[a-zA-Z0-9]+$/.test(appId)) {
    return { isValid: false, error: 'VITE_FIREBASE_APP_ID format is invalid. Expected: 1:SENDER_ID:web:APP_ID' };
  }

  return { isValid: true };
}

/**
 * Validates Apps Script URL format (optional)
 * Should match: https://script.google.com/macros/s/SCRIPT_ID/exec
 */
function validateAppsScriptUrl(url: string | undefined): { isValid: boolean; warning?: string } {
  if (!url || url.trim().length === 0) {
    return { isValid: true }; // Optional, so missing is OK
  }

  if (url.includes('/library/')) {
    return { 
      isValid: false, 
      warning: 'VITE_APPS_SCRIPT_URL appears to be a library deployment URL. Expected Web App URL format: https://script.google.com/macros/s/SCRIPT_ID/exec' 
    };
  }

  if (!url.includes('script.google.com/macros/s/') || !url.endsWith('/exec')) {
    return { 
      isValid: false, 
      warning: 'VITE_APPS_SCRIPT_URL format may be incorrect. Expected: https://script.google.com/macros/s/SCRIPT_ID/exec' 
    };
  }

  return { isValid: true };
}

/**
 * Validates optional numeric environment variables
 */
function validateOptionalNumeric(
  value: string | undefined,
  varName: string,
  defaultValue: number,
  min?: number,
  max?: number
): { isValid: boolean; warning?: string } {
  if (!value || value.trim().length === 0) {
    return { isValid: true }; // Using default is OK
  }

  const numValue = parseInt(value, 10);
  if (isNaN(numValue)) {
    return { isValid: false, warning: `${varName} must be a valid number. Using default: ${defaultValue}` };
  }

  if (min !== undefined && numValue < min) {
    return { isValid: false, warning: `${varName} (${numValue}) is below minimum (${min}). Using default: ${defaultValue}` };
  }

  if (max !== undefined && numValue > max) {
    return { isValid: false, warning: `${varName} (${numValue}) exceeds maximum (${max}). Using default: ${defaultValue}` };
  }

  return { isValid: true };
}

/**
 * Validates optional boolean environment variables
 */
function validateOptionalBoolean(
  value: string | undefined,
  varName: string,
  defaultValue: boolean
): { isValid: boolean; warning?: string } {
  if (!value || value.trim().length === 0) {
    return { isValid: true }; // Using default is OK
  }

  const lowerValue = value.toLowerCase().trim();
  if (lowerValue !== 'true' && lowerValue !== 'false') {
    return { isValid: false, warning: `${varName} must be "true" or "false". Using default: ${defaultValue}` };
  }

  return { isValid: true };
}

/**
 * Main function to validate all environment variables
 */
export function validateEnvironmentVariables(): EnvValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  const isProduction = import.meta.env.PROD;

  // Required Firebase variables
  const apiKeyResult = validateFirebaseApiKey(import.meta.env.VITE_FIREBASE_API_KEY);
  if (!apiKeyResult.isValid && apiKeyResult.error) {
    errors.push(apiKeyResult.error);
  }

  const authDomainResult = validateFirebaseAuthDomain(import.meta.env.VITE_FIREBASE_AUTH_DOMAIN);
  if (!authDomainResult.isValid && authDomainResult.error) {
    errors.push(authDomainResult.error);
  }

  const projectIdResult = validateFirebaseProjectId(import.meta.env.VITE_FIREBASE_PROJECT_ID);
  if (!projectIdResult.isValid && projectIdResult.error) {
    errors.push(projectIdResult.error);
  }

  const storageBucketResult = validateFirebaseStorageBucket(import.meta.env.VITE_FIREBASE_STORAGE_BUCKET);
  if (!storageBucketResult.isValid && storageBucketResult.error) {
    errors.push(storageBucketResult.error);
  }

  const messagingSenderIdResult = validateFirebaseMessagingSenderId(import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID);
  if (!messagingSenderIdResult.isValid && messagingSenderIdResult.error) {
    errors.push(messagingSenderIdResult.error);
  }

  const appIdResult = validateFirebaseAppId(import.meta.env.VITE_FIREBASE_APP_ID);
  if (!appIdResult.isValid && appIdResult.error) {
    errors.push(appIdResult.error);
  }

  // Optional variables - warnings only
  const appsScriptUrlResult = validateAppsScriptUrl(import.meta.env.VITE_APPS_SCRIPT_URL);
  if (!appsScriptUrlResult.isValid && appsScriptUrlResult.warning) {
    warnings.push(appsScriptUrlResult.warning);
  }

  // Optional numeric variables
  const fetchTimeoutResult = validateOptionalNumeric(
    import.meta.env.VITE_FETCH_TIMEOUT_SECONDS,
    'VITE_FETCH_TIMEOUT_SECONDS',
    30,
    5,
    300
  );
  if (!fetchTimeoutResult.isValid && fetchTimeoutResult.warning) {
    warnings.push(fetchTimeoutResult.warning);
  }

  const cacheTtlResult = validateOptionalNumeric(
    import.meta.env.VITE_CACHE_DEFAULT_TTL_MINUTES,
    'VITE_CACHE_DEFAULT_TTL_MINUTES',
    20,
    1,
    1440
  );
  if (!cacheTtlResult.isValid && cacheTtlResult.warning) {
    warnings.push(cacheTtlResult.warning);
  }

  const freshThresholdResult = validateOptionalNumeric(
    import.meta.env.VITE_CACHE_FRESH_THRESHOLD_MINUTES,
    'VITE_CACHE_FRESH_THRESHOLD_MINUTES',
    5,
    1,
    60
  );
  if (!freshThresholdResult.isValid && freshThresholdResult.warning) {
    warnings.push(freshThresholdResult.warning);
  }

  const pollIntervalResult = validateOptionalNumeric(
    import.meta.env.VITE_DELTA_SYNC_POLL_MINUTES,
    'VITE_DELTA_SYNC_POLL_MINUTES',
    15,
    1,
    1440
  );
  if (!pollIntervalResult.isValid && pollIntervalResult.warning) {
    warnings.push(pollIntervalResult.warning);
  }

  // Optional boolean variables
  const deltaSyncResult = validateOptionalBoolean(
    import.meta.env.VITE_DELTA_SYNC_ENABLED,
    'VITE_DELTA_SYNC_ENABLED',
    true
  );
  if (!deltaSyncResult.isValid && deltaSyncResult.warning) {
    warnings.push(deltaSyncResult.warning);
  }

  const cacheWarmingResult = validateOptionalBoolean(
    import.meta.env.VITE_CACHE_WARMING_ENABLED,
    'VITE_CACHE_WARMING_ENABLED',
    true
  );
  if (!cacheWarmingResult.isValid && cacheWarmingResult.warning) {
    warnings.push(cacheWarmingResult.warning);
  }

  // Log results
  if (errors.length > 0) {
    const errorMessage = `Environment variable validation failed:\n${errors.join('\n')}`;
    logger.error('Environment Variables Validation', new Error(errorMessage), {
      component: 'envValidator',
      errors,
      isProduction,
    });

    // In production, throw error to prevent app from starting with invalid config
    if (isProduction) {
      throw new Error(
        `${errorMessage}\n\n` +
        `Please configure these environment variables in:\n` +
        `- Local development: .env.local file\n` +
        `- Production: Vercel Dashboard → Settings → Environment Variables\n\n` +
        `See env.template for required variables.`
      );
    }
  }

  if (warnings.length > 0) {
    logger.warn('Environment variable warnings', {
      component: 'envValidator',
      warnings,
    });
    warnings.forEach((warning) => {
      logger.warn(warning, { component: 'envValidator' });
    });
  }

  if (errors.length === 0 && warnings.length === 0) {
    logger.info('All environment variables validated successfully', {
      component: 'envValidator',
    });
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings,
  };
}

```

## `src/utils/errorHandler.ts`

```typescript
/**
 * Error Handler Utility
 * 
 * Provides standardized error handling patterns for consistent error formatting,
 * logging, and user-facing error messages throughout the application.
 */

import { logger } from './logger';

export interface ErrorContext {
  operation?: string;
  component?: string;
  additionalInfo?: Record<string, unknown>;
}

export interface FormattedError {
  message: string;
  userMessage: string;
  context: ErrorContext;
  originalError: unknown;
}

/**
 * Extracts a readable error message from various error types
 */
function extractErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    return error.message || error.name || 'An error occurred';
  }
  if (typeof error === 'string') {
    return error || 'An error occurred';
  }
  if (error && typeof error === 'object') {
    if ('message' in error && typeof (error as { message: unknown }).message === 'string') {
      return (error as { message: string }).message;
    }
    if ('error' in error && typeof (error as { error: unknown }).error === 'string') {
      return (error as { error: string }).error;
    }
    // Try to stringify for debugging
    try {
      const stringified = JSON.stringify(error);
      if (stringified && stringified !== '{}') {
        return `Error: ${stringified}`;
      }
    } catch {
      // Ignore JSON.stringify errors
    }
  }
  return 'An unknown error occurred';
}

/**
 * Formats error for user display
 * Provides user-friendly error messages with actionable guidance
 */
function formatUserMessage(error: unknown, context?: ErrorContext): string {
  const message = extractErrorMessage(error);
  
  // Handle specific error types with user-friendly messages
  if (message.includes('CORS') || message.includes('cross-origin')) {
    return 'Connection error: Unable to fetch data. Please check your internet connection and try again.';
  }
  
  if (message.includes('timeout') || message.includes('408')) {
    return 'Request timeout: The server took too long to respond. Please try again.';
  }
  
  if (message.includes('404') || message.includes('not found')) {
    return 'Resource not found: The requested data could not be found.';
  }
  
  if (message.includes('401') || message.includes('403') || message.includes('unauthorized')) {
    return 'Access denied: You do not have permission to access this resource.';
  }
  
  if (message.includes('QuotaExceededError') || message.includes('quota')) {
    return 'Storage limit reached: Please clear some browser data and try again.';
  }
  
  if (message.includes('NetworkError') || message.includes('Failed to fetch')) {
    return 'Network error: Unable to connect to the server. Please check your internet connection.';
  }
  
  if (message.includes('Firebase') || message.includes('firebase')) {
    return 'Configuration error: Please check your Firebase configuration.';
  }
  
  // Generic fallback
  if (context?.operation) {
    return `Failed to ${context.operation}. ${message}`;
  }
  
  return message;
}

/**
 * Formats an error with context for consistent error handling
 * 
 * Extracts error messages from various error types (Error, string, objects)
 * and provides both technical and user-friendly messages. This ensures
 * consistent error handling throughout the application.
 * 
 * @param error - The error to format (Error, string, or unknown)
 * @param context - Optional context about where/why the error occurred
 * @returns Formatted error object with message, userMessage, and context
 * 
 * @example
 * ```typescript
 * try {
 *   await fetchData();
 * } catch (error) {
 *   const formatted = formatError(error, {
 *     operation: 'fetch stock data',
 *     component: 'useScoreBoardData',
 *     additionalInfo: { sheetName: 'DashBoard' }
 *   });
 *   console.error(formatted.message); // Technical message
 *   showToast(formatted.userMessage); // User-friendly message
 * }
 * ```
 */
export function formatError(error: unknown, context?: ErrorContext): FormattedError {
  const message = extractErrorMessage(error);
  const userMessage = formatUserMessage(error, context);
  
  return {
    message,
    userMessage,
    context: context || {},
    originalError: error,
  };
}

/**
 * Logs an error consistently using the centralized logger
 * 
 * Formats the error and logs it with appropriate context. This ensures
 * all errors are logged in a consistent format for debugging and monitoring.
 * 
 * @param error - The error to log
 * @param context - Optional context about where/why the error occurred
 * 
 * @example
 * ```typescript
 * try {
 *   await saveUserData(data);
 * } catch (error) {
 *   logError(error, {
 *     operation: 'save user data',
 *     component: 'UserProfile',
 *     additionalInfo: { userId: user.id }
 *   });
 *   // Error is automatically logged with context
 * }
 * ```
 */
export function logError(error: unknown, context?: ErrorContext): void {
  const formatted = formatError(error, context);
  
  // Use centralized logger instead of console.error
  logger.error(
    formatted.message,
    error instanceof Error ? error : new Error(formatted.message),
    {
      component: context?.component,
      operation: context?.operation,
      ...formatted.context.additionalInfo,
    }
  );
}

/**
 * Creates an error handler function for async operations
 * 
 * Returns a reusable error handler function that automatically logs
 * and formats errors with the provided context. Useful for creating
 * consistent error handling in async functions.
 * 
 * @param context - Context about the operation
 * @returns A function that handles errors and returns a formatted error
 * 
 * @example
 * ```typescript
 * const handleTransformError = createErrorHandler({
 *   operation: 'transform data',
 *   component: 'dataTransformers'
 * });
 * 
 * try {
 *   return transformData(rawData);
 * } catch (error) {
 *   const formatted = handleTransformError(error);
 *   throw new Error(formatted.message);
 * }
 * ```
 */
export function createErrorHandler(context: ErrorContext) {
  return (error: unknown): FormattedError => {
    logError(error, context);
    return formatError(error, context);
  };
}

/**
 * Wraps an async function with standardized error handling
 * 
 * Automatically catches errors, logs them, and re-throws formatted errors.
 * This provides a clean way to add error handling to existing async functions
 * without modifying their implementation.
 * 
 * @param fn - The async function to wrap
 * @param context - Context about the operation
 * @returns A function that catches errors and returns them in a standardized format
 * 
 * @example
 * ```typescript
 * const fetchWithErrorHandling = withErrorHandling(
 *   async (url: string) => {
 *     const response = await fetch(url);
 *     return response.json();
 *   },
 *   { operation: 'fetch data', component: 'apiService' }
 * );
 * 
 * // Errors are automatically logged and formatted
 * const data = await fetchWithErrorHandling('/api/stocks');
 * ```
 */
export function withErrorHandling<T extends (...args: unknown[]) => Promise<unknown>>(
  fn: T,
  context: ErrorContext
): T {
  return (async (...args: Parameters<T>) => {
    try {
      return await fn(...args);
    } catch (error: unknown) {
      logError(error, context);
      throw formatError(error, context);
    }
  }) as T;
}

/**
 * Checks if an error is a specific type
 */
export function isErrorType(error: unknown, type: string): boolean {
  if (error instanceof Error) {
    return error.name === type || error.message.includes(type);
  }
  if (typeof error === 'string') {
    return error.includes(type);
  }
  return false;
}

/**
 * Checks if an error is a network error
 */
export function isNetworkError(error: unknown): boolean {
  return isErrorType(error, 'NetworkError') ||
         isErrorType(error, 'Failed to fetch') ||
         isErrorType(error, 'CORS') ||
         isErrorType(error, 'timeout');
}

/**
 * Checks if an error is a quota/storage error
 */
export function isQuotaError(error: unknown): boolean {
  return isErrorType(error, 'QuotaExceededError') ||
         isErrorType(error, 'quota');
}

```

## `src/utils/filterEvaluator.ts`

```typescript
/**
 * Filter Evaluator
 * 
 * Utility functions to evaluate filter groups with AND/OR logic.
 */

import { FilterValues, FilterGroup, FilterOperator } from '../types/filters';

/**
 * Check if a single filter matches an item
 */
function matchesFilter<T extends Record<string, unknown>>(
  item: T,
  filterKey: string,
  filterValue: string | number | { min?: number; max?: number } | boolean | null
): boolean {
  if (filterValue === null || filterValue === '' || filterValue === undefined) {
    return true; // No filter applied
  }

  const itemValue = item[filterKey];

  // Handle null/undefined values
  if (itemValue === null || itemValue === undefined) {
    return false;
  }

  // Handle number range filter
  if (typeof filterValue === 'object' && filterValue !== null && ('min' in filterValue || 'max' in filterValue)) {
    const numValue = typeof itemValue === 'number' ? itemValue : parseFloat(String(itemValue));
    if (isNaN(numValue)) return false;
    
    const { min, max } = filterValue as { min?: number; max?: number };
    if (min !== undefined && numValue < min) return false;
    if (max !== undefined && numValue > max) return false;
    return true;
  }

  // Handle boolean filter
  if (typeof filterValue === 'boolean') {
    return Boolean(itemValue) === filterValue;
  }

  // Handle number filter
  if (typeof filterValue === 'number') {
    const numValue = typeof itemValue === 'number' ? itemValue : parseFloat(String(itemValue));
    return !isNaN(numValue) && numValue === filterValue;
  }

  // Handle text/string filter
  if (typeof filterValue === 'string') {
    return String(itemValue).toLowerCase().includes(filterValue.toLowerCase());
  }

  return true;
}

/**
 * Evaluate a filter group against an item
 */
function evaluateFilterGroup<T extends Record<string, unknown>>(
  item: T,
  group: FilterGroup
): boolean {
  if (group.filters.length === 0) {
    return true; // Empty group matches everything
  }

  if (group.operator === 'AND') {
    // All filters in group must match
    return group.filters.every((filter) => {
      return Object.entries(filter).every(([key, value]) => {
        return matchesFilter(item, key, value);
      });
    });
  } else {
    // OR: At least one filter in group must match
    return group.filters.some((filter) => {
      return Object.entries(filter).some(([key, value]) => {
        return matchesFilter(item, key, value);
      });
    });
  }
}

/**
 * Evaluate filter groups against an item
 */
export function evaluateFilterGroups<T extends Record<string, unknown>>(
  item: T,
  groups: FilterGroup[],
  groupOperator: FilterOperator = 'AND'
): boolean {
  if (groups.length === 0) {
    return true; // No groups means no filtering
  }

  if (groupOperator === 'AND') {
    // All groups must match
    return groups.every((group) => evaluateFilterGroup(item, group));
  } else {
    // OR: At least one group must match
    return groups.some((group) => evaluateFilterGroup(item, group));
  }
}

/**
 * Convert legacy FilterValues to FilterGroup format
 */
export function convertToFilterGroups(filterValues: FilterValues): FilterGroup[] {
  if (!filterValues || Object.keys(filterValues).length === 0) {
    return [];
  }

  // Convert single filter set to a single group with AND operator
  return [
    {
      id: 'group-1',
      operator: 'AND',
      filters: [filterValues],
    },
  ];
}

```

## `src/utils/inputValidator.ts`

```typescript
/**
 * Input Validator
 * 
 * Centralized input validation utilities for filters, search queries,
 * and EntryExit values. Provides sanitization and validation functions.
 */

export interface ValidationResult {
  isValid: boolean;
  error?: string;
}

export interface NumberRange {
  min?: number;
  max?: number;
}

/**
 * Validates text input with configurable constraints
 * 
 * @param value - Text value to validate
 * @param options - Validation options
 * @param options.maxLength - Maximum allowed length (default: 200)
 * @param options.minLength - Minimum required length (default: 0)
 * @param options.required - Whether field is required (default: false)
 * @param options.allowEmpty - Whether empty string is allowed (default: true)
 * @returns Validation result with isValid flag and optional error message
 * 
 * @example
 * ```typescript
 * const result = validateTextInput('hello', { maxLength: 10, required: true });
 * if (!result.isValid) {
 *   console.error(result.error);
 * }
 * ```
 */
export function validateTextInput(
  value: string,
  options: {
    maxLength?: number;
    minLength?: number;
    required?: boolean;
    allowEmpty?: boolean;
  } = {}
): ValidationResult {
  const { maxLength = 200, minLength = 0, required = false, allowEmpty = true } = options;

  // Handle empty values
  if (!value || value.trim().length === 0) {
    if (required) {
      return { isValid: false, error: 'This field is required' };
    }
    if (!allowEmpty) {
      return { isValid: false, error: 'This field cannot be empty' };
    }
    return { isValid: true };
  }

  // Check length
  if (value.length > maxLength) {
    return { isValid: false, error: `Text must be no more than ${maxLength} characters` };
  }

  if (value.length < minLength) {
    return { isValid: false, error: `Text must be at least ${minLength} characters` };
  }

  return { isValid: true };
}

/**
 * Validates number input with range and format constraints
 * 
 * @param value - Number value to validate (can be number, string, null, or undefined)
 * @param options - Validation options
 * @param options.min - Minimum allowed value
 * @param options.max - Maximum allowed value
 * @param options.required - Whether field is required (default: false)
 * @param options.allowDecimal - Whether decimal values are allowed (default: true)
 * @param options.maxDecimals - Maximum decimal places (default: 2)
 * @returns Validation result with isValid flag and optional error message
 * 
 * @example
 * ```typescript
 * const result = validateNumberInput(42.5, { min: 0, max: 100, maxDecimals: 2 });
 * if (!result.isValid) {
 *   console.error(result.error);
 * }
 * ```
 */
export function validateNumberInput(
  value: number | string | null | undefined,
  options: {
    min?: number;
    max?: number;
    required?: boolean;
    allowDecimal?: boolean;
    maxDecimals?: number;
  } = {}
): ValidationResult {
  const { min, max, required = false, allowDecimal = true, maxDecimals = 2 } = options;

  // Handle null/undefined
  if (value === null || value === undefined || value === '') {
    if (required) {
      return { isValid: false, error: 'This field is required' };
    }
    return { isValid: true };
  }

  // Convert to number
  const numValue = typeof value === 'string' ? parseFloat(value) : value;

  // Check if valid number
  if (isNaN(numValue)) {
    return { isValid: false, error: 'Must be a valid number' };
  }

  // Check if integer when decimals not allowed
  if (!allowDecimal && !Number.isInteger(numValue)) {
    return { isValid: false, error: 'Must be a whole number' };
  }

  // Check decimal places
  if (allowDecimal && maxDecimals !== undefined) {
    const decimalPlaces = (numValue.toString().split('.')[1] || '').length;
    if (decimalPlaces > maxDecimals) {
      return { isValid: false, error: `Maximum ${maxDecimals} decimal place${maxDecimals !== 1 ? 's' : ''} allowed` };
    }
  }

  // Check range
  if (min !== undefined && numValue < min) {
    return { isValid: false, error: `Value must be at least ${min}` };
  }

  if (max !== undefined && numValue > max) {
    return { isValid: false, error: `Value must be no more than ${max}` };
  }

  return { isValid: true };
}

/**
 * Validates number range (min and max values)
 * 
 * Ensures both min and max are valid numbers and that min <= max.
 * 
 * @param range - Range object with optional min and max properties
 * @param options - Validation options
 * @param options.min - Global minimum allowed value
 * @param options.max - Global maximum allowed value
 * @param options.required - Whether range is required (default: false)
 * @returns Validation result with isValid flag and optional error message
 * 
 * @example
 * ```typescript
 * const result = validateNumberRange(
 *   { min: 10, max: 100 },
 *   { min: 0, max: 1000 }
 * );
 * if (!result.isValid) {
 *   console.error(result.error);
 * }
 * ```
 */
export function validateNumberRange(
  range: NumberRange | null | undefined,
  options: {
    min?: number;
    max?: number;
    required?: boolean;
  } = {}
): ValidationResult {
  const { min: globalMin, max: globalMax, required = false } = options;

  // Handle null/undefined
  if (!range || (range.min === undefined && range.max === undefined)) {
    if (required) {
      return { isValid: false, error: 'Range is required' };
    }
    return { isValid: true };
  }

  // Validate min if provided
  if (range.min !== undefined) {
    const minResult = validateNumberInput(range.min, { min: globalMin, max: globalMax });
    if (!minResult.isValid) {
      return { isValid: false, error: `Minimum value: ${minResult.error}` };
    }
  }

  // Validate max if provided
  if (range.max !== undefined) {
    const maxResult = validateNumberInput(range.max, { min: globalMin, max: globalMax });
    if (!maxResult.isValid) {
      return { isValid: false, error: `Maximum value: ${maxResult.error}` };
    }
  }

  // Validate that min <= max
  if (range.min !== undefined && range.max !== undefined && range.min > range.max) {
    return { isValid: false, error: 'Minimum value must be less than or equal to maximum value' };
  }

  return { isValid: true };
}

/**
 * Validates select input against allowed options
 */
export function validateSelectInput(
  value: string | number | null | undefined,
  allowedOptions: Array<string | number>,
  options: {
    required?: boolean;
  } = {}
): ValidationResult {
  const { required = false } = options;

  // Handle empty values
  if (value === null || value === undefined || value === '') {
    if (required) {
      return { isValid: false, error: 'Please select a value' };
    }
    return { isValid: true };
  }

  // Check if value is in allowed options
  if (!allowedOptions.includes(value)) {
    return { isValid: false, error: 'Invalid selection' };
  }

  return { isValid: true };
}

/**
 * Sanitizes search query by removing dangerous characters and limiting length
 * 
 * Prevents XSS and regex injection attacks by:
 * - Removing HTML tags (<, >)
 * - Escaping HTML entities (&, ", ')
 * - Escaping regex special characters
 * - Limiting query length
 * 
 * @param query - Search query string to sanitize
 * @param maxLength - Maximum allowed length (default: 200)
 * @returns Sanitized query string safe for use in regex and HTML
 * 
 * @example
 * ```typescript
 * const userInput = '<script>alert("xss")</script>';
 * const safe = sanitizeSearchQuery(userInput);
 * // Returns: sanitized string safe for regex/HTML
 * ```
 */
export function sanitizeSearchQuery(query: string, maxLength: number = 200): string {
  if (!query || typeof query !== 'string') {
    return '';
  }

  // Trim whitespace
  let sanitized = query.trim();

  // Limit length
  if (sanitized.length > maxLength) {
    sanitized = sanitized.substring(0, maxLength);
  }

  // Escape special regex characters to prevent regex injection
  // But keep basic search functionality (letters, numbers, spaces, common punctuation)
  // Remove or escape potentially dangerous characters
  sanitized = sanitized
    .replace(/[<>]/g, '') // Remove < and > to prevent HTML injection
    .replace(/&/g, '&amp;') // Escape & to prevent HTML entities
    .replace(/"/g, '&quot;') // Escape quotes
    .replace(/'/g, '&#x27;') // Escape single quotes
    // Keep regex special chars but escape them for safe regex use
    .replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // Escape regex special characters

  return sanitized;
}

/**
 * Validates EntryExit value for entry/exit price fields
 * 
 * Validates different field types:
 * - entry1, entry2, exit1, exit2: Numeric values (0-1,000,000, max 2 decimals)
 * - currency: Must be one of allowed currency codes (USD, EUR, SEK, etc.)
 * - dateOfUpdate: Must be valid date string in YYYY-MM-DD format
 * 
 * @param field - Field name to validate
 * @param value - Value to validate (number, string, null, or undefined)
 * @returns Validation result with isValid flag and optional error message
 * 
 * @example
 * ```typescript
 * const result = validateEntryExitValue('entry1', 175.50);
 * if (!result.isValid) {
 *   console.error(result.error);
 * }
 * 
 * const dateResult = validateEntryExitValue('dateOfUpdate', '2024-01-15');
 * ```
 */
export function validateEntryExitValue(
  field: 'entry1' | 'entry2' | 'exit1' | 'exit2' | 'currency' | 'dateOfUpdate',
  value: number | string | null | undefined
): ValidationResult {
  // Handle null/undefined for optional fields
  if (value === null || value === undefined) {
    if (field === 'dateOfUpdate') {
      return { isValid: true }; // dateOfUpdate can be null
    }
    if (field === 'currency') {
      return { isValid: true }; // Will default to USD
    }
    return { isValid: true }; // Entry/exit can be 0 (empty)
  }

  // Validate numeric fields (entry1, entry2, exit1, exit2)
  if (field === 'entry1' || field === 'entry2' || field === 'exit1' || field === 'exit2') {
    return validateNumberInput(value, {
      min: 0,
      max: 1000000, // Maximum reasonable price
      allowDecimal: true,
      maxDecimals: 2,
      required: false,
    });
  }

  // Validate currency
  if (field === 'currency') {
    const allowedCurrencies = ['USD', 'EUR', 'SEK', 'DKK', 'NOK', 'GBP', 'AUD', 'CAD', 'NZD'];
    return validateSelectInput(value, allowedCurrencies, { required: false });
  }

  // Validate dateOfUpdate
  if (field === 'dateOfUpdate') {
    if (typeof value !== 'string') {
      return { isValid: false, error: 'Date must be a string' };
    }

    // Validate date format: YYYY-MM-DD
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(value)) {
      return { isValid: false, error: 'Date must be in format YYYY-MM-DD' };
    }

    // Validate that it's a valid date
    const date = new Date(value);
    if (isNaN(date.getTime())) {
      return { isValid: false, error: 'Invalid date' };
    }

    // Check that the date string matches the parsed date (prevents invalid dates like 2024-13-45)
    const [year, month, day] = value.split('-').map(Number);
    if (
      date.getFullYear() !== year ||
      date.getMonth() + 1 !== month ||
      date.getDate() !== day
    ) {
      return { isValid: false, error: 'Invalid date' };
    }

    return { isValid: true };
  }

  return { isValid: true };
}

/**
 * Validates filter name for saved filters
 * 
 * Ensures filter names are safe and within length limits.
 * Prevents dangerous characters that could cause XSS or other issues.
 * 
 * @param name - Filter name to validate
 * @returns Validation result with isValid flag and optional error message
 * 
 * @example
 * ```typescript
 * const result = validateFilterName('My Custom Filter');
 * if (!result.isValid) {
 *   console.error(result.error);
 * }
 * ```
 */
export function validateFilterName(name: string): ValidationResult {
  if (!name || name.trim().length === 0) {
    return { isValid: false, error: 'Filter name cannot be empty' };
  }

  if (name.length > 50) {
    return { isValid: false, error: 'Filter name must be no more than 50 characters' };
  }

  // Prevent dangerous characters in filter names
  if (/[<>"']/.test(name)) {
    return { isValid: false, error: 'Filter name contains invalid characters' };
  }

  return { isValid: true };
}

```

## `src/utils/lazyWithRetry.ts`

```typescript
import { lazy, ComponentType, LazyExoticComponent } from 'react';
import { logger } from './logger';

/**
 * Wraps React.lazy() with retry logic for dynamic imports.
 * Handles transient "Failed to fetch dynamically imported module" errors
 * that can occur in Vite dev (HMR, network blips, etc.).
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function lazyWithRetry<T extends ComponentType<any>>(
  importFn: () => Promise<{ default: T }>,
  componentName = 'module',
  retries = 2,
  intervalMs = 500
): LazyExoticComponent<T> {
  return lazy(async () => {
    let lastErr: unknown;
    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        return await importFn();
      } catch (e) {
        lastErr = e;
        if (attempt < retries) {
          logger.warn(`Retrying dynamic import for ${componentName} (attempt ${attempt + 1}/${retries})`, {
            component: 'lazyWithRetry',
            operation: 'import',
            error: e,
          });
          await new Promise((r) => setTimeout(r, intervalMs));
        }
      }
    }
    throw lastErr;
  }) as LazyExoticComponent<T>;
}

```

## `src/utils/logger.ts`

```typescript
/**
 * Centralized Logger Utility
 * 
 * Provides a centralized logging system with different log levels (debug, info, warn, error).
 * Supports environment-based filtering and prepares for integration with error tracking services
 * like Sentry or LogRocket in production.
 */

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export interface LogContext {
  component?: string;
  operation?: string;
  [key: string]: unknown;
}

interface LoggerConfig {
  level: LogLevel;
  enableInProduction: boolean;
}

// Log levels in order of severity (higher number = more severe)
const LOG_LEVELS: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};

// Determine current log level based on environment
function getLogLevel(): LogLevel {
  if (import.meta.env.DEV) {
    return 'debug'; // Show all logs in development
  }
  // In production, only show warnings and errors
  return 'warn';
}

// Check if a log level should be output
function shouldLog(level: LogLevel, config: LoggerConfig): boolean {
  if (!config.enableInProduction && import.meta.env.PROD) {
    return false;
  }
  return LOG_LEVELS[level] >= LOG_LEVELS[config.level];
}

// Format log message with context
function formatMessage(message: string, context?: LogContext): string {
  if (!context || Object.keys(context).length === 0) {
    return message;
  }
  
  const contextStr = Object.entries(context)
    .filter(([_, value]) => value !== undefined && value !== null)
    .map(([key, value]) => {
      if (typeof value === 'object') {
        try {
          return `${key}: ${JSON.stringify(value)}`;
        } catch {
          return `${key}: [object]`;
        }
      }
      return `${key}: ${value}`;
    })
    .join(', ');
  
  return contextStr ? `${message} (${contextStr})` : message;
}

// Send error to external tracking service (prepared for future integration)
function sendToTrackingService(level: LogLevel, message: string, context?: LogContext, error?: Error): void {
  // In production, this can be extended to send to Sentry, LogRocket, etc.
  // For now, we just prepare the structure
  if (import.meta.env.PROD && level === 'error') {
    // Future: Send to Sentry/LogRocket
    // Example: Sentry.captureException(error, { extra: context });
  }
}

class Logger {
  private config: LoggerConfig;

  constructor() {
    this.config = {
      level: getLogLevel(),
      enableInProduction: false, // Disable verbose logs in production by default
    };
  }

  /**
   * Configure logger settings
   * 
   * Allows runtime configuration of log levels and production behavior.
   * Useful for enabling debug logs in production for troubleshooting.
   * 
   * @param config - Partial configuration to merge with existing settings
   * 
   * @example
   * ```typescript
   * // Enable debug logs in production for troubleshooting
   * logger.configure({ level: 'debug', enableInProduction: true });
   * 
   * // Set to only show errors
   * logger.configure({ level: 'error' });
   * ```
   */
  configure(config: Partial<LoggerConfig>): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * Log debug messages (only in development)
   * 
   * Debug logs are only shown in development mode. Use for detailed
   * information useful during development but too verbose for production.
   * 
   * @param message - Debug message
   * @param context - Optional context information
   * 
   * @example
   * ```typescript
   * logger.debug('Cache hit', { component: 'cacheService', key: 'scoreBoard' });
   * logger.debug('Processing row', { rowIndex: 5, totalRows: 100 });
   * ```
   */
  debug(message: string, context?: LogContext): void {
    if (shouldLog('debug', this.config)) {
      console.debug(`[DEBUG] ${formatMessage(message, context)}`);
    }
  }

  /**
   * Log informational messages
   * 
   * Use for important events that should be visible in production logs,
   * such as successful operations, state changes, or significant events.
   * 
   * @param message - Info message
   * @param context - Optional context information
   * 
   * @example
   * ```typescript
   * logger.info('Data loaded successfully', { 
   *   component: 'useScoreBoardData', 
   *   count: 150 
   * });
   * logger.info('User logged in', { userId: user.id });
   * ```
   */
  info(message: string, context?: LogContext): void {
    if (shouldLog('info', this.config)) {
      console.info(`[INFO] ${formatMessage(message, context)}`);
    }
  }

  /**
   * Log warning messages
   * 
   * Use for situations that are not errors but should be noted, such as
   * fallback behavior, deprecated API usage, or non-critical issues.
   * Warnings are sent to tracking services in production.
   * 
   * @param message - Warning message
   * @param context - Optional context information
   * 
   * @example
   * ```typescript
   * logger.warn('Cache expired, fetching fresh data', { 
   *   component: 'cacheService', 
   *   key: 'scoreBoard' 
   * });
   * logger.warn('Using fallback proxy', { proxy: 'corsproxy.io' });
   * ```
   */
  warn(message: string, context?: LogContext): void {
    if (shouldLog('warn', this.config)) {
      console.warn(`[WARN] ${formatMessage(message, context)}`);
    }
    sendToTrackingService('warn', message, context);
  }

  /**
   * Log error messages
   * 
   * Use for actual errors that need attention. Errors are always logged
   * and sent to tracking services in production for monitoring.
   * 
   * @param message - Error message
   * @param error - Optional Error object or error value
   * @param context - Optional context information
   * 
   * @example
   * ```typescript
   * try {
   *   await fetchData();
   * } catch (error) {
   *   logger.error('Failed to fetch data', error, {
   *     component: 'fetchService',
   *     operation: 'fetchJSONData',
   *     url: apiUrl
   *   });
   * }
   * ```
   */
  error(message: string, error?: Error | unknown, context?: LogContext): void {
    if (shouldLog('error', this.config)) {
      const errorMessage = error instanceof Error ? error.message : String(error || message);
      console.error(`[ERROR] ${formatMessage(message, context)}`, error || '');
    }
    
    // Always send errors to tracking service in production
    const errorObj = error instanceof Error ? error : new Error(message);
    sendToTrackingService('error', message, context, errorObj);
  }

  /**
   * Log with explicit level
   */
  log(level: LogLevel, message: string, error?: Error | unknown, context?: LogContext): void {
    switch (level) {
      case 'debug':
        this.debug(message, context);
        break;
      case 'info':
        this.info(message, context);
        break;
      case 'warn':
        this.warn(message, context);
        break;
      case 'error':
        this.error(message, error, context);
        break;
    }
  }
}

// Export singleton instance
export const logger = new Logger();

// Export logger class for testing purposes
export { Logger };

```

## `src/utils/printUtils.ts`

```typescript
/**
 * Utility functions for print functionality
 */

export interface PrintOptions {
  tableName?: string;
  includeHeader?: boolean;
  includeFooter?: boolean;
  filterInfo?: string;
  rowCount?: number;
  selectedColumns?: string[];
}

/**
 * Formats a date for print headers
 */
export function formatPrintDate(): string {
  return new Date().toLocaleString('sv-SE', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
  });
}

/**
 * Triggers print dialog for the current page
 */
export function printPage(): void {
  window.print();
}

/**
 * Creates a print preview window
 */
export function createPrintPreview(
  tableElement: HTMLElement | null,
  options: PrintOptions = {}
): Window | null {
  if (!tableElement) {
    console.warn('Table element not found for printing');
    return null;
  }

  const {
    tableName = 'Table',
    includeHeader = true,
    includeFooter = true,
    filterInfo,
    rowCount,
  } = options;

  // Clone the table to avoid modifying the original
  const clonedTable = tableElement.cloneNode(true) as HTMLElement;

  // Remove non-printable elements
  const noPrintElements = clonedTable.querySelectorAll('.no-print, button, [role="button"]');
  noPrintElements.forEach((el) => el.remove());

  // Get the table HTML
  const tableHTML = clonedTable.outerHTML;

  // Create a new window for printing
  const printWindow = window.open('', '_blank', 'width=1200,height=800');
  if (!printWindow) {
    console.warn('Could not open print window. Please allow popups.');
    return null;
  }

  // Create print document
  const printDoc = printWindow.document;
  printDoc.open();
  printDoc.write(`
    <!DOCTYPE html>
    <html>
      <head>
        <title>${tableName} - ${formatPrintDate()}</title>
        <meta charset="UTF-8">
        <style>
          @page {
            margin: 1.5cm;
            size: A4 landscape;
          }
          
          @media print {
            body {
              margin: 0;
              padding: 0;
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
              font-size: 9pt;
              color: #000;
              background: #fff;
            }
            
            .print-header {
              margin-bottom: 15px;
              padding-bottom: 10px;
              border-bottom: 2px solid #000;
            }
            
            .print-header h1 {
              margin: 0 0 5px 0;
              font-size: 16pt;
              font-weight: bold;
            }
            
            .print-header .meta {
              font-size: 9pt;
              color: #333;
              margin-top: 5px;
            }
            
            .print-footer {
              margin-top: 15px;
              padding-top: 10px;
              border-top: 1px solid #ccc;
              font-size: 8pt;
              color: #666;
              text-align: center;
            }
            
            table {
              width: 100%;
              border-collapse: collapse;
              margin: 0;
              page-break-inside: auto;
            }
            
            thead {
              display: table-header-group;
            }
            
            tbody {
              display: table-row-group;
            }
            
            tr {
              page-break-inside: avoid;
              page-break-after: auto;
            }
            
            th, td {
              padding: 6px 8px;
              text-align: left;
              border: 1px solid #ddd;
              font-size: 8pt;
              word-wrap: break-word;
            }
            
            th {
              background-color: #f5f5f5 !important;
              font-weight: bold;
              color: #000 !important;
              position: sticky;
              top: 0;
            }
            
            td {
              background-color: #fff !important;
              color: #000 !important;
            }
            
            /* Remove shadows and backgrounds */
            * {
              box-shadow: none !important;
              background-image: none !important;
            }
            
            /* Hide non-essential elements */
            button, .no-print {
              display: none !important;
            }
            
            /* Ensure full width */
            table {
              min-width: 100% !important;
            }
            
            /* Print-specific optimizations */
            .print-optimized {
              page-break-after: avoid;
            }
          }
          
          @media screen {
            body {
              padding: 20px;
              background: #f5f5f5;
            }
            
            .print-header {
              background: #fff;
              padding: 15px;
              border-radius: 4px;
              margin-bottom: 20px;
            }
            
            .print-footer {
              background: #fff;
              padding: 10px;
              border-radius: 4px;
              margin-top: 20px;
            }
            
            table {
              background: #fff;
              box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
          }
        </style>
      </head>
      <body>
        ${includeHeader ? `
        <div class="print-header">
          <h1>${tableName}</h1>
          <div class="meta">
            <div>Printed: ${formatPrintDate()}</div>
            ${filterInfo ? `<div>Filters: ${filterInfo}</div>` : ''}
            ${rowCount !== undefined ? `<div>Rows: ${rowCount}</div>` : ''}
          </div>
        </div>
        ` : ''}
        ${tableHTML}
        ${includeFooter ? `
        <div class="print-footer">
          <div>${tableName} - Page <span class="page-number"></span></div>
          <div>Printed on ${formatPrintDate()}</div>
        </div>
        ` : ''}
      </body>
    </html>
  `);
  printDoc.close();

  return printWindow;
}

/**
 * Prints a specific table element with enhanced options
 * @param tableElement The table element to print
 * @param tableName Optional name for the print header
 * @param options Additional print options
 */
export function printTable(
  tableElement: HTMLElement | null,
  tableName?: string,
  options: PrintOptions = {}
): void {
  const printWindow = createPrintPreview(tableElement, {
    ...options,
    tableName: tableName || options.tableName || 'Table',
  });

  if (!printWindow) {
    return;
  }

  // Wait for content to load, then print
  printWindow.onload = () => {
    setTimeout(() => {
      printWindow.print();
    }, 250);
  };
}

```

## `src/utils/rateLimiter.ts`

```typescript
/**
 * Rate Limiter
 * 
 * Client-side rate limiting utility to prevent excessive API calls.
 * Tracks requests per operation/endpoint and enforces limits.
 */

import { logger } from './logger';

export interface RateLimitConfig {
  maxRequests: number; // Maximum number of requests
  windowMs: number; // Time window in milliseconds
}

export interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  resetAt: number; // Timestamp when the limit resets
  error?: string;
}

class RateLimiter {
  private requests: Map<string, number[]> = new Map();
  private config: RateLimitConfig;

  constructor(config: RateLimitConfig = { maxRequests: 10, windowMs: 60000 }) {
    this.config = config;
  }

  /**
   * Checks if a request is allowed for the given key
   * 
   * @param key - Unique identifier for the rate limit (e.g., endpoint name, operation type)
   * @returns Rate limit result indicating if request is allowed
   */
  checkLimit(key: string): RateLimitResult {
    const now = Date.now();
    const windowStart = now - this.config.windowMs;

    // Get or create request history for this key
    let requestTimes = this.requests.get(key) || [];

    // Remove old requests outside the time window
    requestTimes = requestTimes.filter((timestamp) => timestamp > windowStart);

    // Check if limit is exceeded
    if (requestTimes.length >= this.config.maxRequests) {
      const oldestRequest = requestTimes[0];
      const resetAt = oldestRequest + this.config.windowMs;

      logger.warn('Rate limit exceeded', {
        component: 'rateLimiter',
        key,
        requests: requestTimes.length,
        maxRequests: this.config.maxRequests,
        resetAt: new Date(resetAt).toISOString(),
      });

      return {
        allowed: false,
        remaining: 0,
        resetAt,
        error: `Rate limit exceeded. Maximum ${this.config.maxRequests} requests per ${this.config.windowMs / 1000} seconds. Try again after ${new Date(resetAt).toLocaleTimeString()}`,
      };
    }

    // Add current request
    requestTimes.push(now);
    this.requests.set(key, requestTimes);

    const remaining = this.config.maxRequests - requestTimes.length;
    const oldestRequest = requestTimes[0];
    const resetAt = oldestRequest + this.config.windowMs;

    return {
      allowed: true,
      remaining,
      resetAt,
    };
  }

  /**
   * Resets the rate limit for a specific key
   */
  reset(key: string): void {
    this.requests.delete(key);
  }

  /**
   * Resets all rate limits
   */
  resetAll(): void {
    this.requests.clear();
  }

  /**
   * Gets current rate limit status for a key
   */
  getStatus(key: string): RateLimitResult {
    const now = Date.now();
    const windowStart = now - this.config.windowMs;

    const requestTimes = this.requests.get(key) || [];
    const recentRequests = requestTimes.filter((timestamp) => timestamp > windowStart);

    const remaining = Math.max(0, this.config.maxRequests - recentRequests.length);
    const resetAt = recentRequests.length > 0
      ? recentRequests[0] + this.config.windowMs
      : now;

    return {
      allowed: recentRequests.length < this.config.maxRequests,
      remaining,
      resetAt,
    };
  }
}

// Default rate limiter instance
// Configuration: 10 requests per 60 seconds per operation
const defaultRateLimiter = new RateLimiter({
  maxRequests: 10,
  windowMs: 60000, // 60 seconds
});

// Separate rate limiters for different operation types
const rateLimiters: Map<string, RateLimiter> = new Map();

/**
 * Gets or creates a rate limiter for a specific operation type
 */
function getRateLimiter(operationType: string = 'default'): RateLimiter {
  if (!rateLimiters.has(operationType)) {
    // Different limits for different operations
    const configs: Record<string, RateLimitConfig> = {
      default: { maxRequests: 10, windowMs: 60000 }, // 10 per minute
      fetch: { maxRequests: 20, windowMs: 60000 }, // 20 per minute for data fetching
      search: { maxRequests: 30, windowMs: 60000 }, // 30 per minute for searches
      save: { maxRequests: 10, windowMs: 60000 }, // 10 per minute for saves
    };

    const config = configs[operationType] || configs.default;
    rateLimiters.set(operationType, new RateLimiter(config));
  }

  return rateLimiters.get(operationType)!;
}

/**
 * Checks if a request is allowed for the given operation
 * 
 * Implements client-side rate limiting to prevent excessive API calls.
 * Different operation types have different limits:
 * - fetch: 20 requests per minute
 * - search: 30 requests per minute
 * - save: 10 requests per minute
 * - default: 10 requests per minute
 * 
 * @param operationType - Type of operation (e.g., 'fetch', 'search', 'save')
 * @param key - Unique identifier for the specific request (e.g., endpoint URL, search query)
 * @returns Rate limit result with allowed status, remaining requests, and reset time
 * 
 * @example
 * ```typescript
 * const result = checkRateLimit('fetch', 'scoreBoard');
 * if (!result.allowed) {
 *   throw new Error(result.error);
 * }
 * // Proceed with request
 * await fetchData();
 * ```
 */
export function checkRateLimit(operationType: string = 'default', key: string = 'default'): RateLimitResult {
  const limiter = getRateLimiter(operationType);
  const fullKey = `${operationType}:${key}`;
  return limiter.checkLimit(fullKey);
}

/**
 * Resets rate limit for a specific operation and key
 */
export function resetRateLimit(operationType: string = 'default', key: string = 'default'): void {
  const limiter = getRateLimiter(operationType);
  const fullKey = `${operationType}:${key}`;
  limiter.reset(fullKey);
}

/**
 * Resets all rate limits
 */
export function resetAllRateLimits(): void {
  rateLimiters.forEach((limiter) => limiter.resetAll());
  defaultRateLimiter.resetAll();
}

/**
 * Gets current rate limit status
 */
export function getRateLimitStatus(operationType: string = 'default', key: string = 'default'): RateLimitResult {
  const limiter = getRateLimiter(operationType);
  const fullKey = `${operationType}:${key}`;
  return limiter.getStatus(fullKey);
}

export { RateLimiter };

```

## `src/utils/serviceWorkerRegistration.ts`

```typescript
/**
 * Service Worker Registration
 * 
 * Handles registration and updates of the Service Worker.
 */

import { logger } from './logger';

const SW_URL = '/sw.js';
const SW_VERSION = 'v1';

/**
 * Register Service Worker
 */
export async function registerServiceWorker(): Promise<ServiceWorkerRegistration | null> {
  if (!('serviceWorker' in navigator)) {
    logger.debug('Service Workers are not supported in this browser', {
      component: 'serviceWorkerRegistration',
      operation: 'register',
    });
    return null;
  }

  try {
    const registration = await navigator.serviceWorker.register(SW_URL, {
      scope: '/',
    });

    logger.info('Service Worker registered successfully', {
      component: 'serviceWorkerRegistration',
      operation: 'register',
      scope: registration.scope,
    });

    // Handle updates
    registration.addEventListener('updatefound', () => {
      const newWorker = registration.installing;
      if (!newWorker) return;

      newWorker.addEventListener('statechange', () => {
        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
          // New service worker available
          logger.info('New Service Worker available', {
            component: 'serviceWorkerRegistration',
            operation: 'update',
          });
          // Optionally notify user or auto-update
          // For now, we'll just log it
        }
      });
    });

    // Check for updates periodically (every hour)
    setInterval(() => {
      registration.update();
    }, 60 * 60 * 1000);

    return registration;
  } catch (error) {
    logger.error(
      'Service Worker registration failed',
      error instanceof Error ? error : new Error(String(error)),
      { component: 'serviceWorkerRegistration', operation: 'register' }
    );
    return null;
  }
}

/**
 * Unregister Service Worker (for development/testing)
 */
export async function unregisterServiceWorker(): Promise<boolean> {
  if (!('serviceWorker' in navigator)) {
    return false;
  }

  try {
    const registration = await navigator.serviceWorker.ready;
    const unregistered = await registration.unregister();
    
    if (unregistered) {
      logger.info('Service Worker unregistered', {
        component: 'serviceWorkerRegistration',
        operation: 'unregister',
      });
    }
    
    return unregistered;
  } catch (error) {
    logger.error(
      'Service Worker unregistration failed',
      error instanceof Error ? error : new Error(String(error)),
      { component: 'serviceWorkerRegistration', operation: 'unregister' }
    );
    return false;
  }
}

/**
 * Send message to Service Worker
 */
export function sendMessageToServiceWorker(message: unknown): void {
  if (!('serviceWorker' in navigator) || !navigator.serviceWorker.controller) {
    return;
  }

  navigator.serviceWorker.controller.postMessage(message);
}

const SYNC_REQUEST_TIMEOUT_MS = 45_000;

/**
 * Request background sync from Service Worker
 * @param sheetName - Sheet to sync (e.g. DashBoard, SMA)
 * @param apiBaseUrl - Apps Script API base URL
 * @param token - Optional API token (e.g. VITE_APPS_SCRIPT_TOKEN)
 */
export function requestBackgroundSync(
  sheetName: string,
  apiBaseUrl: string,
  token?: string
): Promise<unknown> {
  return new Promise((resolve, reject) => {
    if (!('serviceWorker' in navigator) || !navigator.serviceWorker.controller) {
      reject(new Error('Service Worker not available'));
      return;
    }

    let settled = false;
    const messageChannel = new MessageChannel();

    const timeoutId = setTimeout(() => {
      if (settled) return;
      settled = true;
      messageChannel.port1.onmessage = null;
      reject(new Error(`Background sync timeout for ${sheetName} (${SYNC_REQUEST_TIMEOUT_MS}ms)`));
    }, SYNC_REQUEST_TIMEOUT_MS);

    messageChannel.port1.onmessage = (event) => {
      if (settled) return;
      if (event.data?.type === 'SYNC_COMPLETE') {
        settled = true;
        clearTimeout(timeoutId);
        messageChannel.port1.onmessage = null;
        resolve(event.data);
      } else if (event.data?.type === 'SYNC_ERROR') {
        settled = true;
        clearTimeout(timeoutId);
        messageChannel.port1.onmessage = null;
        reject(new Error(event.data.error));
      }
    };

    const payload: { type: string; sheetName: string; apiBaseUrl: string; token?: string } = {
      type: 'SYNC_REQUEST',
      sheetName,
      apiBaseUrl,
    };
    if (token) payload.token = token;

    navigator.serviceWorker.controller.postMessage(payload, [messageChannel.port2]);
  });
}

const CLEAR_API_CACHE_TIMEOUT_MS = 5_000;

/**
 * Request Service Worker to clear API cache (used before Refresh Now refetch).
 * Resolves immediately if SW is not available.
 */
export function requestClearApiCache(): Promise<void> {
  return new Promise((resolve) => {
    if (!('serviceWorker' in navigator) || !navigator.serviceWorker.controller) {
      resolve();
      return;
    }

    let settled = false;
    const messageChannel = new MessageChannel();

    const timeoutId = setTimeout(() => {
      if (settled) return;
      settled = true;
      messageChannel.port1.onmessage = null;
      logger.warn('Clear API cache timeout; continuing with refetch', {
        component: 'serviceWorkerRegistration',
        operation: 'requestClearApiCache',
      });
      resolve();
    }, CLEAR_API_CACHE_TIMEOUT_MS);

    messageChannel.port1.onmessage = (event) => {
      if (settled) return;
      if (event.data?.type === 'CLEAR_API_CACHE_DONE') {
        settled = true;
        clearTimeout(timeoutId);
        messageChannel.port1.onmessage = null;
        resolve();
      }
    };

    navigator.serviceWorker.controller.postMessage(
      { type: 'CLEAR_API_CACHE' },
      [messageChannel.port2]
    );
  });
}

```

## `src/utils/typeGuards.ts`

```typescript
/**
 * Type Guards Utility
 * 
 * Provides reusable type guard functions for runtime type checking
 * throughout the application.
 */

/**
 * Type guard to check if a value is a non-null object
 * 
 * Narrowing example:
 * ```typescript
 * const value: unknown = { key: 'value' };
 * if (isObject(value)) {
 *   // TypeScript now knows value is Record<string, unknown>
 *   console.log(value.key); // OK
 * }
 * ```
 */
export function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}

/**
 * Type guard to check if a value is an array
 * 
 * Narrowing example:
 * ```typescript
 * const value: unknown = [1, 2, 3];
 * if (isArray(value)) {
 *   // TypeScript now knows value is unknown[]
 *   value.forEach(item => console.log(item)); // OK
 * }
 * ```
 */
export function isArray(value: unknown): value is unknown[] {
  return Array.isArray(value);
}

/**
 * Type guard to check if a value is a string
 * 
 * Narrowing example:
 * ```typescript
 * const value: unknown = 'hello';
 * if (isString(value)) {
 *   // TypeScript now knows value is string
 *   console.log(value.toUpperCase()); // OK
 * }
 * ```
 */
export function isString(value: unknown): value is string {
  return typeof value === 'string';
}

/**
 * Type guard to check if a value is a valid number (excludes NaN and Infinity)
 * 
 * Narrowing example:
 * ```typescript
 * const value: unknown = 42;
 * if (isNumber(value)) {
 *   // TypeScript now knows value is number (and not NaN/Infinity)
 *   console.log(value * 2); // OK
 * }
 * ```
 */
export function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value) && isFinite(value);
}

/**
 * Type guard to check if a value is a boolean
 */
export function isBoolean(value: unknown): value is boolean {
  return typeof value === 'boolean';
}

/**
 * Type guard to check if a value is null or undefined
 */
export function isNullOrUndefined(value: unknown): value is null | undefined {
  return value === null || value === undefined;
}

/**
 * Type guard to check if a value is a valid number (including 0)
 */
export function isValidNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value) && isFinite(value);
}

/**
 * Type guard to check if a value is a non-empty string
 */
export function isNonEmptyString(value: unknown): value is string {
  return typeof value === 'string' && value.trim().length > 0;
}

/**
 * Type guard to check if an object has a specific key
 */
export function hasKey<T extends string>(
  obj: unknown,
  key: T
): obj is Record<T, unknown> {
  return isObject(obj) && key in obj;
}

/**
 * Type guard to check if an object has all specified keys
 */
export function hasKeys<T extends string>(
  obj: unknown,
  keys: T[]
): obj is Record<T, unknown> {
  if (!isObject(obj)) return false;
  return keys.every(key => key in obj);
}

/**
 * DataRow interface - represents a row from Google Sheets
 */
export interface DataRow {
  [key: string]: string | number | undefined;
}

/**
 * Type guard to check if a value is a DataRow (object with string keys)
 * 
 * DataRow represents a row from Google Sheets where values can be strings,
 * numbers, or undefined. Used throughout the data transformation pipeline.
 * 
 * Narrowing example:
 * ```typescript
 * const value: unknown = { ticker: 'AAPL', price: 175.50 };
 * if (isDataRow(value)) {
 *   // TypeScript now knows value is DataRow
 *   console.log(value.ticker); // OK
 * }
 * ```
 */
export function isDataRow(value: unknown): value is DataRow {
  if (!isObject(value)) return false;
  
  // Check that all values are string, number, or undefined
  for (const key in value) {
    const val = value[key];
    if (val !== undefined && typeof val !== 'string' && typeof val !== 'number') {
      return false;
    }
  }
  
  return true;
}

/**
 * Type guard to check if a value is an array of DataRow
 * 
 * Narrowing example:
 * ```typescript
 * const value: unknown = [{ ticker: 'AAPL' }, { ticker: 'MSFT' }];
 * if (isDataRowArray(value)) {
 *   // TypeScript now knows value is DataRow[]
 *   value.forEach(row => console.log(row.ticker)); // OK
 * }
 * ```
 */
export function isDataRowArray(value: unknown): value is DataRow[] {
  if (!isArray(value)) return false;
  return value.every(item => isDataRow(item));
}

/**
 * Type guard to check if a value is a 2D array (array of arrays)
 */
export function is2DArray(value: unknown): value is unknown[][] {
  if (!isArray(value)) return false;
  return value.every(item => Array.isArray(item));
}

/**
 * Type guard to check if a value is a valid timestamp (number or Date)
 */
export function isValidTimestamp(value: unknown): value is number | Date {
  if (value instanceof Date) return true;
  if (typeof value === 'number') {
    return value > 0 && isFinite(value);
  }
  return false;
}

/**
 * Type guard to check if a value is a valid URL string
 */
export function isValidUrl(value: unknown): value is string {
  if (!isString(value)) return false;
  try {
    new URL(value);
    return true;
  } catch {
    return false;
  }
}

/**
 * Type guard to check if a value is a valid email string
 */
export function isValidEmail(value: unknown): value is string {
  if (!isString(value)) return false;
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(value);
}

/**
 * Type guard to check if a value is a valid JSON string
 */
export function isValidJsonString(value: unknown): value is string {
  if (!isString(value)) return false;
  try {
    JSON.parse(value);
    return true;
  } catch {
    return false;
  }
}

/**
 * Type guard to check if a value is a valid Map
 */
export function isMap<K, V>(value: unknown): value is Map<K, V> {
  return value instanceof Map;
}

/**
 * Type guard to check if a value is a valid Set
 */
export function isSet<T>(value: unknown): value is Set<T> {
  return value instanceof Set;
}

/**
 * Type guard to check if a value is a function
 */
export function isFunction(value: unknown): value is (...args: unknown[]) => unknown {
  return typeof value === 'function';
}

/**
 * Type guard to check if a value is a Promise
 */
export function isPromise<T>(value: unknown): value is Promise<T> {
  return value instanceof Promise || (isObject(value) && 'then' in value && isFunction((value as { then: unknown }).then));
}

/**
 * Type guard to check if a value is a valid Date object
 */
export function isValidDate(value: unknown): value is Date {
  return value instanceof Date && !isNaN(value.getTime());
}

/**
 * Type guard to check if a value is a valid positive integer
 */
export function isPositiveInteger(value: unknown): value is number {
  return Number.isInteger(value) && (value as number) > 0;
}

/**
 * Type guard to check if a value is a valid non-negative integer
 */
export function isNonNegativeInteger(value: unknown): value is number {
  return Number.isInteger(value) && (value as number) >= 0;
}

/**
 * Type guard to check if a value is within a numeric range
 */
export function isInRange(value: unknown, min: number, max: number): value is number {
  return isNumber(value) && value >= min && value <= max;
}

/**
 * Type guard to check if a value is a non-null BenjaminGrahamData-like object
 */
export function isBenjaminGrahamData(value: unknown): value is { companyName: string; ticker: string; price: number | null; benjaminGraham: number | null } {
  return (
    isObject(value) &&
    isString(value.companyName) &&
    isString(value.ticker) &&
    (isNumber(value.price) || value.price === null) &&
    (isNumber(value.benjaminGraham) || value.benjaminGraham === null)
  );
}

/**
 * Type guard to check if a value is a valid currency string
 */
export function isCurrencyString(value: unknown): value is string {
  return isString(value) && value.length > 0 && value.length <= 10;
}

/**
 * Type guard to check if a value is a CacheEntry
 */
export function isCacheEntry<T>(value: unknown): value is { data: T; timestamp: number; ttl: number } {
  return (
    isObject(value) &&
    'data' in value &&
    isNumber(value.timestamp) &&
    isNumber(value.ttl)
  );
}

/**
 * Type guard to check if a value is a DeltaCacheEntry
 */
export function isDeltaCacheEntry<T>(value: unknown): value is { data: T; version: number; timestamp?: number; ttl?: number } {
  return (
    isObject(value) &&
    'data' in value &&
    isNumber(value.version) &&
    (value.timestamp === undefined || isNumber(value.timestamp)) &&
    (value.ttl === undefined || isNumber(value.ttl))
  );
}

```

## `src/utils/xssProtection.ts`

```typescript
/**
 * XSS Protection Utilities
 * 
 * Provides functions to escape HTML and prevent XSS attacks.
 * Note: React automatically escapes content by default, but these utilities
 * are useful for manual string manipulation or when working with dangerouslySetInnerHTML.
 */

/**
 * Escapes HTML special characters to prevent XSS attacks
 * 
 * @param text - The text to escape
 * @returns Escaped text safe for HTML rendering
 */
export function escapeHtml(text: string | null | undefined): string {
  if (text === null || text === undefined) {
    return '';
  }

  const str = String(text);
  
  return str
    .replace(/&/g, '&amp;')   // Must be first to avoid double-escaping
    .replace(/</g, '&lt;')    // Less than
    .replace(/>/g, '&gt;')    // Greater than
    .replace(/"/g, '&quot;')   // Double quote
    .replace(/'/g, '&#x27;')  // Single quote (apostrophe)
    .replace(/\//g, '&#x2F;'); // Forward slash (prevents closing tags)
}

/**
 * Escapes HTML attributes to prevent XSS in attribute values
 * 
 * @param text - The text to escape for use in HTML attributes
 * @returns Escaped text safe for HTML attribute values
 */
export function escapeHtmlAttribute(text: string | null | undefined): string {
  if (text === null || text === undefined) {
    return '';
  }

  const str = String(text);
  
  return str
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

/**
 * Sanitizes a string for use in JavaScript/JSON contexts
 * Escapes special characters that could break out of string literals
 * 
 * @param text - The text to sanitize
 * @returns Sanitized text safe for JavaScript string literals
 */
export function escapeJavaScript(text: string | null | undefined): string {
  if (text === null || text === undefined) {
    return '';
  }

  const str = String(text);
  
  return str
    .replace(/\\/g, '\\\\')   // Backslash
    .replace(/'/g, "\\'")     // Single quote
    .replace(/"/g, '\\"')     // Double quote
    .replace(/\n/g, '\\n')    // Newline
    .replace(/\r/g, '\\r')   // Carriage return
    .replace(/\t/g, '\\t')   // Tab
    .replace(/\f/g, '\\f')   // Form feed
    .replace(/\v/g, '\\v');  // Vertical tab
}

/**
 * Validates that a string doesn't contain dangerous HTML patterns
 * Useful for additional validation before using dangerouslySetInnerHTML
 * 
 * @param html - The HTML string to validate
 * @returns true if the HTML appears safe, false otherwise
 */
export function isHtmlSafe(html: string | null | undefined): boolean {
  if (!html || typeof html !== 'string') {
    return true;
  }

  // Check for script tags
  if (/<script[\s>]/i.test(html)) {
    return false;
  }

  // Check for javascript: protocol
  if (/javascript:/i.test(html)) {
    return false;
  }

  // Check for on* event handlers
  if (/\son\w+\s*=/i.test(html)) {
    return false;
  }

  // Check for iframe tags
  if (/<iframe[\s>]/i.test(html)) {
    return false;
  }

  // Check for object/embed tags
  if (/<(object|embed)[\s>]/i.test(html)) {
    return false;
  }

  return true;
}

/**
 * Sanitizes HTML by removing dangerous elements and attributes
 * This is a basic sanitizer - for production use, consider a library like DOMPurify
 * 
 * @param html - The HTML string to sanitize
 * @returns Sanitized HTML (basic implementation)
 */
export function sanitizeHtml(html: string | null | undefined): string {
  if (!html || typeof html !== 'string') {
    return '';
  }

  // For now, just escape everything - in production, use a proper HTML sanitizer library
  // This prevents XSS but removes formatting
  return escapeHtml(html);
}

```

## `src/vite-env.d.ts`

```typescript
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_FIREBASE_API_KEY: string
  readonly VITE_FIREBASE_AUTH_DOMAIN: string
  readonly VITE_FIREBASE_PROJECT_ID: string
  readonly VITE_FIREBASE_STORAGE_BUCKET: string
  readonly VITE_FIREBASE_MESSAGING_SENDER_ID: string
  readonly VITE_FIREBASE_APP_ID: string
  // more env variables...
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}


```

## `src/workers/dataTransformWorker.ts`

```typescript
/**
 * Data Transform Worker
 * 
 * Web Worker for transforming data from Google Sheets.
 * Runs transformations in a separate thread to avoid blocking the main UI thread.
 * 
 * This file contains inline copies of transformer functions and helper utilities
 * since Web Workers cannot easily import modules.
 */

// ============================================================================
// Type Definitions (inline copies)
// ============================================================================

type DataRow = Record<string, string | number | undefined>;

interface TransformMessage {
  type: 'transform';
  transformerId: string;
  data: DataRow[];
  meta: { fields: string[] | null };
  jobId: string;
  // For ScoreBoard transformer, include external data
  industryPe1Map?: Record<string, number>;
  industryPe2Map?: Record<string, number>;
  smaDataMap?: Record<string, { sma100: number | null; sma200: number | null; smaCross: string | null }>;
}

interface ProgressMessage {
  type: 'progress';
  jobId: string;
  stage: 'transform';
  percentage: number;
  message: string;
  rowsProcessed?: number;
  totalRows?: number;
}

interface CompleteMessage {
  type: 'complete';
  jobId: string;
  data: unknown[];
}

interface ErrorMessage {
  type: 'error';
  jobId: string;
  error: string;
}

// ============================================================================
// Helper Functions (inline copies from dataTransformers.ts)
// ============================================================================

function getValue(possibleNames: string[], row: DataRow): string {
  if (!row || typeof row !== 'object') {
    return '';
  }
  
  for (const name of possibleNames) {
    if (typeof name !== 'string') continue;
    
    // Try exact match first
    const value = row[name];
    if (value !== undefined && value !== null && value !== '') {
      return String(value).trim();
    }
    // Try case-insensitive match
    const lowerName = name.toLowerCase();
    for (const key in row) {
      if (key.toLowerCase() === lowerName) {
        const val = row[key];
        if (val !== undefined && val !== null && val !== '') {
          return String(val).trim();
        }
      }
    }
  }
  return '';
}

function getValueAllowZero(possibleNames: string[], row: DataRow): string {
  for (const name of possibleNames) {
    // Try exact match first
    if (row[name] !== undefined && row[name] !== null) {
      const value = row[name];
      // If value is 0 (number or string "0"), return "0"
      if (value === 0 || value === '0') {
        return '0';
      }
      // If value is empty string, skip
      if (value === '') {
        continue;
      }
      return String(value).trim();
    }
    // Try case-insensitive match
    const lowerName = name.toLowerCase();
    for (const key in row) {
      if (key.toLowerCase() === lowerName) {
        const value = row[key];
        // Allow 0 as a valid value
        if (value !== undefined && value !== null) {
          // If value is 0 (number or string "0"), return "0"
          if (value === 0 || value === '0') {
            return '0';
          }
          // If value is empty string, skip
          if (value === '') {
            continue;
          }
          return String(value).trim();
        }
      }
    }
  }
  return '';
}

function isValidValue(value: string): boolean {
  if (!value) return false;
  const normalized = value.trim().toUpperCase();
  return normalized !== '#N/A' && normalized !== 'N/A' && normalized !== '#NUM!' && normalized !== '#VALUE!' && normalized !== '#DIV/0!' && normalized !== '#REF!' && normalized !== 'LOADING...';
}

function parseNumericValueNullable(valueStr: string): number | null {
  if (typeof valueStr !== 'string' || !isValidValue(valueStr)) return null;
  
  // Remove common prefixes and clean the string
  let cleaned = String(valueStr)
    .replace(/,/g, '.')
    .replace(/\s/g, '')
    .replace(/#/g, '')
    .replace(/%/g, '')
    .replace(/\$/g, '');
  
  const parsed = parseFloat(cleaned);
  if (typeof parsed !== 'number' || isNaN(parsed) || !isFinite(parsed)) return null;
  
  return parsed;
}

function parsePercentageValueNullable(valueStr: string): number | null {
  if (typeof valueStr !== 'string' || !isValidValue(valueStr)) return null;
  
  // Remove % sign and clean the string
  let cleaned = String(valueStr)
    .replace(/,/g, '.')
    .replace(/\s/g, '')
    .replace(/#/g, '')
    .replace(/%/g, '')
    .replace(/\$/g, '');
  
  const parsed = parseFloat(cleaned);
  if (typeof parsed !== 'number' || isNaN(parsed) || !isFinite(parsed)) return null;
  
  return parsed;
}

function calculateMedian(values: number[]): number | null {
  if (!Array.isArray(values) || values.length === 0) return null;
  
  // Filter out invalid numbers
  const validNumbers = values.filter(v => typeof v === 'number' && !isNaN(v) && isFinite(v));
  if (validNumbers.length === 0) return null;
  
  const sorted = [...validNumbers].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  
  if (sorted.length % 2 === 0) {
    return (sorted[mid - 1] + sorted[mid]) / 2;
  } else {
    return sorted[mid];
  }
}

// Industry threshold lookup functions (simplified - we'll pass the maps if needed)
// For Threshold Industry transformer, we'll need to pass the maps as data

// ============================================================================
// Transformer Functions (inline copies)
// ============================================================================

function transformBenjaminGrahamData(results: { data: DataRow[]; meta: { fields: string[] | null } }): unknown[] {
  const benjaminGrahamData = results.data
    .map((row: DataRow) => {
      const companyName = getValue(['Company Name', 'Company', 'company'], row);
      const ticker = getValue(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
      const priceStr = getValue(['Price', 'price', 'PRICE'], row);
      const benjaminGrahamStr = getValue(['Benjamin Graham', 'benjamin graham', 'Benjamin', 'benjamin'], row);
      
      // Only process if company name is valid (not #N/A)
      if (!isValidValue(companyName)) {
        return null;
      }
      
      // Filter out rows where Ticker is N/A
      if (!isValidValue(ticker)) {
        return null;
      }
      
      // Parse Price value as number (handle #N/A)
      const price = parseNumericValueNullable(priceStr);
      
      // Parse Benjamin Graham value as number (handle #N/A)
      const benjaminGraham = parseNumericValueNullable(benjaminGrahamStr);
      
      // Parse IV (FCF) if it exists
      const ivFcfStr = getValue(['IV (FCF)', 'IV(FCF)', 'iv fcf', 'ivfcf'], row);
      const ivFcf = parseNumericValueNullable(ivFcfStr);
      
      // Parse IRR1 if it exists
      const irr1Str = getValue(['IRR1', 'irr1', 'IRR 1', 'irr 1'], row);
      const irr1 = parseNumericValueNullable(irr1Str);
      
      return {
        companyName: companyName,
        ticker: ticker,
        price: price,
        benjaminGraham: benjaminGraham,
        ivFcf: ivFcf,
        irr1: irr1,
      };
    })
    .filter((data) => data !== null);
  
  return benjaminGrahamData;
}

function transformPEIndustryData(results: { data: DataRow[]; meta: { fields: string[] | null } }): unknown[] {
  // Group data by industry
  const industryMap = new Map<string, { pe: number[]; pe1: number[]; pe2: number[]; count: number }>();

  results.data.forEach((row: DataRow) => {
    const companyName = getValue(['Company Name', 'Company', 'company'], row);
    const ticker = getValue(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
    const industry = getValue(['INDUSTRY', 'Industry', 'industry'], row);
    
    // Filter out rows where Company Name, Ticker, or Industry is N/A
    if (!isValidValue(companyName) || !isValidValue(ticker) || !isValidValue(industry)) {
      return;
    }

    const peStr = getValue(['P/E', 'P/E', 'pe', 'PE'], row);
    const pe1Str = getValue(['P/E1', 'P/E 1', 'pe1', 'PE1'], row);
    const pe2Str = getValue(['P/E2', 'P/E 2', 'pe2', 'PE2'], row);

    let industryData = industryMap.get(industry);
    if (!industryData) {
      industryData = { pe: [], pe1: [], pe2: [], count: 0 };
      industryMap.set(industry, industryData);
    }
    industryData.count++;

    const pe = parseNumericValueNullable(peStr);
    const pe1 = parseNumericValueNullable(pe1Str);
    const pe2 = parseNumericValueNullable(pe2Str);

    // Include 0 values (actual zeros) but exclude null (invalid/missing)
    if (pe !== null) {
      industryData.pe.push(pe);
    }
    if (pe1 !== null) {
      industryData.pe1.push(pe1);
    }
    if (pe2 !== null) {
      industryData.pe2.push(pe2);
    }
  });

  // Convert to PEIndustryData array
  const peIndustryData = Array.from(industryMap.entries())
    .map(([industry, data]) => ({
      industry: industry,
      pe: calculateMedian(data.pe),
      pe1: calculateMedian(data.pe1),
      pe2: calculateMedian(data.pe2),
      companyCount: data.count,
    }))
    .filter(item => item.companyCount > 0);
  
  return peIndustryData;
}

function transformSMAData(results: { data: DataRow[]; meta: { fields: string[] | null } }): unknown[] {
  const smaData = results.data
    .map((row: DataRow) => {
      const companyName = getValue(['Company Name', 'Company', 'company'], row);
      const ticker = getValue(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
      const sma100Str = getValue(['SMA(100)', 'SMA(100)', 'sma(100)', 'sma100', 'SMA100'], row);
      const sma200Str = getValue(['SMA(200)', 'SMA(200)', 'sma(200)', 'sma200', 'SMA200'], row);
      const smaCrossStr = getValue(['SMA Cross', 'SMA Cross', 'sma cross', 'smaCross', 'SMACross', 'SMA CROSS'], row);
      
      // Only process if company name is valid (not #N/A)
      if (!isValidValue(companyName)) {
        return null;
      }
      
      // Filter out rows where Ticker is N/A
      if (!isValidValue(ticker)) {
        return null;
      }
      
      // Parse SMA(100) value as number (handle #N/A)
      const sma100 = parseNumericValueNullable(sma100Str);
      
      // Parse SMA(200) value as number (handle #N/A)
      const sma200 = parseNumericValueNullable(sma200Str);
      
      // Extract SMA Cross value as text (handle #N/A and empty values)
      let smaCross: string | null = null;
      if (smaCrossStr && smaCrossStr.trim()) {
        const trimmed = smaCrossStr.trim();
        // Convert #N/A to null, otherwise use the value
        if (trimmed.toUpperCase() !== '#N/A' && trimmed.toUpperCase() !== 'N/A' && trimmed !== '') {
          smaCross = trimmed;
        }
      }
      
      return {
        companyName: companyName,
        ticker: ticker,
        sma100: sma100,
        sma200: sma200,
        smaCross: smaCross,
      };
    })
    .filter((data) => data !== null);
  
  return smaData;
}

function transformScoreBoardData(
  results: { data: DataRow[]; meta: { fields: string[] | null } },
  industryPe1Map: Record<string, number>,
  industryPe2Map: Record<string, number>,
  smaDataMap: Record<string, { sma100: number | null; sma200: number | null; smaCross: string | null }>
): unknown[] {
  const scoreBoardData = results.data
    .map((row: DataRow) => {
      const companyName = getValueAllowZero(['Company Name', 'Company', 'company'], row);
      const ticker = getValueAllowZero(['Ticker', 'ticker', 'Ticket', 'ticket', 'Symbol', 'symbol'], row);
      const irrStr = getValueAllowZero(['IRR', 'irr', 'Irr'], row);
      const mungerQualityScoreStr = getValueAllowZero(['Munger Quality Score', 'Munger Quality Score', 'munger quality score', 'MUNGER QUALITY SCORE'], row);
      const valueCreationStr = getValueAllowZero(['VALUE CREATION', 'Value Creation', 'value creation', 'VALUE_CREATION'], row);
      const ro40CyStr = getValueAllowZero(['Ro40 CY', 'Ro40 CY', 'ro40 cy', 'RO40 CY'], row);
      const ro40F1Str = getValueAllowZero(['Ro40 F1', 'Ro40 F1', 'ro40 f1', 'RO40 F1'], row);
      const ro40F2Str = getValueAllowZero(['Ro40 F2', 'Ro40 F2', 'ro40 f2', 'RO40 F2'], row);
      const leverageF2Str = getValueAllowZero(['Leverage F2', 'Leverage F2', 'leverage f2', 'LEVERAGE F2'], row);
      const currentRatioStr = getValueAllowZero(['Current Ratio', 'Current Ratio', 'current ratio', 'CURRENT RATIO'], row);
      const cashSdebtStr = getValueAllowZero(['Cash/SDebt', 'Cash/SDebt', 'cash/sdebt', 'CASH/SDEBT'], row);
      
      // Detect division-by-zero for Cash/SDebt
      const isCashSdebtDivZero = cashSdebtStr && 
        (cashSdebtStr.trim().toUpperCase() === '#DIV/0!' || 
         cashSdebtStr.trim().toUpperCase() === 'INF' ||
         cashSdebtStr.trim().toUpperCase() === '∞');
      
      // Get (TB/S)/Price directly from Dashboard sheet
      const tbSPriceStr = getValueAllowZero(['(TB/S)/Price', '(TB/S)/Price', '(tb/s)/price', '(TB/S)/PRICE'], row);
      
      const pe1Str = getValueAllowZero(['P/E1', 'P/E 1', 'pe1', 'PE1'], row);
      const pe2Str = getValueAllowZero(['P/E2', 'P/E 2', 'pe2', 'PE2'], row);
      const industryStr = getValueAllowZero(['INDUSTRY', 'Industry', 'industry'], row);
      
      // Filter out rows where Company Name or Ticker is N/A
      if (!isValidValue(companyName) || !isValidValue(ticker)) {
        return null;
      }

      const irr = parseNumericValueNullable(irrStr);
      const mungerQualityScore = parseNumericValueNullable(mungerQualityScoreStr);
      const valueCreation = parsePercentageValueNullable(valueCreationStr);
      const ro40Cy = parsePercentageValueNullable(ro40CyStr);
      const ro40F1 = parsePercentageValueNullable(ro40F1Str);
      const ro40F2 = parsePercentageValueNullable(ro40F2Str);
      const leverageF2 = parseNumericValueNullable(leverageF2Str);
      const currentRatio = parseNumericValueNullable(currentRatioStr);
      const cashSdebt = parseNumericValueNullable(cashSdebtStr);
      // Om #DIV/0! detekteras, sätt cashSdebt till 0 istället för null
      const finalCashSdebt = isCashSdebtDivZero ? 0 : cashSdebt;
      
      // Parse (TB/S)/Price directly from column
      const tbSPrice = parseNumericValueNullable(tbSPriceStr);
      
      // Calculate P/E1 INDUSTRY (procentuell skillnad)
      const pe1 = parseNumericValueNullable(pe1Str);
      let pe1Industry: number | null = null;
      
      if (isValidValue(industryStr) && pe1 !== null && pe1 > 0) {
        const industryKey = industryStr.trim().toLowerCase();
        const pe1IndustryMedian = industryPe1Map[industryKey];
        
        if (pe1IndustryMedian !== undefined && pe1IndustryMedian > 0) {
          // Calculate percentage difference: (pe1 - pe1IndustryMedian) / pe1IndustryMedian * 100
          pe1Industry = ((pe1 - pe1IndustryMedian) / pe1IndustryMedian) * 100;
        }
      }
      
      // Calculate P/E2 INDUSTRY (procentuell skillnad)
      const pe2 = parseNumericValueNullable(pe2Str);
      let pe2Industry: number | null = null;
      
      if (isValidValue(industryStr) && pe2 !== null && pe2 > 0) {
        const industryKey = industryStr.trim().toLowerCase();
        const pe2IndustryMedian = industryPe2Map[industryKey];
        
        if (pe2IndustryMedian !== undefined && pe2IndustryMedian > 0) {
          // Calculate percentage difference: (pe2 - pe2IndustryMedian) / pe2IndustryMedian * 100
          pe2Industry = ((pe2 - pe2IndustryMedian) / pe2IndustryMedian) * 100;
        }
      }

      // Match SMA(100), SMA(200), and SMA Cross from SMA sheet by ticker
      const tickerKey = ticker.toLowerCase().trim();
      const smaMatch = smaDataMap[tickerKey];

      return {
        companyName: companyName,
        ticker: ticker,
        industry: industryStr || '',
        irr: irr,
        mungerQualityScore: mungerQualityScore,
        valueCreation: valueCreation,
        tbSPrice: tbSPrice,
        ro40Cy: ro40Cy,
        ro40F1: ro40F1,
        ro40F2: ro40F2,
        leverageF2: leverageF2,
        pe1Industry: pe1Industry,
        pe2Industry: pe2Industry,
        currentRatio: currentRatio,
        cashSdebt: finalCashSdebt,
        isCashSdebtDivZero: isCashSdebtDivZero || false,
        sma100: smaMatch ? smaMatch.sma100 : null,
        sma200: smaMatch ? smaMatch.sma200 : null,
        smaCross: smaMatch ? smaMatch.smaCross : null,
      };
    })
    .filter((data) => data !== null);
  
  return scoreBoardData;
}

// Threshold Industry uses large industry maps and runs on main thread only.
// getTransformerId returns null for threshold-industry; no worker path.

// ============================================================================
// Transformer Registry
// ============================================================================

type TransformerFunction = (results: { data: DataRow[]; meta: { fields: string[] | null } }, ...args: unknown[]) => unknown[];

const transformers: Record<string, TransformerFunction> = {
  'benjamin-graham': transformBenjaminGrahamData,
  'pe-industry': transformPEIndustryData,
  'sma': transformSMAData,
  'score-board': transformScoreBoardData,
};

// ============================================================================
// Worker Error Handlers
// ============================================================================

self.onerror = function(errorEvent: ErrorEvent) {
  console.error('[Worker] Unhandled error:', {
    message: errorEvent.message,
    filename: errorEvent.filename,
    lineno: errorEvent.lineno,
    colno: errorEvent.colno,
    error: errorEvent.error,
  });
  
  // Try to send error message if we have context
  // Note: We can't send a message without a jobId, so we just log it
  return false; // Don't prevent default error handling
};

// Handle unhandled promise rejections
self.addEventListener('unhandledrejection', function(event: PromiseRejectionEvent) {
  console.error('[Worker] Unhandled promise rejection:', {
    reason: event.reason,
    promise: event.promise,
  });
  
  // Prevent the default browser behavior
  event.preventDefault();
});

// ============================================================================
// Worker Message Handler
// ============================================================================

self.onmessage = function(e: MessageEvent<TransformMessage>) {
  const message = e.data;

  // Validate message structure
  if (!message || typeof message !== 'object') {
    console.error('[Worker] Invalid message received:', message);
    return;
  }

  if (message.type !== 'transform') {
    const jobId = message.jobId || 'unknown';
    self.postMessage({
      type: 'error',
      jobId,
      error: 'Invalid message type',
    } as ErrorMessage);
    return;
  }

  // Ensure jobId exists
  if (!message.jobId) {
    console.error('[Worker] Message missing jobId:', message);
    return;
  }

  try {
    const transformer = transformers[message.transformerId];
    if (!transformer) {
      self.postMessage({
        type: 'error',
        jobId: message.jobId,
        error: `Unknown transformer: ${message.transformerId}`,
      } as ErrorMessage);
      return;
    }

    // Send progress update at start
    self.postMessage({
      type: 'progress',
      jobId: message.jobId,
      stage: 'transform',
      percentage: 0,
      message: `Transforming ${message.transformerId} data...`,
      totalRows: message.data.length,
    } as ProgressMessage);

    // Transform data
    let transformedData: unknown[];
    const totalRows = message.data.length;

    if (message.transformerId === 'score-board') {
      // ScoreBoard needs external maps
      if (!message.industryPe1Map || !message.industryPe2Map || !message.smaDataMap) {
        throw new Error('ScoreBoard transformer requires industryPe1Map, industryPe2Map, and smaDataMap');
      }
      transformedData = transformer(
        { data: message.data, meta: message.meta },
        message.industryPe1Map,
        message.industryPe2Map,
        message.smaDataMap
      ) as unknown[];
    } else {
      transformedData = transformer({ data: message.data, meta: message.meta }) as unknown[];
    }

    // Send progress update during processing (simulate)
    if (totalRows > 100) {
      // For large datasets, send progress updates
      const chunkSize = Math.max(1, Math.floor(totalRows / 10));
      for (let i = 0; i < totalRows; i += chunkSize) {
        const progress = Math.min(90, Math.floor((i / totalRows) * 90));
        self.postMessage({
          type: 'progress',
          jobId: message.jobId,
          stage: 'transform',
          percentage: progress,
          message: `Processing rows ${i + 1}-${Math.min(i + chunkSize, totalRows)} of ${totalRows}...`,
          rowsProcessed: Math.min(i + chunkSize, totalRows),
          totalRows: totalRows,
        } as ProgressMessage);
      }
    }

    // Send completion message
    self.postMessage({
      type: 'complete',
      jobId: message.jobId,
      data: transformedData,
    } as CompleteMessage);

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const jobId = message?.jobId || 'unknown';
    
    console.error('[Worker] Error in message handler:', {
      error,
      errorMessage,
      jobId,
      transformerId: message?.transformerId,
    });
    
    // Only send error message if we have a valid jobId
    if (message?.jobId) {
      self.postMessage({
        type: 'error',
        jobId: message.jobId,
        error: errorMessage,
      } as ErrorMessage);
    }
  }
};

```

## `start.bat`

```batch
@echo off
title Stock Score - Development Server

echo.
echo ========================================
echo   Stock Score - Development Server
echo ========================================
echo.

REM Check for package.json
if not exist "package.json" (
    echo [ERROR] package.json not found!
    echo Please run this script from the project root directory.
    echo.
    pause
    exit /b 1
)

REM Check Node.js
where node >nul 2>&1
if errorlevel 1 (
    echo [ERROR] Node.js is not installed or not in PATH!
    echo Please install Node.js from https://nodejs.org/
    echo.
    pause
    exit /b 1
)

REM Check npm
where npm >nul 2>&1
if errorlevel 1 (
    echo [ERROR] npm is not installed or not in PATH!
    echo.
    pause
    exit /b 1
)

echo [INFO] Node.js and npm found
echo.

REM Install dependencies if needed
if not exist "node_modules" (
    echo [INFO] Installing dependencies...
    call npm install
    if errorlevel 1 (
        echo [ERROR] Failed to install dependencies!
        pause
        exit /b 1
    )
    echo [SUCCESS] Dependencies installed
    echo.
)

REM Warn about .env.local
if not exist ".env.local" (
    echo [WARNING] .env.local file not found!
    echo See env.template for configuration details.
    echo.
)

REM Start server in background
echo [INFO] Starting development server...
echo.

REM Change to script directory and start server
cd /d "%~dp0"

REM Set environment variable to prevent Vite from auto-opening browser
REM We'll open it manually instead
set BROWSER=none
start "Stock Score Dev Server" cmd /k "set BROWSER=none && npm run dev"

echo [SUCCESS] Server window opened!
echo.
echo [INFO] Waiting 10 seconds for server to start...
timeout /t 10 /nobreak >nul

echo.
echo [INFO] Opening browser...

REM Open browser - use only one method
rundll32 url.dll,FileProtocolHandler http://localhost:5173

echo [SUCCESS] Done!
echo.
echo Server is running in a separate window.
echo If browser didn't open, go to: http://localhost:5173
echo.
echo Press any key to close this window...
pause >nul

```

## `tailwind.config.js`

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class',
  theme: {
    extend: {
      // Color System
      colors: {
        // Primary colors
        primary: {
          50: '#eff6ff',
          100: '#dbeafe',
          200: '#bfdbfe',
          300: '#93c5fd',
          400: '#60a5fa',
          500: '#3b82f6',
          600: '#2563eb',
          700: '#1d4ed8',
          800: '#1e40af',
          900: '#1e3a8a',
          950: '#172554',
        },
        // Secondary colors
        secondary: {
          50: '#f8fafc',
          100: '#f1f5f9',
          200: '#e2e8f0',
          300: '#cbd5e1',
          400: '#94a3b8',
          500: '#64748b',
          600: '#475569',
          700: '#334155',
          800: '#1e293b',
          900: '#0f172a',
          950: '#020617',
        },
        // Semantic colors
        success: {
          50: '#f0fdf4',
          100: '#dcfce7',
          200: '#bbf7d0',
          300: '#86efac',
          400: '#4ade80',
          500: '#22c55e',
          600: '#16a34a',
          700: '#15803d',
          800: '#166534',
          900: '#14532d',
          950: '#052e16',
        },
        error: {
          50: '#fef2f2',
          100: '#fee2e2',
          200: '#fecaca',
          300: '#fca5a5',
          400: '#f87171',
          500: '#ef4444',
          600: '#dc2626',
          700: '#b91c1c',
          800: '#991b1b',
          900: '#7f1d1d',
          950: '#450a0a',
        },
        warning: {
          50: '#fffbeb',
          100: '#fef3c7',
          200: '#fde68a',
          300: '#fcd34d',
          400: '#fbbf24',
          500: '#f59e0b',
          600: '#d97706',
          700: '#b45309',
          800: '#92400e',
          900: '#78350f',
          950: '#451a03',
        },
        info: {
          50: '#eff6ff',
          100: '#dbeafe',
          200: '#bfdbfe',
          300: '#93c5fd',
          400: '#60a5fa',
          500: '#3b82f6',
          600: '#2563eb',
          700: '#1d4ed8',
          800: '#1e40af',
          900: '#1e3a8a',
          950: '#172554',
        },
      },
      // Spacing Scale (4px base unit)
      spacing: {
        '0.5': '0.125rem', // 2px
        '1': '0.25rem',     // 4px
        '1.5': '0.375rem', // 6px
        '2': '0.5rem',     // 8px
        '2.5': '0.625rem', // 10px
        '3': '0.75rem',    // 12px
        '3.5': '0.875rem', // 14px
        '4': '1rem',       // 16px
        '5': '1.25rem',    // 20px
        '6': '1.5rem',     // 24px
        '7': '1.75rem',    // 28px
        '8': '2rem',       // 32px
        '9': '2.25rem',    // 36px
        '10': '2.5rem',    // 40px
        '11': '2.75rem',   // 44px
        '12': '3rem',      // 48px
        '14': '3.5rem',    // 56px
        '16': '4rem',      // 64px
        '20': '5rem',     // 80px
        '24': '6rem',     // 96px
        '28': '7rem',     // 112px
        '32': '8rem',     // 128px
        '36': '9rem',     // 144px
        '40': '10rem',    // 160px
        '44': '11rem',    // 176px
        '48': '12rem',    // 192px
        '52': '13rem',    // 208px
        '56': '14rem',    // 224px
        '60': '15rem',    // 240px
        '64': '16rem',    // 256px
        '72': '18rem',    // 288px
        '80': '20rem',    // 320px
        '96': '24rem',    // 384px
      },
      // Typography
      fontFamily: {
        sans: [
          '-apple-system',
          'BlinkMacSystemFont',
          '"Segoe UI"',
          'Roboto',
          '"Helvetica Neue"',
          'Arial',
          'sans-serif',
        ],
        mono: [
          'ui-monospace',
          'SFMono-Regular',
          '"SF Mono"',
          'Menlo',
          'Consolas',
          '"Liberation Mono"',
          'monospace',
        ],
      },
      fontSize: {
        'xs': ['0.75rem', { lineHeight: '1rem', letterSpacing: '0.05em' }],      // 12px
        'sm': ['0.875rem', { lineHeight: '1.25rem', letterSpacing: '0.025em' }], // 14px
        'base': ['1rem', { lineHeight: '1.5rem', letterSpacing: '0.01em' }],     // 16px
        'lg': ['1.125rem', { lineHeight: '1.75rem', letterSpacing: '0.01em' }],  // 18px
        'xl': ['1.25rem', { lineHeight: '1.75rem', letterSpacing: '-0.025em' }],  // 20px
        '2xl': ['1.5rem', { lineHeight: '2rem', letterSpacing: '-0.025em' }],    // 24px
        '3xl': ['1.875rem', { lineHeight: '2.25rem', letterSpacing: '-0.025em' }], // 30px
        '4xl': ['2.25rem', { lineHeight: '2.5rem', letterSpacing: '-0.025em' }], // 36px
        '5xl': ['3rem', { lineHeight: '1', letterSpacing: '-0.025em' }],         // 48px
        '6xl': ['3.75rem', { lineHeight: '1', letterSpacing: '-0.025em' }],      // 60px
        '7xl': ['4.5rem', { lineHeight: '1', letterSpacing: '-0.025em' }],        // 72px
        '8xl': ['6rem', { lineHeight: '1', letterSpacing: '-0.025em' }],         // 96px
        '9xl': ['8rem', { lineHeight: '1', letterSpacing: '-0.025em' }],         // 128px
      },
      fontWeight: {
        thin: '100',
        extralight: '200',
        light: '300',
        normal: '400',
        medium: '500',
        semibold: '600',
        bold: '700',
        extrabold: '800',
        black: '900',
      },
      lineHeight: {
        none: '1',
        tight: '1.25',
        snug: '1.375',
        normal: '1.5',
        relaxed: '1.625',
        loose: '2',
      },
      letterSpacing: {
        tighter: '-0.05em',
        tight: '-0.025em',
        normal: '0em',
        wide: '0.025em',
        wider: '0.05em',
        widest: '0.1em',
      },
      // Shadows (Elevation System)
      boxShadow: {
        'xs': '0 1px 2px 0 rgb(0 0 0 / 0.05)',
        'sm': '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',
        'DEFAULT': '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',
        'md': '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
        'lg': '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',
        'xl': '0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)',
        '2xl': '0 25px 50px -12px rgb(0 0 0 / 0.25)',
        'inner': 'inset 0 2px 4px 0 rgb(0 0 0 / 0.05)',
        'none': 'none',
      },
      // Border Radius
      borderRadius: {
        'none': '0',
        'sm': '0.125rem',   // 2px
        'DEFAULT': '0.25rem', // 4px
        'md': '0.375rem',   // 6px
        'lg': '0.5rem',     // 8px
        'xl': '0.75rem',    // 12px
        '2xl': '1rem',      // 16px
        '3xl': '1.5rem',    // 24px
        'full': '9999px',
      },
      // Transition Durations
      transitionDuration: {
        'fast': '150ms',
        'base': '200ms',
        'normal': '300ms',
        'slow': '500ms',
        'slower': '750ms',
        'slowest': '1000ms',
      },
      // Transition Timing Functions
      transitionTimingFunction: {
        'ease-in': 'cubic-bezier(0.4, 0, 1, 1)',
        'ease-out': 'cubic-bezier(0, 0, 0.2, 1)',
        'ease-in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',
        'smooth': 'cubic-bezier(0.4, 0, 0.2, 1)',
      },
      // Animation
      animation: {
        'fade-in': 'fadeIn 300ms ease-out',
        'fade-in-up': 'fadeInUp 400ms ease-out',
        'slide-in-right': 'slideInRight 300ms ease-out',
        'scale-in': 'scaleIn 200ms ease-out',
        'shimmer': 'shimmer 2s linear infinite',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0', transform: 'translateY(-10px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
        fadeInUp: {
          '0%': { opacity: '0', transform: 'translateY(20px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
        slideInRight: {
          '0%': { opacity: '0', transform: 'translateX(-20px)' },
          '100%': { opacity: '1', transform: 'translateX(0)' },
        },
        scaleIn: {
          '0%': { opacity: '0', transform: 'scale(0.95)' },
          '100%': { opacity: '1', transform: 'scale(1)' },
        },
        shimmer: {
          '0%': { backgroundPosition: '-200% 0' },
          '100%': { backgroundPosition: '200% 0' },
        },
      },
    },
  },
  plugins: [],
}


```

## `temp-set-admin/package.json`

```json
{
  "name": "set-admin-role",
  "version": "1.0.0",
  "description": "Tillfälligt script för att sätta admin-roll",
  "main": "setAdminRole.js",
  "scripts": {
    "start": "node setAdminRole.js"
  },
  "dependencies": {
    "firebase-admin": "^12.0.0"
  }
}

```

## `temp-set-admin/setAdminRole.js`

```javascript
const admin = require('firebase-admin');
const serviceAccount = require('./serviceAccountKey.json');

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount)
});

const userId = 'ih1PUMO6WhXxm13ZGLKlfC9gZ1h2'; // Ditt User UID (babayan.ali@gmail.com)

admin.auth().setCustomUserClaims(userId, { role: 'admin' })
  .then(() => {
    console.log('✅ Admin-roll satt framgångsrikt!');
    console.log('User ID:', userId);
    console.log('Email: babayan.ali@gmail.com');
    console.log('\n📝 Nästa steg:');
    console.log('1. Logga ut från appen');
    console.log('2. Logga in igen');
    console.log('3. Du ska nu se admin-panel knappen i headern');
    process.exit(0);
  })
  .catch((error) => {
    console.error('❌ Fel vid sättning av admin-roll:', error);
    console.error('\nFelsökningssteg:');
    console.error('1. Kontrollera att serviceAccountKey.json finns i samma mapp');
    console.error('2. Kontrollera att User ID är korrekt:', userId);
    console.error('3. Kontrollera att du har rätt behörigheter i Firebase Console');
    process.exit(1);
  });

```

## `TESTING_GUIDE.md`

```markdown
# Testguide för Web Workers och Service Worker

## Web Workers - Testning

### Test 1: Verifiera att UI inte blockeras under transformation

**Steg:**
1. Öppna applikationen i webbläsaren
2. Öppna Developer Tools (F12) → Console
3. Ladda data (t.ex. Score Board eller Benjamin Graham)
4. Under transformation, försök interagera med UI:
   - Scrolla på sidan
   - Klicka på länkar/knappar
   - Öppna dropdown-menyer
   - **Förväntat resultat:** UI ska vara responsiv och inte frysa

**Verifiering:**
- UI ska förbli responsiv även med stora datasets (1000+ rader)
- Progress indicators ska fungera korrekt
- Inga långa freezes eller lags

### Test 2: Verifiera Worker fallback

**Steg:**
1. Öppna Developer Tools → Application → Service Workers
2. Stäng av Web Workers (eller använd en webbläsare som inte stöder Workers)
3. Ladda data
4. **Förväntat resultat:** Appen ska fortfarande fungera, men använda main thread

**Verifiering:**
- I Console ska du se loggar om att Worker inte används
- Data ska fortfarande laddas korrekt (fastare men kan blockera UI)

### Test 3: Testa med stora datasets

**Steg:**
1. Ladda data med många rader (1000+)
2. Öppna Performance tab i Developer Tools
3. Starta recording
4. Ladda data
5. Stoppa recording
6. **Förväntat resultat:** Transformation ska ske i Worker-thread, inte Main thread

**Verifiering:**
- I Performance tab: Se att Worker-thread gör jobbet
- Main thread ska vara ledig för UI-uppdateringar

### Test 4: Verifiera progress callbacks

**Steg:**
1. Ladda data med progress callback (t.ex. Score Board)
2. Observera progress indicators
3. **Förväntat resultat:** Progress ska uppdateras korrekt

**Verifiering:**
- Progress bars/indicators ska uppdateras under transformation
- Meddelanden ska visas korrekt

## Service Worker - Testning

### Test 1: Verifiera Service Worker registrering

**Steg:**
1. Öppna Developer Tools → Application → Service Workers
2. Ladda om sidan
3. **Förväntat resultat:** Service Worker ska vara registrerad (endast i produktion)

**Verifiering:**
- Status ska vara "activated and is running"
- Version ska visas korrekt

### Test 2: Testa bakgrundssynk när fliken blir inaktiv

**Steg:**
1. Öppna Developer Tools → Network tab
2. Ladda data en gång
3. Växla till en annan flik (eller minimera fönstret)
4. Vänta 5-10 sekunder
5. Växla tillbaka
6. **Förväntat resultat:** Service Worker ska ha synkat data i bakgrunden

**Verifiering:**
- I Network tab: Se att API-anrop görs i bakgrunden
- I Console: Se loggar om bakgrundssynk
- Data ska vara uppdaterad när du kommer tillbaka

### Test 3: Testa koordinering med delta sync

**Steg:**
1. Öppna appen i två flikar
2. I första fliken: Vänta tills delta sync körs
3. I andra fliken: Ladda data samtidigt
4. **Förväntat resultat:** Ingen dubbel synk ska ske

**Verifiering:**
- I Network tab: Se att API-anrop inte dupliceras
- I Console: Se koordinerings-loggar

### Test 4: Testa cache-first strategi

**Steg:**
1. Ladda data en gång
2. Öppna Developer Tools → Application → Cache Storage
3. Kontrollera att data är cachad
4. Ladda om sidan
5. **Förväntat resultat:** Cachad data ska användas först

**Verifiering:**
- I Network tab: Se att requests går till cache först
- Svarstider ska vara snabbare för cachad data

### Test 5: Testa offline-scenarier

**Steg:**
1. Öppna Developer Tools → Network tab
2. Aktivera "Offline" mode
3. Försök ladda data
4. **Förväntat resultat:** Cachad data ska visas om tillgänglig

**Verifiering:**
- Appen ska visa cachad data om offline
- Offline indicator ska visas

## Debugging Tips

### Web Workers

**Felsökning:**
- Öppna Developer Tools → Sources → Worker threads
- Sätt breakpoints i worker-filen
- Kontrollera Console för Worker-fel

**Vanliga problem:**
- Worker laddas inte: Kontrollera att filen finns och URL är korrekt
- Transformation misslyckas: Kontrollera att data är JSON-serialiserbar
- Progress callbacks fungerar inte: Kontrollera message format

### Service Worker

**Felsökning:**
- Öppna Developer Tools → Application → Service Workers
- Klicka på "Update" för att ladda om Service Worker
- Använd "Unregister" för att rensa Service Worker
- Kontrollera Console för Service Worker-loggar

**Vanliga problem:**
- Service Worker registreras inte: Kontrollera att filen finns i `public/`
- Bakgrundssynk fungerar inte: Kontrollera att page visibility API fungerar
- Dubbel synk: Kontrollera koordineringslogik i sessionStorage

## Expected Console Logs

### Web Workers
```
[Worker Service] Loading worker...
[Worker Service] Worker loaded successfully
[Worker Service] Transforming data in worker: benjamin-graham
```

### Service Worker
```
[Service Worker] Installing... v1
[Service Worker] Activating... v1
[Service Worker] Background sync requested for: DashBoard
[Service Worker] Background sync completed for: DashBoard
```

### Background Sync Service
```
[Background Sync Service] Page hidden, triggering background sync
[Background Sync Service] Starting background sync for sheet: DashBoard
[Background Sync Service] Background sync completed for sheet: DashBoard
```

## Manuell Testchecklista

- [ ] UI blockeras inte under transformation med stora datasets
- [ ] Progress callbacks fungerar korrekt
- [ ] Worker fallback fungerar när Workers inte stöds
- [ ] Service Worker registreras korrekt (produktion)
- [ ] Bakgrundssynk triggas när flik blir inaktiv
- [ ] Ingen dubbel synk mellan huvudapp och Service Worker
- [ ] Cache-first strategi fungerar för API-requests
- [ ] Offline-scenarier hanteras korrekt
- [ ] Befintliga funktioner (delta sync, cache) fungerar fortfarande

```

## `tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "exclude": [
    "node_modules",
    "dist",
    "**/__tests__/**",
    "**/*.test.ts",
    "**/*.test.tsx"
  ],
  "references": [{ "path": "./tsconfig.node.json" }]
}


```

## `tsconfig.node.json`

```json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}


```

## `vercel.json`

```json
{
  "buildCommand": "npm run build",
  "outputDirectory": "dist",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "framework": "vite",
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ],
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "Content-Security-Policy",
          "value": "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://*.firebaseapp.com https://*.googleapis.com https://*.gstatic.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: https: blob:; connect-src 'self' https://*.firebaseapp.com https://*.googleapis.com https://*.google.com https://*.gstatic.com https://script.google.com https://*.googleusercontent.com https://*.vercel.app wss://*.firebaseio.com https://api.allorigins.win https://corsproxy.io; frame-src 'self' https://*.firebaseapp.com; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; upgrade-insecure-requests;"
        },
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-XSS-Protection",
          "value": "1; mode=block"
        },
        {
          "key": "Referrer-Policy",
          "value": "strict-origin-when-cross-origin"
        },
        {
          "key": "Permissions-Policy",
          "value": "geolocation=(), microphone=(), camera=()"
        }
      ]
    }
  ]
}


```

## `vite.config.ts`

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { visualizer } from 'rollup-plugin-visualizer'

// https://vitejs.dev/config/
export default defineConfig({
  server: {
    port: 5173, // Default Vite port
    strictPort: false, // If port is in use, try next available port
    open: true, // Automatically open browser when dev server starts
  },
  plugins: [
    react(),
    // Only enable visualizer during build, not in dev mode
    ...(process.env.ANALYZE === 'true' 
      ? [visualizer({
          filename: './dist/stats.html',
          open: false,
          gzipSize: true,
          brotliSize: true,
          template: 'treemap', // treemap, sunburst, network
        })]
      : []
    ),
  ],
  build: {
    chunkSizeWarningLimit: 1000, // Increase warning limit to 1000KB (1MB)
    rollupOptions: {
      output: {
        // Manual chunk splitting for better optimization
        manualChunks: {
          // Separate vendor chunks
          'react-vendor': ['react', 'react-dom'],
          'firebase-vendor': ['firebase/app', 'firebase/auth', 'firebase/firestore'],
          'i18n-vendor': ['i18next', 'react-i18next'],
          'chart-vendor': ['recharts'],
          'parser-vendor': ['papaparse'],
        },
      },
    },
  },
  // Worker configuration - Vite handles workers automatically with new URL() syntax
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/dist/',
        '**/build/',
        '**/*.test.{ts,tsx}',
        '**/*.spec.{ts,tsx}',
        '**/__tests__/',
        '**/__mocks__/',
        'e2e/',
      ],
      include: [
        'src/**/*.{ts,tsx}',
      ],
      thresholds: {
        lines: 70,
        functions: 70,
        branches: 65,
        statements: 70,
      },
      all: true,
    },
  },
})


```
